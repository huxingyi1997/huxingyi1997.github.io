<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hxy的博客</title>
  
  <subtitle>Mia san Mia!</subtitle>
  <link href="https://hxy1997.xyz/atom.xml" rel="self"/>
  
  <link href="https://hxy1997.xyz/"/>
  <updated>2021-03-13T06:09:54.572Z</updated>
  <id>https://hxy1997.xyz/</id>
  
  <author>
    <name>hxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue项目部署到Gitee Pages和GitHub Pages</title>
    <link href="https://hxy1997.xyz/2021/03/11/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Gitee%20Pages%E5%92%8CGitHub%20Pages/"/>
    <id>https://hxy1997.xyz/2021/03/11/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Gitee%20Pages%E5%92%8CGitHub%20Pages/</id>
    <published>2021-03-11T04:02:39.000Z</published>
    <updated>2021-03-13T06:09:54.572Z</updated>
    
    <content type="html"><![CDATA[<p>使用Gitee Pages实现静态页面（<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器(Gitee Pages)</a> 和<a href="https://hxy1997.xyz/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器(GitHub Pages)</a>）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Pages，实现项目的正式上线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目(Gitee Pages)</a>和<a href="https://hxy1997.xyz/vue_shops/">Vue电商项目(GitHub Pages)</a></p><span id="more"></span><h1 id="一、简单的音乐播放器静态页面"><a href="#一、简单的音乐播放器静态页面" class="headerlink" title="一、简单的音乐播放器静态页面"></a>一、简单的音乐播放器静态页面</h1><h2 id="1-1-将项目提交至gitee"><a href="#1-1-将项目提交至gitee" class="headerlink" title="1.1 将项目提交至gitee"></a>1.1 将项目提交至gitee</h2><p>到Gitee上新建仓库，写仓库名称 选择是否开源 </p><p>使用git remote add origin <a href="https://gitee.com/%E7%A0%81%E4%BA%91%E7%94%A8%E6%88%B7%E5%90%8D/%E9%A1%B9%E7%9B%AE%E5%90%8D">https://gitee.com/码云用户名/项目名</a> / 添加远程仓库。</p><p>git pull origin master 命令，将码云上的仓库pull到先前创建的文件夹中，期间需要输入gitee上面的账号和密码，输入完成密码之后点击 OK。<br>可能会出现以下提示问题：</p><p>这是因为没有配置提交时的用户名和邮箱的原因，你可以直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure><p>完毕之后再把将要上传的文件，全部添加到之前在桌面创建的文件夹中并使用git add .（. 表示所有的）或者 git add 文件名 // 将文件保存到缓存区<br>然后使用git commit -m ‘这里写新推送的文件描述’ //添加文件描述<br>使用git push origin master ，将本地仓库推送到远程仓库，之后去刷新gitee就能看到推送上去的项目了。</p><h2 id="1-2-配置Gitee-Page"><a href="#1-2-配置Gitee-Page" class="headerlink" title="1.2 配置Gitee Page"></a>1.2 配置Gitee Page</h2><p><img data-src="https://www.pianshen.com/images/787/f15acfa42d77a529ca3163842b954a93.png" alt="在这里插入图片描述"></p><p>点击项目导航栏中的<code>服务 --&gt; Gitee Pages</code></p><h2 id="1-3-访问网站"><a href="#1-3-访问网站" class="headerlink" title="1.3 访问网站"></a>1.3 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，我的项目入口文件不是，所以需要，打开<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器</a> 可以享用音乐了</p><h2 id="1-4-将码云库同步到Github库"><a href="#1-4-将码云库同步到Github库" class="headerlink" title="1.4 将码云库同步到Github库"></a>1.4 将码云库同步到Github库</h2><h4 id="步骤一：在github中新建一个项目"><a href="#步骤一：在github中新建一个项目" class="headerlink" title="步骤一：在github中新建一个项目"></a>步骤一：在github中新建一个项目</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-3e82df4fbe5fa3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤二：在码云中复制要导入github中的git地址"><a href="#步骤二：在码云中复制要导入github中的git地址" class="headerlink" title="步骤二：在码云中复制要导入github中的git地址"></a>步骤二：在码云中复制要导入github中的git地址</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-a04729ae3833d460.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤三：在github平台进入步骤一创建的项目，点击“Import-code”进入导入页面"><a href="#步骤三：在github平台进入步骤一创建的项目，点击“Import-code”进入导入页面" class="headerlink" title="步骤三：在github平台进入步骤一创建的项目，点击“Import code”进入导入页面"></a>步骤三：在github平台进入步骤一创建的项目，点击“Import code”进入导入页面</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-c05082be38fdd50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1031/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin-import”"><a href="#步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin-import”" class="headerlink" title="步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin import”"></a>步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin import”</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-b2c3d0bbb6f5b7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p><p>image.png</p><blockquote><p>注意：有时候步骤四在导入时，会出现一个500异常界面。这时，我们不需要管它，只需要重新进入我们新建的项目，再次从步骤三开始操作即可， 这时候便会看见项目正在导入，稍等一段时间，便会提示你导入成功，最后我们再次访问该项目，便会发现码云中的项目已经导入到github中来了。（导入成功GitHub会发邮件提醒）</p></blockquote><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-80137b7b12df8633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>500异常界面</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-bf599039eac9003d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p><p>再次进入时的导入界面</p><h4 id="步骤五：开启GitHub-Pages"><a href="#步骤五：开启GitHub-Pages" class="headerlink" title="步骤五：开启GitHub Pages"></a>步骤五：开启GitHub Pages</h4><p>点击右上角的 Settings</p><p><img data-src="https://cdn.sspai.com/20190506142601.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>找到 GitHub Pages 选项，设置好后，<a href="https://github用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6">https://Github用户名.github.io/项目名/入口文件</a></p><h1 id="二、使用vue-cli脚手架创建的页面提交至Gitee-Pages"><a href="#二、使用vue-cli脚手架创建的页面提交至Gitee-Pages" class="headerlink" title="二、使用vue-cli脚手架创建的页面提交至Gitee Pages"></a>二、使用vue-cli脚手架创建的页面提交至Gitee Pages</h1><h2 id="2-1-调整本地项目"><a href="#2-1-调整本地项目" class="headerlink" title="2.1 调整本地项目"></a>2.1 调整本地项目</h2><h3 id="在根目录下增加-spa文件"><a href="#在根目录下增加-spa文件" class="headerlink" title="在根目录下增加.spa文件"></a>在根目录下增加.spa文件</h3><p>首先，根据<a href="https://gitee.com/help/articles/4237">官方指示</a></p><p><img data-src="https://www.pianshen.com/images/763/d160e86218b36d31956264b83badf383.png" alt="在这里插入图片描述"></p><p>在项目路径中添加<code>.spa</code>文件</p><p><img data-src="https://www.pianshen.com/images/47/56f6b7fcdf231191cb0eee073e26c65f.png" alt="在这里插入图片描述"></p><p>原理，我不是很清楚，应该是给Nginx做一个<code>标识</code>作用吧。</p><h3 id="配置production版本路径名称"><a href="#配置production版本路径名称" class="headerlink" title="配置production版本路径名称"></a>配置production版本路径名称</h3><p>根目录下的vue.config.js文件，如下图箭头那个要改为项目文件名称</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003141513-937920345.png" alt="img"></p><p>在本地运行<code>npm run build</code>，得到/dist</p><p><img data-src="https://www.pianshen.com/images/168/5518c17f01e39d7a0984962b7276a2e0.png" alt="在这里插入图片描述">`</p><h3 id="配置-gitignore文件"><a href="#配置-gitignore文件" class="headerlink" title="配置.gitignore文件"></a>配置.gitignore文件</h3><p>首先要在.gitignore文件去掉/dist，这个文件默认是不上传的，但是执行打包bulid的时候会生成dist文件，而线上访问的是打包之后的dist文件；</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208002522081-1246305362.png" alt="img"></p><h2 id="2-2-将项目提交至gitee"><a href="#2-2-将项目提交至gitee" class="headerlink" title="2.2 将项目提交至gitee"></a>2.2 将项目提交至gitee</h2><p>参考1.2节的做法，此步不再赘述</p><h2 id="2-3-配置Gitee-Page"><a href="#2-3-配置Gitee-Page" class="headerlink" title="2.3 配置Gitee Page"></a>2.3 配置Gitee Page</h2><p>用上次同样的方法点进Gitee Pages</p><p><img data-src="https://img2018.cnblogs.com/i-beta/475401/202002/475401-20200208002750052-1156032907.png" alt="img"></p><p>这一次部署目录要填写dist</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003016869-817429112.png" alt="img"></p><h2 id="2-4-访问网站"><a href="#2-4-访问网站" class="headerlink" title="2.4 访问网站"></a>2.4 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，这次vue-cli创建的项目不需要，打开线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目</a> 就可以体验电商项目了</p><h1 id="三、使用vue-cli脚手架创建的页面提交至GitHub-Pages"><a href="#三、使用vue-cli脚手架创建的页面提交至GitHub-Pages" class="headerlink" title="三、使用vue-cli脚手架创建的页面提交至GitHub Pages"></a>三、使用vue-cli脚手架创建的页面提交至GitHub Pages</h1><h2 id="3-1-GitHub-Pages服务说明与注意事项"><a href="#3-1-GitHub-Pages服务说明与注意事项" class="headerlink" title="3.1 GitHub Pages服务说明与注意事项"></a>3.1 GitHub Pages服务说明与注意事项</h2><p>在你的github项目设置的GitHub Pages项，有这么一句话：</p><blockquote><p><a href="https://pages.github.com/">GitHub Pages</a> is designed to host your personal, organization, or project pages from a GitHub repository.<br>译：GitHub Pages旨在从GitHub存储库中托管您的个人、组织或项目页面。</p></blockquote><p>这句话主要是介绍GitHub Pages的宗旨，<a href="https://pages.github.com/">Github Pages</a> 官网上有其他的一些介绍，由于都是英文，我们看着费劲，不如直接看Gitee Pages 服务的说明，两者都差不多。<br><a href="https://img-blog.csdnimg.cn/20191224113012803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70"><img data-src="https://img-blog.csdnimg.cn/20191224113012803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70" alt="Gitee Pages 服务说明"></a><br>注意事项大家了解一下切勿违反就行，这里重点给大家说的是红框圈出的内容，Pages服务只支持静态项目，若你的项目需要服务器支持，就不适合部署到这上面了。</p><h2 id="3-2-项目配置注意事项"><a href="#3-2-项目配置注意事项" class="headerlink" title="3.2 项目配置注意事项"></a>3.2 项目配置注意事项</h2><h4 id="1、vue-router-不要开启-history-模式"><a href="#1、vue-router-不要开启-history-模式" class="headerlink" title="1、vue-router 不要开启 history 模式"></a>1、vue-router 不要开启 history 模式</h4><p>正常项目中我们会因为网站路径中带有“#”而将vue-router开启history模式，以去掉#号。但开启history模式需要服务器的支持，因此在github pages中不支持这一模式，所以我们不能开启history模式。</p><h4 id="2、在-vue-config-js-中设置正确的-publicPath"><a href="#2、在-vue-config-js-中设置正确的-publicPath" class="headerlink" title="2、在 vue.config.js 中设置正确的 publicPath"></a>2、在 vue.config.js 中设置正确的 publicPath</h4><p>要将项目部署到 https://<USERNAME>.github.io/<REPO>/ 上 (即仓库地址为 <a href="https://github.com/">https://github.com/</a><USERNAME>/<REPO>)，可将 publicPath 设为 “/<REPO>/“。<br>举个例子，我的仓库名字为“vue-admin-web”，那么 vue.config.js 的内容应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">    ? &#39;&#x2F;vue-admin-web&#x2F;&#39;</span><br><span class="line">    : &#39;&#x2F;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、部署github项目"><a href="#三、部署github项目" class="headerlink" title="三、部署github项目"></a>三、部署github项目</h2><p>做好上述的配置后，就可以把项目推送到github上了，首先在Github上新建仓库</p><p>在本地上.git中的config中[remote “origin”]下增加一行</p><p>  url = <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:<USERNAME>/<REPO>.git</p><p>gitpush成功把项目推送到了该仓库下。接下来把项目部署到github pages上。【参考 <a href="https://cli.vuejs.org/zh/guide/deployment.html#github-pages">vue-cli</a> 官方说明】<br>1、在项目目录下，创建内容如下的 deploy.sh 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env sh</span><br><span class="line"></span><br><span class="line"># 当发生错误时中止脚本</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># 构建</span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"># cd 到构建输出的目录下 </span><br><span class="line">cd dist</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &#39;deploy&#39;</span><br><span class="line"></span><br><span class="line"># 部署到 https:&#x2F;&#x2F;&lt;USERNAME&gt;.github.io&#x2F;&lt;REPO&gt;</span><br><span class="line">git push -f git@github.com:&lt;USERNAME&gt;&#x2F;&lt;REPO&gt;.git master:gh-pages</span><br><span class="line"></span><br><span class="line">cd -</span><br></pre></td></tr></table></figure><p>2、运行该文件<br>在项目目录下打开cmd命令窗口（快捷方法：在项目目录下，按住Shift键，然后鼠标右键，选择“在此处打开命令窗口”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Linux环境下</span><br><span class="line">bash deploy.sh</span><br><span class="line">&#x2F;&#x2F; Windows环境下</span><br><span class="line">deploy.sh</span><br></pre></td></tr></table></figure><p>运行后，git就会执行该文件里的命令。大致就是，构建打包项目代码，然后将打包后的代码上传到仓库中的 gh-pages 分支。（注意：新建的仓库默认只有master分支，没有gh-pages分支，但不需要你手动新建该分支，运行该文件后，会自动帮你生成gh-pages分支）<br>这样，你的项目就已经部署到github pages 了。在你的github项目的 Settings - Options 下的 GitHub Pages项里，可以看到你的项目线上网站地址。<br>示例：<a href="https://marco-hui.github.io/vue-admin-web/">https://marco-hui.github.io/vue-admin-web/</a><br><a href="https://img-blog.csdnimg.cn/20200104151551478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70"><img data-src="https://img-blog.csdnimg.cn/20200104151551478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Gitee Pages实现静态页面（&lt;a href=&quot;https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF&quot;&gt;悦听播放器(Gitee Pages)&lt;/a&gt; 和&lt;a href=&quot;https://hxy1997.xyz/music_player/%E6%A8%A1%E6%9D%BF&quot;&gt;悦听播放器(GitHub Pages)&lt;/a&gt;）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Pages，实现项目的正式上线 &lt;a href=&quot;https://hxy1997.gitee.io/vue_shops/&quot;&gt;Vue电商项目(Gitee Pages)&lt;/a&gt;和&lt;a href=&quot;https://hxy1997.xyz/vue_shops/&quot;&gt;Vue电商项目(GitHub Pages)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://hxy1997.xyz/tags/Vue/"/>
    
    <category term="Gitee Pages" scheme="https://hxy1997.xyz/tags/Gitee-Pages/"/>
    
    <category term="GitHub Pages" scheme="https://hxy1997.xyz/tags/GitHub-Pages/"/>
    
    <category term="实战" scheme="https://hxy1997.xyz/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>HTML和浏览器</title>
    <link href="https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2021-03-09T12:42:39.000Z</published>
    <updated>2021-03-11T13:06:00.641Z</updated>
    
    <content type="html"><![CDATA[<p>HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。</p><span id="more"></span><h1 id="1-行内元素和块级元素"><a href="#1-行内元素和块级元素" class="headerlink" title="1.行内元素和块级元素"></a>1.行内元素和块级元素</h1><h3 id="初窥门径："><a href="#初窥门径：" class="headerlink" title="初窥门径："></a>初窥门径：</h3><p>什么叫行内元素？</p><p>常见的span、a、lable、strong、b等html标签都是行内元素</p><p>什么叫块级元素？</p><p>常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素</p><h3 id="略知一二："><a href="#略知一二：" class="headerlink" title="略知一二："></a>略知一二：</h3><p>行内元素有：<br>a, span, label, strong, em, br, img, input, select, textarea, cite,<br>块级元素：<br>div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset</p><h3 id="粗通皮毛："><a href="#粗通皮毛：" class="headerlink" title="粗通皮毛："></a>粗通皮毛：</h3><h4 id="（行内元素）内联元素-inline-element"><a href="#（行内元素）内联元素-inline-element" class="headerlink" title="（行内元素）内联元素(inline element)"></a>（行内元素）内联元素(inline element)</h4><ul><li>a - 锚点</li><li>abbr - 缩写</li><li>acronym - 首字</li><li>b - 粗体(不推荐)</li><li>bdo - bidi override</li><li>big - 大字体</li><li>br - 换行</li><li>cite - 引用</li><li>code - 计算机代码(在引用源码的时候需要)</li><li>dfn - 定义字段</li><li>em - 强调</li><li>font - 字体设定(不推荐)</li><li>i - 斜体</li><li>img - 图片</li><li>input - 输入框</li><li>kbd - 定义键盘文本</li><li>label - 表格标签</li><li>q - 短引用</li><li>s - 中划线(不推荐)</li><li>samp - 定义范例计算机代码</li><li>select - 项目选择</li><li>small - 小字体文本</li><li>span - 常用内联容器，定义文本内区块</li><li>strike - 中划线</li><li>strong - 粗体强调</li><li>sub - 下标</li><li>sup - 上标</li><li>textarea - 多行文本输入框</li><li>tt - 电传文本</li><li>u - 下划线</li><li>var - 定义变量</li></ul><h4 id="块元素-block-element"><a href="#块元素-block-element" class="headerlink" title="块元素(block element)"></a>块元素(block element)</h4><ul><li>address - 地址</li><li>blockquote - 块引用</li><li>center - 举中对齐块</li><li>dir - 目录列表</li><li>div - 常用块级容易，也是css layout的主要标签</li><li>dl - 定义列表</li><li>fieldset - form控制组</li><li>form - 交互表单</li><li>h1 - 大标题</li><li>h2 - 副标题</li><li>h3 - 3级标题</li><li>h4 - 4级标题</li><li>h5 - 5级标题</li><li>h6 - 6级标题</li><li>hr - 水平分隔线</li><li>isindex - input prompt</li><li>menu - 菜单列表</li><li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容</li><li>noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）</li><li>ol - 排序表单</li><li>p - 段落</li><li>pre - 格式化文本</li><li>table - 表格</li><li>ul - 非排序列表</li></ul><h4 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h4><p>可变元素为根据上下文语境决定该元素为块元素或者行内元素。</p><ul><li>applet - java applet</li><li>button - 按钮</li><li>del - 删除文本</li><li>iframe - inline frame</li><li>ins - 插入的文本</li><li>map - 图片区块(map)</li><li>object - object对象</li><li>script - 客户端脚本</li></ul><h3 id="驾轻就熟："><a href="#驾轻就熟：" class="headerlink" title="驾轻就熟："></a>驾轻就熟：</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>块级元素会独占一行，其宽度自动填满其父元素宽度<br>行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化</li><li>块级元素可以设置 width, height属性，【注意：块级元素即使设置了宽度，仍然是独占一行的】<br>行内元素设置width, height无效;</li><li>块级元素可以设置margin 和 padding.<br>行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）</li></ol><h3 id="青出於蓝"><a href="#青出於蓝" class="headerlink" title="青出於蓝:"></a>青出於蓝:</h3><ul><li>行内元素与块级元素直观上的区别<br>行内元素会在一条直线上排列，都是同一行的，水平方向排列<br>块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</li><li>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上<br>行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display：inline 行内元素&#x2F;内联元素</span><br><span class="line">display: block 块级元素</span><br><span class="line">display:inline-block 设置成行内块级元素。</span><br></pre></td></tr></table></figure><blockquote><p>行内块级元素:和其他元素同一行（行内元素特点），可以设置元素的宽高等（块级元素特点）；这样的元素有img input；它们为行内元素，但可以改变宽和高；<br>但我在我印象中，貌似没有默认样式是inline-block的元素。</p></blockquote><h3 id="融会贯通："><a href="#融会贯通：" class="headerlink" title="融会贯通："></a>融会贯通：</h3><ul><li>行内元素属性<ol><li>行内元素属性标签它和其它标签处在同一行内</li><li>行内元素属性标签无法设置宽度，高度 行高 距顶部距离 距底部距离</li><li>行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的</li><li>行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接）</li></ol></li><li>块级元素属性<ol><li>每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）</li><li>块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离</li><li>块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的100%</li><li>块级元素属性标签是可以直接嵌套的</li><li>p标签中不能嵌套div标签</li></ol></li></ul><h3 id="出类拔萃："><a href="#出类拔萃：" class="headerlink" title="出类拔萃："></a>出类拔萃：</h3><ul><li><p>CSS设置行内元素的</p><ul><li><p>水平居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;text-align:center&#125; &#x2F;*DIV内的行内元素均会水平居中*&#x2F; </span><br></pre></td></tr></table></figure></li><li><p>垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;height:30px; line-height:30px&#125; &#x2F;*DIV内的行内元素均会垂直居中*&#x2F; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>CSS设置块级元素的<br>- 水平居中<br><code>div p&#123;margin:0 auto; width:500px&#125; /*块级元素p一定要设置宽度， 才能相当于DIV父容器水平居中*/</code><br>- 垂直居中<br><code>div&#123;width:500px&#125; /*DIV父容器设置宽度*/ div p&#123;margin:0 aut0; height:30px; line-height:30px&#125; /*块级元素p也可以加个宽度， 以达到相对于DIV父容器的水平居中效果*/</code></p></li></ul><blockquote><p>在以后的实际项目中，块级元素的垂直居中布局方式可能会碰到比这个更复杂, 会尝试用inline-block去解决问题，希望后续多多关注；另外推荐各位一本书肖志华《CSS核心技术详解》</p></blockquote><h3 id="返璞归真："><a href="#返璞归真：" class="headerlink" title="返璞归真："></a>返璞归真：</h3><p>在标准文档流里面，块级元素具有以下特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 总是在新行上开始，占据一整行；</span><br><span class="line">② 高度，行高以及外边距和内边距都可控制；</span><br><span class="line">③ 宽带始终是与浏览器宽度一样，与内容无关；</span><br><span class="line">④ 它可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure><p>行内元素的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 和其他元素都在一行上；</span><br><span class="line">② 高，行高及外边距和内边距部分可改变；</span><br><span class="line">③ 宽度只与内容有关；</span><br><span class="line">④ 行内元素只能容纳文本或者其他行内元素。</span><br><span class="line">不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用</span><br></pre></td></tr></table></figure><h1 id="2-跨页面通信"><a href="#2-跨页面通信" class="headerlink" title="2.跨页面通信"></a>2.跨页面通信</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。</p><p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?imageslim" alt="跨页面通信实例"></p><p>这就是我们所说的前端跨页面通信。</p><p>你知道哪些跨页面通信的方式呢？如果不清楚，下面我就带大家来看看七种跨页面通信的方式。</p><hr><h2 id="一、同源页面间的跨页面通信"><a href="#一、同源页面间的跨页面通信" class="headerlink" title="一、同源页面间的跨页面通信"></a>一、同源页面间的跨页面通信</h2><blockquote><p>以下各种方式的 <a href="https://alienzhou.github.io/cross-tab-communication/">在线 Demo 可以戳这里 &gt;&gt;</a></p></blockquote><p>浏览器的<a href="https://en.wikipedia.org/wiki/Same-origin_policy">同源策略</a>在下述的一些跨页面通信方法中依然存在限制。因此，我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p><h3 id="1-BroadCast-Channel"><a href="#1-BroadCast-Channel" class="headerlink" title="1. BroadCast Channel"></a>1. BroadCast Channel</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadCast Channel</a> 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的API和用法都非常简单。</p><p>下面的方式就可以创建一个标识为<code>AlienZHOU</code>的频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br></pre></td></tr></table></figure><p>各个页面可以通过<code>onmessage</code>来监听被广播的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[BroadcastChannel] receive message:&#39;, text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要发送消息时只需要调用实例上的<code>postMessage</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(mydata);</span><br></pre></td></tr></table></figure><blockquote><p>Broadcast Channel 的具体的使用方式可以看这篇<a href="https://juejin.im/post/6844903811228663815">《【3分钟速览】前端广播式通信：Broadcast Channel》</a>。</p></blockquote><h3 id="2-Service-Worker"><a href="#2-Service-Worker" class="headerlink" title="2. Service Worker"></a>2. Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a> 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p><blockquote><p>Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章<a href="https://juejin.im/post/6844903588691443725">【PWA学习与实践】(3) 让你的WebApp离线可用</a>。</p></blockquote><p>首先，需要在页面注册 Service Worker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.register(&#39;..&#x2F;util.sw.js&#39;).then(function () &#123;</span><br><span class="line">    console.log(&#39;Service Worker 注册成功&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>../util.sw.js</code>是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.sw.js Service Worker 逻辑 *&#x2F;</span><br><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    console.log(&#39;service worker receive message&#39;, e.data);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(function (clients) &#123;</span><br><span class="line">            if (!clients || clients.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            clients.forEach(function (client) &#123;</span><br><span class="line">                client.postMessage(e.data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在 Service Worker 中监听了<code>message</code>事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过<code>self.clients.matchAll()</code>获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的<code>postMessage</code>方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。</p><p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Service Worker] receive message:&#39;, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，当需要同步消息时，可以调用 Service Worker 的<code>postMessage</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.controller.postMessage(mydata);</span><br></pre></td></tr></table></figure><h3 id="3-LocalStorage"><a href="#3-LocalStorage" class="headerlink" title="3. LocalStorage"></a>3. LocalStorage</h3><p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但<a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent"><code>StorageEvent</code></a>这个与它相关的事件有些同学可能会比较陌生。</p><p>当 LocalStorage 变化时，会触发<code>storage</code>事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听<code>storage</code>事件即可收到通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, function (e) &#123;</span><br><span class="line">    if (e.key &#x3D;&#x3D;&#x3D; &#39;ctc-msg&#39;) &#123;</span><br><span class="line">        const data &#x3D; JSON.parse(e.newValue);</span><br><span class="line">        const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">        console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的<code>setItem</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata.st &#x3D; +(new Date);</span><br><span class="line">window.localStorage.setItem(&#39;ctc-msg&#39;, JSON.stringify(mydata));</span><br></pre></td></tr></table></figure><p>注意，这里有一个细节：我们在mydata上添加了一个取当前毫秒时间戳的<code>.st</code>属性。这是因为，<code>storage</code>事件只有在值真正改变时才会触发。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br></pre></td></tr></table></figure><p>由于第二次的值<code>&#39;123&#39;</code>与第一次的值相同，所以以上的代码只会在第一次<code>setItem</code>时触发<code>storage</code>事件。因此我们通过设置<code>st</code>来保证每次调用时一定会触发<code>storage</code>事件。</p><h3 id="小憩一下"><a href="#小憩一下" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是些 tricky 的<code>storage</code>事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。</p><blockquote><p>在上面的例子中，这个“中央站”可以是一个 BroadCast Channel 实例、一个 Service Worker 或是 LocalStorage。</p></blockquote><p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p><hr><h3 id="4-Shared-Worker"><a href="#4-Shared-Worker" class="headerlink" title="4. Shared Worker"></a>4. Shared Worker</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared Worker</a> 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p><p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：</p><p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过<code>postMessage</code>传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p><p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span><br><span class="line">const sharedWorker &#x3D; new SharedWorker(&#39;..&#x2F;util.shared.js&#39;, &#39;ctc&#39;);</span><br></pre></td></tr></table></figure><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.shared.js: Shared Worker 代码 *&#x2F;</span><br><span class="line">let data &#x3D; null;</span><br><span class="line">self.addEventListener(&#39;connect&#39;, function (e) &#123;</span><br><span class="line">    const port &#x3D; e.ports[0];</span><br><span class="line">    port.addEventListener(&#39;message&#39;, function (event) &#123;</span><br><span class="line">        &#x2F;&#x2F; get 指令则返回存储的消息数据</span><br><span class="line">        if (event.data.get) &#123;</span><br><span class="line">            data &amp;&amp; port.postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非 get 指令则存储该消息数据</span><br><span class="line">        else &#123;</span><br><span class="line">            data &#x3D; event.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时轮询，发送 get 指令的消息</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line">    sharedWorker.port.postMessage(&#123;get: true&#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 get 消息的返回数据</span><br><span class="line">sharedWorker.port.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Shared Worker] receive message:&#39;, text);</span><br><span class="line">&#125;, false);</span><br><span class="line">sharedWorker.port.start();</span><br></pre></td></tr></table></figure><p>最后，当要跨页面通信时，只需给 Shared Worker <code>postMessage</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.port.postMessage(mydata);</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果使用<code>addEventListener</code>来添加 Shared Worker 的消息监听，需要显式调用<code>MessagePort.start</code>方法，即上文中的<code>sharedWorker.port.start()</code>；如果使用<code>onmessage</code>绑定监听则不需要。</p></blockquote><h3 id="5-IndexedDB"><a href="#5-IndexedDB" class="headerlink" title="5. IndexedDB"></a>5. IndexedDB</h3><p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> 或 cookie。</p><blockquote><p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p></blockquote><p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p><ul><li><p>打开数据库连接：</p><p>function openStore() { const storeName = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { if (!(‘indexedDB’ in window)) { return reject(‘don’t support indexedDB’); } const request = indexedDB.open(‘CTC_DB’, 1); request.onerror = reject; request.onsuccess =  e =&gt; resolve(e.target.result); request.onupgradeneeded = function (e) { const db = e.srcElement.result; if (e.oldVersion === 0 &amp;&amp; !db.objectStoreNames.contains(storeName)) { const store = db.createObjectStore(storeName, {keyPath: ‘tag’}); store.createIndex(storeName + ‘Index’, ‘tag’, {unique: false}); } } }); }</p></li><li><p>存储数据</p><p>function saveData(db, data) { return new Promise(function (resolve, reject) { const STORE_NAME = ‘ctc_aleinzhou’; const tx = db.transaction(STORE_NAME, ‘readwrite’); const store = tx.objectStore(STORE_NAME); const request = store.put({tag: ‘ctc_data’, data}); request.onsuccess = () =&gt; resolve(db); request.onerror = reject; }); }</p></li><li><p>查询/读取数据</p><p>function query(db) { const STORE_NAME = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { try { const tx = db.transaction(STORE_NAME, ‘readonly’); const store = tx.objectStore(STORE_NAME); const dbRequest = store.get(‘ctc_data’); dbRequest.onsuccess = e =&gt; resolve(e.target.result); dbRequest.onerror = reject; } catch (err) { reject(err); } }); }</p></li></ul><p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null))</span><br></pre></td></tr></table></figure><p>对于消息读取，可以在连接与初始化后轮询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        query(db).then(function (res) &#123;</span><br><span class="line">            if (!res || !res.data) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const data &#x3D; res.data;</span><br><span class="line">            const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">            console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… 省略上面的轮询代码</span><br><span class="line">    &#x2F;&#x2F; 触发 saveData 的方法可以放在用户操作的事件监听内</span><br><span class="line">    saveData(db, mydata);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="小憩一下-1"><a href="#小憩一下-1" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p><p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听<code>visibilitychange</code>这样的事件，来做一次信息同步即可。</p><p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p><hr><h3 id="6-window-open-window-opener"><a href="#6-window-open-window-opener" class="headerlink" title="6. window.open + window.opener"></a>6. window.open + window.opener</h3><p>当我们使用<code>window.open</code>打开页面时，方法会返回一个被打开页面<code>window</code>的引用。而在未显示指定<code>noopener</code>时，被打开的页面可以通过<code>window.opener</code>获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p><p>首先，我们把<code>window.open</code>打开的页面的<code>window</code>对象收集起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let childWins &#x3D; [];</span><br><span class="line">document.getElementById(&#39;btn&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    const win &#x3D; window.open(&#39;.&#x2F;some&#x2F;sample&#39;);</span><br><span class="line">    childWins.push(win);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">if (childWins.length &gt; 0) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; false;</span><br><span class="line">    childWins.forEach(w &#x3D;&gt; w.postMessage(mydata));</span><br><span class="line">&#125;</span><br><span class="line">if (window.opener &amp;&amp; !window.opener.closed) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; true;</span><br><span class="line">    window.opener.postMessage(mydata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我这里先用<code>.closed</code>属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p><p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p><blockquote><p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Cross-document Messaging] receive message:&#39;, text);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (window.opener &amp;&amp; !window.opener.closed &amp;&amp; data.fromOpenner) &#123;</span><br><span class="line">        window.opener.postMessage(data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">    childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (childWins &amp;&amp; !data.fromOpenner) &#123;</span><br><span class="line">        childWins.forEach(w &#x3D;&gt; w.postMessage(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p><h3 id="小憩一下-2"><a href="#小憩一下-2" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的<code>window.open</code>打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p><p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。</p><p>关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇<a href="https://juejin.im/post/6844903618043183111">《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》</a></p><p>此外，我还针对以上各种方式写了一个 <a href="https://alienzhou.github.io/cross-tab-communication/">在线演示的 Demo &gt;&gt;</a></p><p>![Demo页面](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="567"></svg>)</p><h2 id="二、非同源页面之间的通信"><a href="#二、非同源页面之间的通信" class="headerlink" title="二、非同源页面之间的通信"></a>二、非同源页面之间的通信</h2><p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p><p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定<code>origin</code>来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<code>http://sample.com/bridge.html</code>），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.frames[0].window.postMessage(mydata, &#39;*&#39;);</span><br></pre></td></tr></table></figure><p>其中为了简便此处将<code>postMessage</code>的第二个参数设为了<code>&#39;*&#39;</code>，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br><span class="line">&#x2F;&#x2F; 收到来自页面的消息后，在 iframe 间进行广播</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    bc.postMessage(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 对于收到的（iframe）广播消息，通知给所属的业务页面</span><br><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    window.parent.postMessage(e.data, &#39;*&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/31/169d468988a6ba8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天和大家分享了一下跨页面通信的各种方式。</p><p>对于同源页面，常见的方式包括：</p><ul><li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li><li>共享存储模式：Shared Worker / IndexedDB / cookie</li><li>口口相传模式：window.open + window.opener</li><li>基于服务端：Websocket / Comet / SSE 等</li></ul><p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p><h1 id="3-前端路由的两种模式：hash模式和-history模式"><a href="#3-前端路由的两种模式：hash模式和-history模式" class="headerlink" title="3.前端路由的两种模式：hash模式和 history模式"></a>3.前端路由的两种模式：hash模式和 history模式</h1><h2 id="为什么要使用路由"><a href="#为什么要使用路由" class="headerlink" title="为什么要使用路由"></a>为什么要使用路由</h2><p>现在的网络应用程序越来越多的使用AJAX异步请求完成页面的无缝刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而提高了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。</p><p>单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。</p><h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能：</p><ol><li>当浏览器地址变化时，切换页面；</li><li>点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</li><li>刷新浏览器，网页加载当前路由对应内容；</li></ol><p>在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：</p><ul><li>hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；</li><li>history模式：利用history API实现url地址改变，网页内容改变；</li></ul><p>它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。</p><h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：</p><ol><li>hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如<a href="http://localhost/index.html#abc%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84#abc%E5%B0%B1%E6%98%AFhash%EF%BC%9B">http://localhost/index.html#abc，这里的#abc就是hash；</a></li><li>散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；</li><li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；</li><li>location.hash值的变化会直接反应到浏览器地址栏；</li></ol><h2 id="触发hashchange事件的几种情况："><a href="#触发hashchange事件的几种情况：" class="headerlink" title="触发hashchange事件的几种情况："></a>触发hashchange事件的几种情况：</h2><ul><li>浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；</li><li>当浏览器地址栏中URL包含哈希如 <a href="http://www.baidu.com/#home%EF%BC%8C%E8%BF%99%E6%97%B6%E6%8C%89%E4%B8%8B%E8%BE%93%E5%85%A5%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81http://www.baidu.com/%E8%AF%B7%E6%B1%82%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%E8%AE%BE%E7%BD%AE%E6%95%A3%E5%88%97%E5%80%BC%E4%B8%BA#home%EF%BC%8C%E8%BF%9B%E8%80%8C%E8%A7%A6%E5%8F%91onhashchange%E4%BA%8B%E4%BB%B6%EF%BC%9B">http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；</a></li><li>当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；</li><li>html中<a>标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置 url 的 hash，会在当前url后加上&#39;#abc&#39;</span><br><span class="line">window.location.hash&#x3D;&#39;abc&#39;;</span><br><span class="line">let hash &#x3D; window.location.hash &#x2F;&#x2F;&#39;#abc&#39;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;hashchange&#39;,function()&#123;</span><br><span class="line">&#x2F;&#x2F;监听hash变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>概述<br>window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。<br>History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。<br>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。<br>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。<br>属性<br>History 对象主要有两个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">History.length：当前窗口访问过的网址数量（包括当前网页）</span><br><span class="line">History.state：History 堆栈最上层的状态值（详见下文）</span><br><span class="line">&#x2F;&#x2F; 当前窗口访问过多少个网页</span><br><span class="line">history.length &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; History 对象的当前状态</span><br><span class="line">&#x2F;&#x2F; 通常是 undefined，即未设置</span><br><span class="line">history.state &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p><p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p><p>History.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。<br>History.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。<br>History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(1);&#x2F;&#x2F;相当于history.forward()</span><br><span class="line">history.go(-1);&#x2F;&#x2F;相当于history.back()</span><br><span class="line">history.go(0); &#x2F;&#x2F; 刷新当前页面</span><br></pre></td></tr></table></figure><p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p><p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p><p>History.pushState()<br>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。</p><p>语法：history.pushState(object, title, url)</p><p>该方法接受三个参数，依次为：</p><p>object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。<br>title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。<br>url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(data, &#39;&#39;, &#39;2.html&#39;);</span><br><span class="line">console.log(history.state) &#x2F;&#x2F; &#123;foo: &quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure><p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p><p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p><p>如果 pushState() 方法设置了一个跨域网址，则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">&#x2F;&#x2F; 当前网址为 http:&#x2F;&#x2F;example.com</span><br><span class="line">history.pushState(null, &#39;&#39;, &#39;https:&#x2F;&#x2F;twitter.com&#x2F;hello&#39;);</span><br></pre></td></tr></table></figure><p>上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p><p>History.replaceState()<br>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。</p><p>假定当前网页是 example.com/example.html。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;page: 1&#125;, &#39;&#39;, &#39;?page&#x3D;1&#39;)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;page: 2&#125;, &#39;&#39;, &#39;?page&#x3D;2&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;2</span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &#39;&#39;, &#39;?page&#x3D;3&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html</span><br><span class="line"></span><br><span class="line">history.go(2)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br></pre></td></tr></table></figure><p>popstate 事件<br>每当 history 对象出现变化时，就会触发 popstate 事件。</p><p>注意：</p><p>仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;<br>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。<br>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。<br>页面第一次加载的时候，浏览器不会触发popstate事件。<br>使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;popstate&#39;, function(e) &#123;</span><br><span class="line">&#x2F;&#x2F;e.state 相当于 history.state</span><br><span class="line">console.log(&#39;state: &#39; + JSON.stringify(e.state));</span><br><span class="line">console.log(history.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击查看 通过history.pushState 实现页面 tab 切换的功能。</p><p>history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。</p><h1 id="4-DOM树：JavaScript是如何影响DOM树构建的"><a href="#4-DOM树：JavaScript是如何影响DOM树构建的" class="headerlink" title="4.DOM树：JavaScript是如何影响DOM树构建的"></a>4.DOM树：JavaScript是如何影响DOM树构建的</h1><p>续沿着网络数据流路径来介绍 DOM 树是怎么生成的。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p><h2 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h2><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用</p><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p><h2 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h2><p>在渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p><p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p><p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p><p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p><p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/57.png" alt="img"></p><p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p><p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong></p><p>前面《14 | 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/58.png" alt="img"></p><p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如</p><p>就是 StartTag ，就是EndTag，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。</p><p><strong>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中</strong>。</p><blockquote><p>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p></blockquote><ul><li>如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p><p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p><p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/59.png" alt="img"></p><p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/60.png" alt="img"></p><p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/61.png" alt="img"></p><p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/62.png" alt="img"></p><p>按照同样的规则，一路解析，最终结果如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/63.png" alt="img"></p><p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p><h2 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h2><p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。script标签之前，所有的解析流程还是和之前介绍的一样，但是解析到script标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/64.png" alt="img"></p><p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p><p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p><p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">            div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM</span><br><span class="line">            div1.style.color = &#x27;red&#x27;  // 需要 CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p><p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p><p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p><p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了</p><h1 id="5-事件模型"><a href="#5-事件模型" class="headerlink" title="5.事件模型"></a>5.事件模型</h1><p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章介绍 DOM 的事件编程。</p><h2 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h2><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p><p>该接口主要提供三个实例方法。</p><ul><li><code>addEventListener</code>：绑定事件的监听函数</li><li><code>removeEventListener</code>：移除事件的监听函数</li><li><code>dispatchEvent</code>：触发事件</li></ul><h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure><p>该方法接受三个参数。</p><ul><li><code>type</code>：事件名称，大小写敏感。</li><li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li><li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li></ul><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var button &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">button.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p><p>关于参数，有两个地方需要注意。</p><p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(&#39;click&#39;, &#123;</span><br><span class="line">  handleEvent: function (event) &#123;</span><br><span class="line">    console.log(&#39;click&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p><p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p><blockquote><ul><li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li><li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li><li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li></ul></blockquote><p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure><p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p><p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function print(x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var el &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">el.addEventListener(&#39;click&#39;, function () &#123; print(&#39;Hello&#39;); &#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p><p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">var para &#x3D; document.getElementById(&#39;para&#39;);</span><br><span class="line">para.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(this.nodeName); &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p><h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, listener, false);</span><br></pre></td></tr></table></figure><p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p><p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;mousedown&#39;, handleMouseDown, true);</span><br><span class="line">element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p><h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure><p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p>上面代码在当前节点触发了<code>click</code>事件。</p><p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p><p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canceled &#x3D; !cb.dispatchEvent(event);</span><br><span class="line">if (canceled) &#123;</span><br><span class="line">  console.log(&#39;事件取消&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;事件未取消&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h2><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p><p>JavaScript 有三种方法，可以为事件绑定监听函数。</p><h3 id="HTML-的-on-属性"><a href="#HTML-的-on-属性" class="headerlink" title="HTML 的 on- 属性"></a>HTML 的 on- 属性</h3><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line">&lt;div onclick&#x3D;&quot;console.log(&#39;触发事件&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p><p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p><p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure><p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p><p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&quot;console.log(2)&quot;&gt;</span><br><span class="line">  &lt;button onClick&#x3D;&quot;console.log(1)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p><p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(&#39;onclick&#39;, &#39;doSomething()&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; &lt;Element onclick&#x3D;&quot;doSomething()&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h3><p>元素节点对象的事件属性，同样可以指定监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p><p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p><h3 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, doSomething, false);</span><br></pre></td></tr></table></figure><p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p><p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p><p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p><ul><li>同一个事件可以添加多个监听函数。</li><li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li><li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li></ul><h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;btn&quot; onclick&#x3D;&quot;console.log(this.id)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>执行上面代码，点击后会输出<code>btn</code>。</p><p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">btn.onclick &#x3D; function () &#123;</span><br><span class="line">  console.log(this.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">btn.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p><h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p><ul><li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li><li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li><li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li></ul><p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;点击&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p><p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var phases &#x3D; &#123;</span><br><span class="line">  1: &#39;capture&#39;,</span><br><span class="line">  2: &#39;target&#39;,</span><br><span class="line">  3: &#39;bubble&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  var phase &#x3D; phases[event.eventPhase];</span><br><span class="line">  console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击以后的结果</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;capture&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;bubble&#39;</span><br></pre></td></tr></table></figure><p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p><ol><li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li><li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li><li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li></ol><p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p><p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p><p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p><h2 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; some code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 事件传播到 p 元素后，就不再向下传播了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件冒泡到 p 元素后，就不再向上冒泡了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p><p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 会触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件向其他元素传播。因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p><p>如果想要彻底阻止这个事件的传播，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底阻止这个事件传播，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p><h2 id="Event-对象概述"><a href="#Event-对象概述" class="headerlink" title="Event 对象概述"></a>Event 对象概述</h2><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p><p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event &#x3D; new Event(type, options);</span><br></pre></td></tr></table></figure><p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p><ul><li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li><li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; new Event(</span><br><span class="line">  &#39;look&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#39;bubbles&#39;: true,</span><br><span class="line">    &#39;cancelable&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">document.dispatchEvent(ev);</span><br></pre></td></tr></table></figure><p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p><p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  console.log(&#39;Tag: &#39; + tag); &#x2F;&#x2F; 没有任何输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">var click &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p><p>另一方面，如果这个事件在<code>div</code>元素上触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure><p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p><h2 id="Event-对象的实例属性"><a href="#Event-对象的实例属性" class="headerlink" title="Event 对象的实例属性"></a>Event 对象的实例属性</h2><h3 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h3><p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p><p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var phase &#x3D; event.eventPhase;</span><br></pre></td></tr></table></figure><p><code>Event.eventPhase</code>的返回值有四种可能。</p><ul><li>0.事件目前没有发生。</li><li>1.事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li><li>2.事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li><li>3.事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li></ul><h3 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h3><p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p><p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.cancelable  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p><p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function preventEvent(event) &#123;</span><br><span class="line">  if (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.warn(&#39;This event couldn\&#39;t be canceled.&#39;);</span><br><span class="line">    console.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p><p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (event.defaultPrevented) &#123;</span><br><span class="line">  console.log(&#39;该事件已经取消了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h3><p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p><p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">function hide(e) &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.currentTarget);  &#x2F;&#x2F; 总是 true</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.target);  &#x2F;&#x2F; 有可能不是 true</span><br><span class="line">  e.target.style.visibility &#x3D; &#39;hidden&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">para.addEventListener(&#39;click&#39;, hide, false);</span><br></pre></td></tr></table></figure><p>上面代码中，如果在<code>para</code>节点的<code>&lt;em&gt;</code>子节点上面点击，则<code>e.target</code>指向<code>&lt;em&gt;</code>子节点，导致<code>&lt;em&gt;</code>子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个<code>para</code>都将不可见。</p><h3 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h3><p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.type &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure><h3 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h3><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.timeStamp &#x2F;&#x2F; 3683.6999999995896</span><br></pre></td></tr></table></figure><p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p><p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var previousX;</span><br><span class="line">var previousY;</span><br><span class="line">var previousT;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;mousemove&#39;, function(event) &#123;</span><br><span class="line">  if (</span><br><span class="line">    previousX !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousY !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousT !&#x3D;&#x3D; undefined</span><br><span class="line">  ) &#123;</span><br><span class="line">    var deltaX &#x3D; event.screenX - previousX;</span><br><span class="line">    var deltaY &#x3D; event.screenY - previousY;</span><br><span class="line">    var deltaD &#x3D; Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));</span><br><span class="line"></span><br><span class="line">    var deltaT &#x3D; event.timeStamp - previousT;</span><br><span class="line">    console.log(deltaD &#x2F; deltaT * 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX &#x3D; event.screenX;</span><br><span class="line">  previousY &#x3D; event.screenY;</span><br><span class="line">  previousT &#x3D; event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h3><p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.isTrusted &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p><h3 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h3><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dbclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">function giveDetails(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;p&#39;).onclick &#x3D; giveDetails;</span><br></pre></td></tr></table></figure><h2 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h2><h3 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h3><p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p><p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;my-checkbox&quot; &#x2F;&gt;</span><br><span class="line">var cb &#x3D; document.getElementById(&#39;my-checkbox&#39;);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e)&#123; e.preventDefault(); &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p><p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;my-input&quot; &#x2F;&gt;</span><br><span class="line">var input &#x3D; document.getElementById(&#39;my-input&#39;);</span><br><span class="line">input.addEventListener(&#39;keypress&#39;, checkName, false);</span><br><span class="line"></span><br><span class="line">function checkName(e) &#123;</span><br><span class="line">  if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p><h3 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h3><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function stopEvent(e) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, stopEvent, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p><h3 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h3><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p><p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function l1(e)&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function l2(e)&#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, l1, false);</span><br><span class="line">el.addEventListener(&#39;click&#39;, l2, false);</span><br></pre></td></tr></table></figure><p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p><h3 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h3><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.composedPath());</span><br><span class="line">&#125;, false);</span><br><span class="line">&#x2F;&#x2F; [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p><h2 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h2><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p><p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CustomEvent(type, options)</span><br></pre></td></tr></table></figure><p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p><ul><li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li></ul><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; new CustomEvent(&#39;build&#39;, &#123; &#39;detail&#39;: &#39;hello&#39; &#125;);</span><br><span class="line"></span><br><span class="line">function eventHandler(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;build&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p><p>下面是另一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myEvent &#x3D; new CustomEvent(&#39;myevent&#39;, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: &#39;bar&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: true,</span><br><span class="line">  cancelable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;myevent&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;Hello &#39; + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>Wilson Page, <a href="http://coding.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/">An Introduction To DOM Events</a></li><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching">Using Firefox 1.5 caching</a></li><li>Craig Buckler, <a href="http://www.sitepoint.com/css3-animation-javascript-event-handlers/">How to Capture CSS3 Animation Events in JavaScript</a></li><li>Ray Nicholus, <a href="http://blog.garstasio.com/you-dont-need-jquery/events/">You Don’t Need jQuery!: Events</a></li></ul><h1 id="6-彻底理解浏览器的缓存机制"><a href="#6-彻底理解浏览器的缓存机制" class="headerlink" title="6.彻底理解浏览器的缓存机制"></a>6.彻底理解浏览器的缓存机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358082ff05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358033cdc4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635806ca887?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358079780e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><p>以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。</p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359673e7d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63596c9de23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63597182316?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359acd19d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><p>那么强制缓存的缓存规则是什么？</p></blockquote><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><blockquote><p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p></blockquote><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><p>接下来，我们直接看一个例子，如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635aa7b772b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>由上面的例子我们可以知道：</p><ul><li>HTTP响应报文中expires的时间值，是一个绝对值</li><li>HTTP响应报文中Cache-Control为max-age=600，是相对值</li></ul><p>由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635afa6f7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。</p><blockquote><p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p></blockquote><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p><p>访问<a href="https://heyingye.github.io/">heyingye.github.io/ </a> –&gt;200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io>/">heyingye.github.io&gt;</a> –&gt;200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p><p>过程如下：</p><ul><li><p>访问<a href="https://heyingye.github.io/">heyingye.github.io/</a></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b40660cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.io/">heyingye.github.io/</a></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b4f0233b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>刷新</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635bd572192?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>from disk memory</p></li></ul><blockquote><p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</p></blockquote><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ul><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304，如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cbfff69d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>304</p><p>协商缓存失效，返回200和请求结果结果，如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cf070ff5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>200</p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635d2a88984?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>last-modify</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635db6d62fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>If-Modified-Since</p><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635e4dd628b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Etag</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ecb2cae0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Etag-match</p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ed5f6d26?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="7-Chrome-浏览器架构"><a href="#7-Chrome-浏览器架构" class="headerlink" title="7.Chrome 浏览器架构"></a>7.Chrome 浏览器架构</h1><h2 id="CPU与GPU"><a href="#CPU与GPU" class="headerlink" title="CPU与GPU"></a>CPU与GPU</h2><p>﻿CPU和GPU作为计算机中最重要的两个计算单元直接决定了计算性能。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img data-src="https://static001.geekbang.org/infoq/94/9407812940681a84a4b4661b551da819.png" alt="img"></p><p>CPU是计算机的大脑，负责处理各种不同的任务。在过去，大多数CPU是单芯片的，核心被安置在同一个芯片上。更新的CPU可以支持多核心，运算能力大大加强。而最新的的cpu已经达到10核心20线程数的能力了。</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img data-src="https://static001.geekbang.org/infoq/8f/8fc555c4a70f7f844dbb34edec74cf1f.png" alt="img"></p><p>GPU是另一个计算机的组成部分，与CPU不同，GPU更擅长利用多核心同时处理单一的任务。像命名那样，GPU最初被用于处理图像。这就是为什么使用GPU可以更快、更顺畅的渲染页面内容。随着GPU的发展，越来越多的计算任务也可以使用GPU来处理。甚至有人说GPU是人工智能的大功臣，可见GPU已经不再仅用于图像处理上了。</p><h2 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/2a/2af38ddf296b92cd6bbbf97322774c33.png" alt="img"></p><p>我们可以把计算机自下而上分成三层：硬件、操作系统和应用。有了操作系统的存在，上层运行的应用可以使用操作系统提供的能力使用硬件资源而不会直接访问硬件资源。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/97/97afac83d32e43397ea484653bb6b1ec.png" alt="img"></p><p>一个进程是应用正在运行的程序。而线程是进程中更小的一部分。当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作。操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，这段私有的内存也会被释放。其实还有比线程更小的存在就是<strong>协程，而协成是运行在线程中更小的单位。async/await就是基于协程实现的。</strong></p><h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/b8/b8306ca61a00c7ccfa68476e61a0b105.png" alt="img"></p><p>﻿</p><p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以时用IPC(Inter Process Communication)。</p><p>﻿多数程序被设计成使用IPC来进行进程间的通信，好处在于当一个进程给另一个进程发消息而没有回应时，并不影响当前的进程继续工作。</p><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>﻿</p><p>借助进程和线程，浏览器可以被设计成单进程、多线程架构，或者利用IPC实现多进程、多线程架构。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/23/23162955642bb163b16a5d08bdbb3288.png" alt="img"></p><p>这里我们以Chrome多进程架构介绍，在Chrome中存在这不同种类型的进程，它们各司其职。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/89/898bb4e5c529e5d3280b6787a7d261a3.png" alt="img"></p><p>浏览器进程做为Chrome中最核心的进程管理着Chrome中的其他进程，而Renderer则负责渲染不同的站点。</p><h3 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h3><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/7b/7bc84e5abe039f836a0af8002d4a63fd.png" alt="img"></p><p>﻿</p><h4 id="浏览器进程（Browser-process）"><a href="#浏览器进程（Browser-process）" class="headerlink" title="浏览器进程（Browser process）"></a>浏览器进程（Browser process）</h4><p>浏览器进程负责管理Chrome应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。</p><h4 id="渲染进程（Renderer-process）"><a href="#渲染进程（Renderer-process）" class="headerlink" title="渲染进程（Renderer process）"></a>渲染进程（Renderer process）</h4><p>渲染进程负责站点的渲染，其中也包括JavaScript代码的运行，web worker的管理等。</p><h4 id="插件进程（Plugin-process）"><a href="#插件进程（Plugin-process）" class="headerlink" title="插件进程（Plugin process）"></a>插件进程（Plugin process）</h4><p>插件进程负责为浏览器提供各种额外的插件功能，例如flash。</p><h4 id="GPU进程（GPU-process）"><a href="#GPU进程（GPU-process）" class="headerlink" title="GPU进程（GPU process）"></a>GPU进程（GPU process）</h4><p>GPU进程负责提供成像的功能。</p><p>当然还有其他像扩展进程或工具进程等其他进程，可以在Chrome的Task Manager面板中查看，面板中列出了运行的进程和其占用的CPU、内存情况。</p><h3 id="多进程架构的好处"><a href="#多进程架构的好处" class="headerlink" title="多进程架构的好处"></a>多进程架构的好处</h3><p>当我们访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当我们在Chrome中打开三个页签同时访问三个站点时，如果其中一个没有响应，我们可以关闭它然后使用其他的页签，这是因为Chrome为每个站点创建一个独立的渲染进程，专门处理当前站点的渲染工作。如果所有的页面运行在同一个进程中，当有一个页面没有响应时，所有的页面就都卡住了。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/0e/0e8966939127660cee3f7aa05303721b.png" alt="img"></p><p>另一个好处是，借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。</p><p>﻿</p><p>虽然多进程的架构优于单进程架构，但由于进程独享自己的私有内存，以渲染进程为例，虽然渲染的站点不同，但工作内容大体相似，为了完成渲染工作它们会在自己的内存中包含相同的功能，例如V8引擎（用于解析和运行Javascript），这意味着这部分相同的功能需要占用每个进程的内存空间。为了节省内存，Chrome限制了最大进程数，最大进程数取决于硬件的能力，同时<strong>当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程</strong>。</p><h3 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h3><p>Chrome将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式提供，以解决多进程架构中的问题。</p><p>当Chrome运行在拥有强大硬件的计算机上时，会将一个服务以多个进程的方式实现，提高稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p><p><img data-src="https://static001.geekbang.org/infoq/72/72ab917eee34ffd4b8bb1352a8f73ad6.png" alt="img"></p><h3 id="基于站点隔离的渲染进程"><a href="#基于站点隔离的渲染进程" class="headerlink" title="基于站点隔离的渲染进程"></a>基于站点隔离的渲染进程</h3><p>﻿利用iframe我们可以在同一个页面访问不同站点的资源，但从安全的角度考虑，同源策略不允许一个站点在未得到同意的情况下访问其他站点的资源，所以从Chrome 67开始每个站点由独立的渲染进程处理被默认启用。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/fa/fa70a857e645bec8876257580a935282.png" alt="img"></p><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><p><img data-src="https://static001.geekbang.org/infoq/40/4006973a23f68ec28402353d48f91a57.png" alt="img"></p><p>浏览器进程负责处理除了渲染外的大部分工作，浏览器进程包括几个线程：</p><ul><li>UI 线程负责绘制工具栏中的按钮、地址栏等。</li><li>网络线程负责从网络中获取数据。</li><li>存储线程负责文件等功能。</li></ul><p>当我们在地址栏中输入一个地址时，浏览器进程中的UI线程最先得知这个动作，并开始处理。</p><h2 id="一次访问"><a href="#一次访问" class="headerlink" title="一次访问"></a>一次访问</h2><p>下面我们就从一次常见的访问入手，逐步了解浏览器是如何展示页面的。</p><h3 id="Step-1：输入处理"><a href="#Step-1：输入处理" class="headerlink" title="Step 1：输入处理"></a>Step 1：输入处理</h3><p>当我们在地址栏中输入时，UI线程会先判断我们输入的内容是要搜索的内容还是要访问一个站点，因为地址栏同时也是一个搜索框。</p><p><img data-src="https://static001.geekbang.org/infoq/d6/d619ac67749e633ae020812aa0b09bdd.png" alt="img"></p><h3 id="Step-2：访问开始"><a href="#Step-2：访问开始" class="headerlink" title="Step 2：访问开始"></a>Step 2：访问开始</h3><p>当我们按下回车开始访问时，UI线程将借助网络线程访问站点资源. 浏览器页签的标题上会出现加载中的图标，同时网络线程会根据适当的网络协议，例如DNS lookup和TLS为这次请求建立连接。</p><p><img data-src="https://static001.geekbang.org/infoq/74/749ccda4aca068ed34465407973dc3f9.png" alt="img"></p><p>当服务器返回给浏览器重定向请求时，网络线程会通知UI线程需要重定向，然后会以新的地址做开始请求资源。</p><h3 id="Step-3：处理响应数据"><a href="#Step-3：处理响应数据" class="headerlink" title="Step 3：处理响应数据"></a>Step 3：处理响应数据</h3><p><img data-src="https://static001.geekbang.org/infoq/a0/a049bd54e903004676c6f75ec11d373b.png" alt="img"></p><p>当网络线程收到来自服务器的数据时，会试图从数据中的前面的一些字节中得到数据的类型（<strong>Content-Type</strong>），以试图了解数据的格式。</p><p>当返回的数据类型是HTML时，会将数据传递给渲染进程做进一步的渲染工作。但是如果数据类型是zip文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。</p><p><img data-src="https://static001.geekbang.org/infoq/b4/b4797a3b5023a9de4ac03ad174e9bd3f.png" alt="img"></p><p>在开始渲染之前，网络线程要先检查数据的安全性，这里也是浏览器保证安全的地方。如果返回的数据来自一些恶意的站点，网络线程会显示警告的页面。同时，Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程。</p><h3 id="Step-4：渲染过程"><a href="#Step-4：渲染过程" class="headerlink" title="Step 4：渲染过程"></a>Step 4：渲染过程</h3><p>当所有的检查结束后，网络线程确信浏览器可以访问站点时，网络线程通知UI线程数据已经准备好了。UI线程会根据当前的站点找到一个渲染进程完成接下来的渲染工作。</p><p><img data-src="https://static001.geekbang.org/infoq/32/320ebdce97d9fb29329fd47c0c5f0c07.png" alt="img"></p><p>在第二步，UI线程将请求地址传递给网络线程时，UI线程就已经知道了要访问的站点。此时UI线程就可以开始查找或启动一个渲染进程，这个动作与让网络线程下载数据是同时的。如果网络线程按照预期获取到数据，则渲染进程就已经可以开始渲染了，这个动作减少了从网络线程开始请求数据到渲染进程可以开始渲染页面的时间。当然，如果出现重定向的请求时，提前初始化的渲染进程可能就不会被使用了，但相比正常访问站点的场景，重定向往往是少数，在实际工作中，也需要根据特定的场景给出特定的方案，不必追求完美的方案。</p><h3 id="Step-5：提交访问"><a href="#Step-5：提交访问" class="headerlink" title="Step 5：提交访问"></a>Step 5：提交访问</h3><p>经历前面的步骤，数据和渲染进程都已经准备好了。浏览器进程会通过IPC向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。</p><p>这时，地址栏显示出表明安全的图标，同时显示出站点的信息。访问历史中也会加入当前的站点信息。为了能恢复访问历史信息，当页签或窗口被关闭时，访问历史的信息会被存储在硬盘中。</p><p><img data-src="https://static001.geekbang.org/infoq/b9/b9882cfdfbc700b2698116669bf40d4e.png" alt="img"></p><h3 id="Extra-Step：加载完毕"><a href="#Extra-Step：加载完毕" class="headerlink" title="Extra Step：加载完毕"></a>Extra Step：加载完毕</h3><p>当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面。当渲染进程”结束”渲染工作，会给浏览器进程发送消息，这个消息会在页面中所有子页面（frame）结束加载后发出，也就是onLoad事件触发后发送。当收到”结束”消息后，UI线程会隐藏页签标题上的加载状态图标，表明页面加载完毕。</p><p>但这里”结束”并不意味着所有的加载工作都结束了，因为可能还有JavaScript在加载额外的资源或者渲染新的视图。</p><p><img data-src="https://static001.geekbang.org/infoq/b9/b93f199ad2138be6e445d1ceb4416033.png" alt="img"></p><h2 id="访问不同的站点"><a href="#访问不同的站点" class="headerlink" title="访问不同的站点"></a>访问不同的站点</h2><p>﻿一次普通的访问到此就结束了。当我们输入另外一个地址时，浏览器进程会重复上面的过程。但是在开始新的访问前，会确认当前的站点是否关心<code>beforeunload</code>事件。</p><p><code>beforeunload</code>事件可以提醒用户是否要访问新的站点或者关闭页签，如果用户拒绝则新的访问或关闭会被阻止。</p><p>由于所有的包括渲染、运行Javascript的工作都发生在渲染进程中，浏览器进程需要在新的访问开始前与渲染进程确认当前的站点是否关心<code>unload</code>。</p><p><img data-src="https://static001.geekbang.org/infoq/71/71402d5b3a3f7d5629a242727e606079.png" alt="img"></p><p>如果一次访问是从一个渲染进程中发起的，例如用户点击一个链接或者运行JavaScript代码<code>location = &#39;http://newsite.com&#39;</code>时，渲染进程首先检查<code>beforeunload</code>。然后再执行和浏览器进程初始化访问同样的步骤，只不过区别在于这样的访问请求是由渲染进程向浏览器进程发起的。</p><p>当新的站点请求被创建时，一个独立的渲染进程将被用于处理这个请求。为了支持像<code>unload</code>的事件触发，老的渲染进程需要保持住当前的状态。更详细的生命周期介绍可以参考<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events">Page lifecycle</a>。</p><p><img data-src="https://static001.geekbang.org/infoq/e0/e074926b6b24cae624f6c1c906c16616.png" alt="img"></p><h2 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h2><p>Service worker是一种可以web开发者控制缓存的技术。如果Service worker被实现成从本地存储获取数据时，那么原本的请求就不会被浏览器发送给服务器了。</p><p>﻿</p><p>值得注意的是，Service worker中的代码是运行在渲染进程中的。当访问开始时，网络线程会根据域名检查是否有Service worker会处理当前地址的请求，如果有，则UI线程会找到对应的渲染进程去执行Service worker的代码，而Service worker可以让开发者决定这个请求是从本地存储还是从网络中获取数据。</p><p><img data-src="https://static001.geekbang.org/infoq/8c/8c45c55d238b901239d0eb4bd40f2892.png" alt="img"></p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/fd/fdeaee16c665e81bc59f42122080916f.png" alt="img"></p><h3 id="访问预加载"><a href="#访问预加载" class="headerlink" title="访问预加载"></a>访问预加载</h3><p>如果Service worker最终决定要从网络中获取数据时，我们会发现这种跨进程的通信会造成一些延迟。<a href="https://developers.google.com/web/updates/2017/02/navigation-preload">Navigation Preload</a>是一种可以在Service worker启动的同时加载资源的优化机制。借助特殊的请求头，服务器可以决定返回什么样的内容给浏览器。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/21/212631fa2520d730f17b0461ddae71d6.png" alt="img"></p><h3 id="渲染进程负责页面的内容"><a href="#渲染进程负责页面的内容" class="headerlink" title="渲染进程负责页面的内容"></a>渲染进程负责页面的内容</h3><p>渲染进程负责所有发生在浏览器页签中的事情。在一个渲染进程中，主线程负责解析，编译或运行代码等工作，当我们使用Worker时，Worker线程会负责运行一部分代码。合成线程和光栅线程是也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。</p><p>渲染进程最重要的工作就是将HTML、CSS和Javascript代码转换成一个可以与用户产生交互的页面。</p><p><img data-src="https://static001.geekbang.org/infoq/bd/bdfa66a4ef1fbd2805797bc4cd90f8d8.png" alt="img"></p><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>下面的章节主要介绍渲染进程如何将从网络线程中获取的文本转化成图像的过程。</p><h4 id="DOM的创建"><a href="#DOM的创建" class="headerlink" title="DOM的创建"></a>DOM的创建</h4><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受HTML数据，主线程开始解析HTML文本字符串，并且将其转化成<strong>Document Object Model（DOM）</strong>。</p><p>DOM是一种浏览器内部用于表达页面结构的数据，同时也为Web开发者提供了操作页面元素的接口，让web开发者可以在Javascript代码中获取和操作页面中的元素。</p><p>将HTML文本转化成DOM的标准被<a href="https://html.spec.whatwg.org/">HTML Standard</a>定义。我们会发现在转化过程中浏览器从来不会抛出异常，类似关闭标签的丢失，开始、关闭标签匹配错误等等。这是因为HTML标准中定义了要静默的处理这些错误，如果对此感兴趣可以阅读<a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a>。</p><h4 id="额外资源的加载"><a href="#额外资源的加载" class="headerlink" title="额外资源的加载"></a>额外资源的加载</h4><p>一个网站通常还会使用类似图片，样式文件和JavaScript代码等额外的资源。这些资源也需要从网络或缓存中获取。主线程在转化HTML的过程中理应挨个加载它们，但是为了提高效率，预加载扫描（Preload Scanner）与转换过程会同时运行着。当预加载扫描在分析器分析HTML过程中发现了类似img或link这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p><p><img data-src="https://static001.geekbang.org/infoq/fa/fa689d6a31b8687522c58774c8d9d064.png" alt="img"></p><h4 id="JavaScript会阻塞转化过程"><a href="#JavaScript会阻塞转化过程" class="headerlink" title="JavaScript会阻塞转化过程"></a>JavaScript会阻塞转化过程</h4><p>当HTML分析器发现<code>&lt;script&gt;</code>标签时，会暂停接下来的HTML转化工作，然后加载、解析并且运行Javascript代码。因为在Javascript代码中可能会使用类似<code>document.write</code>这样的API去改变DOM的结构。这就是为什么HTML分析器必须等待Javascript代码运行结束才能继续分析的原因。</p><h4 id="告诉浏览器要如何加载资源"><a href="#告诉浏览器要如何加载资源" class="headerlink" title="告诉浏览器要如何加载资源"></a>告诉浏览器要如何加载资源</h4><p>如果我们的Javascript代码并不需要改变DOM，可以为<code>&lt;script&gt;</code>标签添加<code>async</code>或<code>defer</code>属性，这样浏览器就会异步的加载这些资源并且不会阻塞HTML转化过程。<strong>如果script标签是由JavaScript代码创建的，标签的async属性会默认为true。</strong>同时我们也可以使用一些预加载技术，比如<code>&lt;link ref=&quot;preload&quot;&gt;</code>来通知浏览器这些资源需要越快下载越好。</p><h4 id="样式计算（Style-calculation）"><a href="#样式计算（Style-calculation）" class="headerlink" title="样式计算（Style calculation）"></a>样式计算（Style calculation）</h4><p>对于展示一个页面，光有DOM是不够的，因为我们还需要样式来让页面变得更美观。主线程会解析样式（CSS）并决定每个DOM元素的样式。这些样式取决于CSS选择器的范围，在浏览器开发者工具中我们可以看到这些信息。</p><p><img data-src="https://static001.geekbang.org/infoq/fb/fb7d195814a04c6ed98eab8dbda477c6.png" alt="img"></p><p>即使我们没有给DOM指定任何的样式，<code>&lt;h1&gt;</code>标签也会比<code>&lt;h2&gt;</code>标签显示的大。这是因为浏览器为不同的标签内置了不同的样式。可以通过<a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/resources/html.css">Chromium源代码</a>得到这些默认样式。</p><h4 id="布局（layout）"><a href="#布局（layout）" class="headerlink" title="布局（layout）"></a>布局（layout）</h4><p>完成了样式计算工作后，渲染进程已经知道了DOM的结构和每个节点的样式，但是依然不足以渲染一个页面。想象一下，让你在电话中向朋友描述一张图：“图中有一个大红色圆和一个小的、蓝色的方块”是不足以让朋友知道这张图到底是什么样的。</p><p><img data-src="https://static001.geekbang.org/infoq/06/0658494542e14f7db66b913c02c03202.png" alt="img"></p><p>布局是为元素指定几何信息的过程。主线程遍历DOM结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的布局树（Layout tree）。布局树的结构与DOM树的结构十分相似，但只包含将会在页面中显示的元素。<strong>当一个元素的样式被设置成display: none时，元素就不会出现在布局树中，但那些样式被设置成visiblility：hidden的元素会出现在布局树中。</strong>相似的，当我们使用一个包含内容的伪元素（例如<code>p::before &#123; content: &#39;Hi!&#39; &#125;</code>）时，元素会出现在布局树中即使这个元素不存在于DOM树中，这也是为什么我们<strong>使用DOM提供的API无法获取伪元素</strong>的原因。</p><p><img data-src="https://static001.geekbang.org/infoq/0c/0c1de85206f0d177f93a70931a0f8272.png" alt="img"></p><p>描述页面布局信息是一项具有挑战性的工作，即使在只有块元素的页面中也必须要考虑字体的大小和在哪里换行，因为在计算下一个元素的位置时需要知道上一个元素的尺寸和形状。</p><p>CSS可以让元素浮动、可以让元素在父元素中溢出，可以改变文字的方向。可以想象，在布局这个阶段是多么繁重的工作。在Chrome中，有一整个团队在维护布局工作，更详细的信息可以观看<a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA">视频</a>。</p><h4 id="绘制（Paint）"><a href="#绘制（Paint）" class="headerlink" title="绘制（Paint）"></a>绘制（Paint）</h4><p><img data-src="https://static001.geekbang.org/infoq/d8/d8fe81b968531c8b3d4767006ea9725d.png" alt="img"></p><p>有了DOM、样式和布局还是无法完成渲染工作。试想，当我们试图复制一张图画。我们知道图画中元素的尺寸、形状和位置，我们还需要知道绘制这些元素的顺序。</p><p>例如，当一个元素z-index属性被设置后，绘制的顺序会导致渲染成错误的结果。</p><p><img data-src="https://static001.geekbang.org/infoq/11/116fb1ec64e618a7562788911bca8d75.png" alt="img"></p><p>在这个阶段，主线程遍历布局树并创建绘制记录，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。</p><p><img data-src="https://static001.geekbang.org/infoq/a6/a68fd128fc59b9b2bed3511fcf223c94.png" alt="img"></p><h4 id="渲染过程是昂贵的"><a href="#渲染过程是昂贵的" class="headerlink" title="渲染过程是昂贵的"></a>渲染过程是昂贵的</h4><p>在渲染过程中，任何一个步骤中产生的数据变化都会引起后续一系列的的变化。例如，当布局树改变时，绘制需要重构页面中变化的部分。</p><p>当一些元素有动画发生时，浏览器需要在每一帧中绘制这些元素。当无法保证每一帧绘制的连续性时，用户就会感觉到卡顿。</p><p><img data-src="https://static001.geekbang.org/infoq/54/54a9da693ebba8579317ff57be2993ea.png" alt="img"></p><p>正常情况下渲染操作可以与屏幕刷新保持同步，但由于这些操作运行在主线程中，也就意味这些操作可能被正在运行的Javascript代码所阻塞。</p><p><img data-src="https://static001.geekbang.org/infoq/6b/6bd8886a8c2b26a72105c7a2fba7bf3a.png" alt="img"></p><p>为了不影响渲染操作，我们可以将Javascript操作优化成小块，然后使用<code>requestAnimationFrame()</code>，关于如何优化可以参考<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">Optimize JavaScript Exectuion</a>。当需要大量计算时，也可以使用Worker来避免阻塞主进程。</p><p><img data-src="https://static001.geekbang.org/infoq/45/45d6db6a394174c914eb37e13743f94d.png" alt="img"></p><h4 id="合成（Compositing）"><a href="#合成（Compositing）" class="headerlink" title="合成（Compositing）"></a>合成（Compositing）</h4><p>现在，浏览器已经知道了文档结构、每一个元素的样式，元素的几何信息，绘制的顺序。将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。</p><p><img data-src="https://static001.geekbang.org/infoq/9e/9ed512afc63c664458faf1bd42247cc0.gif" alt="img"></p><p>传统的做法是将可视区域的内容进行光栅化。随着用户滚动页面，不断的光栅化更多的区域。然而对于现代浏览器，有着更复杂的的过程，这个过程被称做合成。</p><p><img data-src="https://static001.geekbang.org/infoq/ae/ae1b6d19e8aeb45841f04bbfa72760dd.gif" alt="img"></p><p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组合成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层合成新的帧，动画则可以通过移动层来实现。</p><p>﻿</p><h4 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h4><p>﻿</p><p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对开发者来说，当某一部分需要用独立的层渲染，我们可以使用css属性<code>will-change</code>让浏览器创建层，关于浏览器如何生成层的标准可自行查阅。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/b0/b08901dee7af151982f600e6a7a6ba43.png" alt="img"></p><p>layer.png</p><p>虽然通过分层可以优化浏览器性能，但并不意味着应该给每个元素一个层，过多的层反而影响性能，所以在层的划分上应该具体形况具体分析。</p><p>﻿</p><h4 id="栅格线程与合成线程"><a href="#栅格线程与合成线程" class="headerlink" title="栅格线程与合成线程"></a>栅格线程与合成线程</h4><p>当布局树和绘制顺序确定以后，主线程会将这些信息提交给合成线程。合成线程会光栅化各个层。一个层包含的内容可能是一个完整的页面，也可能是页面的部分，所以合成线程将层拆分成许多块，并将它们发送给栅格线程。栅格线程光栅化这些块并将它们存储在GPU缓存中。</p><p><img data-src="https://static001.geekbang.org/infoq/37/371b5fa654d59f0c8ccb2f4f0658c20a.png" alt="img"></p><p>合成线程可以决定栅格线程光栅块的优先级，这样可以保证用户能看到的部分可以先被光栅化。一个层也会包含多种块以支持类似缩放这样的功能。</p><p>当块被光栅化后，合成线程会使用draw quads收集这些信息并创建合成帧（Compositor frame）。</p><h4 id="Draw-quads"><a href="#Draw-quads" class="headerlink" title="Draw quads"></a>Draw quads</h4><p>存储在缓存中，包含类似块位置这样的信息，用于描述如何使用块合成页面。</p><h4 id="Compositor-frame"><a href="#Compositor-frame" class="headerlink" title="Compositor frame"></a>Compositor frame</h4><p>用于存储表现页面一帧中包含哪些Draw quads的集合。</p><p>然后一个合成帧被提交给浏览器进程。这时如果浏览器UI有变化，或者插件的UI有变化时，另一个合成帧就会被创建出来。所以每当有交互发生时，合成线程就会创建更多的合成帧然后通过GPU将新的部分渲染出来。</p><p><img data-src="https://static001.geekbang.org/infoq/39/397d4949099dd6d1aaffcb55e8678e37.png" alt="img"></p><p>合成的好处在于其独立于主线程。合成线程不需要等待样式计算和Javascript代码的运行。这也是为什么合成更适合优化交互性能，但如果布局或者绘制需要重新计算则主线程是必须要参与的。</p><p>﻿</p><p>本质上，浏览器的渲染过程就是将文本转换成图像的过程，而当用户与页面发生交互动作时，则显示新的图像。在这个过程中由渲染进程中的主线程完成计算工作，由合成线程和栅格线程完成图像的绘制工作。而在计算过程中，还有强制布局、重排、重绘等更加细节的概念会在后面的文章中做讲解。</p><h3 id="从浏览器的角度看事件"><a href="#从浏览器的角度看事件" class="headerlink" title="从浏览器的角度看事件"></a>从浏览器的角度看事件</h3><p>当我们听到事件时，通常会联想到在一个文本框中输入或者单击鼠标，但从浏览器的角度看，输入事件意味着所有的用户动作。鼠标滚轮滚动或者屏幕触摸都是输入事件。</p><p>﻿</p><p>当用户与页面发生交互时，浏览器进程首先接收到事件，然而，浏览器进程只关心事件发生时是在哪个页签中，所以浏览器进程会将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会恰当的找到事件发生的元素并且触发事件监听器。</p><p><img data-src="https://static001.geekbang.org/infoq/7f/7f8581ec78d48302c8ea81f713cdfa56.png" alt="img"></p><h3 id="合成线程对事件的处理"><a href="#合成线程对事件的处理" class="headerlink" title="合成线程对事件的处理"></a>合成线程对事件的处理</h3><p>在前面的章节中，我们知道了合成线程可以通过合成技术合成不同的光栅层优化性能，如果页面并不监听任何事件，合成线程可以完全独立于主线程生成新的合成帧。但如果页面监听了事件呢？</p><h4 id="标记“慢滚动”区域"><a href="#标记“慢滚动”区域" class="headerlink" title="标记“慢滚动”区域"></a>标记“慢滚动”区域</h4><p>由于运行Javascript是主线程的工作，当页面被合成线程合成过，合成线程会标记那些有事件监听的区域。有了这些信息，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理。如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p><p><img data-src="https://static001.geekbang.org/infoq/6f/6fda6b7355162ca393787e870630a083.png" alt="img"></p><h4 id="在事件监听时标记"><a href="#在事件监听时标记" class="headerlink" title="在事件监听时标记"></a>在事件监听时标记</h4><p>在web开发中常见的方式就是事件代理。利用事件冒泡，我们可以在目标元素的上层元素中监听事件。参照下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#39;touchstart&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  if (event.target &#x3D;&#x3D;&#x3D; area) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>﻿通过这种写法，可以更高效的监听事件。但如果从浏览器的角度看，此时整个页面会被标记成“慢滚动”区域。这意味着虽然页面中的某些部分并不需要事件监听，但合成线程依然要在每次交互发生后等待主线程处理事件，合成线程的优化效果不复存在。</p><p><img data-src="https://static001.geekbang.org/infoq/f2/f2e60c76e1cb2b104a46c0da8787d229.png" alt="img"></p><p>为了解决这个问题，我们可在事件代理时传入<code>passive: true</code><strong>（IE不支持）</strong>参数。这样告诉渲染线程，依然需要将事件发送给主线程处理，但不需要等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#39;touchstart&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">    if (event.target &#x3D;&#x3D;&#x3D; area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;passive: true&#125;);</span><br></pre></td></tr></table></figure><p>关于使用passive改善滚屏性能，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">MDN 使用passive改善滚屏性能</a>。</p><h4 id="查找事件目标"><a href="#查找事件目标" class="headerlink" title="查找事件目标"></a>查找事件目标</h4><p><img data-src="https://static001.geekbang.org/infoq/0e/0eb159798080da4adc7ffb76cf184ffa.png" alt="img"></p><p>当渲染线程将事件发送给主线程后，第一件事就是找到事件触发的目标。通过在渲染过程中生成的绘制信息，可以根据坐标找到目标元素。</p><h4 id="减少发送给主线程的事件数量"><a href="#减少发送给主线程的事件数量" class="headerlink" title="减少发送给主线程的事件数量"></a>减少发送给主线程的事件数量</h4><p>为了保证动画的顺畅，需要显示器在每秒刷新60次。对于典型的触摸事件由合成线程提交给主线程的事件频率可以达到每秒60-120次，对于典型的鼠标事件每秒会发送100次。事件发送的频率通常比屏幕刷新频率要高。</p><p>如果类似<code>touchmove</code>这样的事件每秒向主线程发送120次可能会造成主线程执行时间过长而影响性能。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/61/6101cc07df5e744efb2a88208f1d1e52.png" alt="img"></p><p>为了减少发送给主线程的事件数量，Chrome合并了连续的事件。类似<code>wheel</code>，<code>mousewheel</code>，<code>mousemove</code>，<code>pointermove</code>，<code>touchmove</code>这样的事件会被延迟到下一次<code>requestAnimationFrame</code>前触发.</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/53/53005a8114a736ca071a333946664ffd.png" alt="img"></p><p>而任何的离散事件，类似<code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>和 <code>touchend</code>都会立即被发送给主线程处理。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>到此，我们已经可以通过从用户在浏览器地址栏中的一次输入到页面图像的显示了解浏览器是如何工作的。这里我们总结一下。</p><ul><li>浏览器进程做为最重要的进程负责大多数页签外部的工作，包括地址栏显示、网络请求、页签状态管理等。</li><li>不同的渲染进程负责不同的站点渲染工作，渲染进程间彼此独立。</li><li>渲染进程在渲染页面的过程中会通过浏览器进程获取站点资源，只有安全的资源才会被渲染进程接收到。</li><li>渲染进程中主线程负责除了图像生成外绝大多数工作，如何减少主线程上代码的运行是交互性能优化的关键。</li><li>渲染进程中的合成线程和栅格线程负责图像生成，利用分层技术可以优化图像生成的效率。</li><li>当用户与页面发生交互时，事件的传播途径从浏览器进程到渲染进程的合成线程再根据事件监听的区域决定是否要传递给渲染进程的主线程处理。</li></ul><h1 id="8-浏览器的工作原理"><a href="#8-浏览器的工作原理" class="headerlink" title="8.浏览器的工作原理"></a>8.浏览器的工作原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 <code>google.com</code> 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p><h3 id="我们要讨论的浏览器"><a href="#我们要讨论的浏览器" class="headerlink" title="我们要讨论的浏览器"></a>我们要讨论的浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 <a href="http://gs.statcounter.com/">StatCounter 浏览器统计数据</a>，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p><h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p><p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p><p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签设置选项</li><li>用于刷新和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p><h3 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="headerlink" title="浏览器的高层结构"></a>浏览器的高层结构</h3><p>浏览器的主要组件为 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#1_1">1.1</a>)：</p><ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png" alt="img">图：浏览器的主要组件。</p><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>呈现引擎的作用嘛…当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。</p><p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p><h3 id="呈现引擎-1"><a href="#呈现引擎-1" class="headerlink" title="呈现引擎"></a>呈现引擎</h3><p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p><p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 <a href="http://webkit.org/">webkit.org</a>。</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>然后进行如下所示的基本流程：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png" alt="img">图：呈现引擎的基本流程。</p><p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM">DOM</a> 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Render_tree_construction">呈现树</a>。</p><p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p><p>呈现树构建完毕之后，进入“<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#layout">布局</a>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting">绘制</a> - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p><p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p><h4 id="主流程示例"><a href="#主流程示例" class="headerlink" title="主流程示例"></a>主流程示例</h4><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="img">图：WebKit 主流程</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg" alt="img">图：Mozilla 的 Gecko 呈现引擎主流程 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_6">3.6</a>)</p><p>从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p><p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p><h3 id="解析-综述"><a href="#解析-综述" class="headerlink" title="解析 - 综述"></a>解析 - 综述</h3><p>解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p><p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p><p>示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png" alt="img">图：数学表达式树节点</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#context_free_grammar">与上下文无关的语法</a>。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p><h4 id="解析器和词法分析器的组合"><a href="#解析器和词法分析器的组合" class="headerlink" title="解析器和词法分析器的组合"></a>解析器和词法分析器的组合</h4><p>解析的过程可以分成两个子过程：词法分析和语法分析。</p><p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p><p>语法分析是应用语言的语法规则的过程。</p><p>解析器通常将解析工作分给以下两个组件来处理：<strong>词法分析器</strong>（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而<strong>解析器</strong>负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png" alt="img">图：从源文档到解析树</p><p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p><p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png" alt="img">图：编译流程</p><h4 id="解析示例"><a href="#解析示例" class="headerlink" title="解析示例"></a>解析示例</h4><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p><p>词汇：我们用的语言可包含整数、加号和减号。</p><p>语法：</p><ol><li>构成语言的语法单位是表达式、项和运算符。</li><li>我们用的语言可以包含任意数量的表达式。</li><li>表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。</li><li>运算符是加号或减号。</li><li>项是一个整数或一个表达式</li></ol><p>让我们分析一下 2 + 3 - 1。<br>匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。</p><h4 id="词汇和语法的正式定义"><a href="#词汇和语法的正式定义" class="headerlink" title="词汇和语法的正式定义"></a>词汇和语法的正式定义</h4><p>词汇通常用<a href="http://www.regular-expressions.info/">正则表达式</a>表示。</p><p>例如，我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INTEGER :0|[1-9][0-9]*</span><br><span class="line">PLUS : +</span><br><span class="line">MINUS: -</span><br></pre></td></tr></table></figure><p>正如您所看到的，这里用正则表达式给出了整数的定义。</p><p>语法通常使用一种称为 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> 的格式来定义。我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expression :&#x3D;  term  operation  term</span><br><span class="line">operation :&#x3D;  PLUS | MINUS</span><br><span class="line">term :&#x3D; INTEGER | expression</span><br></pre></td></tr></table></figure><p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅<a href="http://en.wikipedia.org/wiki/Context-free_grammar">关于与上下文无关的语法的维基百科文章</a>。</p><h4 id="解析器类型"><a href="#解析器类型" class="headerlink" title="解析器类型"></a>解析器类型</h4><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p><p>让我们来看看这两种解析器会如何解析我们的示例：</p><p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p><p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p><table><thead><tr><th>堆栈</th><th>输入</th></tr></thead><tbody><tr><td></td><td>2 + 3 - 1</td></tr><tr><td>项</td><td>+ 3 - 1</td></tr><tr><td>项运算</td><td>3 - 1</td></tr><tr><td>表达式</td><td>- 1</td></tr><tr><td>表达式运算符</td><td>1</td></tr><tr><td>表达式</td><td></td></tr></tbody></table><p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p><h4 id="自动生成解析器"><a href="#自动生成解析器" class="headerlink" title="自动生成解析器"></a>自动生成解析器</h4><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p><p>WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> 以及用于创建解析器的 <a href="http://www.gnu.org/software/bison/">Bison</a>（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p><h3 id="HTML-解析器"><a href="#HTML-解析器" class="headerlink" title="HTML 解析器"></a>HTML 解析器</h3><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p><h4 id="HTML-语法定义"><a href="#HTML-语法定义" class="headerlink" title="HTML 语法定义"></a>HTML 语法定义</h4><p>HTML 的词汇和语法在 W3C 组织创建的<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#w3c">规范</a>中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。</p><h4 id="非与上下文无关的语法"><a href="#非与上下文无关的语法" class="headerlink" title="非与上下文无关的语法"></a>非与上下文无关的语法</h4><p>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p><p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p><p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p><p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p><p>区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。</p><p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p><h4 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h4><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 <a href="http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a> 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p><p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：<a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a></p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“<a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt; &lt;img src&#x3D;&quot;example.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>可翻译成如下的 DOM 树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt="img">图：示例标记的 DOM 树</p><p>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a>。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：<a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。</p><p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。</p><h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p><p>原因在于：</p><ol><li>语言的宽容本质。</li><li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li><li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 <code>document.write</code>，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li></ol><p>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。</p><p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">HTML5 规范详细地描述了解析算法</a>。此算法由两个阶段组成：标记化和树构建。</p><p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png" alt="img">图：HTML 解析流程（摘自 HTML5 规范）</p><h4 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h4><p>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p><p>基本示例 - 将下面的 HTML 代码标记化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>初始状态是数据状态。遇到字符 <code>&lt;</code> 时，状态更改为<strong>“标记打开状态”</strong>。接收一个 <code>a-z</code> 字符会创建“起始标记”，状态更改为<strong>“标记名称状态”</strong>。这个状态会一直保持到接收 <code>&gt;</code> 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 <code>html</code> 标记。</p><p>遇到 <code>&gt;</code> 标记时，会发送当前的标记，状态改回<strong>“数据状态”</strong>。<code>&lt;body&gt;</code> 标记也会进行同样的处理。目前 <code>html</code> 和 <code>body</code> 标记均已发出。现在我们回到<strong>“数据状态”</strong>。接收到 <code>Hello world</code> 中的 <code>H</code> 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 <code>&lt;</code>。我们将为 <code>Hello world</code> 中的每个字符都发送一个字符标记。</p><p>现在我们回到<strong>“标记打开状态”</strong>。接收下一个输入字符 <code>/</code> 时，会创建 <code>end tag token</code> 并改为<strong>“标记名称状态”</strong>。我们会再次保持这个状态，直到接收 <code>&gt;</code>。然后将发送新的标记，并回到<strong>“数据状态”</strong>。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png" alt="img">图：对示例输入进行标记化</p><h4 id="树构建算法"><a href="#树构建算法" class="headerlink" title="树构建算法"></a>树构建算法</h4><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p><p>让我们来看看示例输入的树构建过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是<strong>“initial mode”</strong>。接收 HTML 标记后转为<strong>“before html”</strong>模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p><p>然后状态将改为<strong>“before head”</strong>。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p><p>现在我们进入了<strong>“in head”</strong>模式，然后转入<strong>“after head”</strong>模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为<strong>“in body”</strong>。</p><p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p><p>接收 body 结束标记会触发<strong>“after body”</strong>模式。现在我们将接收 HTML 结束标记，然后进入<strong>“after after body”</strong>模式。接收到文件结束标记后，解析过程就此结束。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif" alt="img">图：示例 HTML 的树构建</p><h4 id="解析结束后的操作"><a href="#解析结束后的操作" class="headerlink" title="解析结束后的操作"></a>解析结束后的操作</h4><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。</p><p>您可以<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">在 HTML5 规范中查看标记化和树构建的完整算法</a></p><h4 id="浏览器的容错机制"><a href="#浏览器的容错机制" class="headerlink" title="浏览器的容错机制"></a>浏览器的容错机制</h4><p>您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p><p>以下面的 HTML 代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;mytag&gt;</span><br><span class="line">  &lt;&#x2F;mytag&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">    Really lousy HTML</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p><p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p><p>HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p><blockquote><p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。</p><p>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。</p><p>我们至少要能够处理以下错误情况：</p><ol><li>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。</li><li>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。</li><li>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。</li><li>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。</li></ol></blockquote><p>让我们看一些 WebKit 容错的示例：</p><h5 id="使用了-而不是"><a href="#使用了-而不是" class="headerlink" title="使用了  而不是 "></a>使用了 </br> 而不是 <br></h5><p>有些网站使用了 </br> 而不是 <br>。为了与 IE 和 Firefox 兼容，WebKit 将其与 <br> 做同样的处理。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p><h5 id="离散表格"><a href="#离散表格" class="headerlink" title="离散表格"></a>离散表格</h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。<br>比如以下的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>WebKit 会将其层次结构更改为两个同级表格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (m_inStrayTableContent &amp;&amp; localName &#x3D;&#x3D; tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure><p>WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。</p><h5 id="嵌套的表单元素"><a href="#嵌套的表单元素" class="headerlink" title="嵌套的表单元素"></a>嵌套的表单元素</h5><p>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement &#x3D; new HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过于复杂的标记层次结构"><a href="#过于复杂的标记层次结构" class="headerlink" title="过于复杂的标记层次结构"></a>过于复杂的标记层次结构</h5><p>代码的注释已经说得很清楚了。</p><blockquote><p>示例网站 <a href="http://www.liceo.edu.mx/">www.liceo.edu.mx</a> 嵌套了约 1500 个标记，全都来自一堆 <b> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned i &#x3D; 0;</span><br><span class="line">for (HTMLStackElem* curr &#x3D; m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName &#x3D;&#x3D; tagName;</span><br><span class="line">     curr &#x3D; curr-&gt;next, i++) &#123; &#125;</span><br><span class="line">return i !&#x3D; cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="放错位置的-html-或者-body-结束标记"><a href="#放错位置的-html-或者-body-结束标记" class="headerlink" title="放错位置的 html 或者 body 结束标记"></a>放错位置的 html 或者 body 结束标记</h5><p>同样，代码的注释已经说得很清楚了。</p><blockquote><p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;tagName &#x3D;&#x3D; htmlTag || t-&gt;tagName &#x3D;&#x3D; bodyTag )</span><br><span class="line">        return;</span><br></pre></td></tr></table></figure><p>所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p><h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，<a href="http://www.w3.org/TR/CSS2/grammar.html">CSS 规范定义了 CSS 的词法和语法</a>。</p><p>让我们来看一些示例：<br>词法语法（词汇）是针对各个标记用正则表达式定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment   \&#x2F;\*[^*]*\*+([^&#x2F;*][^*]*\*+)*\&#x2F;</span><br><span class="line">num   [0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii  [\200-\377]</span><br><span class="line">nmstart   [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar    [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name    &#123;nmchar&#125;+</span><br><span class="line">ident   &#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。</p><p>语法是采用 BNF 格式描述的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : <span class="string">&#x27;.&#x27;</span> IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : <span class="string">&#x27;[&#x27;</span> S* IDENT S* [ [ <span class="string">&#x27;=&#x27;</span> | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] <span class="string">&#x27;]&#x27;</span></span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : <span class="string">&#x27;:&#x27;</span> [ IDENT | FUNCTION S* [IDENT S*] <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>解释：这是一个规则集的结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.error</span> , <span class="selector-tag">a</span><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。</p><h4 id="WebKit-CSS-解析器"><a href="#WebKit-CSS-解析器" class="headerlink" title="WebKit CSS 解析器"></a>WebKit CSS 解析器</h4><p>WebKit 使用 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#parser_generators">Flex 和 Bison</a> 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png" alt="img">图：解析 CSS</p><h3 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p><h3 id="呈现树构建"><a href="#呈现树构建" class="headerlink" title="呈现树构建"></a>呈现树构建</h3><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。<br>WebKits RenderObject 类是所有呈现器的基类，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RenderObject&#123;</span><br><span class="line">  virtual void layout();</span><br><span class="line">  virtual void paint(PaintInfo);</span><br><span class="line">  virtual void rect repaintRect();</span><br><span class="line">  Node* node;  &#x2F;&#x2F;the DOM node</span><br><span class="line">  RenderStyle* style;  &#x2F;&#x2F; the computed style</span><br><span class="line">  RenderLayer* containgLayer; &#x2F;&#x2F;the containing z-index layer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。<br>框的类型会受到与节点相关的“display”样式属性的影响（请参阅<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#style_computation">样式计算</a>章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">    Document* doc &#x3D; node-&gt;document();</span><br><span class="line">    RenderArena* arena &#x3D; doc-&gt;renderArena();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    switch (style-&gt;display()) &#123;</span><br><span class="line">        case NONE:</span><br><span class="line">            break;</span><br><span class="line">        case INLINE:</span><br><span class="line">            o &#x3D; new (arena) RenderInline(node);</span><br><span class="line">            break;</span><br><span class="line">        case BLOCK:</span><br><span class="line">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case INLINE_BLOCK:</span><br><span class="line">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case LIST_ITEM:</span><br><span class="line">            o &#x3D; new (arena) RenderListItem(node);</span><br><span class="line">            break;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。<br>在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 <code>createRenderer</code> 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p><h5 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h5><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。</p><p>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p><p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt="img">图：呈现树及其对应的 DOM 树 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_1">3.1</a>)。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。</p><h5 id="构建呈现树的流程"><a href="#构建呈现树的流程" class="headerlink" title="构建呈现树的流程"></a>构建呈现树的流程</h5><p>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 <code>FrameConstructor</code>，由该构造器解析样式（请参阅<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#style">样式计算</a>）并创建框架。</p><p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。</p><p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 <code>ViewPortFrame</code>，而 WebKit 称之为 <code>RenderView</code>。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p><p>请参阅<a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">关于处理模型的 CSS2 规范</a>。</p><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p><p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。</p><p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。</p><p>样式计算存在以下难点：</p><ol><li><p>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</p></li><li><p>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p><p>例如下面这个组合选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div div div div&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着规则适用于作为 3 个 div 元素的子代的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>。如果您要检查规则是否适用于某个指定的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。</p></li><li><p>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。</p></li></ol><p>让我们来看看浏览器是如何处理这些问题的：</p><h5 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h5><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li><li>任何元素都没有 ID</li><li>标记名称应匹配</li><li>类属性应匹配</li><li>映射属性的集合必须是完全相同的</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li><li>元素中不能有任何 inline 样式属性</li><li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li></ol><h5 id="Firefox-规则树"><a href="#Firefox-规则树" class="headerlink" title="Firefox 规则树"></a>Firefox 规则树</h5><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image035.png" alt="img">图：Firefox 样式上下文树 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#2_2">2.2</a>)</p><p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p><p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p><p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/tree.png" alt="img"></p><p>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。</p><p>让我们看看规则树如何帮助我们减少工作。</p><h5 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。</p><p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p><h5 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。<br>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p><p>如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在<strong>上下文树</strong>中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。</p><p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p><p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享<strong>整个样式上下文</strong>。</p><p>让我们来看一个例子，假设我们有如下 HTML 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        this is a &lt;span class&#x3D;&quot;big&quot;&gt; big error &lt;&#x2F;span&gt;</span><br><span class="line">        this is also a</span><br><span class="line">        &lt;span class&#x3D;&quot;big&quot;&gt; very  big  error&lt;&#x2F;span&gt; error</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div2&quot;&gt;another error&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>还有如下规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;<span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;<span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;<span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;<span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;<span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure><p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。<br>形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image027.png" alt="img">图：规则树</p><p>上下文树如下图所示（节点名 : 指向的规则节点）：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image029.png" alt="img">图：上下文树</p><p>假设我们解析 HTML 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p><p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p><p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p><p>第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p><p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。<br>例如，如果我们在某个段落中添加 font 规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure><p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。</p><p>在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。</p><p>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue1">1</a> 和问题 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue3">3</a>。Firefox 规则树还有助于按照正确的顺序应用属性。</p><h5 id="对规则进行处理以简化匹配"><a href="#对规则进行处理以简化匹配" class="headerlink" title="对规则进行处理以简化匹配"></a>对规则进行处理以简化匹配</h5><p>样式规则有一些来源：</p><ul><li><p>外部样式表或样式元素中的 CSS 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>inline 样式属性及类似内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style&#x3D;&quot;color:blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li><li><p>HTML 可视化属性（映射到相关的样式规则）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p bgcolor&#x3D;&quot;blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li></ul><p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p><p>我们之前在<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue2">第 2 个问题</a>中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p><p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。<br>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1">4.1</a>)。</p><p>我们以如下的样式规则为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.error &#123;color:red&#125;</span><br><span class="line">#messageDiv &#123;height:50px&#125;</span><br><span class="line">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。<br>对于下面的 HTML 代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;error&quot;&gt;an error occurred &lt;&#x2F;p&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;messageDiv&quot;&gt;this is a message&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。<br>例如，如果 div 的对应规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。</p><p>WebKit 和 Firefox 都进行了这一处理。</p><h5 id="以正确的层叠顺序应用规则"><a href="#以正确的层叠顺序应用规则" class="headerlink" title="以正确的层叠顺序应用规则"></a>以正确的层叠顺序应用规则</h5><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p><p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p><h5 id="样式表层叠顺序"><a href="#样式表层叠顺序" class="headerlink" title="样式表层叠顺序"></a>样式表层叠顺序</h5><p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p><ol><li>浏览器声明</li><li>用户普通声明</li><li>作者普通声明</li><li>作者重要声明</li><li>用户重要声明</li></ol><p>浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Specificity">特异性</a>进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p><h5 id="特异性"><a href="#特异性" class="headerlink" title="特异性"></a>特异性</h5><p>选择器的特异性由 <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">CSS2 规范</a>定义如下：</p><ul><li>如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li><li>记为选择器中 ID 属性的个数 (= b)</li><li>记为选择器中其他属性和伪类的个数 (= c)</li><li>记为选择器中元素名称和伪元素的个数 (= d)</li></ul><p>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。</p><p>您使用的进制取决于上述类别中的最高计数。<br>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。</p><p>一些示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*             &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,0,0,0 *&#x2F;</span><br><span class="line">li            &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;1 -&gt; specificity &#x3D; 0,0,0,1 *&#x2F;</span><br><span class="line">li:first-line &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class="line">ul li         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class="line">ul ol+li      &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;3 -&gt; specificity &#x3D; 0,0,0,3 *&#x2F;</span><br><span class="line">h1 + *[rel&#x3D;up]&#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;1 -&gt; specificity &#x3D; 0,0,1,1 *&#x2F;</span><br><span class="line">ul ol li.red  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;3 -&gt; specificity &#x3D; 0,0,1,3 *&#x2F;</span><br><span class="line">li.red.level  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;2 d&#x3D;1 -&gt; specificity &#x3D; 0,0,2,1 *&#x2F;</span><br><span class="line">#x34y         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;1 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,1,0,0 *&#x2F;</span><br><span class="line">style&#x3D;&quot;&quot;          &#x2F;* a&#x3D;1 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 1,0,0,0 *&#x2F;</span><br></pre></td></tr></table></figure><h5 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h5><p>找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“&gt;”运算符来实现排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 &#x3D; r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 &#x3D; r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 &#x3D;&#x3D; spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="渐进式处理"><a href="#渐进式处理" class="headerlink" title="渐进式处理"></a>渐进式处理</h4><p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p><p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_5">3.5</a>)。</p><p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p><p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <code>&lt;html&gt;</code> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</p><p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。</p><p>所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p><h4 id="Dirty-位系统"><a href="#Dirty-位系统" class="headerlink" title="Dirty 位系统"></a>Dirty 位系统</h4><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p><p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p><h4 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h4><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p><ol><li>影响所有呈现器的全局样式更改，例如字体大小更改。</li><li>屏幕大小调整。</li></ol><p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/reflow.png" alt="img">图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_6">3.6</a>)。</p><h4 id="异步布局和同步布局"><a href="#异步布局和同步布局" class="headerlink" title="异步布局和同步布局"></a>异步布局和同步布局</h4><p>增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。<br>请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。<br>全局布局往往是同步触发的。<br>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。<br>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。</p><h4 id="布局处理"><a href="#布局处理" class="headerlink" title="布局处理"></a>布局处理</h4><p>布局通常具有以下模式：</p><ol><li>父呈现器确定自己的宽度。</li><li>父呈现器依次处理子呈现器，并且：<ol><li>放置子呈现器（设置 x,y 坐标）。</li><li>如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。</li></ol></li><li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。</li><li>将其 dirty 位设置为 false。</li></ol><p>Firefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。<br>Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p><h4 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h4><p>呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。<br>例如以下 div 的宽度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width:30%&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：</p><ul><li><p>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientWidth() - paddingLeft() - paddingRight()</span><br></pre></td></tr></table></figure><p>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。</p></li><li><p>元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。</p></li><li><p>然后加上水平方向的边框和补白。</p></li></ul><p>现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。<br>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。</p><p>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><h4 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h4><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p><h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p><a href="http://www.w3.org/TR/CSS21/zindex.html">CSS2 规范定义了绘制流程的顺序</a>。绘制的顺序其实就是元素进入<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext">堆栈样式上下文</a>的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><h4 id="Firefox-显示列表"><a href="#Firefox-显示列表" class="headerlink" title="Firefox 显示列表"></a>Firefox 显示列表</h4><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。</p><p>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p><h4 id="WebKit-矩形存储"><a href="#WebKit-矩形存储" class="headerlink" title="WebKit 矩形存储"></a>WebKit 矩形存储</h4><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。</p><h3 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h3><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p><h3 id="呈现引擎的线程"><a href="#呈现引擎的线程" class="headerlink" title="呈现引擎的线程"></a>呈现引擎的线程</h3><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。<br>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure><h1 id="9-内存泄露"><a href="#9-内存泄露" class="headerlink" title="9.内存泄露"></a>9.<a href="https://segmentfault.com/a/1190000020231307">内存泄露</a></h1><p>用户一般不会在一个 Web 页面停留比较久，即使有一点内存泄漏，重载页面内存也会跟着释放。而且浏览器也有自动回收内存的机制，所以我们前端其实并没有像 C、C++ 这类语言一样，特别关注内存泄漏的问题。</p><p>但是如果我们对内存泄漏没有什么概念，有时候还是有可能因为内存泄漏，导致页面卡顿。了解内存泄漏，如何避免内存泄漏，也是我们提升前端技能的必经之路。</p><h2 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h2><blockquote><p>在硬件级别上，计算机内存由大量触发器组成。每个触发器包含几个晶体管，能够存储一个位。单个触发器可以通过唯一标识符寻址，因此我们可以读取和覆盖它们。因此，从概念上讲，我们可以把我们的整个计算机内存看作是一个巨大的位数组，我们可以读和写。</p></blockquote><p>这么底层的概念，了解下就好，绝大多数数情况下，JavaScript 语言作为你们高级语言，无需我们使用二进制进直接进行读和写。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>内存也是有<strong>生命周期</strong>的，不管什么程序语言，一般可以按顺序分为三个周期：</p><ul><li><p>分配期</p><p>分配所需要的内存</p></li><li><p>使用期</p><p>使用分配到的内存（读、写）</p></li><li><p>释放期</p><p>不需要时将其释放和归还</p></li></ul><p>内存分配 -&gt; 内存使用 -&gt; 内存释放。</p><h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98">内存</a>。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p></blockquote><p>如果内存不需要时，没有经过生命周期的<strong>释放期</strong>，那么就存在<strong>内存泄漏</strong>。</p><p>内存泄漏简单理解：无用的内存还在占用，得不到释放和归还。比较严重时，无用的内存会持续递增，从而导致整个系统卡顿，甚至崩溃。</p><h2 id="JavaScript-内存管理机制"><a href="#JavaScript-内存管理机制" class="headerlink" title="JavaScript 内存管理机制"></a>JavaScript 内存管理机制</h2><blockquote><p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 <code>malloc()</code>和<code>free()</code>。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。</p></blockquote><p>JavaScript 内存管理机制和内存的<strong>生命周期</strong>是一一对应的。首先需要<strong>分配内存</strong>，然后<strong>使用内存</strong>，最后<strong>释放内存</strong>。</p><p>其中 JavaScript 语言<strong>不需要程序员手动</strong>分配内存，绝大部分情况下也不需要手动释放内存，对 JavaScript 程序员来说通常就是使用内存（即使用变量、函数、对象等）。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>JavaScript 定义变量就会自动分配内存的。<strong>我们只需了解 JavaScript 的内存是自动分配的就足够了</strong>。</p><p>看下内存自动分配的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给数值变量分配内存</span><br><span class="line">let number &#x3D; 123; </span><br><span class="line">&#x2F;&#x2F; 给字符串分配内存</span><br><span class="line">const string &#x3D; &quot;xianshannan&quot;; </span><br><span class="line">&#x2F;&#x2F; 给对象及其包含的值分配内存</span><br><span class="line">const object &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: null</span><br><span class="line">&#125;; </span><br><span class="line">&#x2F;&#x2F; 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line">const array &#x3D; [1, null, &quot;abra&quot;]; </span><br><span class="line">&#x2F;&#x2F; 给函数（可调用的对象）分配内存</span><br><span class="line">function func(a)&#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><blockquote><p>使用值的过程实际上是对分配内存进行<strong>读取与写入</strong>的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p></blockquote><p>根据上面的内存自动分配例子，我们继续内存使用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写入内存</span><br><span class="line">number &#x3D; 234;</span><br><span class="line">&#x2F;&#x2F; 读取 number 和 func 的内存，写入 func 参数内存</span><br><span class="line">func(number);</span><br></pre></td></tr></table></figure><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>前端界一般称<strong>垃圾内存回收</strong>为 <code>GC</code>（Garbage Collection，即垃圾回收）。</p><p><strong>内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，如果存在这些情况，需要我们手动清理内存。</strong></p><p>以前一些老版本的浏览器的 JavaScript 回收机制没那么完善，经常出现一些 bug 的内存泄漏，不过现在的浏览器基本都没这些问题了，已过时的知识这里就不做深究了。</p><p>这里了解下现在的 JavaScript 的垃圾内存的两种回收方式，熟悉下这两种算法可以帮助我们理解一些内存泄漏的场景。</p><h4 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h4><blockquote><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p>看下下面的例子，“这个对象”的内存被回收了吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; “这个对象”分配给 a 变量</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; b 引用“这个对象”</span><br><span class="line">var b &#x3D; a; </span><br><span class="line">&#x2F;&#x2F; 现在，“这个对象”的原始引用 a 被 b 替换了</span><br><span class="line">a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>当前执行环境中，“这个对象”内存还没有被回收的，需要手动释放“这个对象”的内存（当然是还没离开执行环境的情况下），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 或者 b &#x3D; 1，反正替换“这个对象”就行了</span><br></pre></td></tr></table></figure><p>这样引用的”这个对象”的内存就被回收了。</p><p>ES6 把<strong>引用</strong>有区分为<strong>强引用</strong>和<strong>弱引用</strong>，这个目前只有再 Set 和 Map 中才有。</p><p><strong>强引用</strong>才会有<strong>引用计数</strong>叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（手动回收的前提在于<strong>标记清除法</strong>还没执行，还处于当前执行环境）。</p><p>而<strong>弱引用</strong>没有触发<strong>引用计数</strong>叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。</p><h4 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h4><blockquote><p>当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收</p></blockquote><p>环境可以理解为我们的作用域，但是全局作用域的变量只会在页面关闭才会销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设这里是全局变量</span><br><span class="line">&#x2F;&#x2F; b 被标记进入环境</span><br><span class="line">var b &#x3D; 2;</span><br><span class="line">function test() &#123;</span><br><span class="line">  var a &#x3D; 1;</span><br><span class="line">  &#x2F;&#x2F; 函数执行时，a 被标记进入环境</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数执行结束，a 被标记离开环境，被回收</span><br><span class="line">&#x2F;&#x2F; 但是 b 就没有被标记离开环境</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h2 id="JavaScript-内存泄漏的一些场景"><a href="#JavaScript-内存泄漏的一些场景" class="headerlink" title="JavaScript 内存泄漏的一些场景"></a>JavaScript 内存泄漏的一些场景</h2><p>JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况。程序员要让浏览器内存泄漏，浏览器也是管不了的。</p><p><strong>下面有些例子是在执行环境中，没离开当前执行环境，还没触发标记清除法。所以你需要读懂上面 JavaScript 的内存回收机制，才能更好理解下面的场景。</strong></p><h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在全局作用域下定义</span><br><span class="line">function count(number) &#123;</span><br><span class="line">  &#x2F;&#x2F; basicCount 相当于 window.basicCount &#x3D; 2;</span><br><span class="line">  basicCount &#x3D; 2;</span><br><span class="line">  return basicCount + number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在 eslint 帮助下，这种场景现在基本没人会犯了，eslint 会直接报错，了解下就好。</p><h3 id="被遗忘的计时器"><a href="#被遗忘的计时器" class="headerlink" title="被遗忘的计时器"></a>被遗忘的计时器</h3><p>无用的计时器忘记清理是新手最容易犯的错误之一。</p><p>就拿一个 vue 组件来做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    refresh() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取一些数据</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setInterval(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 轮询获取数据</span><br><span class="line">      this.refresh()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，<code>setInterval</code> 还是在运行的，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候清除计时器，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    refresh() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取一些数据</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.refreshInterval &#x3D; setInterval(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 轮询获取数据</span><br><span class="line">      this.refresh()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    clearInterval(this.refreshInterval)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的事件监听器"><a href="#被遗忘的事件监听器" class="headerlink" title="被遗忘的事件监听器"></a>被遗忘的事件监听器</h3><p>无用的事件监听器忘记清理是新手最容易犯的错误之一。</p><p>还是继续使用 vue 组件做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里做一些操作</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候移除相关的事件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.resizeEventCallback &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里做一些操作</span><br><span class="line">    &#125;</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, this.resizeEventCallback)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    window.removeEventListener(&#39;resize&#39;, this.resizeEventCallback)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的-ES6-Set-成员"><a href="#被遗忘的-ES6-Set-成员" class="headerlink" title="被遗忘的 ES6 Set 成员"></a>被遗忘的 ES6 Set 成员</h3><p>如果对 Set 不熟悉，可以看<a href="http://es6.ruanyifeng.com/#docs/set-map#Set">这里</a>。</p><p>如下是有内存泄漏的（成员是引用类型的，即对象）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Set();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">value&#x3D; null;</span><br></pre></td></tr></table></figure><p>需要改成这样，才没内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Set();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">map.delete(value);</span><br><span class="line">value &#x3D; null;</span><br></pre></td></tr></table></figure><p>有个更便捷的方式，使用 WeakSet，WeakSet 的成员是<strong>弱引用</strong>，内存回收不会考虑到这个引用是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new WeakSet();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">value &#x3D; null;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的-ES6-Map-键名"><a href="#被遗忘的-ES6-Map-键名" class="headerlink" title="被遗忘的 ES6 Map 键名"></a>被遗忘的 ES6 Map 键名</h3><p>如果对 Map 不熟悉，可以看<a href="http://es6.ruanyifeng.com/#docs/set-map#Map">这里</a>。</p><p>如下是有内存泄漏的（键值是引用类型的，即对象）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><p>需要改成这样，才没内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line"></span><br><span class="line">map.delete(key);</span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><p>有个更便捷的方式，使用 WeakMap，WeakMap 的键名是<strong>弱引用</strong>，内存回收不会考虑到这个引用是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new WeakMap();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line"></span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的订阅发布事件监听器"><a href="#被遗忘的订阅发布事件监听器" class="headerlink" title="被遗忘的订阅发布事件监听器"></a>被遗忘的订阅发布事件监听器</h3><p>这个跟上面的<strong>被遗忘的事件监听器</strong>的道理是一样的。</p><p>假设订阅发布事件有三个方法 <code>emit</code> 、<code>on</code> 、<code>off</code> 三个方法。</p><p>还是继续使用 vue 组件做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;onClick&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import customEvent from &#39;event&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      customEvent.emit(&#39;test&#39;, &#123; type: &#39;click&#39; &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    customEvent.on(&#39;test&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 一些逻辑</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，自定义 test 事件还是在监听中，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候移除相关的事件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;onClick&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import customEvent from &#39;event&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      customEvent.emit(&#39;test&#39;, &#123; type: &#39;click&#39; &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    customEvent.on(&#39;test&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 一些逻辑</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    customEvent.off(&#39;test&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的闭包"><a href="#被遗忘的闭包" class="headerlink" title="被遗忘的闭包"></a>被遗忘的闭包</h3><p>闭包是经常使用的，闭包能给我们带来很多便利。</p><p>首先看下这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function closure() &#123;</span><br><span class="line">  const name &#x3D; &#39;xianshannan&#39;</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    return name</span><br><span class="line">      .split(&#39;&#39;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const reverseName &#x3D; closure()</span><br><span class="line">&#x2F;&#x2F; 这里调用了 reverseName</span><br><span class="line">reverseName();</span><br></pre></td></tr></table></figure><p>上面有没有内存泄漏？</p><p>上面是没有内存泄漏的，因为<code>name</code> 变量是要用到的（非垃圾）。这也是从侧面反映了闭包的缺点，内存占用相对高，量多了会有性能影响。</p><p>但是改成这样就是有内存泄漏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function closure() &#123;</span><br><span class="line">  const name &#x3D; &#39;xianshannan&#39;</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    return name</span><br><span class="line">      .split(&#39;&#39;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const reverseName &#x3D; closure()</span><br></pre></td></tr></table></figure><p>在当前执行环境未结束的情况下，严格来说，这样是有内存泄漏的，<code>name</code> 变量是被 <code>closure</code> 返回的函数调用了，但是返回的函数没被使用，这个场景下 <code>name</code> 就属于垃圾内存。<code>name</code> 不是必须的，但是还是占用了内存，也不可被回收。</p><p>当然这种也是极端情况，很少人会犯这种低级错误。这个例子可以让我们更清楚的认识内存泄漏。</p><h3 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h3><p>每个页面上的 DOM 都是占用内存的，假设有一个页面 A 元素，我们获取到了 A 元素 DOM 对象，然后赋值到了一个变量（内存指向是一样的），然后移除了页面的 A 元素，如果这个变量由于其他原因没有被回收，那么就存在内存泄漏，如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.elements &#x3D; &#123;</span><br><span class="line">      button: document.querySelector(&#39;#button&#39;),</span><br><span class="line">      div: document.querySelector(&#39;#div&#39;),</span><br><span class="line">      span: document.querySelector(&#39;#span&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeButton() &#123;</span><br><span class="line">    document.body.removeChild(this.elements.button)</span><br><span class="line">    &#x2F;&#x2F; this.elements.button &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new Test()</span><br><span class="line">a.removeButton()</span><br></pre></td></tr></table></figure><p>上面的例子 button 元素 虽然在页面上移除了，但是内存指向换为了 <code>this.elements.button</code>，内存占用还是存在的。所以上面的代码还需要这样写： <code>this.elements.button = null</code>，手动释放这个内存。</p><h2 id="如何发现内存泄漏？"><a href="#如何发现内存泄漏？" class="headerlink" title="如何发现内存泄漏？"></a>如何发现内存泄漏？</h2><p>内存泄漏时，内存一般都是会周期性的增长，我们可以借助谷歌浏览器的开发者工具进行判别。</p><p>这里不进行详细的开发者工具使用说明，详细看<a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">谷歌开发者工具</a>，不过谷歌浏览器是不断迭代更新的，有些文档落后了，界面长得不一样。</p><p>本人测试的谷歌版本为：<strong>版本 76.0.3809.100（正式版本） （64 位）</strong>。</p><p>这里针对下面例子进行一步一步的排查和找到问题出现在哪里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;run&quot;&gt;运行&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;stop&quot;&gt;停止&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const arr &#x3D; []</span><br><span class="line">      for (let i &#x3D; 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        arr.push(i)</span><br><span class="line">      &#125;</span><br><span class="line">      let newArr &#x3D; []</span><br><span class="line"></span><br><span class="line">      function run() &#123;</span><br><span class="line">        newArr &#x3D; newArr.concat(arr)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let clearRun</span><br><span class="line"></span><br><span class="line">      document.querySelector(&#39;#run&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">        clearRun &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          run()</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      document.querySelector(&#39;#stop&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">        clearInterval(clearRun)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面例子的代码可以直接运行的，怎么运行我就不多说了。</p><h3 id="第一步：确定是否是内存泄漏问题"><a href="#第一步：确定是否是内存泄漏问题" class="headerlink" title="第一步：确定是否是内存泄漏问题"></a>第一步：确定是否是内存泄漏问题</h3><p>访问上面的代码页面，打开谷歌开发者工具，切换至 <strong>Performance</strong> 选项，勾选 <code>Memory</code> 选项。</p><p>在页面上点击<strong>运行按钮</strong>，然后在开发者工具上面点击左上角的录制按钮，10 秒后在页面上点击<strong>停止按钮</strong>，5 秒后停止内存录制。得到的内存走势如下：</p><p><img data-src="https://segmentfault.com/img/bVbxaaT" alt="clipboard.png"></p><p>由上图可知，10 秒之前内存周期性增长，10 后点击了停止按钮，内存平稳，不再递增。</p><p>我们可以使用内存走势图判断当前页面是否有内存泄漏。经过测试上面的代码 <code>20000</code> 个数组项改为 <code>20</code> 个数组项，内存走势也一样能看出来。</p><h3 id="第二步：查找内存泄漏出现的位置"><a href="#第二步：查找内存泄漏出现的位置" class="headerlink" title="第二步：查找内存泄漏出现的位置"></a>第二步：查找内存泄漏出现的位置</h3><p>上一步确认是内存泄漏问题后，我们继续利用谷歌开发者工具进行问题查找。</p><p>访问上面的代码页面，打开谷歌开发者工具，切换至 <strong>Memory</strong> 选项。页面上点击运行按钮，然后点击开发者工具左上角录制按钮，录制完成后继续点击录制，知道录制完三个为止。然后点击页面的停止按钮，再连续录制 3 次内存（不要清理之前的录制）。下图就是进行这些步骤后的截图：</p><p><img data-src="https://segmentfault.com/img/bVbxaaO" alt="clipboard.png"></p><p>从这里也可以看出，点击运行按钮后，内存在不断递增。点击停止按钮后，内存就平稳了。虽然我们也可以使用这样的方式来判别是否存在内存泄漏，但是不够第一步的方法便捷，走势图也更直观。</p><p>然后第二步的主要目的来了，记录 JavaScript 堆内存才是内存录制的主要目的，我们可以看到哪个堆占用的内存更高。</p><p>在刚才的录制中选择 Snapshot 3 ，然后按照 <strong>Shallow Size</strong> 进行逆序排序（不了解的可以看<a href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101?hl=zh-cn">内存术语</a>），如下：</p><p><img data-src="https://segmentfault.com/img/bVbxaaL" alt="clipboard.png"></p><p>从内存记录中，发现 array 对象占用最大，展开后发现，第一个 <code>object elements</code> 占用最大，选择这个 <code>object elements</code> 后可以在下面看到 <code>newArr</code> 变量，然后点击 <code>test:23</code>，只要是高亮下划线的地方都可以进去看看 （测试页面是 test.html），可以跳转到 <code>newArr</code> 附近。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">维基百科-内存泄漏</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li><li><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></li><li><a href="https://juejin.im/post/5b684f30f265da0f9f4e87cf">javascript 垃圾回收机制</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML" scheme="https://hxy1997.xyz/tags/HTML/"/>
    
    <category term="浏览器" scheme="https://hxy1997.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>一起愉快刷题</title>
    <link href="https://hxy1997.xyz/2021/03/09/%E4%B8%80%E8%B5%B7%E6%84%89%E5%BF%AB%E5%88%B7%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/09/%E4%B8%80%E8%B5%B7%E6%84%89%E5%BF%AB%E5%88%B7%E9%A2%98/</id>
    <published>2021-03-08T16:02:39.000Z</published>
    <updated>2021-03-14T01:23:52.373Z</updated>
    
    <content type="html"><![CDATA[<p>按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号</p><span id="more"></span><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h4><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p></blockquote><p>解法一</p><p>哈希表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">&#x2F;&#x2F; 新建无重复的set</span><br><span class="line">    let hash &#x3D; new Set();</span><br><span class="line">    for(let i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (hash.has(nums[i]))&#123;</span><br><span class="line">            return nums[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hash.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二</p><p>置换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> * 置换法</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历元素</span><br><span class="line">    for (let i &#x3D; 0; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">        &#x2F;&#x2F;   当前数字</span><br><span class="line">        let cur &#x3D; nums[i];</span><br><span class="line">        &#x2F;&#x2F; 当前位置是否是自身可能已经排行</span><br><span class="line">        if (cur !&#x3D;&#x3D; i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前位置的数放在原来的索引的位置上</span><br><span class="line">            if (cur !&#x3D;&#x3D; nums[cur]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 暂时存储</span><br><span class="line">                let temp &#x3D; nums[cur];</span><br><span class="line">                nums[cur] &#x3D; cur;</span><br><span class="line">                cur &#x3D; temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p></blockquote><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;boolean&#125;&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findNumberIn2DArray &#x3D; function(matrix, target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 排除长或宽为0</span><br><span class="line">    if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0) return false;</span><br><span class="line">    &#x2F;&#x2F; 长</span><br><span class="line">    let lenX &#x3D; matrix.length;</span><br><span class="line">    &#x2F;&#x2F; 宽</span><br><span class="line">    let lenY &#x3D; matrix[0].length;</span><br><span class="line">    &#x2F;&#x2F; 行指针和列指针</span><br><span class="line">    let x &#x3D; 0, y &#x3D; lenY - 1;</span><br><span class="line">    &#x2F;&#x2F; 不越界</span><br><span class="line">    while(x &lt; lenX &amp;&amp; y &gt;&#x3D; 0)&#123;</span><br><span class="line">        if (matrix[x][y] &#x3D;&#x3D; target)&#123;</span><br><span class="line">            &#x2F;&#x2F; 找到目标</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (matrix[x][y] &gt; target)&#123;</span><br><span class="line">            &#x2F;&#x2F; 大于目标列指针减小</span><br><span class="line">            y--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 小于目标行指针增加</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 越界说明找不到</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><blockquote><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p>限制：</p><blockquote><p>0 &lt;= s 的长度 &lt;= 10000</p></blockquote><p>正则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> * 正则表达式</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;\s&#x2F;g, &quot;%20&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> * 库函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.split(&#39; &#39;).join(&#39;%20&#39;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p>无需翻转链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var reversePrint &#x3D; function(head) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数组</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 不断移动链表</span><br><span class="line">    while(head !&#x3D; null)&#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻转链表，额外空间降为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var reversePrint &#x3D; function(head) &#123;</span><br><span class="line">    if (!head) return [];</span><br><span class="line">    &#x2F;&#x2F; 之前的和当前指针</span><br><span class="line">    let pre &#x3D; head, cur &#x3D; head.next;</span><br><span class="line">    &#x2F;&#x2F; 反转链表</span><br><span class="line">    while(cur !&#x3D; null)&#123;</span><br><span class="line">        pre.next &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; head;</span><br><span class="line">        head &#x3D; cur;</span><br><span class="line">        cur &#x3D; pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 头指针</span><br><span class="line">    cur &#x3D; head;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a>07.<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/"> 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure><p>直接递归划分子前序遍历和中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; preorder</span><br><span class="line"> * @param &#123;number[]&#125; inorder</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归出口</span><br><span class="line">    if (preorder.length &lt;&#x3D; 0) return null;</span><br><span class="line">    &#x2F;&#x2F; 前序遍历第一个节点为根节点</span><br><span class="line">    let node &#x3D; new TreeNode(preorder[0]);</span><br><span class="line">    &#x2F;&#x2F; 找到中序遍历对应的节点</span><br><span class="line">    let i &#x3D; inorder.indexOf(preorder[0]);</span><br><span class="line">    &#x2F;&#x2F; 左节点递归构造子二叉树</span><br><span class="line">    node.left &#x3D; buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));</span><br><span class="line">    &#x2F;&#x2F; 右节点递归构造子二叉树</span><br><span class="line">    node.right &#x3D; buildTree(preorder.slice(i + 1, preorder.length), inorder.slice(i + 1, inorder.length));</span><br><span class="line">    &#x2F;&#x2F; 返回根节点</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>牺牲空间优化速度，保存每个子节点 在中序遍历中的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    if (preorder.length &#x3D;&#x3D;&#x3D; 0) return null;</span><br><span class="line">    const map &#x3D; new Map();</span><br><span class="line">    const len &#x3D; inorder.length;</span><br><span class="line">    &#x2F;&#x2F; 空间换时间</span><br><span class="line">    for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        map.set(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    function tree (pre, inor, pre_start, pre_end, inor_start, inor_end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根节点</span><br><span class="line">        const root_val &#x3D; pre[pre_start];</span><br><span class="line">        const root &#x3D; new TreeNode(root_val);</span><br><span class="line">        &#x2F;&#x2F; 在中序遍历中的位置</span><br><span class="line">        const inor_root_index &#x3D; map.get(root_val);</span><br><span class="line">        &#x2F;&#x2F; 左子树长度</span><br><span class="line">        const lsonLen &#x3D; inor_root_index - inor_start;</span><br><span class="line">        &#x2F;&#x2F; 右子树长度</span><br><span class="line">        const rsonLen &#x3D; inor_end - inor_root_index;</span><br><span class="line">        &#x2F;&#x2F; 左子树构建</span><br><span class="line">        if (lsonLen &gt; 0) &#123;</span><br><span class="line">            root.left &#x3D; tree(pre, inor, pre_start + 1, pre_start + 1 + lsonLen, inor_start, inor_root_index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右子树构建</span><br><span class="line">        if (rsonLen &gt; 0) &#123;</span><br><span class="line">            root.right &#x3D; tree(pre, inor, pre_start + 1 + lsonLen, pre_end, inor_root_index + 1, inor_end);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return tree(preorder, inorder, 0, len - 1, 0, len - 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="专题部分"><a href="#专题部分" class="headerlink" title="专题部分"></a>专题部分</h1><h2 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h2><p>贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h3><p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><blockquote><p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p></blockquote><p>示例 2:</p><blockquote><p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p></blockquote><p>因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因此贪心策略</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">g</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContentChildren = <span class="function"><span class="keyword">function</span>(<span class="params">g, s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 按孩子要求先排序</span></span><br><span class="line">    g.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="comment">// 按饼干尺寸先排序</span></span><br><span class="line">    s.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="comment">// 孩子从小到大编号</span></span><br><span class="line">    <span class="keyword">let</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 保证循环</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">        <span class="comment">// 贪心选择给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干</span></span><br><span class="line">        <span class="keyword">if</span> (g[child] &lt;= s[cookie]) child++;</span><br><span class="line">        <span class="comment">// 饼干数+1</span></span><br><span class="line">        cookie++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><strong><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></strong></h3><p>每个孩子有一个评分，如果评分高于旁边的孩子，则被分配的糖果数量也必须更多，求最少总糖果数量，使得每个孩子都有糖果。</p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1：</p><blockquote><p>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p></blockquote><p>贪心策略，从左往右和从右往左各遍历一遍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">ratings</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> * 两次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> candy = <span class="function"><span class="keyword">function</span>(<span class="params">ratings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = ratings.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &lt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num[i - <span class="number">1</span>] = <span class="built_in">Math</span>.max(num[i - <span class="number">1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    <span class="keyword">return</span> num.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><strong><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></strong></h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p><blockquote><p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p><p>输出: 1</p></blockquote><p>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p><blockquote><p>输入: [ [1,2], [1,2], [1,2] ]</p><p>输出: 2</p></blockquote><p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p><blockquote><p>输入: [ [1,2], [2,3] ]</p><p>输出: 0</p></blockquote><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><p>计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> eraseOverlapIntervals = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 序列长度</span></span><br><span class="line">    <span class="keyword">let</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 初始化删除区间数为0</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 排序后，初始化区间尾为最小值</span></span><br><span class="line">    <span class="keyword">let</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前开头小于结尾，需要删除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; x_end) &#123;</span><br><span class="line">            <span class="comment">// 需要删除该项</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间结尾</span></span><br><span class="line">            x_end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h3><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><p>任何左括号 ( 必须有相应的右括号 )。<br>任何右括号 ) 必须有相应的左括号 ( 。<br>左括号 ( 必须在对应的右括号之前 )。</p><p>可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。<br>一个空字符串也被视为有效字符串</p><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: True</p></blockquote><p>示例 2:</p><blockquote><p>输入: “(*)”<br>输出: True</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(*))”<br>输出: True</p></blockquote><p>贪心将（出栈，使用栈来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个栈分别存放左括号和*</span><br><span class="line">    let left &#x3D; [], star &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left.push(i);</span><br><span class="line">        &#x2F;&#x2F; *号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star.push(i);</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先出栈</span><br><span class="line">            if(left.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star.length &#x3D;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号出栈</span><br><span class="line">                star.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号出栈</span><br><span class="line">                left.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; *数量不足以抵消左括号</span><br><span class="line">    if(left.length &gt; star.length) return false;</span><br><span class="line">    &#x2F;&#x2F; 两个都有</span><br><span class="line">    while(left.length &amp;&amp; star.length)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号在*右侧</span><br><span class="line">        if(left.pop() &gt; star.pop()) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历两次实现损失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 模拟栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分别存放剩余左括号和*数量</span><br><span class="line">    let left &#x3D; 0, star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择左括号</span><br><span class="line">            if(left &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号数量-1</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 存放剩余右括号数量</span><br><span class="line">    let right &#x3D; 0;</span><br><span class="line">    star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; s.length - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">        &#x2F;&#x2F; 右括号数量-1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) right++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 左括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择右括号</span><br><span class="line">            if(right &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; )号数量-1</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><blockquote><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><p>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p><blockquote><p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p></blockquote><p>提示：</p><p>1 &lt;= people.length &lt;= 2000<br>0 &lt;= hi &lt;= 106<br>0 &lt;= ki &lt; people.length<br>题目数据确保队列可以被重建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; people</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> * 贪心算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reconstructQueue &#x3D; function(people) &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先按照身高h降序排列，同时如果身高相同那么按照k增序，个高的人忽略前面个矮的人</span><br><span class="line">    people.sort((a, b) &#x3D;&gt; a[0] &#x3D;&#x3D;&#x3D; b[0] ? a[1] - b[1] : b[0] - a[0]);</span><br><span class="line">    &#x2F;&#x2F; 结果数组</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 先安排高个子的位置</span><br><span class="line">    for (let i &#x3D; 0; i &lt; people.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先安排高个子k小,再安排高个子k大的</span><br><span class="line">        res.splice(people[i][1], 0, people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据结构和算法" scheme="https://hxy1997.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css面试题</title>
    <link href="https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-06T04:02:39.000Z</published>
    <updated>2021-03-13T02:01:45.719Z</updated>
    
    <content type="html"><![CDATA[<p>CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧</p><span id="more"></span><h1 id="1-css盒模型简介"><a href="#1-css盒模型简介" class="headerlink" title="1.css盒模型简介"></a>1.<a href="https://www.cnblogs.com/112233-j/p/12600228.html">css盒模型简介</a></h1><p>盒子模型，英文即box model。无论是div、span、还是a都是盒子。</p><p>但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。</p><h3 id="盒子中的区域"><a href="#盒子中的区域" class="headerlink" title="盒子中的区域"></a>盒子中的区域</h3><p>一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>盒子模型的示意图：</p><p><img data-src="http://img.smyhvae.com/20170727_2128.png" alt="img"></p><p>代码演示：</p><p><img data-src="http://img.smyhvae.com/20170727_2326.png" alt="img"></p><p>上面这个盒子，width:200px; height:200px; 但是真实占有的宽高是302*302。 这是因为还要加上padding、border。</p><p>注意：<strong>宽度和真实占有宽度，不是一个概念！</strong>来看下面这例子。</p><h3 id="标准盒模型和IE盒模型"><a href="#标准盒模型和IE盒模型" class="headerlink" title="标准盒模型和IE盒模型"></a>标准盒模型和IE盒模型</h3><blockquote><p>我们目前所学习的知识中，以标准盒子模型为准。</p></blockquote><p>标准盒子模型：</p><p><img data-src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt="img"></p><p>IE盒子模型：</p><p><img data-src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt="img"></p><p>上图显示：</p><p>在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>CSS盒模型和IE盒模型的区别：</p><ul><li>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li></ul><p>注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。</p><h3 id="lt-body-gt-标签也有margin"><a href="#lt-body-gt-标签也有margin" class="headerlink" title="&lt;body&gt;标签也有margin"></a><code>&lt;body&gt;</code>标签也有margin</h3><p><code>&lt;body&gt;</code>标签有必要强调一下。很多人以为<code>&lt;body&gt;</code>标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是<code>&lt;document&gt;</code>，即浏览器。而<code>&lt;body&gt;</code>是<code>&lt;document&gt;</code>的儿子。浏览器给<code>&lt;body&gt;</code>默认的margin大小是8个像素，此时<code>&lt;body&gt;</code>占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;EditPlus®&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="css"><span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin</span>: <span class="number">30px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>有生之年<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>狭路相逢<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们对div标签设置了边距等信息。打开google浏览器，按住F12，显示效果如下：</p><p><img data-src="http://img.smyhvae.com/20151003_27.png" alt="img"></p><h3 id="认识width、height"><a href="#认识width、height" class="headerlink" title="认识width、height"></a>认识width、height</h3><p>一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。</p><p>比如说，丈量稿纸，前端开发工程师只会丈量内容宽度：</p><p><img data-src="http://img.smyhvae.com/20170727_2329.png" alt="img"></p><p>下面这两个盒子，真实占有宽高，都是302*302：</p><p>盒子1：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>盒子2：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实占有宽度 = 左border + 左padding + width + 右padding + 右border</p><p>上面这两个盒子的盒模型图如下：</p><p><img data-src="http://img.smyhvae.com/20170728_0925.png" alt="img"></p><p><strong>如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width</strong>。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。</p><h3 id="认识padding"><a href="#认识padding" class="headerlink" title="认识padding"></a>认识padding</h3><h4 id="padding区域也有颜色"><a href="#padding区域也有颜色" class="headerlink" title="padding区域也有颜色"></a>padding区域也有颜色</h4><p>padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充<strong>所有border以内的区域。</strong></p><p>效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1005.png" alt="img"></p><h4 id="padding有四个方向"><a href="#padding有四个方向" class="headerlink" title="padding有四个方向"></a>padding有四个方向</h4><p>padding是4个方向的，所以我们能够分别描述4个方向的padding。</p><p>方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。</p><p>小属性的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding-top: 30px;</span><br><span class="line">padding-right: 20px;</span><br><span class="line">padding-bottom: 40px;</span><br><span class="line">padding-left: 100px;</span><br></pre></td></tr></table></figure><p>综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding:30px 20px 40px 100px;</span><br></pre></td></tr></table></figure><p>如果写了四个值，则顺序为：上、右、下、左。</p><p>如果只写了三个值，则顺序为：上、右、下。??和右一样。</p><p>如果只写了两个值，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding: 30px 40px;</span><br></pre></td></tr></table></figure><p>则顺序等价于：30px 40px 30px 40px;</p><p>要懂得，<strong>用小属性层叠大属性</strong>。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding: 20px;</span><br><span class="line">padding-left: 30px;</span><br></pre></td></tr></table></figure><p>上面的padding对应盒子模型为：</p><p><img data-src="http://img.smyhvae.com/20170728_1039.png" alt="img"></p><p>下面的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-left: 30px;</span><br><span class="line">padding: 20px;</span><br></pre></td></tr></table></figure><p>第一行的小属性无效，因为被第二行的大属性层叠掉了。</p><p>下面的题，会做了，说明你明白了。</p><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p><strong>题目1</strong>：说出下面盒子真实占有宽高，并画出盒模型图。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><p><img data-src="http://img.smyhvae.com/20170728_1048.png" alt="img"></p><p><strong>题目2</strong>：说出下面盒子真实占有宽高，并画出盒模型图。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">40px</span> <span class="number">50px</span> <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><p><code>padding-left:10px；</code> 和<code>padding-right:20px;</code> 没用，因为后面的padding大属性，层叠掉了他们。</p><p>盒子模型如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1100.png" alt="img"></p><p><strong>题目3</strong>：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p><p><img data-src="http://img.smyhvae.com/20170728_1401.png" alt="img"></p><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width:123px;</span><br><span class="line">height:123px;</span><br><span class="line">padding:20px 40px;</span><br><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><p><strong>题目4</strong>：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p><p><img data-src="http://img.smyhvae.com/20170728_1402.png" alt="img"></p><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">width:123px;</span><br><span class="line">height:123px;</span><br><span class="line">padding:20px;</span><br><span class="line">padding-right:40px;</span><br><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><h4 id="一些元素，默认带有padding"><a href="#一些元素，默认带有padding" class="headerlink" title="一些元素，默认带有padding"></a>一些元素，默认带有padding</h4><p>一些元素，默认带有<code>padding</code>，比如ul标签。如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1413.png" alt="img"></p><p>上图显示，不加任何样式的ul，也是有40px的padding-left。</p><p>所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。</p><p>可以使用<code>*</code>进行清除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>*</code>的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认识border"><a href="#认识border" class="headerlink" title="认识border"></a>认识border</h3><p>border就是边框。边框有三个要素：像素（粗细）、线型、颜色。</p><p>颜色如果不写，默认是黑色。另外两个属性不写，要命了，显示不出来边框。</p><h4 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h4><p>border的所有的线型如下：（我们可以通过查看<code>CSS参考手册</code>得到）</p><p><img data-src="http://img.smyhvae.com/20170728_1435.png" alt="img"></p><p>比如<code>border:10px ridge red;</code>这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已）</p><p><img data-src="http://img.smyhvae.com/20170728_1619.png" alt="img"></p><p>如果公司里面的设计师是处女座的，追求极高的<strong>页面还原度</strong>，那么不能使用css来制作边框。就要用到图片，就要切图了。</p><p>所以，比较稳定的border-style就几个：solid、dashed、dotted。</p><h4 id="border拆分"><a href="#border拆分" class="headerlink" title="border拆分"></a>border拆分</h4><p>border是一个大综合属性。比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><p>就是把4个边框，都设置为1px宽度、线型实线、red颜色。</p><p>PS：小技巧：在sublime text中，为了快速输入<code>border:1px solid red;</code>这个属性，可以直接输入<code>bd</code>，然后选第二个后回车。</p><p>border属性是能够被拆开的，有两大种拆开的方式：</p><ul><li>（1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的）</li><li>（2）按方向拆开：border-top、border-right、border-bottom、border-left。</li></ul><p>现在我们明白了：<strong>一个border属性，是由三个小属性综合而成的</strong>。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-width:10px 20px;</span><br><span class="line">border-style:solid dashed dotted;</span><br><span class="line">border-color:red green blue yellow;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1516.png" alt="img"></p><p>（1）按三要素拆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-width:10px;    &#x2F;&#x2F;边框宽度</span><br><span class="line">border-style:solid;   &#x2F;&#x2F;线型</span><br><span class="line">border-color:red;     &#x2F;&#x2F;颜色。</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>(2)按方向来拆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top:10px solid red;</span><br><span class="line">border-right:10px solid red;</span><br><span class="line">border-bottom:10px solid red;</span><br><span class="line">border-left:10px solid red;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>（3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">border-top-width:10px;</span><br><span class="line">border-top-style:solid;</span><br><span class="line">border-top-color:red;</span><br><span class="line">border-right-width:10px;</span><br><span class="line">border-right-style:solid;</span><br><span class="line">border-right-color:red;</span><br><span class="line">border-bottom-width:10px;</span><br><span class="line">border-bottom-style:solid;</span><br><span class="line">border-bottom-color:red;</span><br><span class="line">border-left-width:10px;</span><br><span class="line">border-left-style:solid;</span><br><span class="line">border-left-color:red;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1606.png" alt="img"></p><p>为了实现上方效果，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br><span class="line">border-right-color:blue;</span><br></pre></td></tr></table></figure><p><img data-src="http://img.smyhvae.com/20170728_1608.png" alt="img"></p><p>为了实现上方效果，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br><span class="line">border-style:solid dashed;</span><br></pre></td></tr></table></figure><p>border可以没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:none;</span><br></pre></td></tr></table></figure><p>可以某一条边没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-left: none;</span><br></pre></td></tr></table></figure><p>也可以调整左边边框的宽度为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-left-width: 0;</span><br></pre></td></tr></table></figure><h4 id="举例：利用border属性画一个三角形（小技巧）"><a href="#举例：利用border属性画一个三角形（小技巧）" class="headerlink" title="举例：利用border属性画一个三角形（小技巧）"></a>举例：利用border属性画一个三角形（小技巧）</h4><p>步骤如下：</p><p>（1）当我们设置盒子的width和height为0时，此时效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1640.png" alt="img"></p><p>（2）然后将border的底部取消：</p><p><img data-src="http://img.smyhvae.com/20170728_1645.png" alt="img"></p><p>（3）最后设置border的左边和右边为白色：</p><p><img data-src="http://img.smyhvae.com/20170728_1649.png" alt="img"></p><p>这样，一个三角形就画好了。</p><p><a href="http://www.yanhuangxueyuan.com/HTML5/icon.html">CSS绘制三角形</a> 讲解的是利用boder外边框属性绘制各种三角形的案例。</p><p><a href="http://www.yanhuangxueyuan.com/HTML5/icon.html">CSS绘制圆(弧)</a> 讲解如何利用CSS的基本属性圆角border-radius绘制与圆、圆弧相关的图形。</p><h1 id="2-CSS-选择器"><a href="#2-CSS-选择器" class="headerlink" title="2.CSS 选择器"></a>2.<a href="https://segmentfault.com/a/1190000013424772">CSS 选择器</a></h1><blockquote><p>摘自 MDN web docs</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>选择器是 CSS 规则的一部分且位于 CSS 声明块前。</p><p><img data-src="https://segmentfault.com/img/remote/1460000013424775?w=644&h=188" alt="image"></p><p>选择器可以被分为以下类别：</p><ul><li><code>简单选择器（Simple selectors）</code>：通过元素类型、class 或 id 匹配一个或多个元素。</li><li><code>属性选择器（Attribute selectors）</code>：通过 属性 / 属性值 匹配一个或多个元素。</li><li><code>伪类（Pseudo-classes）</code>：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。</li><li><code>伪元素（Pseudo-elements）</code>:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。</li><li><code>组合器（Combinators）</code>：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择 divs 的直系子节点的段落，或者直接跟在 headings 后面的段落。</li><li><code>多用选择器（Multiple selectors）</code>：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li></ul><h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><h3 id="类型选择器（又名：元素选择器）"><a href="#类型选择器（又名：元素选择器）" class="headerlink" title="类型选择器（又名：元素选择器）"></a>类型选择器（又名：元素选择器）</h3><p>此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。</p><h3 id="类选择器（Class-selectors）"><a href="#类选择器（Class-selectors）" class="headerlink" title="类选择器（Class selectors）"></a>类选择器（Class selectors）</h3><p>类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。</p><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>ID选择器由哈希/磅符号 (#)组成，后面是给定元素的ID名称。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己选择的ID是什么。 这是选择单个元素的最有效的方式。</p><blockquote><p>重要提示：一个ID名称必须在文件中是唯一的。关于重复ID的行为是不可预测的，比如在一些浏览器只是第一个实例计算，其余的将被忽略。</p></blockquote><h3 id="通用选择器（Universal-selector）"><a href="#通用选择器（Universal-selector）" class="headerlink" title="通用选择器（Universal selector）"></a>通用选择器（Universal selector）</h3><p>通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。</p><blockquote><p>重要提示：使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。不会有太多的情况下，您想使用此选择。</p></blockquote><h3 id="组合器（Combinators）"><a href="#组合器（Combinators）" class="headerlink" title="组合器（Combinators）"></a>组合器（Combinators）</h3><p>在CSS中，组合器允许您将多个选择器组合在一起，这允许您在其他元素中选择元素，或者与其他元素相邻。四种可用的类型是：</p><ul><li>后代选择器——（空格键）——允许您选择嵌套在另一个元素中的某个元素（不一定是直接的后代;例如，它可以是一个孙子）。</li><li>子选择器—— &gt; ——允许您选择一个元素，该元素是另一个元素的直接子元素。</li><li>相邻兄弟选择器—— + ——允许您选择一个元素，它是另一个元素的直接兄弟元素(也就是说，在它的旁边，在层次结构的同一层)。</li><li>通用兄弟选择器—— ~ — —允许您选择其他元素的兄弟元素(例如，在层次结构中的相同级别，但不一定就在它的旁边)。</li></ul><table><thead><tr><th>Combinators</th><th>Select</th></tr></thead><tbody><tr><td>A,B</td><td>匹配满足A（和/或）B的任意元素.</td></tr><tr><td>A B</td><td>匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）</td></tr><tr><td>A &gt; B</td><td>匹配任意元素，满足条件：B是A的直接子节点</td></tr><tr><td>A + B</td><td>匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）</td></tr><tr><td>A ~ B</td><td>匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</td></tr></tbody></table><blockquote><p>注：相邻兄弟选择器和通用兄弟选择器只会“向后”选择，DOM结构靠前的兄弟元素不在选择范围内。</p></blockquote><p>这里有一个简单的例子来展示这些工作是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;h2&gt;Heading 1&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Heading 2&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;Paragraph 3&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;Paragraph 4&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br><span class="line">section p &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &gt; p &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 + p &#123;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 ~ p &#123;</span><br><span class="line">  border: 1px dashed black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS样式的HTML如下所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210307112422139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjc1MjU3NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择器是这样工作的：</p><ul><li>section p选择了所有的 <code>&lt;p&gt;</code> 元素——前两个 <code>&lt;p&gt;</code> 都是 <code>&lt;section&gt;</code> 元素的直接子元素，而后面的两个 <code>&lt;p&gt;</code> 元素是 <code>&lt;section&gt;</code> 元素的孙子元素(它们在 <code>&lt;div&gt;</code>里面)。因此，所有的段落文本都是蓝色的。</li><li>section &gt; p 只选择前两个 <code>&lt;p&gt;</code> 元素，这两个元素是 <code>&lt;section&gt;</code> 元素的直接子元素（但后两个 <code>&lt;p&gt;</code>元素不是，它们不是直接的子元素）。所以只有前两段有黄色的背景色。</li><li>h2 + p 只选择在相同层次结构的 <code>&lt;h2&gt;</code> 元素之后直接相连的 <code>&lt;p&gt;</code> 元素—— 在本例中是第一和第三段。因此，这些文本都是大写的。</li><li>h2 ~ p 选择任何在相同的层级上（还有之后的） <code>&lt;h2&gt;</code> 元素的 <code>&lt;p&gt;</code> 元素 ——在这种情况下，所有的段落符合此条件。因此，所有的这些都有一个虚线的边界。</li></ul><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器是一种特殊类型的选择器，它根据元素的 属性和属性值来匹配元素。它们的通用语法由方括号([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： <strong>存在和值属性选择器</strong> 和<strong>子串值属性选择器</strong>。</p><h3 id="存在和值（Presence-and-value）属性选择器"><a href="#存在和值（Presence-and-value）属性选择器" class="headerlink" title="存在和值（Presence and value）属性选择器"></a>存在和值（Presence and value）属性选择器</h3><p>这些属性选择器尝试匹配精确的属性值：</p><ul><li>[attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。</li><li>[attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。</li><li>[attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。</li></ul><h3 id="子串值（Substring-value）属性选择器"><a href="#子串值（Substring-value）属性选择器" class="headerlink" title="子串值（Substring value）属性选择器"></a>子串值（Substring value）属性选择器</h3><p>这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：</p><ul><li>[attr|=val] : 选择attr属性的值以val（包括val）或val-开头的元素（-用来处理语言编码）。</li><li>[attr^=val] : 选择attr属性的值以val开头（包括val）的元素。</li><li>[attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。</li><li>[attr*=val] : 选择attr属性的值中包含字符串val的元素。</li></ul><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><h3 id="伪类（Pseudo-class）"><a href="#伪类（Pseudo-class）" class="headerlink" title="伪类（Pseudo-class）"></a>伪类（Pseudo-class）</h3><p>一个 CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类（pseudo-class）</a> 是一个以冒号(:)作为前缀的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个 checkbox 被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个孩子元素时。</p><p>:active<br>:any<br>:checked<br>:default<br>:dir()<br>:disabled<br>:empty<br>:enabled<br>:first<br>:first-child<br>:first-of-type<br>:fullscreen<br>:focus<br>:hover<br>:indeterminate<br>:in-range<br>:invalid<br>:lang()<br>:last-child<br>:last-of-type<br>:left<br>:link<br>:not()<br>:nth-child()<br>:nth-last-child()<br>:nth-last-of-type()<br>:nth-of-type()<br>:only-child<br>:only-of-type<br>:optional<br>:out-of-range<br>:read-only<br>:read-write<br>:required<br>:right<br>:root<br>:scope<br>:target<br>:valid<br>:visited</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements">伪元素（Pseudo-element）</a>跟伪类很像，但它们又有不同的地方。它们都是关键字 —— 但这次伪元素前缀是两个冒号 (::) —— 同样是添加到选择器后面达到指定某个元素的某个部分。</p><p>::after<br>::before<br>::first-letter<br>::first-line<br>::selection<br>::backdrop</p><p><a href="https://segmentfault.com/t/css">css</a></p><h2 id="CSS三大特性——-继承、-优先级和层叠。"><a href="#CSS三大特性——-继承、-优先级和层叠。" class="headerlink" title="CSS三大特性—— 继承、 优先级和层叠。"></a>CSS三大特性—— <strong>继承、 优先级和层叠。</strong></h2><p><strong>继承：</strong>即子类元素继承父类的样式;</p><p><strong>优先级：</strong>是指不同类别样式的权重比较;</p><p><strong>层叠：</strong>是说当数量相同时，通过层叠(后者覆盖前者)的样式。</p><h2 id="css选择符分类"><a href="#css选择符分类" class="headerlink" title="css选择符分类"></a>css选择符分类</h2><p>首先来看一下css选择符(css选择器)有哪些?</p><p>　　1.标签选择器(如：body,div,p,ul,li)</p><p>　　2.类选择器(如：class=”head”,class=”head_logo”)</p><p>　　3.ID选择器(如：id=”name”,id=”name_txt”)</p><p>　　4.全局选择器(如：*号)</p><p>　　5.组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</p><p>　　6.后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</p><p>　　7.群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</p><p>　　8.继承选择器(如：div p,注意两选择器用空格键分开)</p><p>　　9.伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</p><p>　　10.字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</p><p>　　11.子选择器 (如：div&gt;p ,带大于号&gt;)</p><p>　　12.CSS 相邻兄弟选择器器 (如：h1+p,带加号+)</p><h2 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h2><p>当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义。</p><p><strong>不同级别</strong></p><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式</p></li><li><p>id选择器</p></li><li><p>类选择器</p></li><li><p>标签选择器</p></li><li><p>通配符选择器</p></li><li><p>浏览器自定义或继承</p><p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p></li></ol><p><strong>同一级别</strong></p><p>同一级别中后写的会覆盖先写的样式</p><p>上面的级别还是很容易看懂的，但是有时候有些规则是多个级别的组合，像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        div.test&#123;</span><br><span class="line">            background-COLOR:#a00;</span><br><span class="line">            width:100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .test.test2&#123;</span><br><span class="line">            background-COLOR:#0e0;</span><br><span class="line">            width:100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;test test2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>到底div是应用那条规则呢，有个简单的计算方法（经园友提示，权值实际并不是按十进制，用数字表示只是说明思想，一万个class也不如一个id权值高）</p><ul><li><p>内联样式表的权值为 1000</p></li><li><p>ID 选择器的权值为 100</p></li><li><p>Class 类选择器的权值为 10</p></li><li><p>HTML 标签选择器的权值为 1</p><p>我们可以把选择器中规则对应做加法，比较权值，如果权值相同那就后面的覆盖前面的了，div.class的权值是1+10=11，而.test1 .test2的权值是10+10=20，所以div会应用.test1 .test2变成绿色</p><p><img data-src="https://images2015.cnblogs.com/blog/625717/201612/625717-20161223085747964-420267465.png" alt="img"></p></li></ul><h2 id="另外一种理解方式："><a href="#另外一种理解方式：" class="headerlink" title="另外一种理解方式："></a>另外一种理解方式：</h2><p>　　CSS优先级：是由四个级别和各级别的出现次数决定的。</p><p>　　四个级别分别为：行内选择符、ID选择符、类别选择符、元素选择符。</p><p>　　优先级的算法：</p><p>　　每个规则对应一个初始”四位数”：0、0、0、0</p><p>　　若是 行内选择符，则加1、0、0、0</p><p>　　若是 ID选择符，则加0、1、0、0</p><p>　　若是 类选择符/属性选择符/伪类选择符，则分别加0、0、1、0</p><p>　　若是 元素选择符/伪元素选择符，则分别加0、0、0、1</p><p>　　算法：将每条规则中，选择符对应的数相加后得到的”四位数“，从左到右进行比较，大的优先级越高。　　</p><h2 id="需注意的："><a href="#需注意的：" class="headerlink" title="需注意的："></a>需注意的：</h2><p>　　①、!important的优先级是最高的，但出现冲突时则需比较”四位数“;</p><p>　　②、优先级相同时，则采用就近原则，选择最后出现的样式;</p><p>　　③、继承得来的属性，其优先级最低;</p><p>　　!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><p>　　*css选择器使用强烈建议采用低权重原则，利于充分发挥css的继承性，复用性，模块化、组件化。</p><h2 id="CSS选择器的解析原则"><a href="#CSS选择器的解析原则" class="headerlink" title="CSS选择器的解析原则"></a><strong>CSS选择器的解析原则</strong></h2><p>​     以前一直认为选择器的定位DOM元素是从左向右的方向，查看了网上的相关资料之后才发现原来自己一直都是错的。郑重的声明选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。<a href="http://blog.csdn.net/jinboker/article/details/52126021">为什么CSS选择器是从右往左解析 ？？？</a></p><h2 id="简洁、高效的css"><a href="#简洁、高效的css" class="headerlink" title="简洁、高效的css"></a><strong>简洁、高效的css</strong></h2><p>​    所谓高效就是让浏览器查找更少的元素标签来确定匹配的style元素。</p><p>   1.不要再ID选择器前使用标签名</p><p>​    解释：ID选择是唯一的，加上标签名相当于画蛇添足了，没必要。</p><p>   2.不要在类选择器前使用标签名</p><p>   解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆如（p.colclass{color：red;} 和 span.colclass{color:red;}</p><p>   3.尽量少使用层级关系；</p><p>​     #divclass p.colclass{color:red;}改为  .colclass{color:red;}</p><p>   4.使用类选择器代替层级关系（如上）</p><h1 id="3-BFC-原理"><a href="#3-BFC-原理" class="headerlink" title="3. BFC 原理"></a>3. BFC 原理</h1><h2 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><h2 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>**</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h2 id="三、触发-BFC"><a href="#三、触发-BFC" class="headerlink" title="三、触发 BFC"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h2 id="四、BFC-特性及应用"><a href="#四、BFC-特性及应用" class="headerlink" title="四、BFC 特性及应用"></a>四、BFC 特性及应用</h2><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.container &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，两个盒子边距就变成了 200px</p><p><img data-src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img data-src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img data-src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p><h1 id="4-position"><a href="#4-position" class="headerlink" title="4. position"></a>4. position</h1><h2 id="1-static"><a href="#1-static" class="headerlink" title="1. static"></a>1. static</h2><p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .static &#123;</span><br><span class="line">                position: static;</span><br><span class="line">                top: 10px;</span><br><span class="line">                left: 10px;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;static&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>金黄色方块会在左上角显示，没有偏移。</p><h2 id="2-fixed"><a href="#2-fixed" class="headerlink" title="2. fixed"></a>2. fixed</h2><p>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p><p>这个比较好理解，只和窗口有关，与父元素，文档流都无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed-outer &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                top: 20px;</span><br><span class="line">                left: 20px;</span><br><span class="line">                width: 20px;</span><br><span class="line">                height: 20px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed-inner &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                top: 40px;</span><br><span class="line">                left: 40px;</span><br><span class="line">                width: 20px;</span><br><span class="line">                height: 20px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body  bgcolor&#x3D;&quot;#999&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;fixed-outer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;fixed-inner&quot;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301141019698-644310256.png" alt="img"></p><p>left就是左边界距离视窗左边距的位置，right就是右边界距离视窗右边距的位置，top，bottom同理。top和bottom或者left和right同时存在，只有top或者left生效。</p><p>小广告效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                right: 0px;</span><br><span class="line">                bottom: 50px;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;fixed&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="3-relative"><a href="#3-relative" class="headerlink" title="3. relative"></a>3. relative</h2><p>生成相对定位的元素，相对于其正常位置进行定位。</p><p>相对元素正常应该在的位置移动，元素所占的空间位置不变，但是显示的位置发生偏移。</p><p>left是向右偏移，right是向左偏移（这么说好奇怪，但是…应该没错吧……），top向下偏移，bottom向上偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .div &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .relative1 &#123;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 10px;</span><br><span class="line">                top: 10px;</span><br><span class="line">                border-color: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .relative2 &#123;</span><br><span class="line">                position: relative;</span><br><span class="line">                right: 10px;</span><br><span class="line">                bottom: 10px;</span><br><span class="line">                border-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div relative1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div relative2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301145327838-51205356.png" alt="img"></p><h2 id="4-absolute"><a href="#4-absolute" class="headerlink" title="4. absolute"></a>4. absolute</h2><p>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。(如果没有这样的父元素呢？emmm……应该是整个文档最外层的框……吧……</p><p>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p><p>absolute元素会附带 display:block 效果，同时，设置absolute后，元素会脱离文档流。</p><p>\1. 如果不设置”left”, “top”, “right” 以及 “bottom”，会显示在正常应该显示的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .relative &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 100px;</span><br><span class="line">                top: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 1px solid red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;relative&quot;&gt;</span><br><span class="line">            outer</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301160725057-1706791347.png" alt="img"></p><p>\2. 设置了偏移……（一下父元素全部指 static 定位以外的第一个父元素</p><p>设置了left 将以父元素的左边界为基准 向右偏移 垂直方向和之前相同。</p><p>设置了right 将以父元素的右边界为基准 向左偏移 垂直方向和之前相同。</p><p>设置了top 将以父元素的上边界为基准 向下偏移 水平方向和之前相同。</p><p>设置了bottom 将以父元素的下边界为基准 向上偏移 水平方向和之前相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .relative &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 100px;</span><br><span class="line">                top: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute1, .absolute2, .absolute3, .absolute4, .absolute5 &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 2px solid red;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute2 &#123;</span><br><span class="line">                left: 60px;</span><br><span class="line">                border-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute3 &#123;</span><br><span class="line">                right: 10px;</span><br><span class="line">                border-color: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute4 &#123;</span><br><span class="line">                top: 0;</span><br><span class="line">                border-color: pink;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute5 &#123;</span><br><span class="line">                bottom: 10px;</span><br><span class="line">                border-color: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;relative&quot;&gt;</span><br><span class="line">            outer</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute4&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute5&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301162703536-1368636423.png" alt="img"></p><h2 id="5-others"><a href="#5-others" class="headerlink" title="5. others"></a>5. others</h2><p>inherit：继承父元素的值。</p><p>initial： 初始值，即默认值，static。</p><p>unset： 非继承属性，相当于initial，static。</p><h2 id="6-navigation-bar"><a href="#6-navigation-bar" class="headerlink" title="6. navigation bar"></a>6. navigation bar</h2><p>效果见右下角</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .right-nav * &#123;</span><br><span class="line">                margin: 0;</span><br><span class="line">                padding: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                right: 10px;</span><br><span class="line">                bottom: 150px;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li &#123;</span><br><span class="line">                list-style-type: none !important;</span><br><span class="line">                position: relative;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li a &#123;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">                display: block;</span><br><span class="line">                width: 150px;</span><br><span class="line">                line-height: 30px;</span><br><span class="line">                text-align: center;</span><br><span class="line">                background: #666;</span><br><span class="line">                border-bottom: 1px solid;</span><br><span class="line">                color: #fff;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li a:hover, .right-nav li a:active  &#123;</span><br><span class="line">                background: #ccc;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav .summary &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                right: 150px;</span><br><span class="line">                top: 0px;</span><br><span class="line">                line-height: 30px;</span><br><span class="line">                height: 30px;</span><br><span class="line">                width: 400px;</span><br><span class="line">                background: #ccc;</span><br><span class="line">                color: #fff;</span><br><span class="line">                text-align: center;</span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li:hover .summary &#123;</span><br><span class="line">                display: block;</span><br><span class="line">                font-size: 12px;</span><br><span class="line">                border-right: 1px solid #fff;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right-nav&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#static&quot;&gt;1. static&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;默认值。没有定位，元素出现在正常的流中。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#fixed&quot;&gt;2. fixed&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成绝对定位的元素，相对于浏览器窗口进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#relative&quot;&gt;3. relative&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成相对定位的元素，相对于其正常位置进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#absolute&quot;&gt;4. absolute&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#others&quot;&gt;5. others&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;inherit &amp; initial &amp; unset&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#navigation-bar&quot;&gt;6. navigation bar&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;根据定位写一个导航栏。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h1 id="5-flex-布局"><a href="#5-flex-布局" class="headerlink" title="5.flex 布局"></a>5.flex 布局</h1><p>网页布局（layout）是 CSS 的一个重点应用。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="img"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">      <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h1 id="6-css样式优先级"><a href="#6-css样式优先级" class="headerlink" title="6.css样式优先级"></a>6.css样式优先级</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>权重决定了你css规则怎样被浏览器解析直到生效。“css权重关系到你的css规则是怎样显示的”。</li><li>当很多的样式被应用到某一个元素上时，权重是一个决定哪种样式生效，或者是优先级的过程。</li><li>每个选择器都有自己的权重。你的每条css规则，都包含一个权重级别。 这个级别是由不同的选择器加权计算的，通过权重，不同的样式最终会作用到你的网页中 。</li><li>如果两个选择器同时作用到一个元素上，权重高者生效。</li></ol><h2 id="权重记忆口诀："><a href="#权重记忆口诀：" class="headerlink" title="权重记忆口诀："></a><strong>权重记忆口诀</strong>：</h2><p><em>从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。</em></p><p><img data-src="https://pic3.zhimg.com/80/v2-b1a9fedf320754acb1d7766c6548d5f6_720w.jpg" alt="img">css权重值记忆图</p><p>接下来增加一下记忆，下面是我瞎写的一个样式，只看选择器那里就可以了，具体样式请忽略，我分别用了id选择器、class选择器和标签选择器各一次。</p><p><img data-src="https://pic3.zhimg.com/80/v2-f27a0588280e867a3bc3ed17c7643cf6_720w.jpg" alt="img"></p><h2 id="样式重复多写情况"><a href="#样式重复多写情况" class="headerlink" title="样式重复多写情况"></a><strong>样式重复多写情况</strong></h2><p>在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的，在开发中基本不会使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这条生效 */</span></span><br><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的权重，权重值高则生效"><a href="#不同的权重，权重值高则生效" class="headerlink" title="不同的权重，权重值高则生效"></a><strong>不同的权重，权重值高则生效</strong></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>权重高的样式生效<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 权重值：1 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="comment">/* 权重值：10 */</span></span></span><br><span class="line">.box2&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="comment">/* 权重值：100 */</span></span></span><br><span class="line">#box&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: green;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-4428f2f2ad22f0541b5c49ec42f261c4_720w.jpg" alt="img">id的权重高，所以id选择器中的样式生效</p><p>从上面的例子不难看出，id选择器的权重值高于其它2种选择器的权重值，所以id选择器中的样式生效了。</p><h2 id="important-提升样式优先级"><a href="#important-提升样式优先级" class="headerlink" title="!important(提升样式优先级)"></a><strong>!important(提升样式优先级)</strong></h2><p>!important的作用是提升样式优先级，如果加了这句的样式的优先级是最高的。不过我这里*<strong>建议大家一下，!important最好不要使用。*</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: blue <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#box</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot; style=&quot;background-color: red;width: 100px;height: 100px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-dffaab8e727068ed415d2e93f11cab30_720w.jpg" alt="img">!important 优先级是最高的，不建议使用</p><h2 id="两种样式都使用-important时"><a href="#两种样式都使用-important时" class="headerlink" title="两种样式都使用!important时"></a><strong>两种样式都使用!important时</strong></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>当两个样式都使用!important时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.box&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red <span class="meta">!important</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: green <span class="meta">!important</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当两个样式都使用!important时，权重值大的优先级更高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-78a61330c654eb406693bcbea09fc728_720w.jpg" alt="img">当两个样式都使用!important时，权重值大的优先级更高</p><h2 id="important应用于简写样式"><a href="#important应用于简写样式" class="headerlink" title="!important应用于简写样式"></a><strong>!important应用于简写样式</strong></h2><p>如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被作用上!important。</p><p>例如：<em>background: blue !important;</em></p><p><img data-src="https://pic1.zhimg.com/80/v2-7d88d39b30972d1b20ef5ba2e96d46d4_720w.jpg" alt="img">简单写的样式如果使用!important，子属性也会默认加上important</p><p>上述结果可以看出，background的子属性都加上了!important，到这里，我提醒一下开发者们，这种复合性样式不建议大量使用，如果里面的属性大多数是可以用到的，还是可以写复合性样式的。我经常看到一些开发都，给某一元素加上颜色，经常性的写成这样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: red;</span><br></pre></td></tr></table></figure><p>这个样式从表面来说，和background-color:red;一样可以实现效果。</p><p>这时你可以通过浏览器的调试工具来查看它具体的样式：</p><p><img data-src="https://pic3.zhimg.com/80/v2-891cb936a5d21fd220732e8d01908bb6_720w.jpg" alt="img">goolge下的效果图</p><p>使用复合写法的时候，它不光只加载了背景颜色样式，还加载了其它一些样式。可想而知，如果一个项目的前台全部都采用复合写法的方式，第设置一个background样式时background相关的样式都会被加载进去，这样性能一定非常差，这也是一种不合理的设计方 案，而单例写法却看不到这种情况。 </p><p><strong>行内、内联和外联样式优先级</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>css优先级<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">        &#125;</span><br><span class="line">        #box&#123;</span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 行内样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red;width: 100px;height: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-ca7b3c40edc41399cf0224c91137551b_720w.jpg" alt="img">效果图</p><p>根据权重值来计算，行内样式的权重值最大，所以行内样式生效了。</p><p><strong>内联和外联样式优先级</strong></p><p>这里我曾经一直以为内联样式的优先级一定大于外联样式的，直到最近的几天我才发现我一直都学错了，所以这里也是给大家提个醒，希望自己也牢记这个教训。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* styles.css */</span></span><br><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>1.外联样式写前面，内联样式写后面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>内联和外联样式的优先级问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#div&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-5558422e14755b5dc2ce0eb0f2ae6ec7_720w.jpg" alt="img">内联样式生效</p><p>2.内联样式写前面，外联样式写后面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>内联和外联样式的优先级问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#div&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-3350f183180f050442665e45f69971cb_720w.jpg" alt="img">外联样式生效</p><p>上面的例子足以说明内联样式的优先级并不一定比外联样式高，因为css样式是单线程，依次从上向下加载的，这也就证明了*<strong>内联样式和外联样式的优先级和加载顺序有关*</strong>。</p><p>总结一下：**<em>!important &gt; 行内样式 &gt; 内联样式 and 外联样式**</em></p><p><img data-src="https://pic1.zhimg.com/80/v2-bb8fc596d248f2c30bae77b565fded84_720w.jpg" alt="img">样式优先级</p><p><strong>样式应用于非目标标签时</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>样式应用于非目标标签时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red&#125;;</span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: blue&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 选中非目标元素的情况下，离目标越近者优先 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>神来之笔<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-a2eed077c5ad66f7de820538fb585217_720w.jpg" alt="img">效果图</p><p><strong>权重相等的情况下</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>权重相等的情况下<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 权重值：201 */</span></span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span> <span class="selector-id">#box2</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/* 权重值：201,离目标最近 */</span></span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span> <span class="selector-id">#box3</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同等权重下,靠近目标的优先 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs3&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-e5bed8244d8296206d76cec0f825dacf_720w.jpg" alt="img">同等权重下,靠近目标的优先</p><p><strong>总结</strong></p><ol><li>常用选择器权重优先级：*<strong>!important &gt; id &gt; class &gt; tag*</strong></li><li>!important可以提升样式优先级，但不建议使用。如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：<em>background: blue !important;</em></li><li>如果两条样式都使用!important，则权重值高的优先级更高</li><li>在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的</li><li>样式指向同一元素，权重规则生效，权重大的被应用</li><li>样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用</li><li>样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用</li></ol><h1 id="7-圣杯布局和双飞翼布局"><a href="#7-圣杯布局和双飞翼布局" class="headerlink" title="7.圣杯布局和双飞翼布局"></a>7.圣杯布局和双飞翼布局</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/11/16a0c9554c172710?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="字面意思"><a href="#字面意思" class="headerlink" title="字面意思"></a>字面意思</h2><p>圣杯布局和双飞翼布局从字面意思来看是这样的：</p><blockquote><p>一个像圣杯或者像展翅的禽类这样的布局</p></blockquote><p><strong>通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。</strong></p><h3 id="两者本质"><a href="#两者本质" class="headerlink" title="两者本质"></a>两者本质</h3><p><img data-src="https://user-gold-cdn.xitu.io/2019/9/5/16cfefeb90d9ec0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><ol><li>首先把left、middle、right都放出来</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;</li></ol><p><strong>接下来比较重要了：</strong></p><ol><li>给left、middle、right设置position: relative;</li><li>left设置 left: -leftWidth, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ol><hr><p>我注意到圣杯布局的left、middle、right都有position: relative;</p><p>设:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.left width:200px</span><br><span class="line">.right width:220px</span><br></pre></td></tr></table></figure><p>那么下面的这些属性为什么要存在？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container上面的paddind</span><br><span class="line">.left 的left: -200px;</span><br><span class="line">.right 的right: -220px;</span><br></pre></td></tr></table></figure><p><strong>因为不这样设置  会遮挡middle的内容</strong></p><p>可以自己尝试一下下</p><hr><p>圣杯布局示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;圣杯布局&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .header,</span><br><span class="line">    .footer &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      font-weight: bolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .footer &#123;</span><br><span class="line">      background-color: goldenrod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">      padding: 0 220px 0 200px;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .middle,</span><br><span class="line">    .right &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      float: left;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      left: -200px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-left: -220px;</span><br><span class="line">      right: -220px;</span><br><span class="line">      width: 220px;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .middle &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;middle&quot;&gt;</span><br><span class="line">      &lt;h4&gt;middle&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddle</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">      &lt;h4&gt;left&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">      &lt;h4&gt;right&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightright</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;footer&quot;&gt;footer&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。</p><p>这样可以先做好主体部分，然后再将附属部分放到合适的位置！</p><ol><li>首先把left、middle、right都放出来, middle中增加inner</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;</li></ol><p><strong>接下来与圣杯布局不一样的地方：</strong></p><ol><li>left设置 margin-left: -100%, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;双飞翼布局&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .header,</span><br><span class="line">    .footer &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      font-weight: bolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .footer &#123;</span><br><span class="line">      background-color: goldenrod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .middle,</span><br><span class="line">    .right &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-left: -220px;</span><br><span class="line">      width: 220px;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .middle &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .inner &#123;</span><br><span class="line">      margin: 0 220px 0 200px;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      background: blue;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;middle&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;inner&quot;&gt;</span><br><span class="line">        &lt;h4&gt;middle&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddle</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">      &lt;h4&gt;left&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">      &lt;h4&gt;right&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightright</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;footer&quot;&gt;footer&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>圣杯布局在DOM结构上显得更加直观和自然；</p><p>双飞翼布局省去了很多css，而且由于不用使用定位，可以获得比圣杯布局更小最小宽度；</p><p>说到这里需要注意一下  由于双飞翼布局会一直随着浏览器可视区域宽度减小从而不断挤压中间部分宽度。</p><p>所以需要设置给页面一个min-width &gt; LeftWidth + RightWidth；</p><hr><p>还有一件事就是他们在单独部分内容扩充的时候，童鞋们可能发现了 底部会参差不齐。</p><p>在我的老师那里知道了最简单的解决办法 / 笑哭</p><blockquote><p>给left、middle、right设置上 padding-bottom: 9999px; margin-bottom: -9999px;</p></blockquote><p>就让他变得无限高，但是又给他送回去了。真的是让我脑洞大开！！！</p><h1 id="8-CSS3新特性"><a href="#8-CSS3新特性" class="headerlink" title="8.CSS3新特性"></a>8.CSS3新特性</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>css3这个相信大家不陌生了，是个非常有趣，神奇的东西！有了css3，js都可以少写很多！我之前也写过关于css3的文章，也封装过css3的一些小动画。个人觉得css3不难，但是很难用得好，用得顺手，最近我也在过一遍css3的一些新特性（不是全部，是我在工作上常用的，或者觉得有用的），以及一些实例，就写了这一篇总结！希望，这篇文章能帮到大家认识css3。写这篇文章主要是让大家能了解css3的一些新特性，以及基础的用法，感觉css3的魅力！如果想要用好css3，这个得靠大家继续努力学习，寻找一些讲得更深入的文章或者书籍了！如果大家有什么其他特性推荐的，欢迎补充！大家一起学习，进步！</p><blockquote><p>看这篇文章，代码可以不用看得过于仔细！这里主要是想让大家了解css3的新特性！代码也是很基础的用法。我给出代码主要是让大家在浏览器运行一下，让大家参考和调试。不要只看代码，只看代码的话，不会知道哪个代码有什么作用的，建议边看效果边看代码。</p></blockquote><h2 id="2-过渡"><a href="#2-过渡" class="headerlink" title="2.过渡"></a>2.过渡</h2><p>过渡，是我在项目里面用得最多的一个特性了！也相信是很多人用得最多的一个例子！我平常使用就是想让一些交互效果（主要是hover动画），变得生动一些，不会显得那么生硬！好了，下面进入正文！</p><p>引用菜鸟教程的说法：CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容：指定要添加效果的CSS属性指定效果的持续时间。</p><h3 id="2-1语法"><a href="#2-1语法" class="headerlink" title="2-1语法"></a>2-1语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*&#x2F;</span><br><span class="line">transition：width,.5s,ease,.2s</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*&#x2F;</span><br><span class="line">transition：all,.5s</span><br></pre></td></tr></table></figure><p>上面例子是简写模式，也可以分开写各个属性（这个在下面就不再重复了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br></pre></td></tr></table></figure><h3 id="2-2实例-hover效果"><a href="#2-2实例-hover效果" class="headerlink" title="2-2实例-hover效果"></a>2-2实例-hover效果</h3><p><img data-src="https://segmentfault.com/img/bVTbJs?w=467&h=139" alt="clipboard.png"></p><p>上面两个按钮，第一个使用了过渡，第二个没有使用过渡，大家可以看到当中的区别，用了过渡之后是不是没有那么生硬，有一个变化的过程，显得比较生动。<br>当然这只是一个最简单的过渡例子，两个按钮的样式代码，唯一的区别就是，第一个按钮加了过渡代码<code>transition: all .5s;</code></p><h3 id="2-3实例-下拉菜单"><a href="#2-3实例-下拉菜单" class="headerlink" title="2-3实例-下拉菜单"></a>2-3实例-下拉菜单</h3><p><img data-src="https://segmentfault.com/img/bVTbLy?w=592&h=570" alt="clipboard.png"></p><p>上面两个菜单，第一个没有使用过渡，第二个使用过渡，大家明显看到区别，使用了过渡看起来也是比较舒服！代码区别就是有过渡的ul的上级元素(祖先元素)有一个类名（ul-transition）。利用这个类名，设置ul的过渡<code>.ul-transition ul&#123;transform-origin: 0 0;transition: all .5s;&#125;</code></p><p>可能大家不知道我在说什么！我贴下代码吧</p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;demo-hover demo-ul t_c&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;fllil&quot;&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;html&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;div&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;h1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;js&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;string&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;array&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;object&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;number&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;css3&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;transition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;animation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;框架&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;vue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;react&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;demo-hover demo-ul ul-transition t_c&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;fllil&quot;&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;html&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;div&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;h1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;js&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;string&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;array&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;object&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;number&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;css3&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;transition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;animation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;框架&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;vue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;react&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.demo-ul&#123;margin-bottom: 300px;&#125;</span><br><span class="line">    .demo-ul li&#123;</span><br><span class="line">        padding: 0 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: #f90;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li a&#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 40px;</span><br><span class="line">        line-height: 40px;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li ul&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100%;</span><br><span class="line">        top: 40px;</span><br><span class="line">        left: 0;</span><br><span class="line">        transform: scaleY(0);</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .ul-transition ul&#123;</span><br><span class="line">        transform-origin: 0 0;</span><br><span class="line">        transition: all .5s;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li:hover ul&#123;</span><br><span class="line">        transform: scaleY(1);</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li ul li&#123;</span><br><span class="line">        float: none;</span><br><span class="line">        background: #0099ff;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个可以说是过渡很基础的用法，过渡用法灵活，功能也强大，结合js，可以很轻松实现各种效果（焦点图，手风琴）等，以及很多意想不到的效果。这个靠大家要去挖掘！</p><h2 id="3-动画"><a href="#3-动画" class="headerlink" title="3.动画"></a>3.动画</h2><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬！</p><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3-1.语法"></a>3-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear;</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear 2s;</span><br></pre></td></tr></table></figure><p>例子3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*无限执行logo2-line动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear alternate infinite;</span><br></pre></td></tr></table></figure><p>还有一个重要属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animation-fill-mode : none | forwards | backwards | both;</span><br><span class="line">&#x2F;*none：不改变默认行为。    </span><br><span class="line">forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。    </span><br><span class="line">backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 </span><br><span class="line">both：向前和向后填充模式都被应用。  *&#x2F;      </span><br></pre></td></tr></table></figure><h3 id="3-2-logo展示动画"><a href="#3-2-logo展示动画" class="headerlink" title="3-2.logo展示动画"></a>3-2.logo展示动画</h3><p><img data-src="https://segmentfault.com/img/bVTdn3?w=776&h=220" alt="clipboard.png"></p><p>这个是我用公司logo写的动画，没那么精细</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;reset.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.logo-box&#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    font-size: 0;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box div&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo-text&#123;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo1&#123;</span><br><span class="line">    animation: logo1 1s ease-in 2s;</span><br><span class="line">    animation-fill-mode:backwards;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo-text&#123;</span><br><span class="line">    animation: logoText 1s ease-in 3s;</span><br><span class="line">    animation-fill-mode:backwards;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo2&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20px;</span><br><span class="line">    left: 20px;</span><br><span class="line">    animation: logo2-middle 2s ease-in;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo2 img&#123;</span><br><span class="line">    animation: logo2-line 2s linear;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logo1 &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform:rotate(180deg);</span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform:rotate(0deg);</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logoText &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform:translateX(30px);</span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform:translateX(0);</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logo2-line &#123;</span><br><span class="line">    0% &#123; transform: translateX(200px)&#125;</span><br><span class="line">    25% &#123; transform: translateX(150px)&#125;</span><br><span class="line">    50% &#123; transform: translateX(100px)&#125;</span><br><span class="line">    75% &#123; transform: translateX(50px)&#125;</span><br><span class="line">    100% &#123; transform: translateX(0); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes logo2-middle &#123;</span><br><span class="line">    0% &#123; transform: translateY(0);     &#125;</span><br><span class="line">    25% &#123; transform: translateY(-100px);     &#125;</span><br><span class="line">    50% &#123; transform: translateY(0);     &#125;</span><br><span class="line">    75% &#123; transform: translateY(-50px);     &#125;</span><br><span class="line">    100% &#123; transform: translateY(0); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo-box&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo1&quot;&gt;&lt;img src&#x3D;&quot;logo1.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo2&quot;&gt;&lt;img src&#x3D;&quot;logo2.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo-text&quot;&gt;&lt;img src&#x3D;&quot;logo3.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;wraper&quot;&gt;&lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>下面让大家看一个专业级别的</p><p><img data-src="https://segmentfault.com/img/bVTdpk?w=734&h=214" alt="clipboard.png"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        font-family: Arial,&quot;Helvetica Neue&quot;,Helvetica,sans-serif;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background: #fff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .center &#123;</span><br><span class="line">        margin: 80px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .so &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line">        background: #ffffff;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner * &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        animation-iteration-count: infinite;</span><br><span class="line">        animation-duration: 3.5s;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .name &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        font-size: 54px;</span><br><span class="line">        left: 130px;</span><br><span class="line">        top: 95px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .name .b &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack-box &#123;</span><br><span class="line">        top: 100px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box &#123;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">        left: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box div &#123;</span><br><span class="line">        background: #BCBBBB;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .bottom &#123;</span><br><span class="line">        bottom: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .left &#123;</span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .right &#123;</span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 103px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .top &#123;</span><br><span class="line">        top: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack &#123;</span><br><span class="line">        left: 22px;</span><br><span class="line">        top: 22px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .inner-item &#123;</span><br><span class="line">        background: #F48024;</span><br><span class="line">        width: 71px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item &#123;</span><br><span class="line">        transition: transform 0.3s;</span><br><span class="line">        width: 291px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(1) &#123;</span><br><span class="line">        transform: rotate(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(2) &#123;</span><br><span class="line">        transform: rotate(12deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(3) &#123;</span><br><span class="line">        transform: rotate(24deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(4) &#123;</span><br><span class="line">        transform: rotate(36deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(5) &#123;</span><br><span class="line">        transform: rotate(48deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box &#123;</span><br><span class="line">        animation-name: box;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .top &#123;</span><br><span class="line">        animation-name: box-top;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .left &#123;</span><br><span class="line">        animation-name: box-left;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .right &#123;</span><br><span class="line">        animation-name: box-right;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .bottom &#123;</span><br><span class="line">        animation-name: box-bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack-box &#123;</span><br><span class="line">        animation-name: stack-box;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack &#123;</span><br><span class="line">        animation-name: stack;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .inner-item &#123;</span><br><span class="line">        animation-name: stack-items;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(1) &#123;</span><br><span class="line">        animation-name: stack-item-1;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(2) &#123;</span><br><span class="line">        animation-name: stack-item-2;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(3) &#123;</span><br><span class="line">        animation-name: stack-item-3;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(4) &#123;</span><br><span class="line">        animation-name: stack-item-4;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(5) &#123;</span><br><span class="line">        animation-name: stack-item-5;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-1 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-2 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-3 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-4 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-5 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-items &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-top &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        6% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        59% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-bottom &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-right &#123;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-box &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        40% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        83% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;so center&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;inner&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;stack-box&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;stack&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;bottom&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;top&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;name&quot;&gt;</span><br><span class="line">            stack&lt;span class&#x3D;&quot;b&quot;&gt;overflow&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-loading效果"><a href="#3-3-loading效果" class="headerlink" title="3-3.loading效果"></a>3-3.loading效果</h3><p><img data-src="https://segmentfault.com/img/bVTdrH?w=1192&h=951" alt="clipboard.png"></p><p>这个代码实在太多了，大家直接上网址看吧。<a href="http://www.html5tricks.com/demo/css3-loading-cool-styles/index.html">css3-loading</a></p><h3 id="3-4-音乐震动条"><a href="#3-4-音乐震动条" class="headerlink" title="3-4.音乐震动条"></a>3-4.音乐震动条</h3><p><img data-src="https://segmentfault.com/img/bVTdsN?w=260&h=155" alt="clipboard.png"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;纯CSS3模拟跳动的音符效果&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;margin:0;padding:0;list-style: none;&#125;</span><br><span class="line">    body&#123;background-color: #efefef;&#125;</span><br><span class="line">    .demo-music &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 200px;</span><br><span class="line">      top: 120px;</span><br><span class="line">      zoom: 1.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music .music &#123;</span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      -webkit-transform: translate(-40px, -25px);</span><br><span class="line">      transform: translate(-40px, -25px);</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves &#123;</span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 12px;</span><br><span class="line">      left: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves li &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 12%;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      margin-right: 1px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves li span &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background: #09f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li1 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li2 span &#123;</span><br><span class="line">      animation: waves 0.9s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.9s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li3 span &#123;</span><br><span class="line">      animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li4 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li5 span &#123;</span><br><span class="line">      animation: waves 0.7s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.7s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li6 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line">    @-webkit-keyframes waves &#123;</span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes waves &#123;</span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;demo-music&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;music&quot;&gt;</span><br><span class="line">      &lt;ul id&#x3D;&quot;waves&quot; class&#x3D;&quot;movement&quot;&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li1&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li2&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li3&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li4&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li5&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li6&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;music-state&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-形状转换"><a href="#4-形状转换" class="headerlink" title="4.形状转换"></a>4.形状转换</h2><p>这一部分，分2d转换和3d转换。有什么好玩的，下面列举几个！</p><h3 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4-1.语法"></a>4-1.语法</h3><p>transform:适用于2D或3D转换的元素<br>transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)</p><h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4-2.实例"></a>4-2.实例</h3><p>transform:rotate(30deg);</p><p><img data-src="https://segmentfault.com/img/bVTdyC?w=284&h=218" alt="clipboard.png"></p><p>transform:translate(30px,30px);</p><p><img data-src="https://segmentfault.com/img/bVTdAC?w=501&h=450" alt="clipboard.png"></p><p>transform:scale(.8);</p><p><img data-src="https://segmentfault.com/img/bVTdAT?w=404&h=373" alt="clipboard.png"></p><p>transform: skew(10deg,10deg);</p><p><img data-src="https://segmentfault.com/img/bVTdBj?w=280&h=160" alt="clipboard.png"></p><p>transform:rotateX(180deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHv?w=142&h=97" alt="clipboard.png"></p><p>transform:rotateY(180deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHA?w=142&h=97" alt="clipboard.png"></p><p>transform:rotate3d(10,10,10,90deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHU?w=182&h=114" alt="clipboard.png"></p><h2 id="5-选择器"><a href="#5-选择器" class="headerlink" title="5.选择器"></a>5.选择器</h2><p>css3提供的选择器可以让我们的开发，更加方便！这个大家都要了解。下面是css3提供的选择器。</p><p><img data-src="https://segmentfault.com/img/bVTd2d?w=780&h=728" alt="clipboard.png"></p><p>图片来自w3c。这一块建议大家去w3c看（<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册</a>），那里的例子通俗易懂。我不重复讲了。<br>提供的选择器里面，基本都挺好用的。但是我觉得有些不会很常用，比如，<code>:root，:empty，:target，:enabled，:checked</code>。而且几个不推荐使用，网上的说法是性能较差<code>[attribute*=value]，[attribute$=value]，[attribute^=value]</code>，这个我没用过，不太清楚。</p><h2 id="6-阴影"><a href="#6-阴影" class="headerlink" title="6.阴影"></a>6.阴影</h2><p>以前没有css3的时候，或者需要兼容低版本浏览器的时候，阴影只能用图片实现，但是现在不需要，css3就提供了！</p><h3 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6-1.语法"></a>6-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;</span><br></pre></td></tr></table></figure><h3 id="6-1-例子"><a href="#6-1-例子" class="headerlink" title="6-1.例子"></a>6-1.例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:100px;</span><br><span class="line">    background:#09f;</span><br><span class="line">    box-shadow: 10px 10px 5px #888888;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTd9F?w=364&h=151" alt="clipboard.png"></p><h2 id="7-边框"><a href="#7-边框" class="headerlink" title="7.边框"></a>7.边框</h2><h3 id="7-1-边框图片"><a href="#7-1-边框图片" class="headerlink" title="7-1.边框图片"></a>7-1.边框图片</h3><h4 id="7-1-1-语法"><a href="#7-1-1-语法" class="headerlink" title="7-1-1.语法"></a>7-1-1.语法</h4><p>border-image: 图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;</p><h4 id="7-1-2-例子"><a href="#7-1-2-例子" class="headerlink" title="7-1-2.例子"></a>7-1-2.例子</h4><p>边框图片（来自菜鸟教程）</p><p><img data-src="https://segmentfault.com/img/bVTefk?w=81&h=81" alt="clipboard.png"></p><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.demo &#123;</span><br><span class="line">    border: 15px solid transparent;</span><br><span class="line">    padding: 15px;   </span><br><span class="line">    border-image: url(border.png);</span><br><span class="line">    border-image-slice: 30;</span><br><span class="line">    border-image-repeat: round;</span><br><span class="line">    border-image-outset: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img data-src="https://segmentfault.com/img/bVTeeg?w=601&h=91" alt="clipboard.png"></p><p>有趣变化</p><p><img data-src="https://segmentfault.com/img/bVTefm?w=617&h=444" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTefl?w=617&h=444" alt="clipboard.png"></p><p>那个更好看，大家看着办</p><h3 id="7-2-边框圆角"><a href="#7-2-边框圆角" class="headerlink" title="7-2.边框圆角"></a>7-2.边框圆角</h3><h4 id="7-2-1-语法"><a href="#7-2-1-语法" class="headerlink" title="7-2-1.语法"></a>7-2-1.语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-radius: n1,n2,n3,n4;</span><br><span class="line">border-radius: n1,n2,n3,n4&#x2F;n1,n2,n3,n4;</span><br><span class="line">&#x2F;*n1-n4四个值的顺序是：左上角，右上角，右下角，左下角。*&#x2F;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-例子"><a href="#7-2-2-例子" class="headerlink" title="7-2-2.例子"></a>7-2-2.例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:2px solid #a1a1a1;</span><br><span class="line">    padding:10px 40px; </span><br><span class="line">    background:#dddddd;</span><br><span class="line">    text-align:center;</span><br><span class="line">    width:300px;</span><br><span class="line">    border-radius:25px 0 25px 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;border-radius&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTegF?w=486&h=82" alt="clipboard.png"></p><h2 id="8-背景"><a href="#8-背景" class="headerlink" title="8.背景"></a>8.背景</h2><p>这一块主要讲css3提供背景的三个属性</p><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h3><p>制定背景绘制（显示）区域</p><p>默认情况（从边框开始绘制）</p><p><img data-src="https://segmentfault.com/img/bVTeqt?w=533&h=251" alt="clipboard.png"></p><p>从padding开始绘制（显示），不算border,，相当于把border那里的背景给裁剪掉！（background-clip: padding-box;）</p><p><img data-src="https://segmentfault.com/img/bVTeqv?w=533&h=255" alt="clipboard.png"></p><p>只在内容区绘制（显示），不算padding和border，相当于把padding和border那里的背景给裁剪掉！（background-clip: content-box;）</p><p><img data-src="https://segmentfault.com/img/bVTeqy?w=537&h=244" alt="clipboard.png"></p><h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h3><p>引用菜鸟教程的说法：background-Origin属性指定background-position属性应该是相对位置</p><p>下面的div初始的html和css代码都是一样的。如下<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:10px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background:url(&#39;logo.png&#39;) no-repeat,#ccc;</span><br><span class="line">    background-position:0px 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下，background-origin不同的三种情况</p><p><img data-src="https://segmentfault.com/img/bVZGAM?w=800&h=506" alt="图片描述"></p><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><p>这个相信很好理解，就是制定背景的大小<br>下面的div初始的html和css代码都是一样的。如下<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:1px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background:url(&#39;test.jpg&#39;) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgk7?w=1016&h=768" alt="clipboard.png"></p><h3 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h3><p>这个没什么，就是在一张图片，使用多张背景图片，代码如下！<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;两张图片的背景&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:1px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background-size: contain;</span><br><span class="line">    background:url(&#39;test.jpg&#39;) no-repeat left,url(logo.png) no-repeat right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTglS?w=999&h=199" alt="clipboard.png"></p><h2 id="9-反射"><a href="#9-反射" class="headerlink" title="9.反射"></a>9.反射</h2><p>这个也可以说是倒影，用起来也挺有趣的。</p><h3 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9-1.语法"></a>9-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</span><br></pre></td></tr></table></figure><h3 id="9-2-下倒影"><a href="#9-2-下倒影" class="headerlink" title="9-2.下倒影"></a>9-2.下倒影</h3><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.reflect-bottom-p &#123;</span><br><span class="line">    padding-bottom: 300px;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">.reflect-bottom &#123;</span><br><span class="line">    -webkit-box-reflect: below;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTeoE?w=518&h=669" alt="clipboard.png"></p><h3 id="9-2-右倒影（有偏移）"><a href="#9-2-右倒影（有偏移）" class="headerlink" title="9-2.右倒影（有偏移）"></a>9-2.右倒影（有偏移）</h3><p><img data-src="https://segmentfault.com/img/bVTeoU?w=994&h=351" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;右倒影同时有偏移&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-right-translate&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.reflect-right-translate &#123;</span><br><span class="line">    -webkit-box-reflect: right 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-下倒影（渐变）"><a href="#9-3-下倒影（渐变）" class="headerlink" title="9-3.下倒影（渐变）"></a>9-3.下倒影（渐变）</h3><p><img data-src="https://segmentfault.com/img/bVTepo?w=507&h=668" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影（渐变）&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom-mask&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reflect-bottom-mask &#123;</span><br><span class="line">    -webkit-box-reflect: below 0 linear-gradient(transparent, white);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-下倒影（图片遮罩）"><a href="#9-3-下倒影（图片遮罩）" class="headerlink" title="9-3.下倒影（图片遮罩）"></a>9-3.下倒影（图片遮罩）</h3><p>使用的图片</p><p><img data-src="https://segmentfault.com/img/bVTepE?w=200&h=200" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTepD?w=510&h=672" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影（png图片）&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom-img&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.reflect-bottom-img &#123;</span><br><span class="line">    -webkit-box-reflect: below 0 url(shou.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-文字"><a href="#10-文字" class="headerlink" title="10.文字"></a>10.文字</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>语法：<code>word-break: normal|break-all|keep-all;</code><br>例子和运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgo9?w=511&h=446" alt="clipboard.png"></p><p>语法：<code>word-wrap: normal|break-word;</code><br>例子和运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgpp?w=602&h=423" alt="clipboard.png"></p><blockquote><p>超出省略号这个，主要讲<code>text-overflow</code>这个属性，我直接讲实例的原因是<code>text-overflow</code>的三个写法，<code>clip|ellipsis|string</code>。<code>clip</code>这个方式处理不美观，不优雅。<code>string</code>只在火狐兼容。</p></blockquote><p><img data-src="https://segmentfault.com/img/bVTgpF?w=595&h=299" alt="clipboard.png"></p><h3 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h3><p>这个其实有三行代码，禁止换行，超出隐藏，超出省略号<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;This is some long text that will not fit in the box&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:200px; </span><br><span class="line">    border:1px solid #000000;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    white-space:nowrap; </span><br><span class="line">    text-overflow:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTgqd?w=292&h=42" alt="clipboard.png"></p><h3 id="多行超出省略号"><a href="#多行超出省略号" class="headerlink" title="多行超出省略号"></a>多行超出省略号</h3><p>超出省略号。这个对于大家来说，不难！但是以前如果是多行超出省略号，就只能用js模拟！现在css3提供了多行省略号的方法！遗憾就是这个暂时只支持webkit浏览器！</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;    </span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:400px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">    overflow : hidden;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果图</p><p><img data-src="https://segmentfault.com/img/bVTd6V?w=491&h=74" alt="clipboard.png"></p><p>这样发现边框贴着难看，要撑开一点，但是撑开上下边框不要使用padding!因为会出现下面这个效果。</p><p><img data-src="https://segmentfault.com/img/bVTd66?w=527&h=102" alt="clipboard.png"></p><p>正确姿势是这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:400px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">    overflow : hidden;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    padding:0 10px;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">    line-height:30px;</span><br><span class="line">    height:60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTd7k?w=478&h=104" alt="clipboard.png"></p><p>这样写，就算在不是webkit内核的浏览器，也可以优雅降级（高度=行高*行数（webkit-line-clamp））！</p><p><img data-src="https://segmentfault.com/img/bVTd7u?w=481&h=108" alt="clipboard.png"></p><h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>语法：text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。<br>例子：<code>text-shadow: 0 0 10px #f00;</code><br>效果</p><p><img data-src="https://segmentfault.com/img/bVTgnR?w=378&h=78" alt="clipboard.png"></p><h2 id="11-颜色"><a href="#11-颜色" class="headerlink" title="11.颜色"></a>11.颜色</h2><p>这个其实就是css3提供了新的颜色表示方法。</p><h3 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h3><p>一个是rgba（rgb为颜色值，a为透明度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: rgba(255,00,00,1);</span><br><span class="line">background: rgba(00,00,00,.5);</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgri?w=924&h=81" alt="clipboard.png"></p><h3 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h3><p>h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”<br>这个我姿势了解过，没用过，这里简单给一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: hsla( 112, 72%, 33%, 0.68);</span><br><span class="line">background-color: hsla( 49, 65%, 60%, 0.68);</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgqS?w=934&h=72" alt="clipboard.png"></p><h2 id="12-渐变"><a href="#12-渐变" class="headerlink" title="12.渐变"></a>12.渐变</h2><p>css3的渐变可以说是一大亮点，提供了线性渐变，径向渐变，圆锥渐变（w3c和菜鸟教程都没有提及，是我从一篇文章了解到，但是我自己在谷歌浏览器尝试，却是一个无效的写法！大家如果知道怎么用，请告知！感谢）<br>渐变这一部分，由于用法灵活，功能也强大，这个写起来很长，写一点又感觉没什么意思，我这里贴几个链接教程给大家，在文章我不多说了，毕竟我也是从那几个地方学的，他们写得也是比我好，比我详细！</p><p><a href="http://www.w3cplus.com/content/css3-gradient">CSS3 Gradient</a><br><a href="http://www.w3cplus.com/css3/new-css3-linear-gradient.html">再说CSS3渐变——线性渐变</a><br><a href="http://www.w3cplus.com/css3/new-css3-radial-gradient.html">再说CSS3渐变——径向渐变</a><br><a href="http://www.cnblogs.com/coco1s/p/7079529.html">神奇的 conic-gradient 圆锥渐变</a>（这篇就是看我看到圆锥渐变的文章）</p><h2 id="13-Filter（滤镜）"><a href="#13-Filter（滤镜）" class="headerlink" title="13.Filter（滤镜）"></a>13.Filter（滤镜）</h2><p>css3的滤镜也是一个亮点，功能强大，写法也灵活。</p><p>例子代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; &#x2F;&gt;</span><br><span class="line">&lt;p&gt;黑白色filter: grayscale(100%)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter: grayscale(100%);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;褐色filter:sepia(1)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:sepia(1);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;饱和度saturate(2)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:saturate(2);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;色相旋转hue-rotate(90deg)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:hue-rotate(90deg);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;反色filter:invert(1)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:invert(1);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;透明度opacity(.5)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:opacity(.5);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;亮度brightness(.5)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:brightness(.5);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;对比度contrast(2)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:contrast(2);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;模糊blur(3px)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:blur(3px);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;阴影drop-shadow(5px 5px 5px #000)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:drop-shadow(5px 5px 5px #000);&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgyB?w=504&h=357" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzW?w=528&h=716" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzY?w=511&h=728" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzZ?w=511&h=721" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgz0?w=513&h=723" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgPQ?w=519&h=715" alt="clipboard.png"></p><h2 id="14-弹性布局"><a href="#14-弹性布局" class="headerlink" title="14.弹性布局"></a>14.弹性布局</h2><p>这里说的弹性布局，就是flex；这一块要讲的话，必须要全部讲完，不讲完没什么意思，反而会把大家搞蒙！讲完也是很长，所以，这里我也只贴教程网址。博客讲的很好，很详细！</p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程：实例篇</a></p><h2 id="15-栅格布局"><a href="#15-栅格布局" class="headerlink" title="15.栅格布局"></a>15.栅格布局</h2><p>栅格化布局，就是grid；这一块和flex一样，要讲就必须讲完。这块的内容和flex差不多，也有点长，这里我也贴链接，这个链接讲得也很详细！</p><p><a href="http://www.jianshu.com/p/d183265a8dad">Grid布局指南</a></p><h2 id="16-多列布局"><a href="#16-多列布局" class="headerlink" title="16.多列布局"></a>16.多列布局</h2><p>这一块，我也是了解过，我觉得多列应该还是挺有用的。虽然我没在项目中用过，下面我简单说下！举个例子！这个属性，建议加私有前缀，兼容性有待提高！<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;newspaper&quot;&gt;</span><br><span class="line">当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.newspaper</span><br><span class="line">&#123;</span><br><span class="line">    column-count: 3;</span><br><span class="line">    -webkit-column-count: 3;</span><br><span class="line">    -moz-column-count: 3;</span><br><span class="line">    column-rule:2px solid #000;</span><br><span class="line">    -webkit-column-rule:2px solid #000;</span><br><span class="line">    -mox-column-rule:2px solid #000;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgRx?w=587&h=163" alt="clipboard.png"></p><h2 id="17-盒模型定义"><a href="#17-盒模型定义" class="headerlink" title="17.盒模型定义"></a>17.盒模型定义</h2><p>box-sizing这个属性，网上说法是：属性允许您以特定的方式定义匹配某个区域的特定元素。</p><p>这个大家看着可能不知道在说什么，简单粗暴的理解就是：box-sizing:border-box的时候，边框和padding包含在元素的宽高之内！如下图</p><p><img data-src="https://segmentfault.com/img/bVZDJZ?w=1040&h=797" alt="图片描述"></p><p>box-sizing:content-box的时候，边框和padding不包含在元素的宽高之内！如下图</p><p><img data-src="https://segmentfault.com/img/bVZDJ5?w=950&h=876" alt="图片描述"></p><h2 id="18-媒体查询"><a href="#18-媒体查询" class="headerlink" title="18.媒体查询"></a>18.媒体查询</h2><p>媒体查询，就在监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式！在做响应式的网站里面，是必不可少的一环！不过由于我最近的项目都是使用rem布局。所以媒体查询就没怎么用了！但是，媒体查询，还是很值得一看的！说不定哪一天就需要用上了！</p><p>例子代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 960px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: darkgoldenrod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: lightgreen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;重置浏览器窗口查看效果！&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgPW?w=1022&h=157" alt="clipboard.png"></p><h2 id="19-混合模式"><a href="#19-混合模式" class="headerlink" title="19.混合模式"></a>19.混合模式</h2><p>混合模式，就像photoshop里面的混合模式！这一块，我了解过，在项目上没用过，但是我觉得这个应该不会没有用武之地！<br>css3的混合模式，两个（background-blend-mode和mix-blend-mode）。这两个写法和显示效果都非常像！区别就在于background-blend-mode是用于同一个元素的背景图片和背景颜色的。mix-blend-mode用于一个元素的背景图片或者颜色和子元素的。看以下代码，区别就出来了！</p><blockquote><p>这一块图片很多，大家看图片快速扫一眼，看下什么效果就好！</p></blockquote><h3 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h3><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            width: 480px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:url(&#39;test.jpg&#39;)no-repeat,#09f;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!----&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;multiply正片叠底&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: multiply;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;screen滤色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: screen;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;overlay叠加&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: overlay;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;darken变暗&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: darken;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;lighten变亮&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: lighten;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-dodge颜色减淡模式&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color-dodge;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-burn颜色加深&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color-burn;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hard-light强光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: hard-light;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;soft-light柔光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: soft-light;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;difference差值&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: difference;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;exclusion排除&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: exclusion;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hue色相&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: hue;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;saturation饱和度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: saturation;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color颜色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;luminosity亮度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: luminosity;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgPX?w=502&h=362" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgPZ?w=506&h=710" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP0?w=512&h=711" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP1?w=516&h=711" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP2?w=514&h=353" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP3?w=523&h=709" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP6?w=521&h=708" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP9?w=544&h=713" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQa?w=525&h=705" alt="clipboard.png"></p><h3 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h3><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            padding: 20px;</span><br><span class="line">            width: 480px;</span><br><span class="line">            background: #09f;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;multiply正片叠底&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: multiply;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;screen滤色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: screen;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;overlay叠加&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: overlay;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;darken变暗&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: darken;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;lighten变亮&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: lighten;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-dodge颜色减淡模式&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color-dodge;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-burn颜色加深&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color-burn;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hard-light强光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: hard-light;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;soft-light柔光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: soft-light;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;difference差值&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: difference;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;exclusion排除&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: exclusion;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hue色相&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: hue;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;saturation饱和度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: saturation;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color颜色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;luminosity亮度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: luminosity;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgQd?w=556&h=406" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQf?w=550&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQk?w=554&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQm?w=554&h=398" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQp?w=551&h=401" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQs?w=544&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQv?w=568&h=402" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQx?w=555&h=391" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQz?w=563&h=404" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQB?w=553&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjea?w=556&h=399" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgSP?w=551&h=396" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjeh?w=560&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjem?w=558&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjep?w=547&h=402" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjeq?w=551&h=395" alt="clipboard.png"></p><h1 id="9-CSS样式隔离"><a href="#9-CSS样式隔离" class="headerlink" title="9.CSS样式隔离"></a>9.CSS样式隔离</h1><p>CSS in JS，意思就是使用 js 语言写 css，完全不需要些单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。</p><p>CSS in JS 其实是一种编写思想，目前已经有超过 40 多种方案的实现，最出名的是 styled-components。</p><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import styled from &quot;styled-components&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个带样式的 h1 标签</span><br><span class="line">const Title &#x3D; styled.h1&#96;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个带样式的 section 标签</span><br><span class="line">const Wrapper &#x3D; styled.section&#96;</span><br><span class="line">  padding: 4em;</span><br><span class="line">  background: papayawhip;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过属性动态定义样式</span><br><span class="line">const Button &#x3D; styled.button&#96;</span><br><span class="line">  background: $&#123;props &#x3D;&gt; (props.primary ? &quot;palevioletred&quot; : &quot;white&quot;)&#125;;</span><br><span class="line">  color: $&#123;props &#x3D;&gt; (props.primary ? &quot;white&quot; : &quot;palevioletred&quot;)&#125;;</span><br><span class="line"></span><br><span class="line">  font-size: 1em;</span><br><span class="line">  margin: 1em;</span><br><span class="line">  padding: 0.25em 1em;</span><br><span class="line">  border: 2px solid palevioletred;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式复用</span><br><span class="line">const TomatoButton &#x3D; styled(Button)&#96;</span><br><span class="line">  color: tomato;</span><br><span class="line">  border-color: tomato;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&lt;Wrapper&gt;</span><br><span class="line">  &lt;Title&gt;Hello World, this is my first styled component!&lt;&#x2F;Title&gt;</span><br><span class="line">  &lt;Button primary&gt;Primary&lt;&#x2F;Button&gt;</span><br><span class="line">&lt;&#x2F;Wrapper&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，我们直接在 js 中编写 css，案例中在定义源生 html 时就创建好了样式，在使用的时候就可以渲染出带样式的组件了。</p><p>除此之外，还有其他比较出名的库：</p><ul><li>emotion</li><li>radium</li><li>glamorous</li></ul><p>日常的开发模式 存在以下痛点。</p><ul><li>全局污染：CSS 选择器的作用域是全局的，所以很容易引起选择器冲突；而为了避免全局冲突，又会导致类命名的复杂度上升</li><li>复用性低：CSS 缺少抽象的机制，选择器很容易出现重复，不利于维护和复用</li></ul><p>对于这个问题，也有一些方案。 vue 框架已经帮我们实现了 css 模块化, 通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性。如图： <img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 但是 react 并未给我们实现，我们可能会能通过其它方案来实现，如：约定 css class 命名规范(命名空间) 加上业务前缀，或者封装组件, 或者<a href="https://bemcss.com/">BEM 命名规范(block-element-modife)</a>/<a href="https://segmentfault.com/a/1190000012705634">BEM 简介</a>、 但并不能解决根源问题，反而使代码更难维护。</p><h2 id="目前主流的-css-模块化分为-css-modules-和-css-in-js-两种方案"><a href="#目前主流的-css-模块化分为-css-modules-和-css-in-js-两种方案" class="headerlink" title="目前主流的 css 模块化分为 css modules 和 css in js 两种方案"></a>目前主流的 css 模块化分为 css modules 和 css in js 两种方案</h2><h3 id="css-modules"><a href="#css-modules" class="headerlink" title="css modules"></a>css modules</h3><blockquote><p>CSS Modules 指的是我们像 import js 一样去引入我们的 css 代码，代码中的每一个类名都是引入对象的一个属性, 编译时会将 css 类名 加上唯一 hash。</p></blockquote><p>css module 需要 webpack 配置 css-loader 或者 scss-loader , module 为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>, <span class="comment">// 开启模块化</span></span><br><span class="line">        localIdentName: <span class="string">&#x27;[path][name]-[local]-[hash:base64:5]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图所示： <img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e81eff3bce7b4d168b7cf72899d75325~tplv-k3u1fbpfcp-zoom-1.image" alt="效果图"></p><p>讲解一下 localIdentName 自定义生成的类名格式，可选参数有：</p><ul><li>[path]表示样式表相对于项目根目录所在的路径(默认不拼接)</li><li>[name] 表示样式表文件名称</li><li>[local] 表示样式表的类名定义名称</li><li>[hash:length] 表示 32 位的 hash 值 注意：只有类名选择器和 ID 选择器才会被模块化控制，类似 body h2 span 这些标签选择器是不会被模块化控制</li></ul><p>css module 作用域</p><ul><li>作用域默认为 local 即只在当前模块生效</li><li>global 被 :global 包裹起来的类名，不会被模块化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加上 :global 会全局样式 */</span></span><br><span class="line">:<span class="function"><span class="title">global</span>(<span class="params">.<span class="built_in">global</span>-color</span>)</span> &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  :<span class="function"><span class="title">global</span>(<span class="params">.common-width</span>)</span> &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css module 高级使用</p><ul><li>和外部样式混用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用classNames</span></span><br><span class="line"><span class="keyword">const</span> wrapperClassNames = classNames(&#123;</span><br><span class="line">  <span class="string">&#x27;common-show&#x27;</span>: visible,</span><br><span class="line">  <span class="string">&#x27;common-hide&#x27;</span>: !visible,</span><br><span class="line">  [styles1[<span class="string">&#x27;view-wrapper&#x27;</span>]]: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;div className=&#123;wrapperClassNames&#125;&gt;&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line">&lt;div className=&#123;<span class="string">`<span class="subst">$&#123;styles1.content&#125;</span> <span class="subst">$&#123;styles1.color&#125;</span> common-show`</span>&#125;&gt;</span><br><span class="line">  我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容</span><br><span class="line">&lt;/div&gt;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>覆盖第三方 UI 库</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* 覆盖第三方UI库 样式*/</span>&#125;</span><br><span class="line">&lt;div className=&#123;styles1[<span class="string">&#x27;am-button-custom-wrapper&#x27;</span>]&#125;&gt;</span><br><span class="line">  &lt;Button type=&#123;<span class="string">&#x27;primary&#x27;</span>&#125; onClick=&#123;<span class="function">() =&gt;</span> toggle()&#125;&gt;</span><br><span class="line">     &#123;visible ? <span class="string">&#x27;隐藏&#x27;</span> : <span class="string">&#x27;显示&#x27;</span>&#125;</span><br><span class="line">  &lt;/Button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  覆盖第三方UI库的 样式</span></span><br><span class="line">.am-button-custom-wrapper &#123;</span><br><span class="line">  :<span class="built_in">global</span> &#123;</span><br><span class="line">    .am-button-primary &#123;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css in js"></a>css in js</h3><ul><li>style 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  color: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">  backgroundColor: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://emotion.sh/docs/introduction">emotion</a></p></li><li><p>styled-components</p><blockquote><p><a href="https://styled-components.com/docs/basics#extending-styles">styled-components</a> 是针对 React 写的一套 css in js 框架, 在你使用 styled-components 进行样式定义的同时，你也就创建了一个 React 组件。<a href="https://www.jianshu.com/p/27788be90605">css in js </a></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">const DivWrapper = styled.div`</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: $&#123;(props) =&gt; props.color&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 封装第三方组件库</span><br><span class="line">const AntdButtonWrapper = styled(Button)`</span><br><span class="line">  <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 通过属性动态定义样式</span><br><span class="line">const MyButton = styled.button`</span><br><span class="line">  <span class="attribute">background</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;palevioletred&#x27;</span> : <span class="string">&#x27;white&#x27;</span>)&#125;;</span><br><span class="line">  <span class="attribute">color</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;white&#x27;</span> : <span class="string">&#x27;palevioletred&#x27;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid palevioletred;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 样式复用</span><br><span class="line">const TomatoButton = styled(MyButton)`</span><br><span class="line">  <span class="attribute">color</span>: tomato;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 创建关键帧</span><br><span class="line">const rotate = keyframes`</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  `;</span><br><span class="line"></span><br><span class="line">// 创建动画组件</span><br><span class="line">const Rotate = styled.div`</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">animation</span>: $&#123;rotate&#125; <span class="number">2s</span> linear infinite;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure></li></ul><p>styled-components 优势: 支持将 props 以插值的方式传递给组件,以调整组件样式, 跨平台可在 RN 和 next 中使用。 缺点： 预处理器和后处理器不兼容。</p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/30/16f5477372d2bee3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="总结"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.im/post/6844904034281734151#heading-9">梳理 CSS 模块化 </a></li><li><a href="https://www.cnblogs.com/yy17yy/p/11618775.html">styled-component, emotion and jss 对比</a></li></ul><h1 id="10-CSS性能优化"><a href="#10-CSS性能优化" class="headerlink" title="10.CSS性能优化"></a>10.CSS性能优化</h1><h2 id="提高性能的方法有哪些"><a href="#提高性能的方法有哪些" class="headerlink" title="提高性能的方法有哪些?"></a>提高性能的方法有哪些?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 合并css文件，如果页面加载<span class="number">10</span>个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。</span><br><span class="line"><span class="number">2.</span> 减少css嵌套，最好不要嵌套三层以上。</span><br><span class="line"><span class="number">3.</span> 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。</span><br><span class="line"><span class="number">4.</span> 建立公共样式类，把相同样式提取出来作为公共类使用。</span><br><span class="line"><span class="number">5.</span> 减少通配符*或者类似[hidden=<span class="string">&quot;true&quot;</span>]这类选择器的使用，挨个查找所有...这性能能好吗？</span><br><span class="line"><span class="number">6.</span> 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</span><br><span class="line"><span class="number">7.</span> 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</span><br><span class="line"><span class="number">8.</span> 不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。</span><br><span class="line"><span class="number">9.</span> 少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。</span><br><span class="line"><span class="number">10.</span> cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。</span><br><span class="line"><span class="number">11.</span> 善后工作，css压缩(在线压缩工具 YUI Compressor)</span><br><span class="line"><span class="number">12.</span> GZIP压缩，是一种流行的文件压缩算法。</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote><p><strong>&gt; \</strong>1. 避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。****</p></blockquote><p>首先，使用@import引入css会影响浏览器的并行下载。使用@import引用的css文件只有在引用它的那个css文件被下载，解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析，构建render tree等一系列操作，这就导致浏览器无法并行下载<br>所需的样式文件。<br>其次，多个@import会导致下载顺序紊乱，在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件优先于@import下载，并且打乱甚至破坏@import自身的并行下载。<br>所以不要使用这一方法，使用link标签就行了。</p><blockquote><p><strong>&gt; \</strong>2.避免过分重排****</p></blockquote><ul><li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow</li><li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，这个过程叫做reflow</li><li>页面上任何一个节点触发来reflow，会导致他的子节点和祖先节点重新渲染</li><li>导致reflow发生的情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1. 改变窗口的大小  </span><br><span class="line"> 2. 改变文字的大小</span><br><span class="line"> 3. 添加 删除样式表</span><br><span class="line"> 4. 内容的改变 输入框输入内容也会</span><br><span class="line"> 5. 伪类的激活</span><br><span class="line"> 6. 操作class属性</span><br><span class="line"> 7. 脚本操作dom js改变css类</span><br><span class="line"> 8. 计算offsetWidth和offsetHeight</span><br><span class="line"> 9. 设置style属性</span><br><span class="line"> 10.改变元素的内外边距 </span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure><ul><li>常见重排元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1. 大小有关的 width,height,padding,margin,border-width,border,min-height</span><br><span class="line"> 2. 布局有关的 display,top,position,<span class="built_in">float</span>,left,right,bottom</span><br><span class="line"> 3. 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</span><br><span class="line"> 4. 隐藏有关的 overflow,overflow-x,overflow-y</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><ul><li>减少reflow对性能的影响的建议</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1. 不要一条条的修改dom的样式，预先定义好class，然后修改dom的classname</span><br><span class="line"> 2. 不要修改影响范围较大的dom</span><br><span class="line"> 3. 为动画元素使用绝对定位</span><br><span class="line"> 4. 不要table布局，因为一个很小的改动会造成整个table重新布局</span><br><span class="line"> 5. 避免设置大量的style属性，通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好使用class属性</span><br><span class="line"> 6. 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><blockquote><p><strong>&gt; \</strong>repaint****</p></blockquote><ol><li>当一个元素的外观被改变，但是布局没有改变的情况</li><li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li><li>常见的重绘元素</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - 颜色 color,background</span><br><span class="line"> - 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</span><br><span class="line"> - 背景有关 background,backgound-image,background-position,background-repeat,background-size</span><br><span class="line">123</span><br></pre></td></tr></table></figure><blockquote><p><strong>&gt; CSS动画</strong></p></blockquote><ol><li>css动画启用GPU加速，应用GPU的图形性能对浏览器中的一些图形操作交给GPU完成。canvas2D，布局合成，css3转换，css3d变换，webGL，视频</li><li>2d加速</li><li>3d加速</li></ol><blockquote><p><strong>&gt; 文件压缩</strong></p></blockquote><p>性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著<br>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><blockquote><p><strong>&gt; 去除无用CSS</strong></p></blockquote><p>虽然文件压缩能够降低文件大小，但css文件压缩通常只会去除无用的空格，这样就限制来css文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的css。<br>一般情况下，会存在这两种无用的CSS代码：</p><ol><li>不同元素或者其他情况下的重复代码，</li><li>整个页面内没有生效的CSS代码</li></ol><blockquote><p><strong>&gt; 有选择地使用选择器</strong></p></blockquote><p>css选择器的匹配是从右向左进行的，这一策略导致来不同种类的选择器之间的性能也存在差异。相比于 #markdown-content-h3,显然使用 #markdown.content h3时，浏览器生成渲染树所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content不是#markdown的。试想，页面中的元素更多，那么匹配所要花费的时间代价自然更高。<br>显得浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微，此外不同选择器在不同浏览器中的性能表现也不统一，在编写css的时候无法兼顾每种浏览器，鉴于这两点，在使用选择器时，尽量记住以下几点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1. 保持简单，不要使用嵌套过多过于复杂的选择器</span><br><span class="line"> 2. 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</span><br><span class="line"> 3. 不要使用类选择器和ID选择器修饰元素标签，如：h3<span class="comment">#markdown-content，这一多此一举，还会降低效率</span></span><br><span class="line"> 4. 不要为了追求速度而放弃可读性和可维护性</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>TIPS：为什么css选择器是从右向左匹配的？<br>css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p><blockquote><p><strong>&gt; 减少使用昂贵的属性</strong></p></blockquote><p>在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价，而页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写css时，应该尽量减少使用昂贵属性，如:<br>box-shadow, border-radius, filter, 透明度, :nth-child等<br>当然并不是不要使用这些属性，这些都是经常使用的属性，只是这里可以作为一个了解。当有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p><blockquote><p><strong>&gt; 硬件加速的好坏</strong></p></blockquote><ol><li>仅仅依靠GPU还是不行的，许多动画还是需要CPU的介入，连接cpu和GPU的总带宽不是无限的，所以需要注意数据在cpu和GPU之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输。</li><li>一个重点是了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存。</li><li><code>**chrome://flags/#composited-layer-borders**</code>观察的地址。</li><li>每一个dom元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层</li><li>另一个重点是保持GPU和CPU之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给GPU。</li><li>因为为了高性能，动画开始之后避免层的更新也是非常重要的，避免动画进行中其他层一直更新导致拥堵。</li><li>也就是使用这些css属性来实现动画：transformation, opacity, filter</li><li>使用性能工具检测优化的合理性，timeline检测优化是否合理，还需要实现自动操作来做性能回归测试。</li><li>检测层数和层更新次数是非常有用的。</li></ol><h1 id="11-CSS中的层叠上下文和层叠顺序"><a href="#11-CSS中的层叠上下文和层叠顺序" class="headerlink" title="11.CSS中的层叠上下文和层叠顺序"></a>11.CSS中的层叠上下文和层叠顺序</h1><h3 id="零、世间的道理都是想通的"><a href="#零、世间的道理都是想通的" class="headerlink" title="零、世间的道理都是想通的"></a>零、世间的道理都是想通的</h3><p>在这个世界上，凡事都有个先后顺序，凡物都有个论资排辈。比方说食堂排队打饭，对吧，讲求先到先得，总不可能一拥而上。再比如说话语权，老婆的话永远是对的，领导的话永远是对的。</p><p>在CSS届，也是如此。只是，一般情况下，大家歌舞升平，看不出什么差异，即所谓的众生平等。但是，当发生冲突发生纠葛的时候，显然，是不可能做到完全等同的，先后顺序，身份差异就显现出来了。例如，杰克和罗斯，只能一人浮在木板上，此时，出现了冲突，结果大家都知道的。那对于CSS世界中的元素而言，所谓的“冲突”指什么呢，其中，很重要的一个层面就是“层叠显示冲突”。</p><p>默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，有点类似于真实世界中论资排辈的感觉。</p><p>而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。</p><p>我们大家可能都熟悉CSS中的<code>z-index</code>属性，需要跟大家讲的是，<code>z-index</code>实际上只是CSS层叠上下文和层叠顺序中的一叶小舟。</p><h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p>这里出现了一个名词-<strong>z轴</strong>，指的是什么呢？</p><p>表示的是用户与屏幕的这条看不见的垂直线（参见下图示意-红线）：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/z-aris.png" alt="网页中z轴示意"></p><p>层叠上下文是一个概念，跟「<a href="http://www.zhangxinxu.com/wordpress/?p=4588">块状格式化上下文(BFC)</a>」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p><p>怎么个具象化法呢？</p><p>你可以<strong>把「层叠上下文」理解为当官</strong>：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p><p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p><p><img data-src="https://image.zhangxinxu.com/image/emtion/point.gif" alt="你懂的"></p><h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C/Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p><p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p><p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p><p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p><img data-src="https://image.zhangxinxu.com/image/emtion/point.gif" alt="你懂的"></p><p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p><h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的<strong>层叠上下文和层叠水平是概念</strong>，而这里的<strong>层叠顺序是规则</strong>。</p><p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_223349.png" alt="层叠顺序"></p><p>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。上面是我自己手动重绘的中文版同时补充很多其他地方绝对没有的重要知识信息。</p><p>缺失的关键信息包括：</p><ol><li>位于最低水平的<code>border</code>/<code>background</code>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li><li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li><li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</li></ol><p>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？<br><img data-src="https://image.zhangxinxu.com/image/emtion/ask.gif" alt="疑问"><br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_235108.png" alt="层叠顺序元素的标注说明"></p><p>诸如<code>border</code>/<code>background</code>一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p><p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。例如，文字和浮动图片重叠的时候：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_235830.jpg" alt="浮动和文字重叠"></p><p>上面说的这些层叠顺序规则还是老时代的，如果把CSS3也牵扯进来。</p><h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p><ol><li><strong>谁大谁上：</strong>当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li><li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p><h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）；</li><li>层叠上下文可以阻断元素的混合模式（见<a href="http://www.zhangxinxu.com/wordpress/?p=5155">此文第二部分说明</a>）；</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><p>翻译成真实世界语言就是：</p><ul><li>当官的比老百姓更有机会面见圣上；</li><li>领导下去考察，会被当地官员阻隔只看到繁荣看不到真实民情；</li><li>一个家里，爸爸可以当官，孩子也是可以同时当官的。但是，孩子这个官要受爸爸控制。</li><li>自己当官，兄弟不占光。有什么福利或者变故只会影响自己的孩子们。</li><li>每个当官的都有属于自己的小团体，当家眷管家发生摩擦磕碰的时候（包括和其他官员的家眷管家），都是要优先看当官的也就是主子的脸色。</li></ul><h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p><p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p><ol><li><strong>皇亲国戚</strong>派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li><li><strong>科考入选</strong>派：z-index值为数值的定位元素的传统层叠上下文。</li><li><strong>其他当官途径</strong>：其他CSS3属性。</li></ol><p>//zxx: 下面很多例子是实时CSS效果，建议您去<a href="http://www.zhangxinxu.com/wordpress/?p=5115">原地址浏览</a>，以便预览更准确的效果。</p><p><strong>①. 根层叠上下文</strong><br>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left</code>/<code>top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p><p><strong>②. 定位元素与传统层叠上下文</strong><br>对于包含有<code>position:relative</code>/<code>position:absolute</code>的定位元素，以及FireFox/IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p><p>知道了这一点，有些现象就好理解了。</p><p>如下HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm2.jpg&quot; style&#x3D;&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p><p>下面，我们对父级简单调整下，把<code>z-index:auto</code>改成层叠水平一致的<code>z-index:0</code>, 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm2.jpg&quot; style&#x3D;&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p>大家会发现，尼玛反过来了，竖着的妹子(mm2)这回趴在了横着的妹子(mm1)身上。</p><p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循“<strong>谁大谁上</strong>”的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p><p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则“<strong>后来居上</strong>”，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p><p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6/IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6/IE7的<code>z-index</code>会搞死人的原因。</p><p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p><p><strong>③. CSS3与新时代的层叠上下文</strong><br>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/">对overflow隐藏对position:fixed定位的影响</a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p><p>如下：</p><ol><li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li><li>元素的<code>opacity</code>值不是<code>1</code>.</li><li>元素的<code>transform</code>值不是<code>none</code>.</li><li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li><li>元素的<code>filter</code>值不是<code>none</code>.</li><li>元素的<code>isolation</code>值是<code>isolate</code>.</li><li><code>will-change</code>指定的属性值为上面任意一个。</li><li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li></ol><p>基本上每一项都有很多槽点。</p><p><strong>1. display:flex|inline-flex与层叠上下文</strong><br>注意，这里的规则有些<del>负责</del>复杂。要满足两个条件才能形成层叠上下文：条件1是父级需要是<code>display:flex</code>或者<code>display:inline-flex</code>水平，条件2是子元素的z-index不是<code>auto</code>，必须是数值。此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是flex父级元素。</p><p>眼见为实，给大家上例子吧。</p><p>如下HTML和CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.box &#123;  &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    &#x2F;* 此时该div是普通元素，z-index无效 *&#x2F;</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     &#x2F;* 注意这里是负值z-index *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，妹子跑到蓝色背景的下面了。为什么呢？层叠顺序图可以找到答案，如下：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-08_235511.png" alt="负值z-index的层叠顺序"></p><p>从上图可以看出负值z-index的层叠顺序在block水平元素的下面，而蓝色背景<code>div</code>元素是个普通元素，因此，妹子直接穿越过去，在蓝色背景后面的显示了。</p><p>现在，我们CSS微调下，增加<code>display:flex</code>, 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; display: flex; &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    &#x2F;* 此时该div是层叠上下文元素，同时z-index生效 *&#x2F;</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     &#x2F;* 注意这里是负值z-index *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，妹子在蓝色背景上面显示了，为什么呢？层叠顺序图可以找到答案，如下：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-08_235217.png" alt="img"></p><p>从上图可以看出负值<code>z-index</code>的层叠顺序在当前第一个父层叠上下文元素的上面，而此时，那个<code>z-index</code>值为<code>1</code>的蓝色背景<code>&lt;div&gt;</code>的父元素的<code>display</code>值是<code>flex</code>，一下子升官发财变成层叠上下文元素了，于是，图片在蓝色背景上面显示了。这个现象也证实了层叠上下文元素是<code>flex</code>子元素，而不是<code>flex</code>容器元素。</p><p>另外，另外，这个例子也颠覆了我们传统的对<code>z-index</code>的理解。在CSS2.1时代，<code>z-index</code>属性必须和定位元素一起使用才有作用，但是，在CSS3的世界里，非定位元素也能和<code>z-index</code>愉快地搞基。</p><p><strong>2. opacity与层叠上下文</strong><br>我们直接看代码，原理和上面例子一样，就不解释了。</p><p>如下HTML和CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.box &#123; background-color: blue;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>然后价格透明度，例如50%透明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; opacity: 0.5;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>原因就是半透明元素具有层叠上下文，妹子图片的<code>z-index:-1</code>无法穿透，于是，在蓝色背景上面乖乖显示了。</p><p><strong>3. transform与层叠上下文</strong><br>应用了<a href="http://www.zhangxinxu.com/wordpress/2010/11/css3-transitions-transforms-animation-introduction/">transform变换</a>的元素同样具有菜单上下文。</p><p>我们直接看应用后的结果，如下CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; transform: rotate(15deg);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>妹子同样在蓝色背景之上。</p><p><strong>4. mix-blend-mode与层叠上下文</strong><br><code>mix-blend-mode</code>类似于PS中的混合模式，之前专门有文章介绍-“<a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/">CSS3混合模式mix-blend-mode简介</a>”。</p><p>元素和白色背景混合。无论哪种模式，要么全白，要么没有任何变化。为了让大家有直观感受，因此，下面例子我特意加了个原创平铺背景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; mix-blend-mode: darken;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>需要注意的是，目前，IE浏览器(包括IE14)还不支持<code>mix-blend-mode</code>，因此，要想看到妹子在背景色之上，请使用Chrome或FireFox。</p><p>同样的，因为蓝色背景元素升级成了层叠上下文，因此，<code>z-index:-1</code>无法穿透，在蓝色背景上显示了。</p><p><strong>5. filter与层叠上下文</strong><br>此处说的<code>filter</code>是CSS3中规范的滤镜，不是旧IE时代私有的那些，虽然目的类似。同样的，我之前有提过，例如<a href="http://www.zhangxinxu.com/wordpress/2012/08/css-svg-filter-image-grayscale/">图片的灰度</a>或者<a href="http://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/">图片的毛玻璃效果</a>等。</p><p>我们使用常见的模糊效果示意下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; filter: blur(5px);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>好吧，果然被你猜对了，妹子蓝色床上躺着，只是你眼镜摘了，看得有些不够真切罢了。</p><p><strong>6. isolation:isolate与层叠上下文</strong><br><code>isolation:isolate</code>这个声明是<code>mix-blend-mode</code>应运而生的。默认情况下，<code>mix-blend-mode</code>会混合z轴所有层叠在下面的元素，要是我们不希望某个层叠的元素参与混合怎么办呢？就是使用<code>isolation:isolate</code>。由于一言难尽，我特意为此写了篇文章：“<a href="http://www.zhangxinxu.com/wordpress/?p=5155">理解CSS3 isolation: isolate的表现和作用</a>”，解释了其阻隔混合模式的原理，建议大家看下。</p><p>要演示这个效果，我需要重新设计下，如下HTML结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;img&#x2F;mm2.jpg&quot; class&#x3D;&quot;mode&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>CSS主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  &#x2F;* 竖妹子绝对定位，同时混合模式 *&#x2F;</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，横妹子被混合模式了。此时，我们给妹子所在容器增加<code>isolation:isolate</code>，如下CSS所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  &#x2F;* 竖妹子绝对定位，同时混合模式 *&#x2F;</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue; isolation:isolate;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现横着的妹子跑到蓝色背景上面了。这表明确实创建了层叠上下文。</p><p><strong>7. will-change与层叠上下文</strong><br>关于<code>will-change</code>，如果有同学还不了解，可以参见我之前写的文章：“<a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/">使用CSS3 will-change提高页面滚动、动画等渲染性能</a>”。</p><p>都是类似的演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; will-change: transform;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>果然不出所料，妹子上了蓝色的背景。</p><h3 id="七、层叠上下文与层叠顺序"><a href="#七、层叠上下文与层叠顺序" class="headerlink" title="七、层叠上下文与层叠顺序"></a>七、层叠上下文与层叠顺序</h3><p>本文多次提到，一旦普通元素具有了层叠上下文，其层叠顺序就会变高。那它的层叠顺序究竟在哪个位置呢？</p><p>这里需要分两种情况讨论：</p><ol><li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li><li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li></ol><p>于是乎，我们上面提供的层叠顺序表，实际上还是缺少其他重要信息。我又花功夫重新绘制了一个更完整的7阶层叠顺序图（同样的版权所有，商业请购买，可得无水印大图）：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p><p>大家知道为什么定位元素会层叠在普通元素的上面吗？</p><p>其根本原因就在于，元素一旦成为定位元素，其<code>z-index</code>就会自动生效，此时其<code>z-index</code>就是默认的<code>auto</code>，也就是<code>0</code>级别，根据上面的层叠顺序表，就会覆盖<code>inline</code>或<code>block</code>或<code>float</code>元素。</p><p>而不支持z-index的层叠上下文元素天然<code>z-index:auto</code>级别，也就意味着，层叠上下文元素和定位元素是一个层叠顺序的，于是当他们发生层叠的时候，遵循的是“后来居上”准则。</p><p>我们可以速度测试下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;mm1&quot; style&#x3D;&quot;position:relative&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm2&quot; style&#x3D;&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm2&quot; style&#x3D;&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm1&quot; style&#x3D;&quot;position:relative&quot;&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><br><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，两者样式一模一样，仅仅是在DOM流中的位置不一样，导致他们的层叠表现不一样，后面的妹子趴在了前面妹子的身上。这也说明了，层叠上下文元素的层叠顺序就是<code>z-index:auto</code>级别。</p><p><strong>z-index值与层叠顺序</strong><br>如果元素支持z-index值，则层叠顺序就要好理解些了，比较数值大小嘛，小盆友都会，本质上是应用的“谁大谁上”的准则。在以前，我们只需要关心定位元素的z-index就好，但是，在CSS3时代，flex子项也支持<code>z-index</code>，使得我们面对的情况比以前要负复杂。然而，好的是，规则都是一样的，对于<code>z-index</code>的使用和表现也是如此，套用上面的7阶层叠顺序表就可以了。</p><p>同样，举个简单例子，看下<code>z-index:-1</code>和<code>z-index:1</code>变化对层叠表现的影响，如下两段HTML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;z-index:-1;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;z-index:1;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最后，会发现，<code>z-index:-1</code>跑到了背景色小面，而<code>z-index:1</code>高高在上。</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><strong>一个与层叠上下文相关的有趣的显示现象</strong><br>在实际项目中，我们可能会渐进使用CSS3的fadeIn淡入animation效果增强体验，于是，我们可能就会遇到类似下面的现象：</p><p>您可以狠狠地点击这里：<a href="http://www.zhangxinxu.com/study/201601/css3-fadein-animation-stacking-context.html">CSS3 fadeIn淡入animation动画有趣现象</a></p><p>有一个绝对定位的黑色半透明层覆盖在图片上，默认显示是这样的：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201801/2018-01-09_004641.png" alt="文字在妹子上"></p><p>但是，一旦图片开始走fadeIn淡出的CSS3动画，文字跑到图片后面去了<img data-src="https://mat1.gtimg.com/www/mb/images/face/36.gif" alt="img">：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201801/2018-01-09_004654.png" alt="文字跑到图片后面"></p><p>为什么会这样？</p><p>实际上，学了本文的内容，就很简单了！fadeIn动画本质是<code>opacity</code>透明度的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes fadeIn &#123;</span><br><span class="line">  0% &#123; </span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要知道，<code>opacity</code>的值不是<code>1</code>的时候，是具有层叠上下文的，层叠顺序是<code>z-index:auto</code>级别，跟没有<code>z-index</code>值的<code>absolute</code>绝对定位元素是平起平坐的。而本demo中的文字元素在图片元素的前面，于是，当CSS3动画只要不是最终一瞬间的<code>opacity: 1</code>，位于DOM流后面的图片就会遵循“后来居上”准则，覆盖文字。</p><p>这就是原因，于是，我们想要解决这个问题就很简单。</p><ol><li>调整DOM流的先后顺序；</li><li>提高文字的层叠顺序，例如，设置<code>z-index:1</code>;</li></ol><h3 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p><p>我发现很多重构小伙伴都有z-index滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p><p>实际上，在我看来，觉得多数常见，z-index根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6/IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p><p>OK，本文已经够长了，就不多啰嗦了。</p><p>行为匆忙，出错在所难免，欢迎大力指正。也欢迎各种形式的交流，或者指出文中概念性的错误。</p><p>感谢阅读！</p><h1 id="12-div居中"><a href="#12-div居中" class="headerlink" title="12.div居中"></a>12.div居中</h1><h2 id="使div水平垂直居中"><a href="#使div水平垂直居中" class="headerlink" title="使div水平垂直居中"></a>使div水平垂直居中</h2><h3 id="1-flex-布局实现-（元素已知宽度）"><a href="#1-flex-布局实现-（元素已知宽度）" class="headerlink" title="1. flex 布局实现 （元素已知宽度）"></a>1. flex 布局实现 （元素已知宽度）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1eccc17f7ff91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>内部 div 要有宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码:</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;           </span><br><span class="line">        background-color: #ccc;            </span><br><span class="line">        display: flex;            </span><br><span class="line">        display: -webkit-flex;            </span><br><span class="line">        justify-content: center;            </span><br><span class="line">        align-items: center;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="2-position-（元素已知宽度）"><a href="#2-position-（元素已知宽度）" class="headerlink" title="2. position （元素已知宽度）"></a>2. position （元素已知宽度）</h3><p>​            父元素设置为：position: relative;</p><p>​            子元素设置为：position: absolute;</p><p>​            距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现</p><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ecd08d952a7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CSS代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        left: 50%;            </span><br><span class="line">        top: 50%;            </span><br><span class="line">        margin: -50px 0 0 -50px;        </span><br><span class="line">    &#125;    </span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="3-position-transform-（元素未知宽度）"><a href="#3-position-transform-（元素未知宽度）" class="headerlink" title="3. position transform （元素未知宽度）"></a>3. position transform （元素未知宽度）</h3><p>如果元素未知宽度，只需将上面例子中的<code> margin: -50px 0 0 -50px;</code>替换为：**<code>transform: translate(-50%,-50%);</code>**</p><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ecf67eb4c5a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        top: 50%;            </span><br><span class="line">        left: 50%;            </span><br><span class="line">        transform: translate(-50%, -50%);        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="4-position（元素已知宽度）（left，right，top，bottom为0，maigin：auto-）"><a href="#4-position（元素已知宽度）（left，right，top，bottom为0，maigin：auto-）" class="headerlink" title="4. position（元素已知宽度）（left，right，top，bottom为0，maigin：auto ）"></a>4. position（元素已知宽度）（left，right，top，bottom为0，maigin：auto ）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ed33c6187453?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;           </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        top: 0;            </span><br><span class="line">        bottom: 0;            </span><br><span class="line">        left: 0;            </span><br><span class="line">        right: 0;            </span><br><span class="line">        margin: auto;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line"> &lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"><a href="#★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）" class="headerlink" title="★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"></a>★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ed5caebd6979?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        &#x2F;* 如果不设置宽高，将铺满整个父级*&#x2F;            </span><br><span class="line">        background-color: pink;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        left: 0;            </span><br><span class="line">        right: 0;            </span><br><span class="line">        top: 0;            </span><br><span class="line">        bottom: 0;            </span><br><span class="line">        margin: auto;            </span><br><span class="line">        text-align: center;                    </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML:</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="5-table-cell-布局实现"><a href="#5-table-cell-布局实现" class="headerlink" title="5. table-cell 布局实现"></a>5. table-cell 布局实现</h3><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        vertical-align: middle;                    </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        margin-left: 100px;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;         </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="使内容（文字，图片）水平垂直居中（table-cell-布局）"><a href="#使内容（文字，图片）水平垂直居中（table-cell-布局）" class="headerlink" title="使内容（文字，图片）水平垂直居中（table-cell 布局）"></a>使内容（文字，图片）水平垂直居中（table-cell 布局）</h2><p>行元素 text-align ：center；</p><p>块元素 ：margin ：0 auto；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-align : center  给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中</span><br><span class="line">line-height : 值为元素的高度，可以使元素的文本内容垂直居中</span><br><span class="line">margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级）</span><br></pre></td></tr></table></figure><p><code>display：table-cell </code>会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。</p><p>小结： </p><ol><li><p>不要与 float：left， position : absolute， 一起使用 </p></li><li><p>可以实现大小不固定元素的垂直居中 </p></li><li><p>margin 设置无效，响应 padding 设置 </p></li><li><p>对高度和宽度高度敏感 </p></li><li><p>不要对 display：table-cell 使用百分比设置宽度和高度</p></li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><h3 id="1-使文字水平垂直居中"><a href="#1-使文字水平垂直居中" class="headerlink" title="1. 使文字水平垂直居中"></a>1. 使文字水平垂直居中</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ee843df854e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        text-align: center;&#x2F;*使元素水平居中 *&#x2F;            </span><br><span class="line">        vertical-align: middle;&#x2F;*使元素垂直居中 *&#x2F;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;love&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>给父级设置 display : table，子集设置 display：tablecell ，子集会充满全屏</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1eed995e17eef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        vertical-align: middle;            </span><br><span class="line">        text-align: center;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML ：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="2-图片水平垂直居中"><a href="#2-图片水平垂直居中" class="headerlink" title="2. 图片水平垂直居中"></a>2. 图片水平垂直居中</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f0a0dfeb3002?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: skyblue;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        text-align: center;            </span><br><span class="line">        vertical-align: middle;        </span><br><span class="line">    &#125;        </span><br><span class="line">    img&#123;            </span><br><span class="line">        &#x2F;* 设置成块元素后，text-align：center 就会失效 *&#x2F;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;    </span><br><span class="line">    &lt;img src&#x3D;&quot;1.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>中间的图片会随着外层容器的大小而自动水平垂直居中，其实原理和文字水平垂直居中一模一样</p><h3 id="3-元素两端垂直对齐"><a href="#3-元素两端垂直对齐" class="headerlink" title="3. 元素两端垂直对齐"></a>3. 元素两端垂直对齐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    *&#123;            </span><br><span class="line">        padding: 0;            </span><br><span class="line">        margin: 0;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        display: table;            </span><br><span class="line">        width: 90%;            </span><br><span class="line">        margin: 10px  auto;            </span><br><span class="line">        padding: 10px;             </span><br><span class="line">        border: 1px solid green;            </span><br><span class="line">        height: 100px;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .left,.right&#123;            </span><br><span class="line">        display: table-cell;                        </span><br><span class="line">        width: 20%;            </span><br><span class="line">        border: 1px solid red;                 </span><br><span class="line">    &#125;        </span><br><span class="line">    .center&#123;            </span><br><span class="line">        &#x2F;* padding-top: 10px; *&#x2F;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: green;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是左边&lt;&#x2F;p&gt;        </span><br><span class="line">    &lt;&#x2F;div&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;center&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是中间&lt;&#x2F;p&gt;       </span><br><span class="line">    &lt;&#x2F;div&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是右边&lt;&#x2F;p&gt;        </span><br><span class="line">    &lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>效果：<img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f1e596191dfa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中 center 的顶部没有与左右两侧对齐，原因是 left 中的 <p> 有一个 margin-top ， 而表格布局中默认是文字顶部对齐的，所以 center 会向下移动到首行文字基线对齐，解决办法是为 center 添加与左右两侧中 margin-top 较大者等值的 padding-top 即可。 </p><h1 id="13-CSS浮动"><a href="#13-CSS浮动" class="headerlink" title="13.CSS浮动"></a>13.<a href="https://segmentfault.com/a/1190000012739764">CSS浮动</a></h1><p>页面布局是CSS的一个重点应用，例如：<br><img data-src="https://segmentfault.com/img/bVuVFG" alt="图片描述"></p><p>而实现页面布局主要应用到两种方法，一种是<strong>CSS浮动</strong>，一种是<strong>Flexbox</strong>（IE9以上），本文主要讲的是CSS浮动，下一篇文章将阐述Flexbox。</p><h2 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h2><p><strong>什么是浮动元素：</strong>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。</p><blockquote><p><strong>常规流：</strong>页面上从左往右，从上往下排列的元素流，就是常规流<br><strong>脱离常规流：</strong>绝对定位，fixed定位的元素有自己固定的位置，脱离了常规流<br><strong>包含块：</strong>一个元素离它最近的块级元素是它的包含块</p></blockquote><p>下面详细描述以上的内容，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.border &#123;</span><br><span class="line">  border: 2px solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.common-div &#123;</span><br><span class="line">  width: 160px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float-red &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #fcc;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float-blue &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #09c;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;border&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;float-red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;common-div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;float-blue&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码显示的样子如下：<br><img data-src="https://segmentfault.com/img/bV1Cjj?w=1482&h=394" alt="图片描述"></p><ul><li>块级元素认为浮动元素不存在：红色的块级元素没有受到粉色浮动元素的影响，还展示在左上角的位置，但是被粉色元素盖住了左边的部分</li><li>浮动元素会影响行内元素：文字部分被蓝色浮动元素影响，空出了蓝色浮动元素的部分</li><li>浮动元素会间接影响了包含块的布局：浮动元素影响了文字部分吗，使之多出了一行，文字部分撑高了最外面的border框，所以间接影响了包含块的布局。</li></ul><p>其中，<strong>浮动元素的摆放</strong>会遵循如下的规则：</p><ul><li>尽量靠上</li><li>尽量靠左</li><li>尽量一个挨着一个</li><li>不能超出包含块，除非元素比包含块更宽</li><li>不能超过所在行的最高点</li><li>不能超过它前面浮动元素的最高点</li><li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>浮动元素并不能撑起包含块，这和我们的预期并不相符。通过以下的办法可以将包含块撑开，称之为<strong>闭合浮动</strong></p></blockquote><p><img data-src="https://segmentfault.com/img/bV1CkU?w=798&h=248" alt="图片描述"><br><img data-src="https://segmentfault.com/img/bV1Ck1?w=802&h=248" alt="图片描述"></p><h3 id="闭合浮动的方法："><a href="#闭合浮动的方法：" class="headerlink" title="闭合浮动的方法："></a>闭合浮动的方法：</h3><ul><li><strong>BFC:</strong> 1) 包含块设置overflow:hidden 或者 2)包含块设置display:table-cell/table/flex…</li></ul><blockquote><p><strong>BFC：块级格式化上下文。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。</strong><br>只要<strong>符合以下的条件就是BFC:</strong></p><ol><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol></blockquote><p>相应的背景文档可以参阅：<a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">《BFC的神奇原理》</a></p><ul><li><strong>伪元素</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">    content: &#39;&#39;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>clear:both;意味着块级元素的左边和右边都不能有浮动元素。在包含块的末尾建立了一个内容为空的伪元素，并设置clear:both，使这个元素位于所有的浮动元素之后，从而撑开了包含块的高。</p></blockquote><ul><li><strong>包含块自己也浮动</strong></li></ul><p>这个方法也是w3c使用的方法。不过，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记。</p><p>相应的背景文档：<a href="http://www.w3school.com.cn/css/css_positioning_floating.asp">《W3C CSS浮动》</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CSS" scheme="https://hxy1997.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-04T11:14:39.000Z</published>
    <updated>2021-03-04T11:45:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。</p><span id="more"></span><h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章主要介绍进程与线程的区别与联系相关知识点，也是我们面试过程中，经常会问到的一个问题。希望通过这篇文章，能让大家理解相关知识点~</p><p>涉及面试题：</p><ul><li>1.进程与线程之间有什么区别？</li><li>2.进程、线程都各有什么特点？</li><li>3.进程之间的是怎么进行交互的呢？</li><li>4.什么是缓冲区溢出？</li><li>5.进程之间如何进行交互？</li><li>6.线程之间如何进行交互？</li></ul><blockquote><p>上面的面试题可以看出，其实都是一回事，只是换了一种提问方式，只要我们能掌握核心要点，随便面试官怎么提问，我们都能轻松应对！</p></blockquote><h2 id="1-小例子："><a href="#1-小例子：" class="headerlink" title="1. 小例子："></a>1. 小例子：</h2><blockquote><p>我们生活中有许许多多关于进程与线程的小例子，比如：1.我们使用打开一个微信软件，这个时候就开启了一个进程，<br>当我们在微信里面进行各种操作（查看朋友圈，扫一扫…），这么多的操作就是线程。<br>所以我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。</p></blockquote><blockquote><p><strong>来源百度百科：</strong></p></blockquote><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><blockquote><p>我们简单总结下：</p></blockquote><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p><h2 id="2-深入理解："><a href="#2-深入理解：" class="headerlink" title="2. 深入理解："></a>2. 深入理解：</h2><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3bb5683b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-1-进程-线程-内存-文件-网络句柄"><a href="#2-1-进程-线程-内存-文件-网络句柄" class="headerlink" title="2.1 进程(线程+内存+文件/网络句柄)"></a>2.1 进程(线程+内存+文件/网络句柄)</h3><p>我们通过上面的图片进行进一步理解：</p><p><strong>“内存”：</strong> 我们通常所理解的内存是我们所见到的(2G/4G/8G/16G)物理内存,它为什么会在进程之中呢？ 实际上，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。 否则的话会出现一个问题：我们把指针的值改一改就指向其他进程的内存了，通过这样我们岂不是就可以看到其他进程中”微信”或者是”网上银行”的信息， 这样的话，那我们的微信聊天记录或者是银行账户的信息就都被别人找到了，这是一个很危险的信号！显然这样是不可能的。</p><p><strong>“文件/网络句柄”：</strong> 它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。</p><p><strong>“线程”：</strong> 接下来，我们就要介绍一下我们的“线程”有关知识</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3ba97f25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-2-线程-栈-PC-TLS"><a href="#2-2-线程-栈-PC-TLS" class="headerlink" title="2.2 线程(栈+PC+TLS)"></a>2.2 线程(栈+PC+TLS)</h3><h4 id="2-2-1-栈"><a href="#2-2-1-栈" class="headerlink" title="2.2.1 栈:"></a>2.2.1 栈:</h4><p>我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。 那么我们的栈里面有什么呢？ 我们从主线程的入口main函数，会不断的进行函数调用， 每次调用的时候，会把所有的参数和返回地址压入到栈中。</p><h4 id="2-2-2-PC："><a href="#2-2-2-PC：" class="headerlink" title="2.2.2 PC："></a>2.2.2 PC：</h4><p>Program Counter 程序计数器，操作系统真正运行的是一个个的线程， 而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。 计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的 这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。</p><h5 id="2-2-2-1-缓冲区溢出"><a href="#2-2-2-1-缓冲区溢出" class="headerlink" title="2.2.2.1 缓冲区溢出"></a>2.2.2.1 缓冲区溢出</h5><p>例如我们经常听到一个漏洞：<strong>缓冲区溢出</strong> 这是什么意思呢？ 例如：我们有个地方要输入用户名，本来是用来存数据的地方。 然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了 我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码 写入到用户名框中，来植入进来。我们的解决方法就是，用用户名的长度来限制不要超过 用户名的缓冲区的大小来解决。</p><h4 id="2-3-TLS"><a href="#2-3-TLS" class="headerlink" title="2.3 TLS:"></a>2.3 TLS:</h4><p>全称：thread local storage 之前我们看到每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢?答案是有的，就是TLS。 可以用来存储我们线程所独有的数据。 可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p><h3 id="3-小结："><a href="#3-小结：" class="headerlink" title="3.小结："></a>3.小结：</h3><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了. 2.一个程序至少有一个进程,一个进程至少有一个线程. 3.进程是资源分配的最小单位，线程是程序执行的最小单位。 4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.</p><h1 id="2-进程间通信"><a href="#2-进程间通信" class="headerlink" title="2.进程间通信"></a>2.进程间通信</h1><h2 id="一、进程间通信的概念"><a href="#一、进程间通信的概念" class="headerlink" title="一、进程间通信的概念"></a>一、进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="img"></p><p>进程间通信模型</p><h2 id="二、进程间通信的7种方式"><a href="#二、进程间通信的7种方式" class="headerlink" title="二、进程间通信的7种方式"></a>二、进程间通信的7种方式</h2><p><strong>第一类：传统的Unix通信机制</strong><br> <strong>1. 管道/匿名管道(pipe)</strong></p><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt="img"></p><p>进程间管道通信模型</p></li></ul><p><strong>管道的实质：</strong><br> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><p><strong>2. 有名管道(FIFO)</strong><br> 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><p><strong>3. 信号(Signal)</strong></p><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-3eed8cca67aa9f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p><p>信号的生命周期</p><p><strong>4. 消息(Message)队列</strong></p><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649">延伸阅读：消息队列C语言的实践</a></li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><p><strong>5. 共享内存(share memory)</strong></p><ul><li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p></li><li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="img"></p><p>共享内存原理图</p></li></ul><p><strong>6. 信号量(semaphore)</strong><br> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br> （3）<strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</p><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com/?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp" alt="img"></p><p>两个进程使用一个二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="img"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284/format/webp" alt="img"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><p><strong>7. 套接字(socket)</strong><br> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/319/format/webp" alt="img"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> 原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p></blockquote><p><strong>套接字通信的建立</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2575b81bbab6b67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/437/format/webp" alt="img"></p><p>Socket通信基本流程</p><p>** 服务器端**<br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。<br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。<br> <a href="https://link.jianshu.com/?t=http://developer.51cto.com/art/201509/490775.htm">延伸阅读 ：Java socket编程</a></p><h2 id="三、参考引用"><a href="#三、参考引用" class="headerlink" title="三、参考引用"></a>三、参考引用</h2><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">1. 进程间通信–管道 </a><br> <a href="https://link.jianshu.com/?t=http://blog.csdn.net/ljianhui/article/details/10253345">2. Linux进程间通信——使用共享内存</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3230564.html">3. 进程间通信—共享内存</a><br> <a href="https://link.jianshu.com/?t=http://www.cnblogs.com/diyingyun/archive/2011/12/04/2275229.html">4. 信号量与互斥锁</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-23193900-id-3194924.html">5. 信号量</a></p><h1 id="3-进程调度策略"><a href="#3-进程调度策略" class="headerlink" title="3.进程调度策略"></a>3.进程调度策略</h1><h2 id="1-先来先服务调度算法："><a href="#1-先来先服务调度算法：" class="headerlink" title="1.先来先服务调度算法："></a>1.先来先服务调度算法：</h2><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h2 id="2-短作业-进程-优先调度算法："><a href="#2-短作业-进程-优先调度算法：" class="headerlink" title="2.短作业(进程)优先调度算法："></a>2.短作业(进程)优先调度算法：</h2><p>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h2 id="3-高优先权优先调度算法："><a href="#3-高优先权优先调度算法：" class="headerlink" title="3.高优先权优先调度算法："></a>3.高优先权优先调度算法：</h2><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><h3 id="3-1-非抢占式优先权算法："><a href="#3-1-非抢占式优先权算法：" class="headerlink" title="3.1) 非抢占式优先权算法："></a>3.1) 非抢占式优先权算法：</h3><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><h3 id="3-2-抢占式优先权调度算法："><a href="#3-2-抢占式优先权调度算法：" class="headerlink" title="3.2) 抢占式优先权调度算法："></a>3.2) 抢占式优先权调度算法：</h3><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><h3 id="3-3-容易出现优先级倒置现象："><a href="#3-3-容易出现优先级倒置现象：" class="headerlink" title="3.3)容易出现优先级倒置现象："></a>3.3)容易出现优先级倒置现象：</h3><p>优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p><h3 id="3-4-优先级反转案例解释："><a href="#3-4-优先级反转案例解释：" class="headerlink" title="3.4)优先级反转案例解释："></a>3.4)优先级反转案例解释：</h3><p>不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。</p><h3 id="3-5-优先级倒置解决方案："><a href="#3-5-优先级倒置解决方案：" class="headerlink" title="3.5)优先级倒置解决方案："></a>3.5)优先级倒置解决方案：</h3><p>​       (3.5.1）设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。<br>​     （3.5.2）优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。<br>​       这里还有一个八卦，1997年的美国的火星探测器（使用的就是vxworks)就遇到一个优先级反转问题引起的故障。简单说下，火星探测器有一个信息总线，有一个高优先级的总线任务负责总线数据的存取，访问总线都需要通过一个互斥锁（共享资源出现了）；还有一个低优先级的，运行不是很频繁的气象搜集任务，它需要对总线写数据，也就同样需要访问互斥锁；最后还有一个中优先级的通信任务，它的运行时间比较长。平常这个系统运行毫无问题，但是有一天，在气象任务获得互斥锁往总线写数据的时候，一个中断发生导致通信任务被调度就绪，通信任务抢占了低优先级的气象任务，而无巧不成书的是，此时高优先级的总线任务正在等待气象任务写完数据归还互斥锁，但是由于通信任务抢占了CPU并且运行时间比较长，导致气象任务得不到CPU时间也无法释放互斥锁，本来是高优先级的总线任务也无法执行，总线任务无法及时执行的后果被探路者认为是一个严重错误，最后就是整个系统被重启。Vxworks允许优先级继承，然而遗憾的工程师们将这个选项关闭了。<br>​     （3.5.3）第三种方法就是临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</p><h2 id="4、高响应比优先调度算法："><a href="#4、高响应比优先调度算法：" class="headerlink" title="4、高响应比优先调度算法："></a>4、高响应比优先调度算法：</h2><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p><img data-src="https://img-blog.csdn.net/20180922085248936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>   在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h2 id="5、时间片轮转法："><a href="#5、时间片轮转法：" class="headerlink" title="5、时间片轮转法："></a>5、时间片轮转法：</h2><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p><h2 id="6、多级反馈队列调度算法："><a href="#6、多级反馈队列调度算法：" class="headerlink" title="6、多级反馈队列调度算法："></a>6、多级反馈队列调度算法：</h2><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p><p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p><p>(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p><p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p><p><img data-src="https://img-blog.csdn.net/20180922085249110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？<br>批处理系统常用调度算法：<br>①、先来先服务：FCFS<br>②、最短作业优先<br>③、最短剩余时间优先<br>④、响应比最高者优先</p><p>分时系统调度算法：<br>①、轮转调度<br>②、优先级调度<br>③、多级队列调度<br>④、彩票调度</p><p>实时系统调度算法：<br>①、单比率调度<br>②、限期调度<br>③、最少裕度法</p><h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h1><p>死锁是什么，以及在并发程序中如何避免死锁一直是面试官偏爱的一个问题。<br> 本文尽量以最简洁的示例来帮助你快速理解，掌握死锁发生的原因及其解决方法。在阅读接下来的内容之前，你必须具备java中独占锁与线程之间通信的基本知识。</p><p><strong>死锁</strong><br> 当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p>下面用一个非常简单的死锁示例来帮助你理解死锁的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取String.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">线程b尝试获取String.class</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">无限阻塞下去</span><br></pre></td></tr></table></figure><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>教科书般的回答应该是，结合“哲学家就餐[<a href="#fn1">1]</a>”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p><p>造成死锁必须达成的4个条件（原因）：</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p><ol><li>互斥条件 —&gt; 独占锁的特点之一。</li><li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li><li>不剥夺条件 —&gt; 独占锁的特点之一。</li><li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li></ol><p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p><p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p><p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是否能够简单明了的在面试中阐述清楚死锁产生的原因，并给出解决死锁的方案，可以体现程序员在面对对并发问题时思路是否清晰，对并发的基础掌握是否牢固等等。<br> 而且在实际项目中并发模块的逻辑往往比本文的示例复杂许多，所以写并发应用之前一定要充分理解本文所总结的要点，并切记，并发程序编程在不显著影响程序性能的情况下，一定要尽可能的保守。</p><h1 id="5-I-O-多路复用，select-poll-epoll-详解"><a href="#5-I-O-多路复用，select-poll-epoll-详解" class="headerlink" title="5.I/O 多路复用，select / poll / epoll 详解"></a>5.I/O 多路复用，select / poll / epoll 详解</h1><h2 id="从阻塞-I-O-到-I-O-多路复用"><a href="#从阻塞-I-O-到-I-O-多路复用" class="headerlink" title="从阻塞 I/O 到 I/O 多路复用"></a>从阻塞 I/O 到 I/O 多路复用</h2><p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用<strong>多线程</strong>来处理多个文件描述符。</p><p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在<strong>一个线程</strong>里<em>轮询</em>多个文件描述符是否就绪。</p><p>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查<strong>一个</strong>文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。</p><p>因此引入了 I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p><blockquote><p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p></blockquote><p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：<strong>如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回</strong>。使用非阻塞 I/O 检查每个描述符的就绪状态。</p><p>如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><p>I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。这部分内容可以查看最下文 <a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">Redis 的线程模型</a>。</p><h3 id="为什么-I-O-多路复用内部需要使用非阻塞-I-O"><a href="#为什么-I-O-多路复用内部需要使用非阻塞-I-O" class="headerlink" title="为什么 I/O 多路复用内部需要使用非阻塞 I/O"></a>为什么 I/O 多路复用内部需要使用非阻塞 I/O</h3><p>I/O 多路复用<strong>内部</strong>会遍历集合中的每个文件描述符，判断其是否就绪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for fd in read_set</span><br><span class="line">    if（ readable(fd) ) &#x2F;&#x2F; 判断 fd 是否就绪</span><br><span class="line">        count++</span><br><span class="line">        FDSET(fd, &amp;res_rset) &#x2F;&#x2F; 将 fd 添加到就绪集合中</span><br><span class="line">        break</span><br><span class="line">...</span><br><span class="line">return count</span><br></pre></td></tr></table></figure><p>这里的 <code>readable(fd)</code> 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 <code>fd</code> 未就绪时，<code>select</code> 会阻塞在这个文件描述符上，无法检查下个文件描述符。</p><p>注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，见下文<a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#whynonblock">为什么边缘触发必须使用非阻塞 I/O</a>。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="函数签名与参数"><a href="#函数签名与参数" class="headerlink" title="函数签名与参数"></a>函数签名与参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds,</span><br><span class="line">            fd_set *restrict readfds,</span><br><span class="line">            fd_set *restrict writefds,</span><br><span class="line">            fd_set *restrict errorfds,</span><br><span class="line">            struct timeval *restrict timeout);</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="什么是文件描述符-fd"><a href="#什么是文件描述符-fd" class="headerlink" title="什么是文件描述符 fd"></a>什么是文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">这篇文章</a>以图示的方式对文件描述符作了深入地讲解，可以进一步阅读。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。</p><p>可以这样理解：<strong>socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现</strong>。socket 与 fd 是一一对应的。<strong>通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件</strong>。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;select.h&gt;   </span><br><span class="line">int FD_ZERO(int fd, fd_set *fdset);  &#x2F;&#x2F; 将 fd_set 所有位置 0</span><br><span class="line">int FD_CLR(int fd, fd_set *fdset);   &#x2F;&#x2F; 将 fd_set 某一位置 0</span><br><span class="line">int FD_SET(int fd, fd_set *fd_set);  &#x2F;&#x2F; 将 fd_set 某一位置 1</span><br><span class="line">int FD_ISSET(int fd, fd_set *fdset); &#x2F;&#x2F; 检测 fd_set 某一位是否为 1</span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img data-src="https://imageslr.github.io/media/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 采用链表的方式存储文件描述符，没有最大存储数量的限制。</p><p>从性能开销上看，poll 和 select 的差别不大。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><p><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</p></li><li><p><code>fd</code> 表示要监听的目标文件描述符</p></li><li><p><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</p></li><li><pre><code class="plaintext">op<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">表示要对</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;plaintext</span><br><span class="line">fd</span><br></pre></td></tr></table></figure> 执行的操作，有以下几种：- `EPOLL_CTL_ADD`：为 `fd` 添加一个监听事件 `event`- `EPOLL_CTL_MOD`：Change the event event associated with the target file descriptor fd（`event` 是一个结构体变量，这相当于变量 `event` 本身没变，但是更改了其内部字段的值）- `EPOLL_CTL_DEL`：删除 `fd` 的所有监听事件，这种情况下 `event` 参数没用</code></pre></li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">               int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll 的优点"></a>epoll 的优点</h3><p>一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p><p>对于“性能开销大”，<code>epoll_ctl</code> 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 <code>select</code> 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p><blockquote><p>相当于时间复杂度从 O(n) 降为 O(1)</p></blockquote><p>此外，每次调用 <code>select</code> 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递。这也大大提高了效率。</p><h3 id="水平触发、边缘触发"><a href="#水平触发、边缘触发" class="headerlink" title="水平触发、边缘触发"></a>水平触发、边缘触发</h3><p><code>select</code> 只支持水平触发，<code>epoll</code> 支持水平触发和边缘触发。</p><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。</p><p>区别：边缘触发效率更高，<strong>减少了事件被重复触发的次数</strong>，函数不会返回大量用户程序可能不需要的文件描述符。</p><blockquote><p>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li><p>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</p></li><li><p><code>select</code> 可以使用阻塞 I/O</p><p>。通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure><p>获取到所有可读的文件描述符后，遍历每个文件描述符，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read</span><br></pre></td></tr></table></figure><p>一次</p><p>数据（见上文</p><p>select 示例</p><p>）</p><ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll</span><br></pre></td></tr></table></figure><p>的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知</p><ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul></li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。</p><h2 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h2><p>Redis 是一个单线程的工作模型，使用 I/O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？</p><p>I/O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I/O 请求时，先将它挂起，切换到别的线程；当 I/O 设备就绪时，再切换回该线程。总之，<strong>多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景</strong>。</p><p>而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I/O 操作，因此<strong>多线程频繁的上下文切换反而是一种负优化</strong>。Redis 选择基于非阻塞 I/O 的 <strong>I/O 多路复用机制</strong>，在单线程里<strong>并发</strong>处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。</p><p>不过 redis 在最新的几个版本中也引入了多线程，目的是：</p><ol><li>异步处理删除操作。当删除超大键值对的时候，单线程内同步地删除可能会阻塞待处理的任务</li><li>应对网络 I/O 的场景，网络 I/O 是慢速 I/O。redis6 吞吐量提高了 1 倍</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://linux.die.net/man/7/epoll">Linux man page - epoll</a></li><li><a href="https://linux.die.net/man/2/epoll_create">Linux man page - epoll_create</a></li><li><a href="https://linux.die.net/man/2/epoll_ctl">Linux man page - epoll_ctl</a></li><li><a href="https://linux.die.net/man/2/epoll_wait">Linux man page - epoll_wait</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="操作系统" scheme="https://hxy1997.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>前端性能</title>
    <link href="https://hxy1997.xyz/2021/02/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    <id>https://hxy1997.xyz/2021/02/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/</id>
    <published>2021-02-24T16:02:39.000Z</published>
    <updated>2021-03-13T14:04:05.307Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化的相关内容，好好掌握消化，其实这一部分实用性远高于应试性，很考验各位前端仔的实战水平的</p><span id="more"></span><h1 id="1-RAIL模型"><a href="#1-RAIL模型" class="headerlink" title="1.RAIL模型"></a>1.RAIL模型</h1><p>RAIL是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。</p><p>有以下四个方面：</p><ul><li>Response</li><li>Animation</li><li>Idle</li><li>Load</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/7/13/1734894ee7aaf2b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="RAIL示意图"></p><h2 id="1-聚焦用户"><a href="#1-聚焦用户" class="headerlink" title="1.聚焦用户"></a>1.聚焦用户</h2><p>以下是用户对性能延迟的感知：</p><table><thead><tr><th>延迟时间</th><th>用户感知</th></tr></thead><tbody><tr><td>0-16ms</td><td>很流畅</td></tr><tr><td>0-100ms</td><td>基本流畅</td></tr><tr><td>100-1000ms</td><td>感觉到网站上有一些加载任务</td></tr><tr><td>1000ms or more</td><td>失去耐心了</td></tr><tr><td>10000ms or more</td><td>直接离开，不会再访问了</td></tr></tbody></table><h2 id="2-Response-事件处理最好在50ms内完成"><a href="#2-Response-事件处理最好在50ms内完成" class="headerlink" title="2.Response: 事件处理最好在50ms内完成"></a>2.Response: 事件处理最好在50ms内完成</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>用户的输入到响应的时间不超过100ms，给用户的感受是瞬间就完成了。</li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>事件处理函数在50ms内完成，考虑到idle task的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations等，不适用于drag和scroll。</li><li>复杂的js计算尽可能放在后台，如web worker，避免对用户输入造成阻塞</li><li>超过50ms的响应，一定要提供反馈，比如倒计时，进度百分比等。</li></ul><blockquote><p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。</p></blockquote><p>下图是idle task对input response的影响：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/7/13/173489db13875e5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Idle Task示意图"></p><h2 id="3-Animation-在10ms内产生一帧"><a href="#3-Animation-在10ms内产生一帧" class="headerlink" title="3.Animation: 在10ms内产生一帧"></a>3.Animation: 在10ms内产生一帧</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul><li>产生每一帧的时间不要超过10ms，为了保证浏览器60帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧。</li><li>旨在视觉上的平滑。用户对帧率变化感知很敏感。</li></ul><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>在一些高压点上，比如动画，不要去挑战cpu，尽可能地少做事，如：取offset，设置style等操作。尽可能地保证60帧的体验。</li><li>在渲染性能上，针对不同的动画做一些特定优化</li></ul><blockquote><p>动画不只是UI的视觉效果，以下行为都属于</p><ul><li>视觉动画，如渐隐渐显，tweens，loading等</li><li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离</li><li>拖拽，缩放，经常伴随着用户行为</li></ul></blockquote><h2 id="4-Idle-最大化空闲时间"><a href="#4-Idle-最大化空闲时间" class="headerlink" title="4.Idle: 最大化空闲时间"></a>4.Idle: 最大化空闲时间</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul><li>最大化空闲时间，以增大50ms内响应用户输入的几率</li></ul><h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">requestIdleCallback API</a></li><li>在空闲时间内执行的任务尽量控制在50ms以内，如果更长的话，会影响input handle的pending时间</li><li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务</li></ul><h2 id="5-Load-传输内容到页面可交互的时间不超过5秒"><a href="#5-Load-传输内容到页面可交互的时间不超过5秒" class="headerlink" title="5.Load: 传输内容到页面可交互的时间不超过5秒"></a>5.Load: 传输内容到页面可交互的时间不超过5秒</h2><p>如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率</p><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><ul><li>优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的3G网络手机上打开时间不超过5秒</li><li>对于第二次打开，尽量不超过2秒</li></ul><h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 <a href="https://www.webpagetest.org/easy">WebPageTest</a> 来测试</li><li>要注意的是，即使用户的网络是4G，但因为丢包或者网络波动，可能会比预期的更慢</li><li><a href="https://web.dev/render-blocking-resources/">禁用渲染阻塞的资源，延后加载</a></li><li>可以采用 <a href="https://web.dev/native-lazy-loading/">lazy load</a>，<a href="https://web.dev/reduce-javascript-payloads-with-code-splitting/">code-splitting</a> 等 <a href="https://web.dev/fast/">其他优化</a> 手段，让第一次加载的资源更少</li></ul><h2 id="分析RAIL用的工具"><a href="#分析RAIL用的工具" class="headerlink" title="分析RAIL用的工具"></a>分析RAIL用的工具</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li><li><a href="https://web.dev/measure/">Lighthouse</a></li><li><a href="https://webpagetest.org/easy">WebPageTest</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RAIL是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p><ul><li>聚焦用户</li><li>100ms内响应用户的输入</li><li>10ms内产生1帧，在滚动或者动画执行时</li><li>最大化主线程的空闲时间</li><li>5s内让网页变得可交互</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://web.dev/rail/">web.dev/rail/</a></p><h1 id="2-前端性能优化"><a href="#2-前端性能优化" class="headerlink" title="2.前端性能优化"></a>2.前端性能优化</h1><h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h2><p>当浏览器想要获取远程的数据时，我们的性能之旅就开始了。然而，我们并不会立即动身（发送请求）。在计算机领域，很多性能问题都会通过增加缓存来解决，前端也不例外。和许多后端服务一样，前端缓存也是多级的。下面让我们一起来具体看一看。</p><h3 id="1-1本地数据存储"><a href="#1-1本地数据存储" class="headerlink" title="1. 1本地数据存储"></a>1. 1本地数据存储</h3><p>通过结合本地存储，可以在业务代码侧实现缓存。</p><p>对于一些请求，我们可以直接在业务代码侧进行缓存处理。缓存方式包括 <code>localStorage</code>、<code>sessionStorage</code>、<code>indexedDB</code>。把这块加入缓存的讨论也许会有争议，但利用好它确实能在程序侧达到一些类似缓存的能力。</p><p>例如，我们的页面上有一个日更新的榜单，我们可以做一个当日缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当用户加载站点中的榜单组件时，可以通过该方法获取榜单数据</span><br><span class="line">async function readListData() &#123;</span><br><span class="line">    const info &#x3D; JSON.parse(localStorage.getItem(&#39;listInfo&#39;));</span><br><span class="line">    if (isExpired(info.time, +(new Date))) &#123;</span><br><span class="line">        const list &#x3D; await fetchList();</span><br><span class="line">        localStorage.setItem(&#39;listInfo&#39;, JSON.stringify(&#123;</span><br><span class="line">            time: +(new Date),</span><br><span class="line">            list: list</span><br><span class="line">        &#125;));</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 大家都比较了解了，<code>indexedDB</code> 可能会了解的更少一些。想快速了解 <code>indexedDB</code> 使用方式可以看<a href="https://medium.com/free-code-camp/a-quick-but-complete-guide-to-indexeddb-25f030425501">这篇文章</a>[1]。</p><p>从前端视角看，这是一种本地存储；但如果从整个系统的维度来看，很多时候其实也是缓存链条中的一环。对于一些特殊的、轻量级的业务数据，可以考虑使用本地存储作为缓存。</p><h3 id="1-2-内存缓存（Memory）"><a href="#1-2-内存缓存（Memory）" class="headerlink" title="1.2. 内存缓存（Memory）"></a>1.2. 内存缓存（Memory）</h3><p>当你访问一个页面及其子资源时，有时候会出现一个资源被使用多次，例如图标。由于该资源已经存储在内存中，再去请求反而多此一举，浏览器内存则是最近、最快的响应场所。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/1-cache/img/memcache.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/1-cache/img/memcache.png" alt="memory cache"></a></p><p>内存缓存并无明确的标准规定，它与 HTTP 语义下的缓存关联性不大，算是浏览器帮我们实现的优化，很多时候其实我们意识不到。</p><p>对内存缓存感兴趣，可以在<a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/">这篇文章</a>[2]的 Memory Cache 部分进一步了解。</p><h3 id="1-3-Cache-API"><a href="#1-3-Cache-API" class="headerlink" title="1.3. Cache API"></a>1.3. Cache API</h3><p>当我们没有命中内存缓存时，是否就开始发送请求了呢？其实不一定。</p><p>在这时我们还可能会碰到 Cache API 里的缓存，提到它就不得不提一下 Service Worker 了。它们通常都是配合使用的。</p><p>首先明确一下，这层的缓存没有规定说该缓存什么、什么情况下需要缓存，它只是提供给了客户端构建请求缓存机制的能力。如果你对 PWA 或者 Service Worker 很了解，应该非常清楚是怎么一回事。如果不了解也没有关系，我们可以简单看一下：</p><p>首先，Service Worker 是一个后台运行的独立线程，可以在代码中启用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(&#39;.&#x2F;sw.js&#39;).then(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 注册成功</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后需要处理一些 Service Worker 的生命周期事件，而其中与这里提到的缓存功能直接相关的则是请求拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sw.js</span><br><span class="line">self.addEventListener(&#39;fetch&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果有cache则直接返回，否则通过fetch请求</span><br><span class="line">    e.respondWith(</span><br><span class="line">        caches.match(e.request).then(function (cache) &#123;</span><br><span class="line">            return cache || fetch(e.request);</span><br><span class="line">        &#125;).catch(function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            return fetch(e.request);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。与内存缓存不同，Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。</p><p>Service Worker 与 Cache API 其实是一个功能非常强大的组合，能够实现堆业务的透明，在[兼容性](<a href="https://caniuse.com/#feat=serviceworkers&amp;search=service">https://caniuse.com/#feat=serviceworkers&amp;search=service</a> worker)上也可以做成渐进支持。还是非常推荐在业务中尝试的。当然上面代码简略了很多，想要进一步了解 Service Worker 和 Cache API 的使用可以看<a href="https://juejin.im/post/5aca14b6f265da237c692e6f">这篇文章</a>[3]。同时推荐使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/">Workbox</a>。</p><h3 id="1-4-HTTP-缓存"><a href="#1-4-HTTP-缓存" class="headerlink" title="1.4. HTTP 缓存"></a>1.4. HTTP 缓存</h3><p>如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了。这个时候出现的就是我们所熟知的 HTTP 缓存规范。</p><p>HTTP 有一系列的规范来规定哪些情况下需要缓存请求信息、缓存多久，而哪些情况下不能进行信息的缓存。我们可以通过相关的 HTTP 请求头来实现缓存。</p><p>HTTP 缓存大致可以分为强缓存与协商缓存。</p><h4 id="1-4-1-强缓存"><a href="#1-4-1-强缓存" class="headerlink" title="1.4.1. 强缓存"></a>1.4.1. 强缓存</h4><p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/1-cache/img/diskcache.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/1-cache/img/diskcache.png" alt="disk cache"></a></p><p>与其相关的响应头则是 <code>Expires</code> 和 <code>Cache-Control</code>。在 <code>Expires</code> 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 <code>Cache-Control</code> 则可以通过给它设置一个 <code>max-age</code>，来控制过期时间。例如，<code>max-age=300</code> 就是表示在响应成功后 300 秒内，资源请求会走强缓存。</p><h4 id="1-4-2-协商缓存"><a href="#1-4-2-协商缓存" class="headerlink" title="1.4.2. 协商缓存"></a>1.4.2. 协商缓存</h4><p>你可能也感觉到了，强缓存不是那么灵活。如果我在 300 秒内更新了资源，需要怎么通知客户端呢？常用的方式就是通过协商缓存。</p><p>我们知道，远程请求慢的一大原因就是报文体积较大。协商缓存就是希望能通过先“问一问”服务器资源到底有没有过期，来避免无谓的资源下载。这伴随的往往会是 HTTP 请求中的 304 响应码。下面简单介绍一下实现协商缓存的两种方式：</p><p>一种协防缓存的方式是：服务器第一次响应时返回 <code>Last-Modified</code>，而浏览器在后续请求时带上其值作为 <code>If-Modified-Since</code>，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p><p>上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— <code>ETag</code>。服务器第一次响应时返回 <code>ETag</code>，而浏览器在后续请求时带上其值作为 <code>If-None-Match</code>。一般会用文件的 MD5 作为 <code>ETag</code>。</p><p>作为前端工程师，一定要善于应用 HTTP 缓存。如果想要了解更多关于 HTTP 缓存的内容，可以阅读<a href="https://github.com/amandakelake/blog/issues/41">这篇文章</a>[4]。</p><blockquote><p>上面这些的各级缓存的匹配机制里，都是包含资源的 uri 的匹配，即 uri 更改后不会命中缓存。也正是如此，我们目前在前端实践中都会把文件 HASH 加入到文件名中，避免同名文件命中缓存的旧资源。</p></blockquote><h3 id="1-5-Push-Cache"><a href="#1-5-Push-Cache" class="headerlink" title="1.5. Push Cache"></a>1.5. Push Cache</h3><p>假如很不幸，以上这些缓存你都没有命中，那么你将会碰到最后一个缓存检查 —— Push Cache。</p><p>Push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源。例如，你在请求 <a href="http://www.sample.com/">www.sample.com</a> 时，服务端不仅发送了页面文档，还一起推送了 关键 CSS 样式表。这也就避免了浏览器收到响应、解析到相应位置时才会请求所带来的延后。</p><p>不过 HTTP/2 Push Cache 是一个比较底层的网络特性，与其他的缓存有很多不同，例如：</p><ul><li>当匹配上时，并不会在额外检查资源是否过期；</li><li>存活时间很短，甚至短过内存缓存（例如有文章提到，Chrome 中为 5min 左右）；</li><li>只会被使用一次；</li><li>HTTP/2 连接断开将导致缓存直接失效；</li><li>……</li></ul><p>如果对 HTTP/2 Push 感兴趣，可以看看<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">这篇文章</a>[5]。</p><hr><p>好了，到目前为止，我们可能还没有发出一个真正的请求。这也意味着，在缓存检查阶段我们就会有很多机会将后续的性能问题扼杀在摇篮之中 —— 如果远程请求都不必发出，又何须优化加载性能呢？</p><p>所以，审视一下我们的应用、业务，看看哪些性能问题是可以在源头上解决的。</p><h2 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2.发送请求"></a>2.发送请求</h2><p>在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。</p><blockquote><p>在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。</p></blockquote><h3 id="2-1-避免多余重定向"><a href="#2-1-避免多余重定向" class="headerlink" title="2.1. 避免多余重定向"></a>2.1. 避免多余重定向</h3><p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。</p><p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p><p>同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p><h3 id="2-2-DNS-预解析"><a href="#2-2-DNS-预解析" class="headerlink" title="2.2. DNS 预解析"></a>2.2. DNS 预解析</h3><p>基本我们访问远程服务的时候，不会直接使用服务的出口 IP，而是使用域名。所以请求的一个重要环节就是域名解析。</p><p>DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：</p><ol><li>先检查本地 hosts 文件中是否有映射，有则使用；</li><li>查找本地 DNS 缓存，有则返回；</li><li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li><li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li><li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li><li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li></ol><p>更详细的介绍可以看<a href="https://www.zhihu.com/question/23042131">这篇文章</a>[1]。</p><p>这里我们需要了解的是：</p><ul><li>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li><li>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。</li></ul><p><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch">DNS Prefetch</a>[2] 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;yourwebsite.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了👇</p><blockquote><p>user agent SHOULD resolve as early as possible</p></blockquote><h3 id="2-3-预先建立连接"><a href="#2-3-预先建立连接" class="headerlink" title="2.3. 预先建立连接"></a>2.3. 预先建立连接</h3><p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 <a href="https://www.w3.org/TR/resource-hints/#preconnect">Preconnect</a>[3] 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p><p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p><ul><li>首先，解析 Preconnect 的 url；</li><li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li><li>然后，默认先将 credential 设为 <code>true</code>，如果 cors 为 <code>Anonymous</code> 并且存在跨域，则将 credential 置为 <code>false</code>；</li><li>最后，进行连接。</li></ul><p>使用 Preconnect 只需要将 <code>rel</code> 属性设为 <code>preconnect</code> 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;sample.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>当然，你也可以设置 CORS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;sample.com&quot; crossorigin&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p><h3 id="2-4-使用-CDN"><a href="#2-4-使用-CDN" class="headerlink" title="2.4. 使用 CDN"></a>2.4. 使用 CDN</h3><p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p><p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p><p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p><p>想了解更多 CDN 的工作方式可以阅读<a href="https://yq.aliyun.com/articles/577708">这篇文章</a>[4]。</p><hr><p>下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/2-request/img/resourcetiming.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/2-request/img/resourcetiming.png" alt="resource timing line"></a></p><hr><p>在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。</p><p>过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.zhihu.com/question/23042131">DNS 的解析过程</a></li><li><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch">Resource Hints - DNS Prefetch</a></li><li><a href="https://www.w3.org/TR/resource-hints/#preconnect">Resource Hints - Preconnect</a></li><li><a href="https://yq.aliyun.com/articles/577708">CDN 之我见：原理篇</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing">Understanding Resource Timing</a></li><li><a href="https://www.geeksforgeeks.org/tcp-3-way-handshake-process/">TCP 3-Way Handshake Process</a></li><li><a href="https://www.geeksforgeeks.org/tcp-connection-termination/">TCP 4 wave hands</a></li><li><a href="https://mp.weixin.qq.com/s/3NKOCOeIUF2SGJnY7II9hA">图文还原HTTPS原理</a></li><li><a href="https://en.wikipedia.org/wiki/URL_redirection">URL redirection (wikipedia)</a></li></ol><h2 id="3-服务端响应"><a href="#3-服务端响应" class="headerlink" title="3.服务端响应"></a>3.服务端响应</h2><p>把这一部分放进前端性能优化并不是很严谨：</p><ul><li>其一，服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域；</li><li>其二，我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。</li></ul><p>所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。</p><h3 id="3-1-使用流进行响应"><a href="#3-1-使用流进行响应" class="headerlink" title="3.1. 使用流进行响应"></a>3.1. 使用流进行响应</h3><p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p><p>例如 <a href="https://github.com/alienzhou/css-only-chat-node">css-only-chat-node</a> 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。</p><h3 id="3-2-业务聚合"><a href="#3-2-业务聚合" class="headerlink" title="3.2. 业务聚合"></a>3.2. 业务聚合</h3><p>BFF 非常合适做的一件事就是后端服务的聚合。</p><p>如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。</p><p>此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。</p><h3 id="3-3-避免代码问题"><a href="#3-3-避免代码问题" class="headerlink" title="3.3. 避免代码问题"></a>3.3. 避免代码问题</h3><p>代码问题其实就非常细节了。简单列举一些常见的问题：</p><ul><li><code>async</code> <code>await</code> 的不当使用导致并行请求被串行化了；</li><li>频繁地 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 大对象；</li><li>正则表达式的灾难性回溯；</li><li>闭包导致的内存泄漏；</li><li>CPU 密集型任务导致事件循环 delay 严重；</li><li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；</li><li>……</li></ul><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/README.md">https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/README.md</a>)</p><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.yuque.com/office/yuque/0/2019/pdf/168578/1547529466557-357032b6-12fb-4e02-9682-076f498c1f42.pdf">你不知道的 Node.js 性能优化</a></li><li><a href="https://www.smashingmagazine.com/2018/06/nodejs-tools-techniques-performance-servers/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more">Keeping Node.js Fast: Tools, Techniques, And Tips For Making High-Performance Node.js Servers</a></li><li><a href="https://hackernoon.com/frontend-in-the-backend-a-pattern-for-cleaner-code-b497c92d0b49">Backend-in-the-frontend: a pattern for cleaner code</a></li><li><a href="https://github.com/aliyun-node/Node.js-Troubleshooting-Guide">Node.js 应用故障排查手册</a></li><li><a href="https://github.com/goldbergyoni/nodebestpractices">Node.js Best Practices</a></li></ol><h2 id="4-页面解析与处理"><a href="#4-页面解析与处理" class="headerlink" title="4.页面解析与处理"></a>4.页面解析与处理</h2><h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><p>这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：</p><ul><li>页面 DOM 的解析；</li><li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li><li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li></ul><p>大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。</p><h3 id="4-1-注意资源在页面文档中的位置"><a href="#4-1-注意资源在页面文档中的位置" class="headerlink" title="4.1. 注意资源在页面文档中的位置"></a>4.1. 注意资源在页面文档中的位置</h3><p>我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。</p><p>JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。</p><p>仅仅看 DOM 与 CSS 的关系，则如下图所示：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/pipeline1.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/pipeline1.png" alt="pipeline for dom and css"></a></p><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/pipeline2.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/pipeline2.png" alt="pipeline for dom and css with js"></a></p><p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 ——</p><blockquote><p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。</p></blockquote><p>所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <code>&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code>&lt;body&gt;</code> 的最后（即页面的尾部）。</p><p>关于这部分的一些解释可以看<a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/">这篇文章</a>[1]。</p><h3 id="4-2-使用-defer-和-async"><a href="#4-2-使用-defer-和-async" class="headerlink" title="4.2. 使用 defer 和 async"></a>4.2. 使用 defer 和 async</h3><p>上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。</p><p>那除了将脚本放在 <code>body</code> 的最后，还有什么优化方法么？是有的。</p><p>可以使用 <code>defer</code> 或 <code>async</code> 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/async-defer.jpeg"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/async-defer.jpeg" alt="async defer"></a></p><p><code>defer</code> 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 <code>async</code> 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p><p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 <code>async</code> 可以有效避免这些非核心功能的加载影响页面解析速度。</p><h3 id="4-3-页面文档压缩"><a href="#4-3-页面文档压缩" class="headerlink" title="4.3. 页面文档压缩"></a>4.3. 页面文档压缩</h3><p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p><hr><p>说一句题外话，你知道与页面解析密切相关的 DOMContentLoaded 事件何时触发么？interactive/complete 等 readyState 具体代表什么么？如果不太了解可以从<a href="https://html.spec.whatwg.org/multipage/dom.html#current-document-readiness">HTML spec</a>[2]里看。</p><p>用原话来说就是：</p><blockquote><p>Returns “loading” while the Document is loading, “interactive” once it is finished parsing but still loading subresources, and “complete” once it has loaded.</p></blockquote><blockquote><p>The readystatechange event fires on the Document object when this value changes.</p></blockquote><blockquote><p>The DOMContentLoaded event fires after the transition to “interactive” but before the transition to “complete”, at the point where all subresources apart from async script elements have loaded.</p></blockquote><hr><p>好了，在这一站我们又了解了页面的解析过程及其性能优化。</p><h2 id="5-页面静态资源"><a href="#5-页面静态资源" class="headerlink" title="5.页面静态资源"></a>5.页面静态资源</h2><p>首先还是从宏观上来了解一下：</p><h3 id="5-1-总体原则"><a href="#5-1-总体原则" class="headerlink" title="5.1. 总体原则"></a>5.1. 总体原则</h3><p>这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。</p><p>但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于：</p><ul><li>减少不必要的请求</li><li>减少包体大小</li><li>降低应用资源时的消耗</li><li>利用缓存</li></ul><p>为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。</p><h4 id="5-1-1-减少不必要的请求"><a href="#5-1-1-减少不必要的请求" class="headerlink" title="5.1.1. 减少不必要的请求"></a>5.1.1. 减少不必要的请求</h4><p>核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。</p><p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。</p><p>减少不必要的请求主要分为几个维度：</p><ul><li>对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；</li><li>对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；</li><li>对于可以合并的资源，进行资源合并也是一种方法。</li></ul><h4 id="5-1-2-减少包体大小"><a href="#5-1-2-减少包体大小" class="headerlink" title="5.1.2. 减少包体大小"></a>5.1.2. 减少包体大小</h4><p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。</p><p>减少包体大小常用的方式包括了：</p><ul><li>使用适合当前资源的压缩技术；</li><li>避免再响应包体里“塞入”一些不需要的内容。</li></ul><h4 id="5-1-3-降低应用资源时的消耗"><a href="#5-1-3-降低应用资源时的消耗" class="headerlink" title="5.1.3. 降低应用资源时的消耗"></a>5.1.3. 降低应用资源时的消耗</h4><p>以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。</p><p>此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。</p><h4 id="5-1-4-利用缓存"><a href="#5-1-4-利用缓存" class="headerlink" title="5.1.4. 利用缓存"></a>5.1.4. 利用缓存</h4><p>还记得咱们这趟旅程从哪出发的么？没错，缓存。</p><p>在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。</p><p>由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。</p><h3 id="5-2-针对各类资源的性能优化-🚀"><a href="#5-2-针对各类资源的性能优化-🚀" class="headerlink" title="5.2. 针对各类资源的性能优化 🚀"></a>5.2. 针对各类资源的性能优化 🚀</h3><p>以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。</p><h4 id="5-2-1-JavaScript-优化"><a href="#5-2-1-JavaScript-优化" class="headerlink" title="5.2.1 JavaScript 优化"></a>5.2.1 <a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html">JavaScript 优化</a></h4><h5 id="1-减少不必要的请求"><a href="#1-减少不必要的请求" class="headerlink" title="1. 减少不必要的请求"></a>1. 减少不必要的请求</h5><p>在进行 JavaScript 优化时，我们还是秉承总体思路，首先就是减少不必要的请求。</p><h6 id="1-1-代码拆分（code-split）与按需加载"><a href="#1-1-代码拆分（code-split）与按需加载" class="headerlink" title="#1.1. 代码拆分（code split）与按需加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_1-1-%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%88code-split%EF%BC%89%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">#</a>1.1. 代码拆分（code split）与按需加载</h6><p>相信熟练使用 webpack 的同学对这一特性都不陌生。</p><p>虽然整体应用的代码非常多，但是很多时候，我们在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载。核心思路如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里加载 chat 组件相关资源 chat.js</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.src = <span class="string">&#x27;/static/js/chat.js&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在按钮点击的监听函数中，我动态添加了 <code>&lt;script&gt;</code> 元素。这样就可以实现在点击按钮时，才加载对应的 JavaScript 脚本。</p><p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a>[1] 来告诉 webpack 去做代码拆分。webpack 编译时会进行语法分析，之后遇到 dynamic import 就会认为这个模块是需要动态加载的。相应的，其子资源也会被如此处理（除非被其他非动态模块也引用了）。</p><p>在 webpack 中使用代码拆分最常见的一个场景是基于路由的代码拆分。目前很多前端应用都在使用 SPA（单页面应用）形式，或者 SPA 与 MPA（多页面应用）的结合体，这就会涉及到前端路由。而页面间的业务差异也让基于路由的代码拆分成为一个最佳实践。想了解如何在 react-router v4 中实现路由级别的代码拆分，可以看<a href="https://www.jianshu.com/p/547aa7b92d8c">这篇文章</a>[2]。</p><p>当然，如果你不使用 webpack 之类的构建工具，你也可以选择一个 AMD 模块加载器（例如 <a href="https://requirejs.org/">RequireJS</a>）来实现前端运行时上的异步依赖加载。</p><h6 id="1-2-代码合并"><a href="#1-2-代码合并" class="headerlink" title="#1.2. 代码合并"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_1-2-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6">#</a>1.2. 代码合并</h6><p>我们在总体思路里有提到，减少请求的一个方法就是合并资源。试想一个极端情况：我们现在不对 node_modules 中的代码进行打包合并，那么当我们请求一个脚本之前将可能会并发请求数十甚至上百个依赖的脚本库。同域名下的并发请求数过高会导致请求排队，同时还可能受到 TCP/IP 慢启动的影响。</p><p>当然，在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会帮你把依赖打包到一起的。不过当你使用其他一些工具时，就要注意了。例如使用 <a href="https://fis.baidu.com/fis3/docs/pack.html">FIS3</a> 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并。又或者使用 Gulp 这样的工具，也需要注意进行打包。</p><p>总之，千万不要让你的碎文件散落一地。</p><h5 id="2-减少包体大小"><a href="#2-减少包体大小" class="headerlink" title="#2. 减少包体大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F">#</a>2. 减少包体大小</h5><h6 id="2-1-代码压缩"><a href="#2-1-代码压缩" class="headerlink" title="#2.1. 代码压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-1-%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9">#</a>2.1. 代码压缩</h6><p>JavaScript 代码压缩比较常见的做法就是使用 <a href="http://lisperator.net/uglifyjs/">UglifyJS</a> 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 <a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a> 这样的功能插件。</p><p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/gzip1.51bd67d4.png" alt="响应头"></p><p>上图中响应头的 <code>Content-Encoding</code> 表示其使用了 gzip。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/gzip2.ab7a2dab.png" alt="压缩效果"></p><p>深色的数字表示压缩后的大小为 22.0KB，浅色部分表示压缩前的大小为 91.9KB，压缩比还是挺大的，很有效果。一般服务器都会内置相应模块来进行 gzip 处理，不需要我们单独编写压缩算法模块。例如在 Nginx 中就包含了 <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module</a>[3] 模块，通过简单的配置就可以开启。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span>            <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_types</span>      application/javascript application/x-javascript text/javascript;</span><br></pre></td></tr></table></figure><h6 id="2-2-Tree-Shaking"><a href="#2-2-Tree-Shaking" class="headerlink" title="#2.2. Tree Shaking"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-2-tree-shaking">#</a>2.2. Tree Shaking</h6><p>Tree Shaking 最早进入到前端的视线主要是因为 Rollup。后来在 webpack 中也被实现了。其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 B</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;module.A.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>可以看到，模块 B 引用了模块 A，但是只使用了 <code>add</code> 方法。因此 <code>minus</code> 方法相当于成为了 Dead Code，将它打包进去没有意义，该方法是永远不会被使用到的。</p><p>注意，我在上面的代码中使用了 ESM 规范的模块语法，而没有使用 CommonJS。这主要是由于 Tree Shaking 算是一种静态分析，而 ESM 本身是一种的静态的模块化规范，所有依赖可以在编译期确定。如果想要更好得在 webpack 中使用，可以在查看其<a href="https://webpack.js.org/guides/tree-shaking/">官网上的这部分内容</a>[4]。关于 Tree Shaking 的介绍也可以<a href="https://juejin.im/post/5a4dc842518825698e7279a9">从这里了解下</a>[5]。</p><p>注意，刚才说了 Tree Shaking 非常依赖于 ESM。像是前端流行的工具库 <a href="https://lodash.com/">lodash</a> 一般直接安装的版本是非 ESM 的，为了支持 Tree Shaking，我们需要去安装它的 ESM 版本 —— <a href="https://www.npmjs.com/package/lodash-es">lodash-es</a> 来<a href="https://www.zhihu.com/question/333421533/answer/764963886">实现 Tree Shaking</a>[6]。</p><p>此外，Chrome DevTools 也可以帮助你查看加载的 <a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage">JavaScript 代码的使用覆盖率</a>[7]。</p><h6 id="2-3-优化-polyfill-的使用"><a href="#2-3-优化-polyfill-的使用" class="headerlink" title="#2.3. 优化 polyfill 的使用"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-3-%E4%BC%98%E5%8C%96-polyfill-%E7%9A%84%E4%BD%BF%E7%94%A8">#</a>2.3. 优化 polyfill 的使用</h6><p>前端技术的一大特点就是需要考虑兼容性。为了让大家能顺畅地使用浏览器的新特性，一些程序员们开发了新特性对应的 polyfill，用于在非兼容浏览器上也能使用新特性的 API。后续升级不用改动业务代码，只需要删除相应的 polyfill 即可。</p><p>这种舒适的开发体验也让 polyfill 成为了很多项目中不可或缺的一份子。然而 polyfill 也是有代价的，它增加了代码的体积。毕竟 polyfill 也是 JavaScript 写的，不是内置在浏览器中，引入的越多，代码体积也越大。所以，只加载真正所需的 polyfill 将会帮助你减小代码体积。</p><p>首先，不是每个业务的兼容性要求都一样。因此，按你业务的场景来确定引入哪些 polyfill 是最合适的。然而，特性千千万，手动 import 或者添加 Babel Transformer 显然是一件成本极高的事。针对这点，我们可以通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来帮忙，许多前端工具（<a href="https://babeljs.io/docs/en/next/babel-preset-env.html#how-does-it-work">babel-preset-env</a>/<a href="https://github.com/postcss/autoprefixer#browsers">autoprefixer</a>/<a href="https://github.com/amilajack/eslint-plugin-compat#3-configure-target-browsers">eslint-plugin-compat</a>）都依赖于它。使用方式可以<a href="https://babeljs.io/docs/en/next/babel-preset-env.html">看这里</a>。</p><p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 <a href="https://youtu.be/reztLS3vomE?t=1254">Differential Serving</a>[8] 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;legacy.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在能够处理 <code>module</code> 属性的浏览器（具有很多新特性）上就只需加载 <code>main.mjs</code>（不包含 polyfill），而在老式浏览器下，则会加载 <code>legacy.js</code>（包含 polyfill）。</p><p>最后，其实在理想上，polyfill 最优的使用方式应该是根据浏览器特性来分发，同一个项目在不同的浏览器，会加载不同的 polyfill 文件。例如 <a href="https://polyfill.io/v3/">Polyfill.io</a> 就会根据请求头中的客户端特性与所需的 API 特性来按实际情况返回必须的 polyfill 集合。</p><h6 id="2-4-webpack"><a href="#2-4-webpack" class="headerlink" title="#2.4. webpack"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-4-webpack">#</a>2.4. webpack</h6><p>webpack 现在已经成为很多前端应用的构建工具，因此这里单独将其列了出来。我们可以通过 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 这个工具来查看打包代码里面各个模块的占用大小。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/webpack-bundle-analyzer.ebc4ca21.gif" alt="webpack-bundle-analyzer"></p><p>很多时候，打包体积过大主要是因为引入了不合适的包，对于如何优化依赖包的引入，这里有<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">一些建议可以帮助你减小 bundle 的体积</a>[9]。</p><h5 id="3-解析与执行"><a href="#3-解析与执行" class="headerlink" title="#3. 解析与执行"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a>3. 解析与执行</h5><p>除了 JavaScript 下载需要耗时外，脚本的解析与执行也是会消耗时间的。</p><h6 id="3-1-JavaScript-的解析耗时"><a href="#3-1-JavaScript-的解析耗时" class="headerlink" title="#3.1. JavaScript 的解析耗时"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-1-javascript-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%80%97%E6%97%B6">#</a>3.1. JavaScript 的解析耗时</h6><p>很多情况下，我们会忽略 JavaScript 文件的解析。一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/js-cost.d58178c5.png" alt="js 处理"></p><p>从<a href="https://twitter.com/addyosmani/status/830126731470073857">上图</a>可以看出，解析与编译消耗了好几百毫秒。所以换一个角度来说，删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p><p>同时，我们从前一节已经知道，JavaScript 的解析、编译和执行会阻塞页面解析，延迟用户交互。所以有时候，加载同样字节数的 JavaScript 对性能的影响可能会高于图片，因为图片的处理可以放在其他线程中并行执行。</p><h6 id="3-2-避免-Long-Task"><a href="#3-2-避免-Long-Task" class="headerlink" title="#3.2. 避免 Long Task"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-2-%E9%81%BF%E5%85%8D-long-task">#</a>3.2. 避免 Long Task</h6><p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑。如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/longtask.c0388c89.png" alt="long task"></p><p>例如在上图中，帧率下降明显的地方出现了 Long Task，伴随着的是有一段超过 700 ms 的脚本执行时间。而性能指标 FCP 与 DCL 处于其后，一定程度上可以认为，这个 Long Task 阻塞了主线程并拖慢了页面的加载时间，严重影响了前端性能与体验。</p><p>想要了解更多关于 Long Task 的内容，可以看看 <a href="https://w3c.github.io/longtasks/">Long Task 相关的标准</a>[10]。</p><h6 id="3-3-是否真的需要框架"><a href="#3-3-是否真的需要框架" class="headerlink" title="#3.3. 是否真的需要框架"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-3-%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A1%86%E6%9E%B6">#</a>3.3. 是否真的需要框架</h6><p>相信如果现在问大家，我们是否需要 React、Vue、Angular 或其他前端框架（库），大概率是肯定的。</p><p>但是我们可以换个角度来思考这个问题。类库/框架帮我们解决的问题之一是快速开发与后续维护代码，很多时候，类库/框架的开发者是需要在可维护性、易用性和性能上做取舍的。对于一个复杂的整站应用，使用框架给你的既定编程范式将会在各个层面提升你工作的质量。但是，对于某些页面，我们是否可以反其道行之呢？</p><p>例如产品经理反馈，咱们的落地页加载太慢了，用户容易流失。这时候你会开始优化性能，用上这次「性能之旅」里的各种措施。但你有没有考虑过，对于像落地页这样的、类似静态页的页面，是不是可以“返璞归真”？</p><p>也许你使用了 React 技术栈 —— 你加载了 React、Redux、React-Redux、一堆 Reducers…… 好吧，整个 JavaScript 可能快 1MB 了。更重要的是，这个页面如果是用于拉新的，这也代表着访问者并没有缓存可以用。好吧，为了一个静态页（或者还有一些非常简单的表单交互），用户付出了高额的成本，而原本这只需要 50 行不到的代码。所以有时候考虑使用原生 JavaScript 来实现它也是一种策略。Netflix 有一篇文章介绍了他们是<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">如何通过这种方式大幅缩减加载与操作响应时间的</a>[11]。</p><p>当然，还是强调一下，并不是说不要使用框架/类库，只是希望大家不要拘泥于某个思维定式。做工具的主人，而不是工具的“奴隶”。</p><h6 id="3-4-针对代码的优化"><a href="#3-4-针对代码的优化" class="headerlink" title="#3.4. 针对代码的优化"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-4-%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96">#</a>3.4. 针对代码的优化</h6><blockquote><p>请注意，截止目前（2019.08）以下内容不建议在生产环境中使用。</p></blockquote><p>还有一种优化思路是把代码变为最优状态。它其实算是一种编译优化。在一些编译型的静态语言上（例如 C++），通过编译器进行一些优化非常常见。</p><p>这里要提到的就是 facebook 推出的 <a href="https://prepack.io/">Prepack</a>。例如下面一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">&#x27;world&#x27;</span>;&#125;</span><br><span class="line">    <span class="built_in">global</span>.s = hello() + <span class="string">&#x27; &#x27;</span> + world();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不过很多时候，代码体积和运行性能是会有矛盾的。同时 Prepack 也还不够成熟，所以不建议在生产环境中使用。</p><h5 id="4-缓存"><a href="#4-缓存" class="headerlink" title="#4. 缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-%E7%BC%93%E5%AD%98">#</a>4. 缓存</h5><p>JavaScript 部分的缓存与我们在第一部分里提到的缓存基本一致，如果你记不太清了，<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">可以回到咱们的第一站</a>。</p><h6 id="4-1-发布与部署"><a href="#4-1-发布与部署" class="headerlink" title="#4.1. 发布与部署"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-1-%E5%8F%91%E5%B8%83%E4%B8%8E%E9%83%A8%E7%BD%B2">#</a>4.1. 发布与部署</h6><p>这里简单提一下：大多数情况下，我们对于 JavaScript 与 CSS 这样的静态资源，都会启动 HTTP 缓存。当然，可能使用强缓存，也可能使用协商缓存。当我们在强缓存机制上发布了更新的时候，如何让浏览器弃用缓存，请求新的资源呢？</p><p>一般会有一套配合的方式：首先在文件名中包含文件内容的 Hash，内容修改后，文件名就会变化；同时，设置不对页面进行强缓存，这样对于内容更新的静态资源，由于 uri 变了，肯定不会再走缓存，而没有变动的资源则仍然可以使用缓存。</p><p>上面说的主要涉及前端资源的发布和部署，详细可以看<a href="https://www.zhihu.com/question/20790576/answer/32602154">这篇内容</a>[12]，这里就不展开了。</p><h6 id="4-2-将基础库代码打包合并"><a href="#4-2-将基础库代码打包合并" class="headerlink" title="#4.2. 将基础库代码打包合并"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-2-%E5%B0%86%E5%9F%BA%E7%A1%80%E5%BA%93%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85%E5%90%88%E5%B9%B6">#</a>4.2. 将基础库代码打包合并</h6><p>为了更好利用缓存，我们一般会把不容易变化的部分单独抽取出来。例如一个 React 技术栈的项目，可能会将 React、Redux、React-Router 这类基础库单独打包出一个文件。</p><p>这样做的优点在于，由于基础库被单独打包在一起了，即使业务代码经常变动，也不会导致整个缓存失效。基础框架/库、项目中的 common、util 仍然可以利用缓存，不会每次发布新版都会让用户花费不必要的带宽重新下载基础库。</p><p>所以一种常见的策略就是<a href="https://juejin.im/post/5aed037b6fb9a07aa047e1e1">将基础库这种 Cache 周期较长的内容单独打包在一起</a>，利用缓存减少新版本发布后用户的访问速度。这种方法本质上是将缓存周期不同的内容分离了，隔离了变化。</p><p>webpack 在 v3.x 以及之前，可以通过 CommonChunkPlugin 来分离一些公共库。而升级到 v4.x 之后有了一个新的配置项 <code>optimization.splitChunks</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                commons: &#123;</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    automaticNamePrefix: <span class="string">&#x27;commons&#x27;</span>,</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]react|redux|react-redux/</span>,</span><br><span class="line">                    chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-3-减少-webpack-编译不当带来的缓存失效"><a href="#4-3-减少-webpack-编译不当带来的缓存失效" class="headerlink" title="#4.3. 减少 webpack 编译不当带来的缓存失效"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-%E5%87%8F%E5%B0%91-webpack-%E7%BC%96%E8%AF%91%E4%B8%8D%E5%BD%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88">#</a>4.3. 减少 webpack 编译不当带来的缓存失效</h6><p>由于 webpack 已经成为前端主流的构建工具，因此这里再特别提一下使用 webpack 时的一些注意点，减少一些不必要的缓存失效。</p><p>我们知道，对于每个模块 webpack 都会分配一个唯一的模块 ID，一般情况下 webpack 会使用自增 ID。这就可能导致一个问题：一些模块虽然它们的代码没有变化，但由于增/删了新的其他模块，导致后续所有的模块 ID 都变更了，文件 MD5 也就变化了。另一个问题在于，webpack 的入口文件除了包含它的 runtime、业务模块代码，同时还有一个用于异步加载的小型 manifest，任何一个模块的变化，最后必然会传导到入口文件。这些都会使得网站发布后，没有改动源码的资源也会缓存失效。</p><p>规避这些问题有一些常用的方式。</p><h6 id="4-3-1-使用-Hash-来替代自增-ID"><a href="#4-3-1-使用-Hash-来替代自增-ID" class="headerlink" title="#4.3.1. 使用 Hash 来替代自增 ID"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-1-%E4%BD%BF%E7%94%A8-hash-%E6%9D%A5%E6%9B%BF%E4%BB%A3%E8%87%AA%E5%A2%9E-id">#</a>4.3.1. 使用 Hash 来替代自增 ID</h6><p>你可以使用 <a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/">HashedModuleIdsPlugin 插件</a>，它会根据模块的相对路径来计算 Hash 值。当然，你也可以使用 webpack 提供的 <a href="https://webpack.js.org/configuration/optimization/#optimizationmoduleids"><code>optimization.moduleIds</code></a>，将其设置为 <code>hash</code>，或者选择其他合适的方式。</p><h6 id="4-3-2-将-runtime-chunk-单独拆分出来"><a href="#4-3-2-将-runtime-chunk-单独拆分出来" class="headerlink" title="#4.3.2. 将 runtime chunk 单独拆分出来"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-2-%E5%B0%86-runtime-chunk-%E5%8D%95%E7%8B%AC%E6%8B%86%E5%88%86%E5%87%BA%E6%9D%A5">#</a>4.3.2. 将 runtime chunk 单独拆分出来</h6><p>通过 <a href="https://webpack.js.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 配置可以让 webpack 把包含 manifest 的 runtime 部分单独分离出来，这样就可以尽可能限制变动影响的文件范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: &#123;</span><br><span class="line">            name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你对 webpack 模块化 runtime 运行的原理不太了解，可以看看<a href="https://juejin.im/post/5b82ac82f265da431d0e6d25">这篇文章</a>[13]。</p></blockquote><h6 id="4-3-3-使用-records"><a href="#4-3-3-使用-records" class="headerlink" title="#4.3.3. 使用 records"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-3-%E4%BD%BF%E7%94%A8-records">#</a>4.3.3. 使用 records</h6><p>你可以通过 <a href="https://webpack.js.org/configuration/other-options/#recordspath"><code>recordsPath</code></a> 配置来让 webpack 产出一个包含模块信息记录的 JSON 文件，其中包含了一些模块标识的信息，可以用于之后的编译。这样在后续的打包编译时，对于被拆分出来的 Bundle，webpack 就可以根据 records 中的信息来尽量避免破坏缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  recordsPath: path.join(__dirname, <span class="string">&#x27;records.json&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果对上述避免或减少缓存失效的方法感兴趣，也可以再读一读<a href="https://survivejs.com/webpack/optimizing/separating-manifest/#using-records">这篇文章</a>14。在 webpack v5.x 的计划中，也有<a href="https://github.com/webpack/changelog-v5/blob/master/README.md#deterministic-chunk-and-module-ids">针对 module 和 chunk ID 的一些工作计划来提高长期缓存</a>。</p><hr><p>这一部分就到这里了，我们基于减少不必要的请求、减少包体大小、降低解析与执行消耗、利用缓存这四个基本思想，展开去看了 JavaScript 资源的性能优化措施有哪些。</p><p>下面我们就会进入前端三驾马车中的 CSS 部分了！</p><p><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html"></a></p><hr><h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://github.com/tc39/proposal-dynamic-import">Proposal Dynamic Import</a></li><li><a href="https://www.jianshu.com/p/547aa7b92d8c">在 react-router4 中进行代码拆分</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">Module ngx_http_gzip_module</a></li><li><a href="https://webpack.js.org/guides/tree-shaking/">Tree Shaking - webpack</a></li><li><a href="https://juejin.im/post/5a4dc842518825698e7279a9">Tree Shaking 性能优化实践 - 原理篇</a></li><li><a href="https://www.zhihu.com/question/333421533/answer/764963886">Tree Shaking for Lodash</a></li><li><a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage">CSS and JS code coverage - Chrome DevTools</a></li><li><a href="https://youtu.be/reztLS3vomE?t=1254">Chrome Dev Summit 2018</a></li><li><a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">Optimize your libraries with webpack</a></li><li><a href="https://w3c.github.io/longtasks/">Long Tasks API 1</a></li><li><a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">A Netflix Web Performance Case Study</a></li><li><a href="https://www.zhihu.com/question/20790576/answer/32602154">大公司里怎样开发和部署前端代码？</a></li><li><a href="https://juejin.im/post/5b82ac82f265da431d0e6d25">webpack进阶：前端运行时的模块化设计与实现</a></li><li><a href="https://survivejs.com/webpack/optimizing/separating-manifest/#using-records">Separating a Manifest</a></li><li><a href="https://v8.dev/blog/cost-of-javascript-2019">The cost of JavaScript in 2019</a></li><li>[<a href="https://juejin.im/post/5d1f27285188252f275fdbb6">译] 2019 年的 JavaScript 性能</a></li><li><a href="https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366">webpack 4: Code Splitting, chunk graph and the splitChunks optimization</a></li><li><a href="https://www.cnblogs.com/zhuxian8/p/7197356.html">文本压缩算法的对比和选择</a></li><li><a href="https://zhuanlan.zhihu.com/p/42418273">简单聊聊 GZIP 的压缩原理与日常应用</a></li><li><a href="https://www.sciencedirect.com/topics/computer-science/text-compression">Text Compression</a></li><li><a href="https://medium.com/webpack/better-tree-shaking-with-deep-scope-analysis-a0b788c0ce77">Better tree shaking with deep scope analysis</a></li><li><a href="https://dev.to/goenning/how-we-reduced-our-initial-jscss-size-by-67-3ac0">How we reduced our initial JS/CSS size by 67%</a></li></ol><h3 id="5-3CSS-优化"><a href="#5-3CSS-优化" class="headerlink" title="5.3CSS 优化"></a>5.3<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html">CSS 优化</a></h3><p>在这一部分，我们来详细看一看与 CSS 相关的优化内容。其中一部分内容与 JavaScript 部分类似，另一部分可能是 CSS 特有的一些优化或注意事项。</p><h4 id="1-关键-CSS"><a href="#1-关键-CSS" class="headerlink" title="#1. 关键 CSS"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_1-%E5%85%B3%E9%94%AE-css">#</a>1. 关键 CSS</h4><p>在性能优化上，其实我们会更关注关键渲染路径（Critical Rendering Path，即 CRP），而不一定是最快加载完整个页面。</p><p>CRP 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS。识别出当前业务中的关键 CSS，优先下载与解析它，将会帮助我们更好降低延迟。</p><p>所以我们首先还是需要先建立好概念：很多时候，我们并不是在追求整体页面的最快加载，而是最核心最关键的那部分。例如在视频网站上可能是播放器，在文档站点可能是阅读器。</p><p>由于很多时候，关键 CSS 不会太大，因此有一种常见的优化措施是，将关键 CSS 的内容通过 <code>&lt;style&gt;</code> 标签内联到 <code>&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS。这样对于关键路径的渲染可以减少一次 RTT (Round-Trip Time)。用户可以更快看到一些页面初始的渲染结果。</p><p>经典的<a href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a">骨架屏</a>[1]可以算是这种思路的一个延展。我们会生成一个不包含实际功能的静态页面，将必要的脚本、样式、甚至图片（base64）资源都内联到其中，当用户访问时直接先返回该页面，就可以很快让用户看到页面结果，之后在异步渐进加载预渲染，就会让用户感觉“很快”。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/fb-skeleton.d4ea2857.png" alt="facebook skeleton"></p><p>骨架屏可以<a href="https://css-tricks.com/building-skeleton-screens-css-custom-properties/">手动编写</a>[2]，当然也可以通过<a href="https://github.com/ElemeFE/page-skeleton-webpack-plugin">编译插件</a>来帮助你<a href="https://zhuanlan.zhihu.com/p/34702561">自动生成</a>[3]骨架屏。</p><h4 id="2-优化资源请求"><a href="#2-优化资源请求" class="headerlink" title="#2. 优化资源请求"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82">#</a>2. 优化资源请求</h4><h5 id="2-1-按需加载"><a href="#2-1-按需加载" class="headerlink" title="#2.1. 按需加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-1-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">#</a>2.1. 按需加载</h5><p>与 JavaScript 类似，我们的 CSS 也是可以按需加载的。尤其在当下组件化盛行的潮流里，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片。在上一部分介绍的 <a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#user-content-11-%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">webpack code split</a> 也会包含这一部分。</p><p>除了使用一些构建工具以及对应的插件外，你也可以使用 <a href="https://github.com/filamentgroup/loadCSS">loadCSS</a> 这样的库来实现 CSS 文件的按需异步加载。</p><h5 id="2-2-合并文件"><a href="#2-2-合并文件" class="headerlink" title="#2.2. 合并文件"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-2-%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6">#</a>2.2. 合并文件</h5><p>同样的，参照 JavaScript，我们也可以把一些 CSS 文件进行合并来减少请求数。</p><h5 id="2-3-请求的优先级排序"><a href="#2-3-请求的优先级排序" class="headerlink" title="#2.3. 请求的优先级排序"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-3-%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F">#</a>2.3. 请求的优先级排序</h5><p>浏览器中的各类请求是有优先级排序的。低优请求会被排在高优之后再发送。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/priority.7e69b357.png" alt="network priority"></p><p>不过可惜的是，浏览器没有将优先级排序的能力给我们直接开放出来。但在一些场景下，我们可以通过更合理的使用媒体类型和媒体查询来实现资源加载的优先级。下面会介绍一下这种方法。</p><p>一些网站为了达到不同屏幕之间的兼容，可能会使用媒体查询的方式来构建它的样式系统。一般而言，我们都会把样式代码写在一起，例如导航的在各类屏幕下的样式都会放在 <code>navigator.css</code> 下，列表都会放在 <code>list.css</code> 下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里带来的一个问题就是，在宽度小于 400px 的场景下，其实并不需要应用宽度 400px 以上的 CSS 样式。针对这个问题，<code>link</code> 标签上其实有一个 <code>media</code> 属性来处理媒体查询下的加载优先级。浏览器会优先下载匹配当前环境的样式资源，相对的，其他非匹配的优先级会下降。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.small.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 500px)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.small.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 500px)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样拆分后，当页面大于 500 px 时，<code>navigator.small.css</code> 和 <code>list.small.css</code> 的优先级会降低，同时，<strong>它们也不再会阻塞页面的渲染</strong>。需要注意的是，优先级降低代表可能会后加载，并非不加载。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/priority-css.7c9b4fdb.png" alt="css network priority"></p><h5 id="2-4-慎用-import"><a href="#2-4-慎用-import" class="headerlink" title="#2.4. 慎用 @import"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-4-%E6%85%8E%E7%94%A8-import">#</a>2.4. 慎用 <code>@import</code></h5><p>CSS 提供了一个 <code>@import</code> 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p><p>考虑 <code>index.css</code> 这个资源，页面上是这么引用的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>而在 <code>index.css</code> 中引用了 <code>other.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.css */</span></span><br><span class="line"><span class="keyword">@import</span> url(other.css);</span><br></pre></td></tr></table></figure><p>这样浏览器只有当下载了 <code>index.css</code> 并解析到其中 <code>@import</code> 时，才会再去请求 <code>other.css</code>。这是一个串行过程。</p><p>而如果我们把它改造为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>那就不需要等待 <code>index.css</code> 下载，几乎是并行执行了。</p><h5 id="2-5-谨慎对待-JavaScript-脚本的位置"><a href="#2-5-谨慎对待-JavaScript-脚本的位置" class="headerlink" title="#2.5. 谨慎对待 JavaScript 脚本的位置"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-5-%E8%B0%A8%E6%85%8E%E5%AF%B9%E5%BE%85-javascript-%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%8D%E7%BD%AE">#</a>2.5. 谨慎对待 JavaScript 脚本的位置</h5><p>在<a href="https://alienzhou.com/projects/fe-performance-journey/4-parse/#1-%E6%B3%A8%E6%84%8F%E8%B5%84%E6%BA%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE">第四站「页面解析与处理」</a>中，我们提到将 “JavaScript 脚本放到页面尾部、CSS 放到页面头部”的模式。这只是大多数情况的处理方式。对于一些特殊情况，我们还是需要特殊处理的。</p><p>还记得之前提到的一些统计类、监控类的第三方脚本么？一般而言，第三方会提供你如下一段脚本，然后推荐你内联到页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望通过这样的方式来尽快异步加载脚本。然而，如果我们一不小心出现了下面这样的操作，可能会事与愿违：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时，<code>navigator.css</code> 的加载会阻塞后面的 JavaScript 执行，这是为了防止后续脚本对样式的查询出现不确定性。所以，这两个资源就变成了串行加载。</p><p>要优化这个问题很简单 —— 调换一下顺序即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这时，<code>vendor.lib.js</code> 和 <code>navigator.css</code> 就会并行加载了。当然，你需要确保不需要查询 <code>navigator.css</code> 样式应用后的信息。</p><h4 id="3-减少包体大小"><a href="#3-减少包体大小" class="headerlink" title="#3. 减少包体大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F">#</a>3. 减少包体大小</h4><h5 id="3-1-压缩"><a href="#3-1-压缩" class="headerlink" title="#3.1. 压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-1-%E5%8E%8B%E7%BC%A9">#</a>3.1. 压缩</h5><p>CSS 同样可以进行压缩，与 JavaScript 类似，也有相应的 CSS uglify 工具，例如 <a href="https://github.com/jakubpawlowicz/clean-css">clean-css</a>，可以优化代码、删除多余的换行与空格。</p><p>同时，由于 CSS 同样是文本内容，因此针对文本的各类压缩算法同样适用，最常用到的就是 gzip。如何在 Nginx 上开启它<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#user-content-21-%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9">之前也介绍过</a>，这里就不赘述了。</p><h5 id="3-2-选择合适的兼容性"><a href="#3-2-选择合适的兼容性" class="headerlink" title="#3.2. 选择合适的兼容性"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-2-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">#</a>3.2. 选择合适的兼容性</h5><p>对于 CSS 的 polyfill，同样可以配合 browserslist 来实现你的业务场景下的兼容性支持。比较常见的是配合 <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> 和 <a href="https://github.com/csstools/postcss-preset-env">PostCSS Preset Env</a> 来使用。可以根据指定的浏览器范围，决定使用哪些 CSS polyfill 来帮助你将新的 CSS 代码转换为旧的浏览器能识别的内容。</p><h4 id="4-解析与渲染树构建"><a href="#4-解析与渲染树构建" class="headerlink" title="#4. 解析与渲染树构建"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%A0%91%E6%9E%84%E5%BB%BA">#</a>4. 解析与渲染树构建</h4><h5 id="4-1-简化选择器"><a href="#4-1-简化选择器" class="headerlink" title="#4.1. 简化选择器"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-1-%E7%AE%80%E5%8C%96%E9%80%89%E6%8B%A9%E5%99%A8">#</a>4.1. 简化选择器</h5><p>在 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a> 一文中，作者介绍了样式计算的原理。虽然文章发布时间比较早了，但其中部分内容还是具有参考价值的。</p><p>其中指出了，样式数据是一个超大的结构，为每一个元素查找匹配的规则会造成性能问题，同时，复杂的层叠规则也会带来很高的复杂度。针对这些问题<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation">浏览器也做了很多优化</a>[4]。</p><p>正是由于这些问题，我们应该尽量避免不必要的选择器复杂度。例如下面这个复杂选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">main</span><span class="selector-class">.container</span> &gt; <span class="selector-tag">section</span><span class="selector-class">.intro</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type</span>(odd) + <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> <span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.pdf&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="comment">/* …… */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般情况下我们是不会写出如此复杂的选择器的。但有一个情况还是需要注意一下，就是使用 SASS、LESS 这样的工具时，避免过多的嵌套。以 LESS 为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">    <span class="selector-class">.item</span> &#123;</span><br><span class="line">        <span class="selector-class">.product</span> &#123;</span><br><span class="line">            <span class="selector-class">.intro</span> &#123;</span><br><span class="line">                <span class="selector-class">.pic</span> &#123;</span><br><span class="line">                    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于过多的嵌套，编译后会产生如下选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> <span class="selector-class">.item</span> <span class="selector-class">.product</span> <span class="selector-class">.intro</span> <span class="selector-class">.pic</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以考虑使用类似 <a href="https://en.bem.info/">BEM</a> 这样的方式来进行 <a href="https://www.jianshu.com/p/900e26060c09">CSS className 的组织与命名</a>[5]，避免过多的嵌套层级。这里有<a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/">一篇文章</a>[6]介绍了选择器的匹配成本。</p><p>不过千万要注意了，代码的可维护性还是最重要的，不要为了过分简化选择器而放弃了代码语义和可维护性。我们仅仅是要尽量避免像上面那样的一些过分复杂的、或者不必要的繁琐的选择器。</p><h5 id="4-2-避免使用昂贵的属性"><a href="#4-2-避免使用昂贵的属性" class="headerlink" title="#4.2. 避免使用昂贵的属性"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-2-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%98%82%E8%B4%B5%E7%9A%84%E5%B1%9E%E6%80%A7">#</a>4.2. 避免使用昂贵的属性</h5><p>有一些 CSS 的属性在渲染上是有比较高的成本的，渲染速度相较而言也会慢些。在不同的浏览器上，具体的表现不太一致，但总体来说，下面一些属性是比较昂贵的：</p><ul><li>border-radius</li><li>box-shadow</li><li>opacity</li><li>transform</li><li>filter</li><li>position: fixed</li></ul><h5 id="4-3-使用先进的布局方式"><a href="#4-3-使用先进的布局方式" class="headerlink" title="#4.3. 使用先进的布局方式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-3-%E4%BD%BF%E7%94%A8%E5%85%88%E8%BF%9B%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F">#</a>4.3. 使用先进的布局方式</h5><p>对于页面布局，我们有很多方法，例如 <a href="https://juejin.im/post/5b3b56a1e51d4519646204bb">float、positioning、flex、grid</a>[7] 等。float 本身设计出来并非是为了处理复杂的布局，但是通过大家的发掘和研究，已经可以通过它来实现很多种布局形式了。基于兼容性考虑，float 也成为了流行的布局方式。</p><p>不过，<a href="https://www.zhihu.com/question/271492607">一些资料</a>[8]也指出，使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。 flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局。同时，虽然 flex 有<a href="https://caniuse.com/#search=flex">兼容性要求</a>，但由于很多 PC 站都不再兼容低版本 IE，因此也可以开始尝试使用它。</p><p>如果你之前对 flex 了解不多，这里有一个不错的<a href="https://scrimba.com/g/gflexbox">教程</a>可以帮你快速入门。</p><h4 id="5-利用缓存"><a href="#5-利用缓存" class="headerlink" title="#5. 利用缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_5-%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98">#</a>5. 利用缓存</h4><p>与其他静态资源类似，我们仍然可以使用<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">各类缓存策略</a>来加速资源的加载。</p><p>此外，如果使用 webpack 作为构建工具，我们一般会使用 css-loader 和 style-loader，这样可以直接在 JavaScript 代码中 import 样式文件。不过这样带来的一个问题就是样式代码其实是耦合在 JavaScript 代码中的，通过运行时添加 <code>style</code> 标签注入页面。</p><p>一个更好的做法是在生产环境中将样式信息单独抽离成 CSS 文件，这样也可以更好地利用缓存。在 webpack v4.x 之前的版本中，我们习惯于用 <a href="https://github.com/webpack-contrib/extract-text-webpack-plugin">ExtractTextWebpackPlugin</a> 插件。不过在 v4.x 之后，对于 CSS 的抽取，推荐使用 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a> 插件。它可以将样式信息单独抽离出 CSS 文件来。基础的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&#x27;[contenthash:8].css&#x27;</span>,</span><br><span class="line">      chunkFilename: <span class="string">&#x27;[contenthash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>相较于 JavaScript，用户对 CSS 的可控性可能会稍弱一些，基础的优化点也许没有那么多。但随着 CSS 特性（例如 <a href="https://codersblock.com/blog/say-hello-to-houdini-and-the-css-paint-api/">Houdini/CSS Paint API</a>）的不断发展，相信也会有更多我们需要关注的优化点。</p><h4 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a">Everything you need to know about skeleton screens</a></li><li><a href="https://css-tricks.com/building-skeleton-screens-css-custom-properties/">Building Skeleton Screens with CSS Custom Properties</a></li><li><a href="https://zhuanlan.zhihu.com/p/34702561">自动化生成 H5 骨架页面</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://www.jianshu.com/p/900e26060c09">使用 BEM-constructor 构建 CSS</a></li><li><a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/">Optimizing CSS: ID Selectors and Other Myths</a></li><li><a href="https://juejin.im/post/5b3b56a1e51d4519646204bb">一篇全面的CSS布局学习指南(译)</a></li><li><a href="https://www.zhihu.com/question/271492607">flex布局对性能的影响主要体现在哪方面？</a></li><li><a href="https://csswizardry.com/2018/11/css-and-network-performance/">CSS and Network Performance</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css">Render Blocking CSS</a></li><li><a href="https://blog.nextzy.me/how-to-write-css-for-a-great-performance-web-application-edf75bb8a8cc">How to write CSS for a great performance web application</a></li><li><a href="https://www.sitepoint.com/optimizing-css-performance/">20 Tips for Optimizing CSS Performance</a></li></ol><h3 id="5-4图片优化"><a href="#5-4图片优化" class="headerlink" title="5.4图片优化"></a>5.4<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html">图片优化</a></h3><p>优质的图片可以有效吸引用户，给用户良好的体验，所以随着互联网的发展，越来越多的产品开始使用图片来提升产品体验。相较于页面其他元素，图片的体积不容忽视。下图是截止 2019 年 6 月 <a href="https://httparchive.org/reports/page-weight?view=grid">HTTP Archive</a>[1] 上统计的网站上各类资源加载的体积：</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/overall.51635114.png" alt="overall"></p><p>可以看到，图片占据了半壁江山。同样，在一篇 2018 年的文章中，也提到了<a href="https://dougsillars.com/2018/05/21/state-of-the-web-top-image-optimization-strategies/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more">图片在网站中体量的平均占比已经超过了 50%</a>[2]。然而，随着平均加载图片总字节数的增加，图片的请求数却再减少，这也说明网站使用的图片质量和大小正在不断提高。</p><p>所以，如果单纯从加载的字节数这个维度来看性能优化，那么很多时候，优化图片带来的流量收益要远高于优化 JavaScript 脚本和 CSS 样式文件。下面我们就来看看，如何优化图片资源。</p><h4 id="1-优化请求数"><a href="#1-优化请求数" class="headerlink" title="#1. 优化请求数"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-%E4%BC%98%E5%8C%96%E8%AF%B7%E6%B1%82%E6%95%B0">#</a>1. 优化请求数</h4><h5 id="1-1-雪碧图"><a href="#1-1-雪碧图" class="headerlink" title="#1.1. 雪碧图"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-1-%E9%9B%AA%E7%A2%A7%E5%9B%BE">#</a>1.1. 雪碧图</h5><p>图片可以合并么？当然。最为常用的图片合并场景就是<a href="https://css-tricks.com/css-sprites/">雪碧图（Sprite）</a>[3]。</p><p>在网站上通常会有很多小的图标，不经优化的话，最直接的方式就是将这些小图标保存为一个个独立的图片文件，然后通过 CSS 将对应元素的背景图片设置为对应的图标图片。这么做的一个重要问题在于，页面加载时可能会同时请求非常多的小图标图片，这就会受到浏览器并发 HTTP 请求数的限制。我见过一个没有使用雪碧图的页面，首页加载时需要发送 20+ 请求来加载图标。将图标合并为一张大图可以实现「20+ → 1」的巨大缩减。</p><p>雪碧图的核心原理在于设置不同的背景偏移量，大致包含两点：</p><ul><li>不同的图标元素都会将 <code>background-url</code> 设置为合并后的雪碧图的 uri；</li><li>不同的图标通过设置对应的 <code>background-position</code> 来展示大图中对应的图标部分。</li></ul><p>你可以用 Photoshop 这类工具自己制作雪碧图。当然比较推荐的还是将雪碧图的生成集成到前端自动化构建工具中，例如在 webpack 中使用 <a href="https://github.com/mixtur/webpack-spritesmith">webpack-spritesmith</a>，或者在 gulp 中使用 <a href="https://github.com/twolfson/gulp.spritesmith">gulp.spritesmith</a>。它们两者都是基于于 <a href="https://github.com/twolfson/spritesmith">spritesmith</a> 这个库，你也可以自己将这个库集成到你喜欢的构建工具中。</p><h5 id="1-2-懒加载"><a href="#1-2-懒加载" class="headerlink" title="#1.2. 懒加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-2-%E6%87%92%E5%8A%A0%E8%BD%BD">#</a>1.2. 懒加载</h5><p>我们知道，一般来说我们访问一个页面，浏览器加载的整个页面其实是要比可视区域大很多的，也是什么我们会提出“首屏”的概念。这就导致其实很多图片是不在首屏中的，如果我们都加载的话，相当于是加载了用户不一定会看到图片。而图片体积一般都不小，这显然是一种流量的浪费。这种场景在一些带图片的长列表或者配图的博客中经常会遇到。</p><p>解决的核心思路就是图片懒加载 —— 尽量只加载用户正在浏览或者即将会浏览到的图片。实现上来说最简单的就是通过监听页面滚动，判断图片是否进入视野，从而真正去加载图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadIfNeeded</span>(<span class="params">$img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bounding = $img..getBoundingClientRect();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        getComputedStyle($img).display !== <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &amp;&amp; bounding.top &lt;= <span class="built_in">window</span>.innerHeight</span><br><span class="line">        &amp;&amp; bounding.bottom &gt;= <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        $img.src = $img.dataset.src;</span><br><span class="line">        $img.classList.remove(<span class="string">&#x27;lazy&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash</span></span><br><span class="line"><span class="keyword">const</span> lazy = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> $imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.lazy&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ($imgList.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazy);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;resize&#x27;</span>, lazy);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;orientationchange&#x27;</span>, lazy);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $imgList.forEach(loadIfNeeded);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazy);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, lazy);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;orientationchange&#x27;</span>, lazy);</span><br></pre></td></tr></table></figure><p>对于页面上的元素只需要将原本的 <code>src</code> 值设置到 <code>data-src</code> 中即可，而 <code>src</code> 可以设置为一个统一的占位图。注意，由于页面滚动、缩放和横竖方向（移动端）都可能会改变可视区域，因此添加了三个监听。</p><p>当然，这是最传统的方法，现代浏览器还提供了一个更先进的 <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">Intersection Observer API</a>[4] 来做这个事，它可以通过更高效的方式来监听元素是否进入视口。考虑兼容性问题，在生产环境中建议使用对应的 <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill">polyfill</a>。</p><p>如果想使用懒加载，还可以借助一些已有的工具库，例如 <a href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a>、<a href="https://github.com/verlok/lazyload">verlok/lazyload</a>、<a href="https://github.com/tuupola/lazyload">tuupola/lazyload</a> 等。</p><p>在使用懒加载时也有一些注意点：</p><ul><li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li><li>设置合理的占位图，避免图片加载后的页面“抖动”。</li><li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup。</li></ul><p>对于占位图这块可以再补充一点。为了更好的用户体验，我们可以使用一个基于原图生成的体积小、清晰度低的图片作为占位图。这样一来不会增加太大的体积，二来会有很好的用户体验。<a href="https://www.guypo.com/introducing-lqip-low-quality-image-placeholders">LQIP (Low Quality Image Placeholders)</a>[5] 就是这种技术。目前也已经有了 <a href="https://github.com/zouhir/lqip">LQIP</a> 和 <a href="https://github.com/axe312ger/sqip">SQIP(SVG-based LQIP)</a> 的自动化工具可以直接使用。</p><p>如果你想了解更多关于图片懒加载的内容，这里有一篇更详尽的<a href="https://css-tricks.com/the-complete-guide-to-lazy-loading-images/">图片懒加载指南</a>[6]。</p><h5 id="1-3-CSS-中的图片懒加载"><a href="#1-3-CSS-中的图片懒加载" class="headerlink" title="#1.3. CSS 中的图片懒加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-3-css-%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">#</a>1.3. CSS 中的图片懒加载</h5><p>除了对于 <code>&lt;img&gt;</code> 元素的图片进行来加载，在 CSS 中使用的图片一样可以懒加载，最常见的场景就是 <code>background-url</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.login</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>-url: <span class="built_in">url</span>(<span class="string">/static/img/login.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。所以你可以通过切换 className 的方式，放心得进行 CSS 中图片的懒加载。</p><h5 id="1-4-内联-base64"><a href="#1-4-内联-base64" class="headerlink" title="#1.4. 内联 base64"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-4-%E5%86%85%E8%81%94-base64">#</a>1.4. 内联 base64</h5><p>还有一种方式是将图片转为 base64 字符串，并将其内联到页面中返回，即将原 url 的值替换为 base64。这样，当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可。</p><p>但是这种方式的一个缺点在于相同的图片，相比使用二进制，变成 base64 后体积会增大 33%。而全部内联进页面后，也意味着原本可能并行加载的图片信息，都会被放在页面请求中（像当于是串行了）。同时这种方式也不利于复用独立的文件缓存。所以，使用 base64 需要权衡，常用于首屏加载 CRP 或者骨架图上的一些小图标。</p><h4 id="2-减小图片大小"><a href="#2-减小图片大小" class="headerlink" title="#2. 减小图片大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-%E5%87%8F%E5%B0%8F%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">#</a>2. 减小图片大小</h4><h5 id="2-1-使用合适的图片格式"><a href="#2-1-使用合适的图片格式" class="headerlink" title="#2.1. 使用合适的图片格式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-1-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F">#</a>2.1. 使用合适的图片格式</h5><p>使用合适的图片格式不仅能帮助你减少不必要的请求流量，同时还可能提供更好的图片体验。</p><p>图片格式是一个比较大的话题，<a href="https://www.sitepoint.com/what-is-the-right-image-format-for-your-website/">选择合适的格式</a>[7]有利于性能优化。这里我们简单总结一些。</p><p><strong>1) 使用 WebP：</strong></p><p>考虑<a href="https://css-tricks.com/using-webp-images/">在网站上使用 WebP 格式</a>[8]。在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式。WebP 无损压缩比 PNG 的体积小 26%，webP 的有损压缩比同质量的 JPEG 格式体积小 25-34%。同时 WebP 也支持透明度。下面提供了一种兼容性较好的写法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/static/img/perf.webp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/static/img/perf.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/img/perf.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2) 使用 SVG 应对矢量图场景：</strong></p><p>在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错。有时使用 SVG 格式会比相同的 PNG 或 JPEG 更小。</p><p><strong>3) 使用 video 替代 GIF：</strong></p><p>在<a href="https://caniuse.com/#feat=video">兼容性允许</a>的情况下考虑，可以在想要动图效果时使用视频，通过静音（muted）的 video 来代替 GIF。相同的效果下，<a href="https://youtu.be/reztLS3vomE?t=158">GIF 比视频（MPEG-4）大 5～20 倍</a>。<a href="https://www.smashingmagazine.com/2018/11/gif-to-video/">Smashing Magazine 上有篇文章</a>[9]详细介绍使用方式。</p><p><strong>4) 渐进式 JPEG：</strong></p><p>基线 JPEG (baseline JPEG) 会从上往下逐步呈现，类似下面这种：</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/baseline-jpeg.12d690f4.jpeg" alt="baseline jpeg"></p><p>而另一种<a href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式 JPEG (progressive JPEG)</a>[10] 则会从模糊到逐渐清晰，使人的感受上会更加平滑。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/progressive-jpeg.9dc04432.jpeg" alt="progressive jpeg"></p><p>不过渐进式 JPEG 的解码速度会慢于基线 JPEG，所以还是需要综合考虑 CPU、网络等情况，在实际的用户体验之上做权衡。</p><h5 id="2-2-图片质量的权衡"><a href="#2-2-图片质量的权衡" class="headerlink" title="#2.2. 图片质量的权衡"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-2-%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E6%9D%83%E8%A1%A1">#</a>2.2. 图片质量的权衡</h5><p>图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression）。顾名思义，有损压缩下，会损失一定的图片质量，无损压缩则能够在保证图片质量的前提下压缩数据大小。不过，无损压缩一般可以带来更可观的体积缩减。在使用有损压缩时，一般我们可以指定一个 0-100 的压缩质量。在大多数情况下，相较于 100 质量系数的压缩，80～85 的质量系数可以带来 30～40% 的大小缩减，同时对图片效果影响较小，即人眼不易分辨出质量效果的差异。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/jpeg-quality.db4579d5.jpg" alt="jpeg quality"></p><p>处理图片压缩可以使用 <a href="https://github.com/imagemin/imagemin">imagemin</a> 这样的工具，也可以进一步将它集成至 <a href="https://github.com/tcoopman/image-webpack-loader">webpack</a>、<a href="https://github.com/sindresorhus/gulp-imagemin">Gulp</a>、<a href="https://github.com/gruntjs/grunt-contrib-imagemin">Grunt</a> 这样的自动化工具中。</p><h5 id="2-3-使用合适的大小和分辨率"><a href="#2-3-使用合适的大小和分辨率" class="headerlink" title="#2.3. 使用合适的大小和分辨率"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-3-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87">#</a>2.3. 使用合适的大小和分辨率</h5><p>由于移动端的发展，屏幕尺寸更加多样化了。同一套设计在不同尺寸、像素比的屏幕上可能需要不同像素大小的图片来保证良好的展示效果；此外，响应式设计也会对不同屏幕上最佳的图片尺寸有不同的要求。</p><p>以往我们可能会在 1280px 宽度的屏幕上和 640px 宽度的屏幕上都使用一张 400px 的图，但很可能在 640px 上我们只需要 200px 大小的图片。另一方面，对于如今盛行的“2 倍屏”、“3 倍屏”也需要使用不同像素大小的资源。</p><p>好在 HTML5 在 <code>&lt;img&gt;</code> 元素上为我们提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-srcset"><code>srcset</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes"><code>sizes</code></a> 属性，可以让浏览器根据屏幕信息选择需要展示的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;small.jpg 480w, large.jpg 1080w&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;50w&quot;</span> <span class="attr">src</span>=<span class="string">&quot;large.jpg&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>具体的使用方式可以看<a href="https://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/">这篇文章</a>[11]。</p><h5 id="2-4-删除冗余的图片信息"><a href="#2-4-删除冗余的图片信息" class="headerlink" title="#2.4. 删除冗余的图片信息"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-4-%E5%88%A0%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF">#</a>2.4. 删除冗余的图片信息</h5><p>你也许不知道，很多图片含有一些非“视觉化”的元信息（metadata），带上它们可会<a href="https://www.keycdn.com/blog/image-metadata">导致体积增大与安全风险</a>[12]。元信息包括图片的 DPI、相机品牌、拍摄时的 GPS 等，可能导致 JPEG 图片大小增加 15%。同时，其中的一些隐私信息也可能会带来安全风险。</p><p>所以如果不需要的情况下，可以使用像 <a href="https://imageoptim.com/versions">imageOptim</a> 这样的工具来移除隐私与非关键的元信息。</p><h5 id="2-5-SVG-压缩"><a href="#2-5-SVG-压缩" class="headerlink" title="#2.5 SVG 压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-5-svg-%E5%8E%8B%E7%BC%A9">#</a>2.5 SVG 压缩</h5><p>在 2.1. 中提到，合适的场景下可以使用 SVG。针对 SVG 我们也可以进行一些压缩。压缩包括了两个方面：</p><p>首先，与图片不同，图片是二进制形式的文件，而 SVG 作为一种 XML 文本，同样是适合使用 gzip 压缩的。</p><p>其次，SVG 本身的信息、数据是可以压缩的，例如用相比用 <code>&lt;path&gt;</code> 画一个椭圆，直接使用 <code>&lt;ellipse&gt;</code> 可以节省文本长度。关于信息的“压缩”还有<a href="https://css-tricks.com/understanding-and-manually-improving-svg-optimization/">更多可以优化的点</a>[13]。<a href="https://github.com/svg/svgo">SVGGO</a> 是一个可以集成到我们构建流中的 NodeJS 工具，它能帮助我们进行 SVG 的优化。当然你也可以使用它提供的 <a href="https://jakearchibald.github.io/svgomg/">Web 服务</a>。</p><h4 id="3-缓存"><a href="#3-缓存" class="headerlink" title="#3. 缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_3-%E7%BC%93%E5%AD%98">#</a>3. 缓存</h4><p>与其他静态资源类似，我们仍然可以使用<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">各类缓存策略</a>来加速资源的加载。</p><hr><p>图片作为现代 Web 应用的重要部分，在资源占用上同样也不可忽视。可以发现，在上面提及的各类优化措施中，同时附带了相应的工具或类库。平时我们主要的精力会放在 CSS 与 JavaScript 的优化上，因此在图片优化上可能概念较为薄弱，自动化程度较低。如果你希望更好得去贯彻图片的相关优化，非常建议将自动化工具引入到构建流程中。</p><p>除了上述的一些工具，这里再介绍两个非常好用的图片处理的自动化工具：<a href="https://github.com/lovell/sharp">Sharp</a> 和 <a href="https://github.com/oliver-moran/jimp">Jimp</a>。</p><hr><h4 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://httparchive.org/reports/page-weight?view=grid">HTTP Archive: Page Weight Report</a></li><li><a href="https://dougsillars.com/2018/05/21/state-of-the-web-top-image-optimization-strategies/">State of the Web: Top Image Optimization Strategies</a></li><li><a href="https://css-tricks.com/css-sprites/">CSS Sprites: What They Are, Why They’re Cool, and How To Use Them</a></li><li><a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">IntersectionObserver’s Coming into View</a></li><li><a href="https://www.guypo.com/introducing-lqip-low-quality-image-placeholders">Introducing LQIP – Low Quality Image Placeholders</a></li><li><a href="https://css-tricks.com/the-complete-guide-to-lazy-loading-images/">The Complete Guide to Lazy Loading Images</a></li><li><a href="https://www.sitepoint.com/what-is-the-right-image-format-for-your-website/">What Is the Right Image Format for Your Website?</a></li><li><a href="https://css-tricks.com/using-webp-images/">Using WebP Images</a></li><li><a href="https://www.smashingmagazine.com/2018/11/gif-to-video/">Improve Animated GIF Performance With HTML5 Video</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式jpeg(progressive jpeg)图片及其相关</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/">响应式图片srcset全新释义sizes属性w描述符</a></li><li><a href="https://www.keycdn.com/blog/image-metadata">An Overview of Image Metadata - How It Affects Web Performance and Security</a></li><li><a href="https://css-tricks.com/understanding-and-manually-improving-svg-optimization/">Understanding and Manually Improving SVG Optimization</a></li><li><a href="https://images.guide/">Essential Image Optimization Guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/50280008">见微知著，Google Photos Web UI 完善之旅</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/">Automating image optimization</a></li><li><a href="http://deanhume.com/lazy-loading-images-using-intersection-observer/">Lazy loading images using Intersection Observer</a></li><li><a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2">Trust is Good, Observation is Better—Intersection Observer v2</a></li><li><a href="https://web.dev/image-policies/">Image policies for fast load times and more</a></li></ol><h3 id="5-5字体优化"><a href="#5-5字体优化" class="headerlink" title="5.5字体优化"></a>5.5<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html">字体优化</a></h3><p>有些时候，内置的字体并不能满足我们的需求，如果我们希望使用一些更有设计性的字体，我们一般会使用 <code>@font-face</code> 来加载字体文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这种方式的一大问题在于，在字体加载的期间，浏览器页面是默认不展示文本内容的。即我们常说的 FOIT (Flash of Invisible Text)。在现代浏览器中，FOIT 持续至多 3 秒，会带来糟糕的用户体验。所以在字体这部分的性能优化中，主要关注点在于如何平滑的加载字体。下面有一些解决方案。</p><h4 id="1-font-display"><a href="#1-font-display" class="headerlink" title="#1. font-display"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_1-font-display">#</a>1. font-display</h4><p>你可以在 <code>@font-face</code> 中设置 <code>font-display: swap</code>，他可以让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，即先会使用默认字体样式展示文本，字体加载完毕后再将文本的字体样式进行替换。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">    <span class="attribute">font-display</span>: swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>font-display 的取值包括 <code>auto|block|swap|fallback|optional</code>，这里详细介绍了<a href="https://developers.google.com/web/updates/2016/02/font-display">各种值的使用场景</a>[1]。不过目前该属性的<a href="https://caniuse.com/#feat=css-font-rendering-controls">兼容性一般</a>。</p><h4 id="2-内联字体"><a href="#2-内联字体" class="headerlink" title="#2. 内联字体"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_2-%E5%86%85%E8%81%94%E5%AD%97%E4%BD%93">#</a>2. 内联字体</h4><p>我们在上一节介绍过，可以使用 base64 将图片“内联”到页面中。同样的，字体也可以使用这种方式，这样就避免异步加载字体时的 FOIT 或 FOUT。我们可以将字体文件转为 base64 的字符串，设置到 <code>@font-face</code> 里的 <code>src</code> 属性上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方式的局限性在于，在一个 <code>@font-face</code> 中只能加载加载一种字体类型。同时，与使用内联图片一样，这也会将本可以并行请求的数据量变为串行。</p><h4 id="3-使用-CSS-Font-Loading-API"><a href="#3-使用-CSS-Font-Loading-API" class="headerlink" title="#3. 使用 CSS Font Loading API"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_3-%E4%BD%BF%E7%94%A8-css-font-loading-api">#</a>3. 使用 CSS Font Loading API</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API">CSS Font Loading API</a> 是浏览器提供的，可以用来自定义控制字体加载的 API。这样你就可以在 JavaScript 中进行字体的加载，等加载完成后，再将需要应用新字体的元素设置为对应的样式，例如添加一个对应的 className。这里介绍了<a href="https://medium.com/@matuzo/getting-started-with-css-font-loading-e24e7ffaa791">如何使用 CSS Font Loading API</a>[2]。</p><p>不过目前 <a href="https://caniuse.com/#feat=font-loading">CSS Font Loading API 的兼容性</a>也不乐观。同时，由于一些困难也<a href="https://github.com/bramstein/fontloader#deprecated">无法实现一个完美的 polyfill</a>。因此如果想要使用类似的能力，可以考虑 <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a>这个库。基本的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> font = <span class="keyword">new</span> FontFaceObserver(<span class="string">&#x27;Samplefont&#x27;</span>);</span><br><span class="line"></span><br><span class="line">font.load(<span class="literal">null</span>, <span class="number">5000</span>).then(</span><br><span class="line">    () =&gt; <span class="built_in">document</span>.documentElement.classList.add(<span class="string">&#x27;loaded&#x27;</span>),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">&#x27;Font is not available&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loaded</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Samplefont, sans-serif;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-FOFT"><a href="#4-FOFT" class="headerlink" title="#4. FOFT"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_4-foft">#</a>4. FOFT</h4><p>在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p><p>首先你需要了解的是，对于一种字体，它的斜体与粗体是有专门的字符集的；与此同时，如果你指定了某种字体的粗体，但浏览器没有加载，那么你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-synthesis"><code>font-synthesis</code></a> 属性来让浏览器帮你模拟。而当实际的粗体或斜体加载完毕后，再使用实际的字体集。</p><p>具体实践起会借助上面提到的 CSS Font Loading API 或者 Font Face Observer，实现当字体加载完毕后的样式修改。</p><hr><p>了解完字体的优化措施你会发现，它们主要集中于 <strong>如何通过加载策略来降低甚至消除 FOIT</strong>。当然上面提到的这些策略与技术你可以组合使用，以达到所需的优化效果。</p><p>如果还想了解更多关于字体加载的问题，可以看看这篇文章里总结的<a href="https://www.zachleat.com/web/comprehensive-webfonts/">各类加载策略</a>[3]，它还随文提供了相应的代码示例。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/font-strategies.ef47066c.svg" alt="font strategy"></p><h4 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://developers.google.com/web/updates/2016/02/font-display">Controlling Font Performance with font-display</a></li><li><a href="https://medium.com/@matuzo/getting-started-with-css-font-loading-e24e7ffaa791">Getting started with CSS Font Loading</a></li><li><a href="https://www.zachleat.com/web/comprehensive-webfonts/">A COMPREHENSIVE GUIDE TO FONT LOADING STRATEGIES</a></li></ol><h3 id="5-6视频优化"><a href="#5-6视频优化" class="headerlink" title="5.6视频优化"></a>5.6<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html">视频优化</a></h3><p>视频作为一种重要的媒体形态，在网站中使用可以提高网站内容的丰富性，但同时对网络加载来说也是一个负担。所以会出现一些如下针对 Web 上视频的优化。</p><h4 id="1-使用合适的视频格式"><a href="#1-使用合适的视频格式" class="headerlink" title="#1. 使用合适的视频格式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_1-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F">#</a>1. 使用合适的视频格式</h4><p>与图片类似，不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4。除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。</p><p>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，不过<a href="https://caniuse.com/#feat=webm">兼容性相对来说也较差</a>。因此可以考虑在 <code>&lt;video&gt;</code> 中指定多个 <code>&lt;source&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/static/video/me.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/static/video/me.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，使用 <a href="https://www.youtube.com/watch?v=04lXWMcwdXA">AV1 编码</a>[1]会比 <a href="https://youtu.be/reztLS3vomE?t=356">VP9(WebM) 小约30%，比 x264(MPEG-4) 小约45-50%</a>[2]。</p><h4 id="2-视频压缩"><a href="#2-视频压缩" class="headerlink" title="#2. 视频压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_2-%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9">#</a>2. 视频压缩</h4><p>对于视频，我们也可以进行有损与无损压缩，同样可以有效减少视频大小。下面列举了一些常用的工具：</p><ul><li><a href="https://handbrake.fr/">HandBrake</a></li><li><a href="https://www.freemake.com/free_video_converter/">Freemake</a></li><li><a href="http://www.selur.de/">Hybrid</a></li><li><a href="https://sourceforge.net/projects/megui/">MeGUI</a></li></ul><h4 id="3-移除不必要的音轨信息"><a href="#3-移除不必要的音轨信息" class="headerlink" title="#3. 移除不必要的音轨信息"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_3-%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%9F%B3%E8%BD%A8%E4%BF%A1%E6%81%AF">#</a>3. 移除不必要的音轨信息</h4><p>在上一节中我们提到，可以使用 <code>&lt;video&gt;</code> 代替 GIF 来实现动画，同时体积也会更小。由于在这种场景下本身就是不需要声音的，所以我们会将 <code>&lt;video&gt;</code> 设置为 <code>muted</code>。</p><p>那么，既然不需要声音，我们是不是可以直接移除掉音轨的数据？是的，这样做也会帮助进一步缩减视频的体积。</p><h4 id="4-使用“流”"><a href="#4-使用“流”" class="headerlink" title="#4. 使用“流”"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_4-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%B5%81%E2%80%9D">#</a>4. 使用“流”</h4><p>尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术。简单来说，使用 HLS 技术，你的视频会包含一个 <code>.m3u8</code> 的索引文件和一系列包含播放内容的 <code>.ts</code> 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p><p>你也可以尝试使用 <a href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP">MPEG-DASH</a>[3] 这个技术，目前开源社区也有一个配套的<a href="https://github.com/Dash-Industry-Forum/dash.js">客户端实现</a>。</p><h4 id="5-移除不必要的视频"><a href="#5-移除不必要的视频" class="headerlink" title="#5. 移除不必要的视频"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_5-%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%A7%86%E9%A2%91">#</a>5. 移除不必要的视频</h4><p>对于不需要使用视频的场景，最好的优化方法就是去掉视频。例如在小屏幕上，你可以通过媒体查询来避免下载视频：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">650px</span>) &#123;</span><br><span class="line">    <span class="selector-id">#hero-video</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于视频的优化这里只介绍了一些基本的手段，但对于一个重度的视频网站来说，会包含例如播放器 SDK 的优化、数据预取、码率自适应等更多的优化内容，在 2019 GMTC 上，[B站分享了他们的缩减首帧耗时的一系列优化措施](<a href="https://static001.geekbang.org/con/42/pdf/3841774823/file/%E8%B0%AD%E5%85%86%E6%AD%86%E2%80%94GMTC">https://static001.geekbang.org/con/42/pdf/3841774823/file/谭兆歆—GMTC</a> B站的视频体验进化之路 - bilibili .pdf)[4]。所以这里算是一个抛砖引玉。</p><p>此外，虽然上面介绍了一些视频处理的软件工具，但是如果有更高的定制化或集成需求，建议使用 <a href="https://www.ffmpeg.org/">FFmpeg</a>[5] 或其<a href="https://github.com/FFmpeg/FFmpeg#libraries">背后的这些包</a>。</p><h4 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://www.youtube.com/watch?v=04lXWMcwdXA">a technial overview of the AV1</a></li><li><a href="https://youtu.be/reztLS3vomE?t=356">Speed Essentials: Key Techniques for Fast Websites (Chrome Dev Summit 2018)</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP">Dynamic Adaptive Streaming over HTTP (Wikipedia)</a></li><li>[B 站的视频体验进化之路](<a href="https://static001.geekbang.org/con/42/pdf/3841774823/file/%E8%B0%AD%E5%85%86%E6%AD%86%E2%80%94GMTC">https://static001.geekbang.org/con/42/pdf/3841774823/file/谭兆歆—GMTC</a> B站的视频体验进化之路 - bilibili .pdf)</li><li><a href="https://www.ffmpeg.org/">FFmepg</a></li><li><a href="https://www.keycdn.com/blog/video-optimization">8 Video Optimization Tips for Faster Loading Times</a></li><li><a href="https://rigor.com/blog/optimizing-mp4-video-for-fast-streaming">Optimizing MP4 Video for Fast Streaming</a></li><li><a href="https://blog.catchpoint.com/2017/06/16/web-performance-101-video-optimization/">Web Performance 101: Video Optimization</a></li></ol><h1 id="3-重排-reflow-和重绘-repaint"><a href="#3-重排-reflow-和重绘-repaint" class="headerlink" title="3.重排(reflow)和重绘(repaint)"></a>3.重排(reflow)和重绘(repaint)</h1><h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；</p><p>2.CSS 被 CSS 解析器解析成 CSSOM 树；</p><p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p><p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p><p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af501e710ce67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。</p><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><table><thead><tr><th>常见引起重排属性和方法</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>clientTop</td><td>clientLeft</td></tr><tr><td>offsetWudth</td><td>offsetHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>scrollIntoView()</td><td>scrollTo()</td><td>getComputedStyle()</td><td></td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewIfNeeded()</td><td></td><td></td></tr></tbody></table><h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;&#x2F;strong&gt;BDing&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table><thead><tr><th>属性：</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td>background-size</td><td></td></tr></tbody></table><h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">var left &#x3D; 10;</span><br><span class="line">var top &#x3D; 10;</span><br><span class="line">el.style.left &#x3D; left + &quot;px&quot;;</span><br><span class="line">el.style.top &#x3D; top + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当top和left的值是动态计算而成时...</span><br><span class="line">&#x2F;&#x2F; better </span><br><span class="line">el.style.cssText +&#x3D; &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.className +&#x3D; &quot; className&quot;;</span><br></pre></td></tr></table></figure><h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad 强制刷新 触发四次重排+重绘</span><br><span class="line">div.style.left &#x3D; div.offsetLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; div.offsetTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; div.offsetRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; div.offsetBottom + 1 + &#39;px&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span><br><span class="line">var curLeft &#x3D; div.offsetLeft;</span><br><span class="line">var curTop &#x3D; div.offsetTop;</span><br><span class="line">var curRight &#x3D; div.offsetRight;</span><br><span class="line">var curBottom &#x3D; div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left &#x3D; curLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; curTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; curRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; curBottom + 1 + &#39;px&#39;;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 根据上面的结论</span><br><span class="line">* 将 2d transform 换成 3d</span><br><span class="line">* 就可以强制开启 GPU 加速</span><br><span class="line">* 提高动画性能</span><br><span class="line">*&#x2F;</span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(10px, 10px, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af50e460d9a23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ul><li>蓝色: 网络通信和HTML解析</li><li>黄色: JavaScript执行</li><li>紫色: 样式计算和布局，即重排</li><li>绿色: 重绘</li></ul><p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af5139b7ba71b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li><li>CSS3 就是在 GPU 发生的：Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://segmentfault.com/a/1190000017491520">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a></p><p><a href="https://csstriggers.com/">csstriggers</a></p><p><a href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/">CSS硬件加速的好与坏</a></p><h1 id="4-白屏时间"><a href="#4-白屏时间" class="headerlink" title="4.白屏时间"></a>4.白屏时间</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。</p><blockquote><p>白屏时间的长短将直接影响用户对该网站的第一印象。</p></blockquote><h2 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h2><p>当用户点开一个链接或者是直接在浏览器中输入URL开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。</p><h2 id="三、白屏是一个怎样的过程呢？"><a href="#三、白屏是一个怎样的过程呢？" class="headerlink" title="三、白屏是一个怎样的过程呢？"></a>三、白屏是一个怎样的过程呢？</h2><blockquote><p>让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！</p></blockquote><h3 id="1-DNS-Lookup"><a href="#1-DNS-Lookup" class="headerlink" title="1. DNS Lookup"></a>1. DNS Lookup</h3><blockquote><p>DNS Lookup 即浏览器从DNS服务器中进行域名查询。</p></blockquote><p>浏览器会先对页面进行<a href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>，获取到服务器的IP地址后，进而和服务器进行通信。</p><p>Tips: 通常在整个加载页面的过程中，浏览器会多次进行DNS Lookup，包括页面本身的域名查询以及在解析HTML页面时加载的JS、CSS、Image、Video等资源产生的域名查询。</p><h3 id="2-建立TCP请求连接"><a href="#2-建立TCP请求连接" class="headerlink" title="2. 建立TCP请求连接"></a>2. 建立TCP请求连接</h3><p>浏览器和服务端TCP请求建立的过程，是基于TCP/IP，该协议由网络层的IP和传输层的TCP组成。IP是每一台互联网设备在互联网中的唯一地址。</p><p>TCP通过三次握手建立连接，并提供可靠的数据传输服务。</p><h3 id="3-服务端请求处理响应"><a href="#3-服务端请求处理响应" class="headerlink" title="3. 服务端请求处理响应"></a>3. 服务端请求处理响应</h3><p>在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。</p><p>Web服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS文件、静态HTML直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。</p><blockquote><p>在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据</p></blockquote><h3 id="4-客户端下载、解析、渲染显示页面"><a href="#4-客户端下载、解析、渲染显示页面" class="headerlink" title="4. 客户端下载、解析、渲染显示页面"></a>4. 客户端下载、解析、渲染显示页面</h3><p>在服务器返回数据后，客户端浏览器接收数据，进行HTML下载、解析、渲染显示。</p><ul><li>a. 如果是Gzip包，则先解压为HTML</li><li>b. 解析HTML的头部代码，下载头部代码中的样式资源文件或脚本资源文件</li><li>c. 解析HTML代码和样式文件代码，构建HTML的DOM树以及与CSS相关的CSSOM树</li><li>d. 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树</li><li>e. 根据渲染树完成绘制过程</li></ul><p>浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。</p><p>Tips:浏览器安全解析策略对解析HTML造成的影响：</p><ul><li>当解析HTML时遇到内联JS代码，会阻塞DOM树的构建</li><li>特别悲惨的情况： 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时！！！根据浏览器的安全解析策略，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。 一定要合理放置JS代码！！！</li></ul><h2 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h2><p>至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。</p><h3 id="1-DNS解析优化"><a href="#1-DNS解析优化" class="headerlink" title="1. DNS解析优化"></a>1. DNS解析优化</h3><p>针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。</p><ul><li>DNS缓存优化</li><li>DNS预加载策略</li><li>稳定可靠的DNS服务器</li></ul><h3 id="2-TCP网络链路优化"><a href="#2-TCP网络链路优化" class="headerlink" title="2. TCP网络链路优化"></a>2. TCP网络链路优化</h3><p>针对网络链路的优化，好像除了花钱没有什么更好的方式！</p><h3 id="3-服务端处理优化"><a href="#3-服务端处理优化" class="headerlink" title="3. 服务端处理优化"></a>3. 服务端处理优化</h3><p>服务端的处理优化，是一个非常庞大的话题，会涉及到如<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等…</p><h3 id="4-浏览器下载、解析、渲染页面优化"><a href="#4-浏览器下载、解析、渲染页面优化" class="headerlink" title="4. 浏览器下载、解析、渲染页面优化"></a>4. 浏览器下载、解析、渲染页面优化</h3><p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p><ul><li>尽可能的精简HTML的代码和结构</li><li>尽可能的优化CSS文件和结构</li><li>一定要合理的放置JS代码，尽量不要使用内联的JS代码</li></ul><h1 id="5-图片加载优化方案"><a href="#5-图片加载优化方案" class="headerlink" title="5.图片加载优化方案"></a>5.图片加载优化方案</h1><p>饿了么 App 中新零售项目主要是以图片展示为主，引导用户点击轮播广告栏或者店铺列表进入指定的商品页面，因此页面中包含了大量图片，如搜索框下面的轮播广告栏、中部的促销栏以及底部的店铺列表，这些区域中都有大量的展示图片。因此图片的加载速率直接影响页面的加载速度。下面将从图片加载存在的问题和原因、解决方案两个方面来阐述如何优化新零售图片的加载。</p><p>本文所有数据及图片都是通过 <strong>Charles</strong> 模拟 256 kbps ISDN/DSL 网络环境获取到的。在本案例中只考虑位图，因此文本中提及的图片都是指位图而非矢量图。</p><h2 id="图片加载存在的问题和原因"><a href="#图片加载存在的问题和原因" class="headerlink" title="图片加载存在的问题和原因"></a><strong>图片加载存在的问题和原因</strong></h2><p><strong>问题一</strong>：启动页面时加载过多图片</p><p><img data-src="https://pic3.zhimg.com/80/v2-f3f1170a7d72690c62f078a067b9327e_720w.jpg" alt="img"></p><p><strong>图1</strong>： 新零售图片请求瀑布图</p><p><strong>问题原因分析：</strong>如上图所示，页面启动时加载了大约 49 张图片（具体图片数量会根据后端返回数据而变化），而这些图片请求几乎是并发的，在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。上面的瀑布图中，在绿色的标记框中，我们看到不同长度的白色横柱，这些都是请求的图片资源排队等待时间。</p><p><strong>问题二</strong>：部分图片体积过大</p><p><img data-src="https://pic1.zhimg.com/80/v2-c3f2397f4515379d7741feaec49e178c_720w.jpg" alt="img"></p><p><strong>图2.</strong> 顶部轮播图中的一张图片加载图</p><p><strong>问题原因分析：</strong>如图 1，红框中是搜索框下部的轮播广告中的一张图片，通过图 2 可以看到，该图片主要耗时在 <code>Conent Download</code> 阶段。在下载阶段耗时 13.50s。而该请求的总共时间也就 13.78s。产生该问题的原因从图 1 也能看出一些端倪，该图片体积 <code>76.2KB</code>，<strong>图片体积过大</strong>，直接导致了下载图片时间过长。</p><h2 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><strong>前端解决方案</strong></h2><p><strong>针对问题一的解决方案</strong></p><p>由于新零售首页展示展示大量图片，其实在这大约 49 张图片中，大部分图片都不是首屏所需的，因此可以延迟首屏不需要的图片加载，而优先加载首屏所需图片。这儿<strong>首屏</strong>的含义是指打开新零售首页首先进入屏幕视窗内的区域范围。</p><p>判断图片是否是首屏内图片，首先想到的肯定是通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 <code>viewport</code> 内部。可能的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rect.top &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; rect.bottom &lt; <span class="built_in">window</span>.innerHeight</span><br><span class="line">    &amp;&amp; rect.left &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在项目中，我们并没有采用该方案来判断是否在首屏，其原因在于，只有当 DOM 元素插入到 DOM 树中，并且页面进行重排和重绘后，我们才能够知道该元素是否在首屏中。在项目中我们使用了 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a> 指令（新零售项目使用该指令对图片进行加载、并且将 hash 转换成 Url。项目已开源，在符合需求前提下欢迎使用），在 Vue 指令中包含两个钩子函数 <code>bind</code> 和 <code>inserted</code>。官网对这两个钩子函数进行如下解释：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li></ul><p>由上面解释可知，我们只能够在 inserted 钩子函数中才能够获取到元素的位置，并且判断其是否在首屏中。在新零售项目中，经过笔者测试，这两个钩子函数的触发时差大约是200ms，因此如果在 inserted 钩子函数内再去加载图片就会比在 bind 钩子函数中加载晚大约200ms，在 4G 网络环境下，200ms 对于很多图片来说已经足够用来加载了，因此我们最终放弃了在 inserted 钩子函数中加载首屏图片的方案。</p><p><strong>如果元素没有插入到 DOM 树中并渲染，怎么能够判断其是否在首屏中呢？</strong></p><blockquote><img v-img="{ hash: 'xxx', defer: true }"></blockquote><p>项目中使用了一种比较笨的方式来判断哪些是首屏图片，新零售页面布局是确定的，轮播广告栏下面是促销栏、再下面是店铺列表，这些组件的高度也都相对固定，因此这些组件是否在首屏中其实我们是事先知道的。因此在实际使用 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a> 指令的时候，通过传 <code>defer</code> 配置项来告诉 v-img 哪些图片需要提前加载，哪些图片等待提前加载的图片加载完毕后再加载。这样我们就能够在 bind 钩子函数中加载优先加载的图片了。比如说，轮播组件图片、促销组件图片、前两个店铺中的展示图片需要先加载，除此以外的其他图片，需等待首屏图片完全加载后再进行请求加载。实际实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [] <span class="comment">// 用来存储优先加载的图片  </span></span><br><span class="line">Vue.directive(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">        promises.push(update(el, binding, vnode))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">      <span class="keyword">if</span> (!defer) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">        promises.push(update(el, binding, vnode))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promises.length = <span class="number">0</span></span><br><span class="line">            update(el, binding, vnode)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>首先通过声明一个数组 promises 用于存储优先加载的图片，在 bind 钩子函数内部，如果 defer 配置项为 false，说明不延时加载，那么就在 bind 钩子函数内部加载该图片，且将返回的 promise 推入到 promises 数组中。在 inserted 钩子函数内，对于延迟加载的图片（defer 为 true），但是其又在首屏内，那么也有优先加载权，在 inseted 钩子函数调用时就对其加载。而对于非首屏且延迟加载的图片等待 promises 数组内部所有的图片都加载完成后才加载。当然在实际代码中还会考虑容错机制，比如上面某张图片加载失败、或者加载时间太长等。因此我们可以配置一个最大等待时间。</p><p>优化后的图片加载瀑布图如下：</p><p><img data-src="https://pic2.zhimg.com/80/v2-980599738f2adfb6822df8f503c1769d_720w.jpg" alt="img"></p><p><strong>图3</strong>. 图片按需加载的瀑布图</p><p>如上图所示，下面红框的图片不是首屏图片，因此进行了延迟加载。可以看出，其是在上面所有图片（包括上面的红框中耗时最长的那张图）加载完成之后进行加载的。这样减少了首屏加载时的网络消耗，提升了图片下载速度。</p><p><strong>优化前后对比</strong></p><p>通过上面的优化方案，在预设的网络环境下（参见文末注），分别对优化前和优化后进行了 5 次平行<code>清空缓存加载</code>，平均数据如下：</p><p><img data-src="https://pic3.zhimg.com/80/v2-d52cdac7a87683457710fa8a0175591e_720w.jpg" alt="img"></p><p>通过上面表格可以看出，<code>DOMContentLoaded</code> 和 <code>Loaded</code> 并没有多大参考价值，首屏的完整展现所需要的时间依然由加载最慢（一般都是体积最大那张图片）的图片决定，也就是上表的 <code>Max_size_image</code> 决定，上表可以看出，优化后比优化前最大体积图片的加载时间缩短了 <strong>5.74s</strong>。提速了整整 **41.41%**。加载最慢的图片加载速度的变化也很好的反应了首屏时间的变化。</p><p>当然上面的数据也不能够完全反应线上场景，毕竟测试的时间点及后端数据都有所不同。我们也不能够在同一时间点、同一网络环境下对优化前、优化后进行同时数据采集。</p><p><strong>针对问题一还有些后续的解决方案：</strong></p><ul><li>在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</li></ul><p><strong>针对问题二的解决方案</strong></p><p><strong>图片体积过大，导致下载时间过长。</strong>在保证清晰度的前提下尽量使用体积较小的图片。而一张图片的体积由两个因素决定，该图片总的像素数目和编码单位像素所需的字节数。因此一张图片的文件大小就等于图片总像素数目乘以编码单位像素所需字节数，也就是如下等式：</p><blockquote><p>FileSize = Total Number Pixels * Bytes of Encode single Pixels</p></blockquote><p>举个例子：</p><p>一张 <code>100px * 100px</code> 像素的图片，其包含该 <code>100 * 100 = 10000</code> 个像素点，而每个像素点通过 <code>RGBA</code> 颜色值进行存储，<code>R\G\B\A</code> 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：<code>10000 * 4bytes = 40000bytes = 39KB</code>。</p><p>有了上面的背景知识后，我们就知道怎么去优化一张图片了，无非就两个方向：</p><ul><li>一方面是减少单位像素所需的字节数</li><li>另一方面是减少一张图片总的像素个数</li></ul><p><strong>单位像素优化</strong>：单位像素的优化也有两个方向，一个方向是「有损」的删除一些像素数据，另一个方面是做一些「无损」的图片像素压缩。正如上面例子所说，<code>RGBA</code> 颜色值可以表示 <code>256^4</code> 种颜色，这是一个很大的数字，往往我们不需要这么多颜色值，因此我们是否可以减少色板中的颜色种类呢？这样表示单位像素的字节数就减少了。而「无损」压缩是通过一些算法，存储像素数据不变的前提下，尽量减少图片存储体积。比如一张图片中的某一个像素点和其周围的像素点很接近，比如一张蓝天的图片，因此我们可以存储两个像素点颜色值的差值（当然实际算法中可能不止考虑两个像素点也许更多），这样既保证了像素数据的「无损」，同时也减少了存储体积。不过也增加了图片解压缩的开销。</p><p>针对单位像素的优化，衍生出了不同的图片格式，<code>jpeg</code>、<code>png</code>、<code>gif</code>、<code>webp</code>。不同的图片格式都有自己的减少单位像素体积的算法。同时也有各自的优势和劣势，比如 <code>jpeg</code> 和 <code>png</code> 不支持动画效果，<code>jpeg</code> 图片体积小但是不支持透明度等。因此项目在选择图片格式上的策略就是，在满足自己需求的前提下选择体积最小的图片格式，新零售项目中已经统一使用的 <code>WebP</code> 格式，和 <code>jpeg</code> 格式相比，其体积更减少 30%，同时还支持动画和透明度。</p><p><strong>图片像素总数优化</strong>：</p><p><img data-src="https://pic2.zhimg.com/80/v2-0332bf16cf3b094fd0c311a56d4b56dd_720w.jpg" alt="img"></p><p><strong>图4</strong>：图片加载尺寸和实际渲染尺寸对比</p><p>上图是新零售类目页在 Chrome 浏览器中的 iPhone 6 模拟器加载后的轮播展示的图片之一，展示的图片是 <code>750 * 188</code> 像素，但是图片的实际尺寸为 <code>1440 * 360</code> 像素，也就是说我们根本不需要这么大的图片，大图片不仅造成了图片加载的时长增加（后面会有数据说明），同时由于图片尺寸需要缩小增加CPU的负担。</p><p>上文中已经提及，项目中我们使用的 <code>v-img</code> 指令来加载项目中的所需图片，如果我们能够根据设备的尺寸来加载不同尺寸（像素总数不同）的图片，也就是说在保证图片清晰度的前提下，尽量使用体积小的图片，问题就迎刃而解了。项目中我们使用的是七牛的图片服务，<a href="https://link.zhihu.com/?target=https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2">七牛图片服务</a>提供了图片格式转换、按尺寸裁剪等图片处理功能。只需要对 <code>v-img</code> 指令添加图片宽、高的配置，那么我们是不是可以对不同的设备加载不同尺寸的图片呢？</p><p>项目中我们使用的 <a href="https://link.zhihu.com/?target=https://github.com/amfe/lib-flexible">lib-flexible</a> 来对不同的移动端设备进行适配，<code>lib-flexible</code> 库在我们页面的html元素添加了两个属性，<code>data-dpr</code> 和 <code>style</code>。这儿我们主要会用到 style 中的 <code>font-size</code> 值，在一定的设备范围内其正好是html元素宽度的十分之一（具体原理参见：<a href="https://link.zhihu.com/?target=http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用Flexible实现手淘H5页面的终端适配</a>），也就是说我们可以通过style属性大概获取到设备的宽度。同时设计稿又是以 iPhone6 为基础进行设计的，也就是设计稿是宽度为 750px的设计图，这样在设计图中的图片大小我们也就能够转换成其他设备中所需的图片大小了。</p><p>举个例子：</p><p>设计稿中一张宽 200px 的图片，其对应的 iPhone 6 设备的宽度为 750px。我们通过 html 元素的 style 属性计算出 iPhone6 plus 的宽度为 1242px。这样也就能够计算中 iPhone6 plus 所需图片尺寸。计算如下：</p><blockquote><p>200 * 1242 / 750 = 331.2px</p></blockquote><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> viewWidth</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement</span><br><span class="line">  <span class="keyword">const</span> dataDpr = html.getAttribute(<span class="string">&#x27;data-dpr&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> ratio = dataDpr ? (dpr / dataDpr) : dpr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    viewWidth = +(html.getAttribute(<span class="string">&#x27;style&#x27;</span>).match(<span class="regexp">/(\d+)/</span>) || [])[<span class="number">1</span>]</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = html.offsetWidth</span><br><span class="line">    <span class="keyword">if</span> (w / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      viewWidth = <span class="number">540</span> * dpr / <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewWidth = w / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  viewWidth = viewWidth * ratio</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>(viewWidth) &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> viewWidth === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (size * viewWidth) / <span class="number">75</span> <span class="comment">// 75 is the 1/10 iphone6 deivce width pixel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 resize 方法用于将配置的宽、高值转换为实际所需的图片尺寸，也就是说，size 参数是 iphone 6 设计稿中的尺寸，resize 的返回值就是当前设备所需的尺寸，再把该尺寸配置到图片服务器的传参中，这样我们就能够获取到按设备裁剪后的图片了。</p><p><strong>优化前后效果对比</strong>，有了上面的基础，我们在 Chrome 中的不同的移动端模拟器上进行了实验，我们对新零售类目页中的一张体积最大的广告图片在不同设备中的加载进行了数据统计（平行三次清空缓存加载），为什么选择体积最大的图片，上文也已经说过，其决定了首屏展现所需的时间。</p><p><img data-src="https://pic4.zhimg.com/80/v2-12e8515d258f0d54dbd0dec319c867df_720w.jpg" alt="img"></p><p>上表格中，除去最后一行是未优化的加载数据，从上到下，设备屏幕尺寸逐渐变大，加载的图片尺寸也从 23.2kb增加到 65.5kb。而加载时间和下载时长也跟随着图片体积的加大而增加，下面的折线图更能够反应图片尺寸、加载时长、下载时长之间的正相关关系。TTFB（从发送请求到接收到第一个字节所需时长）却和图片大小没有明显的正相关关系，可能对于图片服务器在裁剪上述不同尺寸的图片所需时长差异不大。</p><p><img data-src="https://pic2.zhimg.com/80/v2-c93fa12974f624ba119f57c5cad88359_720w.jpg" alt="img"></p><p><strong>图5</strong>：不同设备中对同一张图片进行加载，文件大小、加载和下载时长的折线变化</p><p>由上折线图我们还能看到，对于小屏幕设备的效果尤为明显，在不优化下，iPhone5 中图片的加载需要 14.85s，而优化后，加载时长缩短到了 3.90s。加载时长整整缩短了 <strong>73.73%**。而对于大屏幕的 iPhone6 plus 也有 **26.00%</strong> 时长优化。</p><p>当然上面的数据是建立在 <code>256 kbps ISDN/DSL</code> 的网络环境下的，该低速网络环境下，图片的加载时间主要是由于下载时间决定的，因此通过优化图片体积能够达到很好的效果。在 <code>4G</code>（Charles模拟）环境下，iPhone5 中的优化效果就会有些折扣，加载时长缩短 **69.15%**。其实也很容易想到，在高速的网络环境下，TTFB 对加载时长的影响会比低速网络环境下影响要大一些。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h2><p>通过上面的研究及数据结果表明，新零售图片加载缓慢的优化策略：</p><ul><li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。</li><li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li></ul><p>本文中没有过多的讨论代码实现细节，而是把重点放在了图片加载缓慢的原因分析，以及优化前后效果对比的数据分析上，如果想看更多代码细节，请移步 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">vue-img</a>。</p><h1 id="6-从-URL-输入到页面展现到底发生了什么？"><a href="#6-从-URL-输入到页面展现到底发生了什么？" class="headerlink" title="6.从 URL 输入到页面展现到底发生了什么？"></a>6.从 URL 输入到页面展现到底发生了什么？</h1><p>对浏览器原理有过了解的一定不会陌生这篇神文《<a href="https://link.jianshu.com/?t=https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browsers Work</a>》中文翻译：<a href="https://link.jianshu.com/?t=https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器原理：新式网络浏览器幕后揭秘</a>。另外还有一篇 《<a href="https://link.jianshu.com/?t=http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">What really happens when you navigate to a URL</a>》。大神写的东西很长很复杂，阅读成本虽然大，但能学到东西。所以，我也试着用自己的理解去写一写，算是做个巩固。里面有很多参考，如涉及版权，侵权删！表述有误，请指正！</p><h2 id="前端为什么要研究渲染原理？"><a href="#前端为什么要研究渲染原理？" class="headerlink" title="前端为什么要研究渲染原理？"></a>前端为什么要研究渲染原理？</h2><p>像素完美（Pixel Perfection）、分辨率无关（Resolution Independent）和多平台体验一致性是设计师的追求。而访问性（Accessability）、加载性能和重构灵活性则是前端工程师必懂的技能。最重要的加载性能又与浏览器渲染机制深深挂钩，所以只有弄明白了浏览器背后的渲染机制，才能在日常的前端开发中明白如何进行性能优化。<br> 还有就是像类似：<br> <strong>从输入 URL 到页面加载完成的过程中都发生了什么事情</strong>？<br> <strong>从按下键盘到屏幕上出现字符，中间都发生了什么事情</strong>？<br> <strong>用户反应网站卡，请问都有哪些可能性，以及解决方法</strong>？<br> 这样的问题面试官都是比较喜欢问的，今天尝试来详细说一下这个过程。</p><h2 id="从输入-URL-到页面加载完成的过程中都发生了什么？"><a href="#从输入-URL-到页面加载完成的过程中都发生了什么？" class="headerlink" title="从输入 URL 到页面加载完成的过程中都发生了什么？"></a>从输入 URL 到页面加载完成的过程中都发生了什么？</h2><p><strong>简单路径线</strong>：</p><ol><li>键盘或触屏输入URL并回车确认</li><li>URL解析/DNS解析查找域名IP地址</li><li>网络连接发起HTTP请求</li><li>HTTP报文传输过程</li><li>服务器接收数据</li><li>服务器响应请求/MVC</li><li>服务器返回数据</li><li>客户端接收数据</li><li>浏览器加载/渲染页面</li><li>打印绘制输出</li></ol><p>实际上并没有这么简单，下面说说它的<strong>详细路径线</strong>：</p><h3 id="1-键盘或触屏输入URL并回车确认"><a href="#1-键盘或触屏输入URL并回车确认" class="headerlink" title="1. 键盘或触屏输入URL并回车确认"></a><strong>1. 键盘或触屏输入URL并回车确认</strong></h3><p>当然故事其实并不是从输入一个URL或抓着鼠标点击一个链接开始的，事情的开端要追溯到服务器启动监听服务的时候，在某个未知的时刻，一台机房里普普通通的服务器，加上电，启动了操作系统，随着操作系统的就绪，服务器启动了 http 服务进程，这个 http 服务的守护进程（daemon），可能是 Apache、Nginx、IIS、Lighttpd中的一个，不管怎么说，这个 http 服务进程开始定位到服务器上的 www 文件夹（网站根目录），一般是位于 /var/www ，然后启动了一些附属的模块，例如 php，或者，使用 fastcgi 方式连接到 php 的 fpm 管理进程，然后，向操作系统申请了一个 tcp 连接，然后绑定在了 80 端口，调用了 accept 函数，开始了默默的监听，监听着可能来自位于地球任何一个地方的请求，随时准备做出响应。这个时候，典型的情况下，机房里面应该还有一个数据库服务器，或许，还有一台缓存服务器，如果对于流量巨大的网站，那么动态脚本的解释器可能还有单独的物理机器来跑，如果是中小的站点，那么，上述的各色服务，甚至都可能在一台物理机上，这些服务监听之间的关系，可以通过自己搭建一次 Apache PHP MySQL 环境来了解一下，不管怎么说，他们做好了准备，静候差遣。<br> 然后是开始键盘或手机触屏输入URL，然后通过某种机制传到CPU（过程略），CPU进行内部处理（过程略），处理完后，再从CPU传到操作系统内核（过程略），然后再由操作系统GUI传到浏览器，再由浏览器到浏览器内核。这个过程因为涉及很多底层的知识，自己也只是了解皮毛，过程这里不多讲了，具体请参考我的另一篇博客《<a href="https://www.jianshu.com/p/d38a79a4f0f4">字符集历史和乱码问题</a>》和以下书籍：<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/20260928/">编码</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/4289836/">操作系统概念</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/25780703/">CPU自制入门</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/6559064/">计算机体系结构</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/6097773/">Linux内核设计与实现</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/4311450/">精通Linux设备驱动程序开发</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/7006537/">计算机体系结构：量化研究方法</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/10441748/">计算机组成与设计：硬件/软件接口</a>》</p><p>上面一步操作系统 GUI 会将输入事件传递到浏览器中，在这过程中，浏览器可能会做一些预处理，甚至已经在智能匹配所有可能的URL了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的URL，来预估所输入字符对应的网站，然后给出智能提示，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「<a href="https://link.jianshu.com/?t=http://www.baidu.com">www.baidu.com</a> 」，因此就会在输入回车前就马上开始建立 TCP 链接了。对于 Chrome这种变态的浏览器，他甚至会直接从缓存中把网页渲染出来，就是说，你还没有按下「回车」键，页面就已经出来了，再比如Chrome会在浏览器启动时预先查询10个你有可能访问的域名等等，这里面还有很多其它策略，不详细讲了。感兴趣的推荐阅读 <a href="https://link.jianshu.com/?t=http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">High Performance Networking in Chrome</a>。</p><h3 id="2-URL-解析-DNS-查询"><a href="#2-URL-解析-DNS-查询" class="headerlink" title="2. URL 解析/DNS 查询"></a><strong>2. URL 解析/DNS 查询</strong></h3><p>接着是输入 URL 「回车」后，这时浏览器会对 URL 进行检查，这里需要对URL有个回顾，请见百科《<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/url">URL</a>》，完整的URL由几个部分构成：<br> <em>协议、网络地址、资源路径、文件名、动态参数</em><br> <em>协议/模式（scheme）</em>是从该计算机获取资源的方式，一般有Http、Https、Ftp、File、Mailto、Telnet、News等协议，不同协议有不同的通讯内容格式，协议主要作用是告诉浏览器如何处理将要打开的文件；<br> <em>网络地址</em>指示该连接网络上哪一台计算机（服务器），可以是<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E5%9F%9F%E5%90%8D">域名</a>或者<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>，域名或IP地址后面有时还跟一个冒号和一个端口号；<br> <em>端口号</em>如果地址不包含端口号，根据协议的类型会确定一个默认端口号。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。一般如果你的端口号就是默认的，那么url是不需要输入端口号的，但如果你更改了默认端口号，你就必须要在url后输入新端口号才能正常访问。例如：http协议默认端口号是80。如果你输入的url是<a href="https://link.jianshu.com/?t=http://www.zhihu.com:8080/">http://www.zhihu.com:8080/</a> ，那表示不使用默认的端口号，而使用指定的端口号8080。如果使用的就是默认端口号那么输入<a href="https://link.jianshu.com/?t=http://www.zhihu.com:80">http://www.zhihu.com:80</a> 和<a href="https://link.jianshu.com/?t=http://www.zhihu.com">http://www.zhihu.com</a>是一样的。有个特殊情况有所不同，比如本地IP 127.0.0.1 其实走的是 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Localhost">loopback</a>，和网卡设备没关系。<br> <em>资源路径</em>指示从服务器上获取哪一项资源的等级结构路径，以斜线<code>/</code>分隔；<br> <em>文件名</em>一般是需要真正访问的文件，有时候，URL以斜杠“/”结尾，而隐藏了文件名，在这种情况下，URL引用路径中最后一个目录中的默认文件（通常对应于主页），这个文件常被称为 index.html 或 default.htm。<br> <em>动态参数</em>有时候路径后面会有以问号<code>?</code>开始的参数，这一般都是用来传送对服务器上的数据库进行动态询问时所需要的参数，有时候没有，很多为了seo优化，都已处理成<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E4%BC%AA%E9%9D%99%E6%80%81">伪静态</a>了。要注意区分url和<a href="https://link.jianshu.com/?t=http://www.digpage.com/route.html">路由</a>的区别。<br> <strong>URL完整格式为：协议://用户名:密码@子域名.域名.顶级域名:<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>/目录/文件名.文件后缀?参数=值#标志</strong><br> 例如：<a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/55998388/answer/166987812">https://www.zhihu.com/question/55998388/answer/166987812</a><br> 协议部分：https<br> 网络地址：<a href="https://link.jianshu.com/?t=http://www.zhihu.com">www.zhihu.com</a>（依次为 子/三级域名.二级域名.顶/一级域名）<br> 资源路径：/question/55998388/answer/166987812<br> 浏览器对 URL 进行检查时首先判断协议，如果是 http/https 就按照 Web 来处理，另外还会对 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，接下来是对网络地址进行处理，如果地址不是一个IP地址而是域名则通过DNS（域名系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。 例如：<a href="https://link.jianshu.com/?t=http://www.zhihu.com">www.zhihu.com</a>域名请求对应获得的IP是 116.211.167.187。DNS 在解析域名的时候有两种方式：<strong>递归查询和迭代查询</strong>，<br> 递归查询的流程如下：<br> 一般来说，浏览器会首先查询<strong>浏览器缓存</strong>（DNS 在各个层级都有缓存的，相应的，缓存当然有过期时间，Time to live），如果没有找到，就会检查<strong>系统缓存</strong>，检查本地硬盘的hosts文件，这个文件保存了一些以前访问过的网站的域名和IP对应的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了（注意这个地方存在安全隐患，如果有病毒把一些常用的域名，修改 hosts 文件，指向一些恶意的IP，那么浏览器也会不加判断的去连接，是的，这正是很多病毒的惯用手法）。如果本地hosts也没有找到的话，则需要再向上层找<strong>路由器缓存</strong>，路由器有自己的DNS缓存，可能就包括了查询的内容；如果还是没有，需要接着往上找，查询<strong>ISP DNS 缓存</strong>（本地名称服务器缓存，就是客户端电脑TCP/IP参数中设置的首选DNS服务器，此解析具有权威性。一般情况下你在不同的地区或者不同的网络，如电信、联通、移动的情况下，转换后的IP地址很可能是不一样的，这涉及到负载均衡，通过DNS解析域名时会将你的访问分配到不同的入口，先找附近的本地 DNS 服务器去请求解析域名，尽可能保证你所访问的入口是所有入口中较快的一个，这和<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/CDN">CDN</a>还不一样，比如我们经常使用的114.114.114.114或Google的8.8.8.8就是本地名称服务器）。如果附近的本地DNS服务器还是没有缓存我们请求的域名记录的话，这时候会根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，则本地名称服务器再以DNS客户端的角色发送与前面一样的DNS域名查询请求转发给上一层。这里可能经过一次或者多次转发，从<strong>本地名称服务器</strong>到<strong>权威名称服务器</strong>再到<strong>顶级名称服务器</strong>最后到<strong>根名称服务器</strong>。（顺便一提，根服务器是互联网域名解析系统DNS中最高级别的域名服务器，全球一共13组，每组都只有一个主根名称服务器采用同一个IP。注意不是13个，前期是个现在已经是集群了，据说已经有上千台了，好多台用于负载均衡，备份等，全球有386台根物理服务器，被编号为A到M共13个标号。中国包括台港也持有其中5组14台辅根服务器或叫镜像也可以，386台根服务器总共只使用了13个IP，因此可以抵抗针对其所进行的分布式拒绝服务攻击DDoS。具体情况可以参看维基百科的 <a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8B%99%E5%99%A8">根域名服务器</a> 条目）所以，最终请求到了根服务器后，根服务器查询发现我们这个被请求的域名是由类似A或者B这样的服务器解析的，但是，根服务器并不会送佛送到西地找A或B之类的直接去解析，因为它没有保存全部互联网域名记录，并不直接用于名称解析，它只是负责顶级名称服务器（如.com/.cn/.net等）的相关内容。所以它会把所查询得到的被请求的DNS域名中顶级域名所对应的顶级名称服务器IP地址返回给本地名称服务器。本地名称服务器拿到地址后再向对应的顶级名称服务器发送与前面一样的DNS域名查询请求。对应的顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有则直接把对应的记录项返回给本地名称服务器，然后再由本地名称服务器返回给DNS客户端，如果没有则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的二级名称服务器（如<a href="https://link.jianshu.com/?t=http://baidu.com/qq.com/net.cn">baidu.com/qq.com/net.cn</a>等）地址。然后本地名称服务器继续按照前面介绍的方法一次次地向三级（如<a href="https://link.jianshu.com/?t=http://www.baidu.com/www.qq.com/bbs.taobao.com">www.baidu.com/www.qq.com/bbs.taobao.com</a>等）、四级名称服务器查询，直到最终的对应域名所在区域的权威名称服务器返回最终记录给本地名称服务器。同时本地名称服务器会缓存本次查询得到的记录项（每层都应该会缓存）。再层层下传，最后到了我们的DNS客户端机子，一次 DNS 解析请求就此完成。如果最终权威名称服务器都说找不到对应的域名记录，则会向本地名称服务器返回一条查询失败的DNS应答报文，这条报文最终也会由本地名称服务器返回给DNS客户端。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询的。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-7d3f7e0c5b12d23a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>DNS递归解析示例图</p><p> 所以，我们看到DNS的域名解析是递归的，递归的DNS首先会查看自己的DNS缓存，如果缓存能够命中，那么就从缓存中把IP地址返回给浏览器，如果找不到对应的域名的IP地址，那么就依此层层向上转发请求，从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP，最高达到根节点，找到或者全部找不到为止。然后把找到的这个域名对应的 nameserver 的地址拿到，再向这个 namserver 去请求域名对应的IP，最后把这个IP地址返回给浏览器，在这个<strong>递归查询</strong>的过程中，对于浏览器来说是透明的，如果DNS客户端的本地名称服务器不能解析的话，则后面的查询都会以本地名称服务器为中心，全交由本地名称服务器代替DNS客户端进行查询，DNS客户端只是发出原始的域名查询请求报文，然后就一直处于坐等状态，直到本地名称服务器最终从权威名称服务器得到了正确的IP地址查询结果并返回给它。虽然递归查询是默认的DNS查询方式，但是如果有以下情况发生的话，则会使用迭代的查询方式进行。<br> 情况一：DNS客户端的请求报文中没有申请使用递归查询，即在DNS请求报头部的RD字段没有置1。<br> 情况二：DNS客户端的请求报文中申请使用的是递归查询（也就是RD字段置1了），但在所配置的本地名称服务器上是禁用递归查询了（即在应答DNS报文头部的RA字段置0）。</p><p><strong>迭代查询的流程如下</strong>：<br> 开始也是从浏览器缓存到系统缓存到路由缓存，如果还是没找到则客户端向本机配置的本地名称服务器（在此仅以首先DNS服务器为例进行介绍，其它备用DNS服务器的解析流程完全一样）发出DNS域名查询请求。本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器就直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则向DNS客户端返回一条DNS应答报文，报文中会给出一些参考信息，如本地名称服务器上的根名称服务器地址等。DNS客户端在收到本地名称服务器的应答报文后，会根据其中的根名称服务器地址信息，向对应的根名称服务器再次发出与前面一样的DNS查询请求报文。根名称服务器在收到DNS查询请求报文后，通过查询自己的DNS数据库得到请求DNS域名中顶级域名所对应的顶级名称服务器信息，然后以一条DNS应答报文返回给DNS客户端。DNS客户端根据来自根名称服务器应答报文中的对应顶级名称服务器地址信息，向该顶级名称服务器发出与前面一样的DNS查询请求报文。顶级名称服务器在收到DNS查询请求后，先查询自己的缓存，如果有请求的DNS域名的记录项，则直接把对应的记录项返回给DNS客户端，否则通过查询后把对应域名中二级域名所对应的二级名称服务器地址信息以一条DNS应答报文返回给DNS客户端。然后DNS客户端继续按照前面介绍的方法一次次地向三级、四级名称服务器查询，直到最终的权威名称服务器返回到最终的记录。如果权威名称服务器也找不到对应的域名记录，则会向DNS客户端返回一条查询失败的DNS应答报文。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-e8a5727b9a6a0c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>DNS迭代解析示意图</p><p> 所以，我们发现在递归查询中后面的查询工作是由本地名称服务器替代DNS客户端进行的（以“本地名称服务器”为中心），只需要本地名称服务器向DNS客户端返回最终的查询结果即可。而DNS迭代查询的所有查询工作则全部是DNS客户端自己进行（以“DNS客户端”自己为中心）。</p><p><strong>DNS递归查询和迭代查询的区别</strong>？<br> 递归查询是以本地名称服务器为中心的，是DNS客户端和服务器之间的查询活动，递归查询的过程中“查询的递交者” 一直在更替，其结果是直接告诉DNS客户端需要查询的网站目标IP地址。<br> 迭代查询则是DNS客户端自己为中心的，是各个服务器和服务器之间的查询活动，迭代查询的过程中“查询的递交者”一直没变化，其结果是间接告诉DNS客户端另一个DNS服务器的地址。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-f1a9326b8de436c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>递归和迭代查询</p><p><strong>扩展阅读：</strong><br> <a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/DNS%E5%8A%AB%E6%8C%81">什么是DNS劫持？</a><br> <a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/301%E9%87%8D%E5%AE%9A%E5%90%91">什么是301重定向？</a>与<a href="https://link.jianshu.com/?t=http://www.chinaz.com/web/2013/1212/330808.shtml">301重定向设置教程</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/34784697">电脑上不了网将DNS改为114.114.114.114或8.8.8.8可以解决或加快网速的原理是什么？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/27714563">局域网 IP 和公网 IP 有何差别？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/22364736">根域名服务器的作用是什么？全球 13 组根域名服务器中有 10 组在美国，意味着什么？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/20278387">递归和迭代的区别？</a></p><h3 id="3-应用层客户端发送HTTP请求"><a href="#3-应用层客户端发送HTTP请求" class="headerlink" title="3. 应用层客户端发送HTTP请求"></a><strong>3. 应用层客户端发送HTTP请求</strong></h3><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-5272cd06ebf5f4e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/832/format/webp" alt="img"></p><p>从上面的步骤中得到 IP 地址后，浏览器会开始构造一个 HTTP 请求，应用层客户端向服务器端发送的HTTP请求包括：请求报头和请求主体两个部分，其中请求报头（request header）包含了至关重要的信息，包括请求的方法（GET / POST和不常用的PUT / DELETE以及更不常用的HEAD / OPTION / TRACE，一般的浏览器只能发起 GET 或者 POST 请求）、目标url、遵循的协议（HTTP / HTTPS / FTP…），返回的信息是否需要缓存，以及客户端是否发送Cookie等信息。需要注意的是，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 文本的。</p><h3 id="4-传输层TCP传输报文"><a href="#4-传输层TCP传输报文" class="headerlink" title="4. 传输层TCP传输报文"></a><strong>4. 传输层TCP传输报文</strong></h3><p>当应用层的 HTTP 请求准备好后，浏览器会在传输层发起一条到达服务器的 TCP 连接，位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-fac6b90588bec446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt="img"></p><p> 这里需要谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段（segments），编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。为了解决 TCP 协议的性能问题，Chrome 团队提出了 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/QUIC">QUIC</a> 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回（round trip）时间，还有前向纠错码（Forward Error Correction）等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过<a href="https://link.jianshu.com/?t=chrome://net-internals/#spdy">chrome://net-internals/#spdy</a> 页面来发现。另外，浏览器对同一个域名有连接数限制，<a href="https://link.jianshu.com/?t=http://www.browserscope.org/?category=network&v=top">大部分是 6</a>，但并非将这个连接数改大后就会提升性能，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。</p><h3 id="5-网络层IP协议查询MAC地址"><a href="#5-网络层IP协议查询MAC地址" class="headerlink" title="5. 网络层IP协议查询MAC地址"></a><strong>5. 网络层IP协议查询MAC地址</strong></h3><p>IP协议的作用是把TCP分割好的各种数据包封装到IP包里面传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址才可以。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p><h3 id="6-数据到达数据链路层"><a href="#6-数据到达数据链路层" class="headerlink" title="6. 数据到达数据链路层"></a><strong>6. 数据到达数据链路层</strong></h3><p>在找到对方的MAC地址后，已被封装好的IP包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输，再通过物理层的比特流送出去。这时，客户端发送请求的阶段结束。</p><blockquote><p>这些分层的意义在于分工合作，数据链路层通过 CSMA/CD 协议保证了相邻两台主机之间的数据报文传递，而网络层的 IP 数据包通过不同子网之间的路由器的路由算法和路由转发，保证了互联网上两台遥远主机之间的点对点的通讯，不过这种传输是不可靠，于是可靠性就由传输层的 TCP 协议来保证，TCP 通过慢开始，乘法减小等手段来进行流量控制和拥塞避免，同时提供了两台遥远主机上进程到进程的通信，最终保证了 HTTP 的请求头能够被远方的服务器上正在监听的 HTTP 服务器进程收到，终于，数据包在跳与跳之间被拆了又封装，在子网与子网之间被转发了又转发，最后进入了服务器的操作系统的缓冲区，服务器的操作系统由此给正在被阻塞住的 accept 函数一个返回，将他唤醒。</p></blockquote><h3 id="7-服务器接收数据"><a href="#7-服务器接收数据" class="headerlink" title="7. 服务器接收数据"></a><strong>7. 服务器接收数据</strong></h3><p>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。</p><h3 id="8-服务器响应请求并返回相应文件"><a href="#8-服务器响应请求并返回相应文件" class="headerlink" title="8. 服务器响应请求并返回相应文件"></a><strong>8. 服务器响应请求并返回相应文件</strong></h3><p>服务接收到客户端发送的HTTP请求后，服务器上的的 http 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。http 服务器首先会查看重写规则，然后如果请求的文件是真实存在，例如一些图片，或 html、css、js 等静态文件，则会直接把这个文件返回，如果是一个动态的请求，那么会根据 url 重写模块的规则，把这个请求重写到一个 rest 风格的 url 上，然后根据动态语言的脚本，来决定调用什么类型的动态文件脚本解释器来处理这个请求。</p><p>我们以 php 语言为例来说的话，请求到达一个 php 的 mvc 框架之后，框架首先应该会初始化一些环境的参数，例如远端 ip，请求参数等等，然后根据请求的 url 送到一个路由器类里面去匹配路由，路由由上到下逐条匹配，一旦遇到 url 能够匹配的上，而且请求的方法也能够命中的话，那么请求就会由这个路由所定义的处理方法去处理。</p><p>请求进入处理函数之后，如果客户端所请求需要浏览的内容是一个动态的内容，那么处理函数会相应的从数据源里面取出数据，这个地方一般会有一个缓存，例如 memcached 来减小 db 的压力，如果引入了 orm 框架的话，那么处理函数直接向 orm 框架索要数据就可以了，由 orm 框架来决定是使用内存里面的缓存还是从 db 去取数据，一般缓存都会有一个过期的时间，而 orm 框架也会在取到数据回来之后，把数据存一份在内存缓存中的。</p><p>orm 框架负责把面向对象的请求翻译成标准的 sql 语句，然后送到后端的 db 去执行，db 这里以 mysql 为例的话，那么一条 sql 进来之后，db 本身也是有缓存的，不过 db 的缓存一般是用 sql 语言 hash 来存取的，也就是说，想要缓存能够命中，除了查询的字段和方法要一样以外，查询的参数也要完全一模一样才能够使用 db 本身的查询缓存，sql 经过查询缓存器，然后就会到达查询分析器，在这里，db 会根据被搜索的数据表的索引建立情况，和 sql 语言本身的特点，来决定使用哪一个字段的索引，值得一提的是，即使一个数据表同时在多个字段建立了索引，但是对于一条 sql 语句来说，还是只能使用一个索引，所以这里就需要分析使用哪个索引效率最高了，一般来说，sql 优化在这个点上也是很重要的一个方面。</p><p>sql 由 db 返回结果集后，再由 orm 框架把结果转换成模型对象，然后由 orm 框架进行一些逻辑处理，把准备好的数据，送到视图层的渲染引擎去渲染，渲染引擎负责模板的管理，字段的友好显示，也包括负责一些多国语言之类的任务。对于一条请求在 mvc 中的生命周期，可以参考这里，<a href="https://link.jianshu.com/?t=http://zrj.me/archives/404">临摹了一个 PHP MVC 框架</a>，在视图层把页面准备好后，再从动态脚本解释器送回到 http 服务器，由 http 服务器把这些正文加上一个响应头，封装成一个标准的 http 响应包，再通过 tcp ip 协议，送回到客户机浏览器。</p><h3 id="9-浏览器开始处理数据信息并渲染页面"><a href="#9-浏览器开始处理数据信息并渲染页面" class="headerlink" title="9.浏览器开始处理数据信息并渲染页面"></a><strong>9.浏览器开始处理数据信息并渲染页面</strong></h3><p>历经千辛万苦，我们请求的响应终于成功到达了客户端的浏览器，响应到达浏览器之后，浏览器首先会根据返回的响应报文里的一个重要信息——状态码，来做个判断。如果是 200 开头的就好办，表示请求成功，直接进入渲染流程，如果是 300 开头的就要去相应头里面找 location 域，根据这个 location 的指引，进行跳转，这里跳转需要开启一个跳转计数器，是为了避免两个或者多个页面之间形成的循环的跳转，当跳转次数过多之后，浏览器会报错，同时停止。比如：301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。如果是 400 开头或者 500 开头的状态码，浏览器也会给出一个错误页面。比如：404 not found 就表示客户端请求的资源找不到。</p><p>当浏览得到一个正确的 200 响应之后，接下来面临的一个问题就是多国语言的编码解析了，响应头是一个 ascii 的标准字符集的文本，这个还好办，但是响应的正文本质上就是一个字节流，对于这一坨字节流，浏览器要怎么去处理呢？首先浏览器会去看响应头里面指定的 encoding 域，如果有了这个东西，那么就按照指定的 encoding 去解析字符，如果没有的话，那么浏览器会使用一些比较智能的方式，去猜测和判断这一坨字节流应该使用什么字符集去解码。相关的笔记可以看这里，<a href="https://www.jianshu.com/p/d38a79a4f0f4">字符集编码</a></p><p>接下来就是构建 dom 树了，在 html 语言嵌套正常而且规范的情况下，这种 xml 标记的语言是比较容易的能够构建出一棵 dom 树出来的，当然，对于互联网上大量的不规范的页面，不同的浏览器应该有自己不同的容错去处理。构建出来的 dom 本质上还是一棵抽象的逻辑树，构建 dom 树的过程中，如果遇到了由 script 标签包起来的 js 动态脚本代码，那么会把代码送到 js 引擎里面去跑，如果遇到了 style 标签包围起来的 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 或 css 和 js等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 http 请求，去把这个文件拉取回来，值得一提的是，对于同一个域名下的下载过程来说，浏览器一般允许的并发请求是有限的，通常控制在两个左右，所以如果有很多的图片的话，一般出于优化的目的，都会把这些图片使用一台静态文件的服务器来保存起来，负责响应，从而减少主服务器的压力。</p><p>dom 树构造好了之后，就是根据 dom 树和 css 样式表来构造 render 树了，这个才是真正的用于渲染到页面上的一个一个的矩形框的树，网页渲染是浏览器最复杂、最核心的功能，对于 render 树上每一个框，需要确定他的 x y 坐标，尺寸，边框，字体，形态，等等诸多方面的东西，render 树一旦构建完成，整个页面也就准备好了，可以上菜了。需要说明的是，下载页面，构建 dom 树，构建 render 树这三个步骤，实际上并不是严格的先后顺序的，为了加快速度，提高效率，让用户不要等那么久，现在一般都并行的往前推进的，现代的浏览器都是一边下载，下载到了一点数据就开始构建 dom 树，也一边开始构建 render 树，构建了一点就显示一点出来，这样用户看起来就不用等待那么久了。</p><h3 id="10-将渲染好的页面图像显示出来，并开始响应用户的操作"><a href="#10-将渲染好的页面图像显示出来，并开始响应用户的操作" class="headerlink" title="10.将渲染好的页面图像显示出来，并开始响应用户的操作"></a><strong>10.将渲染好的页面图像显示出来，并开始响应用户的操作</strong></h3><p>这一步主要涉及显卡，内存及显示器原理等知识，不做详细解说，大概就是从内存到 LCD/LED，再由光线进入人眼的一个过程。</p><blockquote><p>以上过程简单讲主要是：从输入 URL 到浏览器接收（回车前），从浏览器接收到数据如何发送给网卡（回车后），再把接收的数据从本机网卡发送到服务器，服务器接收到数据后做了怎么的处理？服务器返回数据后浏览器又做了哪些处理？浏览器又是如何将处理好的页面展现在屏幕上的？的这么一个过程。<br> 但只是最基本的一些步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML等等，还需要考虑很多情况，比如广播、拆包解包合并包丢包重传、路由表，NAT、TCP 状态机、CDN、HTTPS 证书校验与中间人攻击检测、RSA 密钥协商、AES 加解密、浏览器解析 HTTP 的有限自动状态机、GUI 库与绘图、OpenGL 绘图、GPU 加速（OpenCL 与 CUDA）、JIT（JavaScript 会把 JavaScript 代码编译成汇编代码）、服务器的数据库 NoSQL 或 SQL 查询、主从数据库同步、服务器和浏览器的内存管理（WebKit 实现的 fastMalloc()，服务器上可能是 TCMalloc 或者 JeMalloc）、服务器上的语言解释器（可能也是 JIT）、多媒体：傅里叶变换、H.264 解码（硬件解码，硬件解码的话 GPU 的处理单元又在计算…….或软件解码）、音频解码、WebGL 绘图、浏览器的 Sandbox、服务器的 SQL 注入检查、产生的键盘中断信号处理（或者是高级层面的输入输出驱动）、网卡驱动、网络栈的 TCP FastOpen、SYN Cookie 之类众多技术……每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。即便是计算机专业的同学看了也会头大，但我保证这里面的每一个步骤都经过深思熟虑和时间的考验的，并不是谁闲的蛋疼非要搞得那么复杂，不复杂也不行啊。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出了你难以想象的努力。有兴趣的可以阅读下<br> <a href="https://link.jianshu.com/?t=http://kb.cnblogs.com/page/132716/">你刚才在淘宝上买了一件东西</a></p></blockquote><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-3983d99c29c8f967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>浏览器解析渲染页面原理</p><p><a href="https://link.jianshu.com/?t=http://coolshell.cn/articles/9666.html">http://coolshell.cn/articles/9666.html</a><br><a href="https://www.jianshu.com/p/e305ace24ddf">http://www.jianshu.com/p/e305ace24ddf</a><br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000005169412">https://segmentfault.com/a/1190000005169412</a><br><a href="https://link.jianshu.com/?t=https://www.chengrang.com/how-browsers-work.html">https://www.chengrang.com/how-browsers-work.html</a><br><strong>参考资料</strong>：<br><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html">了解html页面的渲染过程</a><br><a href="https://link.jianshu.com/?t=https://leohxj.gitbooks.io/front-end-database/content/">前端工程师手册</a><br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000005169412">浏览器渲染那些事</a><br><a href="https://link.jianshu.com/?t=http://fex.baidu.com/blog/2014/05/what-happen/">手机上从输入URL到页面加载完成的过程中都发生了什么？</a><br><a href="https://link.jianshu.com/?t=https://github.com/skyline75489/what-happens-when-zh_CN">当页面渲染时，浏览器发生了什么？</a><br><a href="https://link.jianshu.com/?t=https://www.chengrang.com/how-browsers-work.html">浏览器工作原理分析与首屏加载</a><br><a href="https://link.jianshu.com/?t=https://www.youtube.com/watch?v=eeS4brbDVuU">https://www.youtube.com/watch?v=eeS4brbDVuU</a></p><h1 id="7-动画性能"><a href="#7-动画性能" class="headerlink" title="7.动画性能"></a>7.动画性能</h1><p>先总结几个要点</p><ol><li><h4 id="精简DOM，合理布局"><a href="#精简DOM，合理布局" class="headerlink" title="精简DOM，合理布局"></a>精简DOM，合理布局</h4></li><li><h4 id="使用transform代替left、top减少使用引起页面重排的属性"><a href="#使用transform代替left、top减少使用引起页面重排的属性" class="headerlink" title="使用transform代替left、top减少使用引起页面重排的属性"></a>使用transform代替left、top减少使用引起页面重排的属性</h4></li><li><h4 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h4></li><li><h4 id="尽量避免浏览器创建不必要的图形层"><a href="#尽量避免浏览器创建不必要的图形层" class="headerlink" title="尽量避免浏览器创建不必要的图形层"></a>尽量避免浏览器创建不必要的图形层</h4></li><li><h4 id="尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame"><a href="#尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame" class="headerlink" title="尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame"></a>尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame</h4></li><li><h4 id="使用chrome-performance工具调试动画性能"><a href="#使用chrome-performance工具调试动画性能" class="headerlink" title="使用chrome performance工具调试动画性能"></a>使用chrome performance工具调试动画性能</h4></li></ol><p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于24镇的动画，人眼就能感受到停顿，每秒30-60帧才能比较流畅 浏览器会按照大多数显示器的刷新频率60Hz来刷新动画， 如果想达到60FPS,就意味着每一帧的任务耗时不能高于16毫秒。</p><p>通过下图我们可以了解浏览器渲染每一帧的过程</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-a41d34fd8b262bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1095/format/webp" alt="img"></p><p>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</p><p>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</p><p>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</p><p>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</p><p>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</p><p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</p><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</p><p>重排还重绘会消耗大量的CPU和GPU资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-67a605f7213dd67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt="img"></p><p>影响网页渲染的因素</p><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的DOM元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简DOM元素，合理布局。</p><p>另外Table元素的重排和重绘成本要高于div，所以我们提倡使用div+css布局，尽量避免使用table布局。</p><p>还有其他对渲染性能有影响的操作，比如：</p><ul><li>DOM元素读写分离</li><li>让进行大量动画的元素脱离文档流，减少重排开销</li><li>通过改变元素的class或csstext一次性的更改样式</li><li>缓存DOM元素的位置信息，避免不必要的属性读取</li><li>尽量使用离线DOM</li><li>使用css3 transform优化动画性能</li></ul><h3 id="使用css3-transform"><a href="#使用css3-transform" class="headerlink" title="使用css3 transform"></a>使用css3 transform</h3><p>该CSS属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改CSS 可视格式模型的坐标空间来实现的。<br> 如果该属性的值不是none，则会创建一个堆叠上下文。在这种情况下，该对象将充当position: fixed的包含块（所以position: fixed的元素将会被他覆盖）。</p><h3 id="css3-transform-的执行效率"><a href="#css3-transform-的执行效率" class="headerlink" title="css3 transform 的执行效率"></a>css3 transform 的执行效率</h3><p>我们通过一个例子来解释为什么transform的动画执行效果更佳。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>--&gt;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">transition</span>: height <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">height</span>: <span class="number">200px</span>; &#125; </span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> --&gt;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>); <span class="attribute">transition</span>: transform <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.0</span>); &#125;</span><br></pre></td></tr></table></figure><p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-2f9474dd0744d413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455/format/webp" alt="img"></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-a013fcb7fed434ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510/format/webp" alt="img"></p><p>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到GPU内存中的操作是个相对耗时的操作。</p><p>GPU 在如下方面很快：</p><ul><li>绘制位图到屏幕上</li><li>可不断的绘制相同的位图</li><li>将同一位图进行位移、旋转、缩放</li></ul><p>我们看使用了transform属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p><h3 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h3><p>页面一旦在装入并解析完成后，就会表示为许多Web开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。</p><p>在Chrome中实际上有几种不同类型的层：掌管DOM子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。</p><p>拥有单独GraphicsLayer的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。</p><p>什么渲染层会提升为合成层？Chrome在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起Chrome创建层：</p><ul><li>进行3D或者透视变换的CSS属性</li><li>使用硬件加速视频解码的<video>元素</li><li>具有3D（WebGL）上下文或者硬件加速的2D上下文的<canvas>元素</li><li>组合型插件（即Flash）</li><li>具有有CSS透明度动画或者使用动画式Webkit变换的元素</li><li>具有硬件加速的CSS滤镜的元素</li><li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li><li>同级元素中有Z索引比其小的元素，而且该Z索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li></ul><p>提升为合成层简单说来有以下几点好处</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p><p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p><p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)</p><p>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，</p><p>对于合成层占用内存的问题，这里有两个 demo 进行了验证。</p><p><a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-3cdd12ef501d0d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/947/format/webp" alt="img"></p><h3 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a><strong>网页动画的渲染</strong></h3><p>有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。</p><p>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window<span class="selector-class">.requestAnimationFrame</span>(fn);</span><br></pre></td></tr></table></figure><p>**<code>\**</code>window.requestIdleCallback()<code>\**</code>**也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function"><span class="keyword">fn</span>);</span></span><br></pre></td></tr></table></figure><p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function"><span class="keyword">fn</span>, 5000);</span></span><br></pre></td></tr></table></figure><h3 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h3><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance是一个很好的选择。这里请大家参考这篇文章<a href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新Chrome Devtool Performance使用指南</a></p><h1 id="8-渲染合成层"><a href="#8-渲染合成层" class="headerlink" title="8.渲染合成层"></a>8.渲染合成层</h1><h2 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p><blockquote><ul><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染</li></ul></blockquote><p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p><blockquote><ul><li>解析html建立dom树</li><li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。</li></ul></blockquote><p>参考一张图（webkit渲染主要流程）：</p><p><img data-src="https://segmentfault.com/img/bVHJfZ?w=624&h=289" alt="图片描述"></p><p>这里先解释一下几个概念，方便大家理解：</p><p>　　DOM Tree：浏览器将HTML解析成树形的数据结构。</p><p>　　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p><p>　　Render Tree: DOM和CSSOM合并后生成Render Tree。</p><p>　　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p><p>　　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p><p>　　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p><p>　　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p><p>注意：</p><ol><li>display:none 的节点不会被加入Render Tree，而visibility: hidden<br>则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</li><li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li></ol><p>再参考一张图理解一下：</p><p><img data-src="https://segmentfault.com/img/bV7TBl?w=700&h=111" alt="图片描述"></p><p>细致分离两个环节，其他环节参考上述概念注解：</p><p><code>JavaScript</code>：JavaScript实现动画效果，DOM元素操作等。<br><code>Composite（渲染层合并）</code>：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p><p>在实际场景下，大致会出现三种常见的渲染流程（Layout和Paint步骤是可避免的，可参考上一张图的注意部分理解）：</p><p><img data-src="https://segmentfault.com/img/bV7TKK?w=580&h=381" alt="图片描述"></p><hr><h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h4><blockquote><p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p><ul><li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li><li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和GraphicsLayer(负责 RenderLayer的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li><li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li><li>Chrome 使用纹理来从 GPU上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是3DCSS 的工作原理，它对于快速滚动也十分有效。</li></ul></blockquote><p>整个图：</p><p><img data-src="https://segmentfault.com/img/bV7URO?w=650&h=268" alt="图片描述"></p><p>在 Chrome 中其实有几种不同的层类型：</p><ul><li>RenderLayers 渲染层，这是负责对应 DOM 子树</li><li>GraphicsLayers 图形层，这是负责对应 RenderLayers子树。</li></ul><p>在浏览器渲染流程中提到了composite概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。</p><p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p><p>而每个GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p><h2 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><blockquote><h4 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p><ul><li>3D 或透视变换(perspective transform) CSS 属性</li><li>使用加速视频解码的 <video> 元素 拥有 3D</li><li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li><li>混合插件(如 Flash)</li><li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li><li>拥有加速 CSS 过滤器的元素</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul></blockquote><h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦renderLayer提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p><strong>注意：</strong></p><ol><li>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。</li><li>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</li><li>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</li></ol><p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p><p><strong>性能优化点：</strong></p><ol><li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 <code>提升合成层的最好方式是使用 CSS 的 will-change属性。从上一节合成层产生原因中，可以知道 will-change 设置为opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</code></li><li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li><li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。<code>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</code></li></ol><h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol><li>合成层占用内存的问题</li><li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：<code>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。</code> 在这篇<a href="http://div.io/topic/1348">文章</a>中的<a href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li></ol><p>用chremo打开demo页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：</p><p><img data-src="https://segmentfault.com/img/bV85wj?w=1056&h=1358" alt="图片描述"></p><p>开启 Rendering 的Layer borders后 观察点击<code>为动画元素设置z-index复选框</code>的页面提示变化：</p><p><img data-src="https://segmentfault.com/img/bV85zk?w=1056&h=1206" alt="图片描述"></p><p>上图中可以明显看出：页面中设置了一个h1标题，应用了translate3d动画，使得它被放到composited layer中渲染，然后在这个元素后面创建了2000个list。在不为h1元素设置z-index的情况下，使得本不需要提升到合成层的ul元素下的每个li元素都提升为一个单独合成层（每个li元素的黄色提示边框），最终会导致GPU资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。</p><p><img data-src="https://segmentfault.com/img/bV85Ag?w=1070&h=1200" alt="图片描述"></p><p>如上图操作选中<code>为动画元素设置z-index</code>，可以看出ul下的每个li都回归到普通渲染层，不再是合成层也就不会消耗GPU资源去渲染，从而达到了优化页面性能优化的目的。</p><p>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加z-index前后的性能差距非常明显。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。<br>关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。<br>最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！</p><p><strong>参考文章：</strong><br><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a><br><a href="https://www.html5rocks.com/zh/tutorials/speed/layers/">DOM to Screen</a><br><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">CSS GPU Animation: Doing It Right</a><br>[web优化之composite](<a href="https://github.com/hello2dj/blog/blob/master/%08web%E4%BC%98%E5%8C%96%E4%B9%8Bcomposite.md">https://github.com/hello2dj/blog/blob/master/web优化之composite.md</a>)<br><a href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a><br><a href="http://div.io/topic/1348">CSS3硬件加速也有坑</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端性能优化的相关内容，好好掌握消化，其实这一部分实用性远高于应试性，很考验各位前端仔的实战水平的&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端性能" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
    <category term="优化" scheme="https://hxy1997.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>javascript面试问题</title>
    <link href="https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-22T16:09:54.000Z</published>
    <updated>2021-03-06T03:47:04.620Z</updated>
    
    <content type="html"><![CDATA[<p>javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  <a href="https://github.com/mqyqingfeng/Blog">冴羽的博客</a> ，内容丰富，适合有一定JS基础的人进行阅读</p><span id="more"></span><h1 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h1><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个构造函数都有一个 prototype 属性 ，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 虽然写在注释里，但是你要注意：</span><br><span class="line">&#x2F;&#x2F; prototype是对象的属性</span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person2.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在Firefox或者Chrome中控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图"></a></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为同一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person &#x3D;&#x3D;&#x3D; Person.prototype.constructor); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图"></a></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图"></a></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 就是 Object.prototype 没有原型，表达了同一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 关键 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>缺点：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向Parent传参</p><h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义每个子类实例不能共享父函数，浪费内存，开销较大。不能继承父类原型。</p><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">Child.prototype.constructor &#x3D; Child;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#39;black&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class="line">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class="line">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;kevin&#39;,</span><br><span class="line">    friends: [&#39;daisy&#39;, &#39;kelly&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; createObj(person);</span><br><span class="line">var person2 &#x3D; createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name &#x3D; &#39;person1&#39;;</span><br><span class="line">console.log(person2.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#39;taylor&#39;);</span><br><span class="line">console.log(person2.friends); &#x2F;&#x2F; [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone &#x3D; Object.create(o);</span><br><span class="line">    clone.sayName &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype &#x3D; new Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键的三步</span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line">F.prototype &#x3D; Parent.prototype;</span><br><span class="line">Child.prototype &#x3D; new F();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype(child, parent) &#123;</span><br><span class="line">    var prototype &#x3D; object(parent.prototype);</span><br><span class="line">    prototype.constructor &#x3D; child;</span><br><span class="line">    child.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h1 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链"></a>3.作用域链</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>函数的作用域在函数定义的时候就决定了,这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] &#x3D; [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] &#x3D; [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope &#x3D; [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h2 id="按照步骤分析"><a href="#按照步骤分析" class="headerlink" title="按照步骤分析"></a>按照步骤分析</h2><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 &#x3D; &#39;local scope&#39;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#39;local scope&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>MDN 对闭包的定义为：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p><p>那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……</p><p>还真是这样的！</p><p>所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><p>这只是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：</p><p>ECMAScript中，从实践角度，以下函数才算是闭包：</p><p>1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p><p>2.在代码中引用了自由变量</p><p>接下来就来讲讲实践上的闭包。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><p>这里直接给出简要的执行过程：</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p>了解到这个过程，我们应该思考一个问题，那就是：</p><p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)</p><p>然而 JavaScript 却是可以的！</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext &#x3D; &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</p><p>所以，让我们再看一遍实践角度上闭包的定义：</p><ol><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol><p>在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义:</p><blockquote><p>This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p></blockquote><p>闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。</p><h2 id="必刷题"><a href="#必刷题" class="headerlink" title="必刷题"></a>必刷题</h2><p>接下来，看这道刷题必刷，面试必考的闭包题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>答案是都是 3，让我们分析一下原因：</p><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><p>data[1] 和 data[2] 是一样的道理。</p><p>所以让我们改成闭包看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; (function (i) &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟没改之前一模一样。</p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数执行上下文的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 0,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。</p><p>data[1] 和 data[2] 是一样的道理。</p><h1 id="5-变量对象"><a href="#5-变量对象" class="headerlink" title="5.变量对象"></a>5.变量对象</h1><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p><blockquote><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p></blockquote><blockquote><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p></blockquote><blockquote><p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p></blockquote><p>如果看的不是很懂的话，容我再来介绍下全局对象:</p><p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br></pre></td></tr></table></figure><p>2.全局对象是由 Object 构造函数实例化的一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this instanceof Object);</span><br></pre></td></tr></table></figure><p>3.预定义了一堆，嗯，一大堆函数和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 都能生效</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(this.Math.random());</span><br></pre></td></tr></table></figure><p>4.作为全局变量的宿主。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(this.a);</span><br></pre></td></tr></table></figure><p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(window.a);</span><br><span class="line"></span><br><span class="line">this.window.b &#x3D; 2;</span><br><span class="line">console.log(this.b);</span><br></pre></td></tr></table></figure><p>花了一个大篇幅介绍全局对象，其实就想说：</p><p>全局上下文中的变量对象就是全局对象呐！</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后让我们看几个例子：</p><p>1.第一题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; ???</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; ???</span><br></pre></td></tr></table></figure><p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p><p>第二段会打印：<code>1</code>。</p><p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p><p>第一段执行 console 的时候， AO 的值是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p><p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p><p>2.第二题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo);</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; 1;</span><br></pre></td></tr></table></figure><p>会打印函数，而不是 undefined 。</p><p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><h1 id="6-从ECMAScript规范解读this"><a href="#6-从ECMAScript规范解读this" class="headerlink" title="6.从ECMAScript规范解读this"></a>6.从ECMAScript规范解读this</h1><p> ECMAScript 5.1 规范地址：</p><p>英文版：<a href="http://es5.github.io/#x15.1">http://es5.github.io/#x15.1</a></p><p>中文版：<a href="http://yanhaijing.com/es5/#115">http://yanhaijing.com/es5/#115</a></p><p>让我们开始了解规范吧！</p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>首先是第 8 章 Types：</p><p>ECMAScript 的类型分为语言类型和规范类型。</p><p>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。</p><p>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p><p>没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p> Reference 类型。它与 this 的指向有着密切的关联。</p><p>让我们看 8.7 章 The Reference Specification Type：</p><blockquote><p>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.</p></blockquote><p>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。</p><p>抄袭尤雨溪大大的话，就是：</p><blockquote><p>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p></blockquote><p>再看接下来的这段具体介绍 Reference 的内容：</p><blockquote><p>A Reference is a resolved name binding.</p></blockquote><blockquote><p>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.</p></blockquote><blockquote><p>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).</p></blockquote><blockquote><p>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p><ul><li>base value</li><li>referenced name</li><li>strict reference</li></ul><p>可是这些到底是什么呢？</p><p>我们简单的理解的话：</p><p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p><p>referenced name 就是属性的名称。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 对应的Reference是：</span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bar对应的Reference是：</span><br><span class="line">var BarReference &#x3D; &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &#39;bar&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p><p>这两个方法很简单，简单看一看：</p><p>1.GetBase</p><blockquote><p>GetBase(V). Returns the base value component of the reference V.</p></blockquote><p>返回 reference 的 base value。</p><p>2.IsPropertyReference</p><blockquote><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p></blockquote><p>简单的理解：如果 base value 是一个对象，就返回true。</p><h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。</p><p>简单模拟 GetValue 的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) &#x2F;&#x2F; 1;</span><br></pre></td></tr></table></figure><p>GetValue 返回对象属性真正的值，但是要注意：</p><p><strong>调用 GetValue，返回的将是具体的值，而不再是一个 Reference</strong></p><p>这个很重要，这个很重要，这个很重要。</p><h2 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h2><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：</p><p>看规范 11.2.3 Function Calls：</p><p>这里讲了当函数调用的时候，如何确定 this 的取值。</p><p>只看第一步、第六步、第七步：</p><blockquote><p>1.Let <em>ref</em> be the result of evaluating MemberExpression.</p></blockquote><blockquote><p>6.If Type(<em>ref</em>) is Reference, then</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.If IsPropertyReference(ref) is true, then</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be GetBase(ref).</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.Else, the base of ref is an Environment Record</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).</span><br></pre></td></tr></table></figure><p>7.Else, Type(<em>ref</em>) is not Reference.</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a. Let thisValue be undefined.</span><br></pre></td></tr></table></figure></blockquote><p>让我们描述一下：</p><p>1.计算 MemberExpression 的结果赋值给 ref</p><p>2.判断 ref 是不是一个 Reference 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</span><br><span class="line"></span><br><span class="line">2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</span><br><span class="line"></span><br><span class="line">2.3 如果 ref 不是 Reference，那么 this 的值为 undefined</span><br></pre></td></tr></table></figure><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>让我们一步一步看：</p><ol><li>计算 MemberExpression 的结果赋值给 ref</li></ol><p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：</p><p>MemberExpression :</p><ul><li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li><li>FunctionExpression // 函数定义表达式</li><li>MemberExpression [ Expression ] // 属性访问表达式</li><li>MemberExpression . IdentifierName // 属性访问表达式</li><li>new MemberExpression Arguments // 对象创建表达式</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); &#x2F;&#x2F; MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); &#x2F;&#x2F; MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure><p>所以简单理解 MemberExpression 其实就是()左边的部分。</p><p>2.判断 ref 是不是一个 Reference 类型。</p><p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p><p>举最后一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><p>在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？</p><p>查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：</p><blockquote><p>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.</p></blockquote><p>我们得知该表达式返回了一个 Reference 类型！</p><p>根据之前的内容，我们知道该值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference &#x3D; &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &#39;bar&#39;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来按照 2.1 的判断流程走：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？</p><p>前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。</p><p>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。</p><p>这个时候我们就可以确定 this 的值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this &#x3D; GetBase(ref)，</span><br></pre></td></tr></table></figure><p>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！</p><p>唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。</p><h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><p>看示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((foo.bar)());</span><br></pre></td></tr></table></figure><p>foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator</p><p>直接看结果部分：</p><blockquote><p>Return the result of evaluating Expression. This may be of type Reference.</p></blockquote><blockquote><p>NOTE This algorithm does not apply GetValue to the result of evaluating Expression.</p></blockquote><p>实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。</p><h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h3><p>看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ):</p><p>计算的第三步：</p><blockquote><p>3.Let rval be GetValue(rref).</p></blockquote><p>因为使用了 GetValue，所以返回的值不是 Reference 类型，</p><p>按照之前讲的判断逻辑：</p><blockquote><p>2.3 如果 ref 不是Reference，那么 this 的值为 undefined</p></blockquote><p>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。</p><h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><p>看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators：</p><p>计算第二步：</p><blockquote><p>2.Let lval be GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><p>看示例5，逗号操作符，查看规范11.14 Comma Operator ( , )</p><p>计算第二步：</p><blockquote><p>2.Call GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="揭晓结果"><a href="#揭晓结果" class="headerlink" title="揭晓结果"></a>揭晓结果</h3><p>所以最后一个例子的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</p><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>最最后，忘记了一个最最普通的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure><p>MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来进行判断：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。</p><p>IsPropertyReference(ref) 的结果为 false，进入下个判断：</p><blockquote><p>2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</p></blockquote><p>base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)</p><p>查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。</p><p>所以最后 this 的值就是 undefined。</p><h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。</p><p>此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。</p><h1 id="7-立即执行函数"><a href="#7-立即执行函数" class="headerlink" title="7.立即执行函数"></a>7.立即执行函数</h1><p>可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。</p><p>除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到<strong>立即调用函数表达式</strong>进行阅读，但是我建议你读完整篇文章。</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter() &#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(++i);</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记住：&#96;counter&#96;和&#96;counter2&#96;都有他们自己的变量 &#96;i&#96;</span><br><span class="line"></span><br><span class="line">var counter &#x3D; makeCounter();</span><br><span class="line">counter();&#x2F;&#x2F;1</span><br><span class="line">counter();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">var counter2 &#x3D; makeCounter();</span><br><span class="line">counter2();&#x2F;&#x2F;1</span><br><span class="line">counter2();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">i;&#x2F;&#x2F;ReferenceError: i is not defined(它只存在于makeCounter里)</span><br></pre></td></tr></table></figure><p>在许多情况下，你可能并不需要<code>makeWhatever</code>这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。</p><h3 id="它的核心"><a href="#它的核心" class="headerlink" title="它的核心"></a>它的核心</h3><p>现在，无论你定义一个函数像这样<code>function foo()&#123;&#125;</code>或者<code>var foo = function()&#123;&#125;</code>，调用时，你都需要在后面加上一对圆括号，像这样<code>foo()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样&#96;foo()&#96;，</span><br><span class="line">&#x2F;&#x2F;因为foo相对于函数表达式&#96;function()&#123;&#x2F;* code *&#x2F;&#125;&#96;只是一个引用变量</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？</span><br><span class="line"></span><br><span class="line">function()&#123; &#x2F;* code *&#x2F;&#125;(); &#x2F;&#x2F;SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure><p>正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的<code>function</code>关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。</p><p><strong>问题1：</strong>这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数 <code>var foo = function()&#123;console.log(1)&#125;()</code>，答案是可以的。<br><strong>问题2：</strong>同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。</p><h3 id="函数，圆括号，错误"><a href="#函数，圆括号，错误" class="headerlink" title="函数，圆括号，错误"></a>函数，圆括号，错误</h3><p>有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span><br><span class="line"></span><br><span class="line">function foo()&#123; &#x2F;* code *&#x2F; &#125;();&#x2F;&#x2F;SyntaxError: Unexpected token</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line">(1);</span><br></pre></td></tr></table></figure><h2 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h2><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能<strong>包含</strong>声明。因为这点，当圆括号为了包裹函数碰上了 <code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。<strong>注意理解</strong>这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p><ul><li>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</li><li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量</span><br><span class="line"></span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;());&#x2F;&#x2F;Crockford recommends this one，括号内的表达式代表函数立即调用表达式</span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;)();&#x2F;&#x2F;But this one works just as well，括号内的表达式代表函数表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Because the point of the parens or coercing operators is to disambiguate</span><br><span class="line">&#x2F;&#x2F; between function expressions and function declarations, they can be</span><br><span class="line">&#x2F;&#x2F; omitted when the parser already expects an expression (but please see the</span><br><span class="line">&#x2F;&#x2F; &quot;important note&quot; below).</span><br><span class="line"></span><br><span class="line">var i &#x3D; function()&#123;return 10;&#125;();</span><br><span class="line">true &amp;&amp; function()&#123;&#x2F;*code*&#x2F;&#125;();</span><br><span class="line">0,function()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节</span><br><span class="line"></span><br><span class="line">!function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">~function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">-function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">+function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Here&#39;s another variation, from @kuvos - I&#39;m not sure of the performance</span><br><span class="line">&#x2F;&#x2F; implications, if any, of using the &#96;new&#96; keyword, but it works.</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;twitter.com&#x2F;kuvos&#x2F;status&#x2F;18209252090847232</span><br><span class="line"></span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;</span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;() &#x2F;&#x2F; Only need parens if passing arguments</span><br></pre></td></tr></table></figure><h3 id="关于括号的重要笔记"><a href="#关于括号的重要笔记" class="headerlink" title="关于括号的重要笔记"></a>关于括号的重要笔记</h3><p>在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。</p><p>这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。</p><p>作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误 <code>WTFError</code>!</p><h3 id="保存闭包的状态"><a href="#保存闭包的状态" class="headerlink" title="保存闭包的状态"></a>保存闭包的状态</h3><p>就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 它的运行原理可能并不像你想的那样，因为&#96;i&#96;的值从来没有被锁定。</span><br><span class="line">&#x2F;&#x2F; 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，</span><br><span class="line">&#x2F;&#x2F; 因为这是 &#96;i&#96; 此时的真实值。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(&#39;I am link #&#39; + i)</span><br><span class="line">        &#125;,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 而像下面这样改写，便可以了，因为在IIFE里，&#96;i&#96;值被锁定在了&#96;lockedInIndex&#96;里。</span><br><span class="line">&#x2F;&#x2F; 在循环结束执行时，尽管&#96;i&#96;值的数值是所有元素的总和，但每一次函数表达式被调用时，</span><br><span class="line">&#x2F;&#x2F; IIFE 里的 &#96;lockedInIndex&#96; 值都是&#96;i&#96;传给它的值,所以当链接被点击时，正确的值被弹出。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length;i++) &#123;</span><br><span class="line">    (function(lockedInIndex)&#123;</span><br><span class="line">        elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(&#39;I am link #&#39; + lockedInIndex);</span><br><span class="line">            &#125;,false)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个&#96;addEventListener&#96;。</span><br><span class="line">&#x2F;&#x2F;无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName( &#39;a&#39; );</span><br><span class="line"></span><br><span class="line">for ( var i &#x3D; 0; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[ i ].addEventListener( &#39;click&#39;, (function( lockedInIndex )&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( &#39;I am link #&#39; + lockedInIndex );</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;)( i ),false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记住，在这最后两个例子里，<code>lockedInIndex</code>可以没有任何问题的访问<code>i</code>,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。</p><p>立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。</p><h4 id="自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？"><a href="#自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？" class="headerlink" title="自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？"></a>自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？</h4><p>你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成**”Immediately-Invoked Function Expression”<strong>，或者，</strong>IIFE**，如果你喜欢缩写的话。</p><p>什么是<strong>Immediately-Invoked Function Expression</strong>呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。</p><p>我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，<strong>Immediately-Invoked Function Expression</strong>和 <strong>IIFE</strong>，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下面是个自执行函数，递归的调用自己本身</span><br><span class="line"></span><br><span class="line">function foo()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是一个自执行匿名函数。因为它没有标识符，它必须是使用&#96;arguments.callee&#96;属性来调用它自己</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;arguments.callee();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这也许算是一个自执行匿名函数，但是仅仅当&#96;foo&#96;标识符作为它的引用时，如果你将它换成用&#96;foo&#96;来调用同样可行</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有些人像这样叫&#39;self-executing anonymous function&#39;下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。</span><br><span class="line"></span><br><span class="line">(function()&#123; &#x2F;*code*&#x2F; &#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。</span><br><span class="line"></span><br><span class="line">(function foo()&#123;&#x2F;* code *&#x2F;&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IIFEs同样也可以自执行，尽管，也许他不是最有用的模式</span><br><span class="line"></span><br><span class="line">(function()&#123;arguments.callee();&#125;())</span><br><span class="line">(function foo()&#123;foo();&#125;())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; One last thing to note: this will cause an error in BlackBerry 5, because</span><br><span class="line">&#x2F;&#x2F; inside a named function expression, that name is undefined. Awesome, huh?</span><br><span class="line"></span><br><span class="line">(function foo()&#123; foo(); &#125;());</span><br></pre></td></tr></table></figure><p>希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，<strong>Immediately Invoked Function Expression</strong>，既可以是命名函数也可以匿名函数。</p><h2 id="最后：模块模式"><a href="#最后：模块模式" class="headerlink" title="最后：模块模式"></a>最后：模块模式</h2><p>当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不属性 JavaScript 里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; (function()&#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            i &#x3D; val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: function()&#123;</span><br><span class="line">            return ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">    counter.get();&#x2F;&#x2F;0</span><br><span class="line">    counter.set(3);</span><br><span class="line">    counter.increment();&#x2F;&#x2F;4</span><br><span class="line">    counter.increment();&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class="line">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure><p>模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。</p><h1 id="8-instanceof-和-typeof-的实现原理"><a href="#8-instanceof-和-typeof-的实现原理" class="headerlink" title="8.instanceof 和 typeof 的实现原理"></a>8.instanceof 和 typeof 的实现原理</h1><h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>,  <code>string</code>,  <code>object</code>,  <code>boolean</code>,  <code>function</code>, <code>undefined</code>,  <code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">typeof s &#x3D;&#x3D;&#x3D; &#39;object&#39;&#x2F;&#x2F; true</span><br><span class="line">s instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><p><code>null</code>：所有机器码均为0</p><p><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null instanceof null &#x2F;&#x2F; TypeError: Right-hand side of &#39;instanceof&#39; is not an object</span><br></pre></td></tr></table></figure><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>。</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(1) &#x2F;&#x2F; &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#39;hi&#39;) &#x2F;&#x2F; &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;a:&#39;hi&#39;&#125;) &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([1,&#39;a&#39;]) &#x2F;&#x2F; &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true) &#x2F;&#x2F; &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(() &#x3D;&gt; &#123;&#125;) &#x2F;&#x2F; &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null) &#x2F;&#x2F; &quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) &#x2F;&#x2F; &quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(Symbol(1)) &#x2F;&#x2F; &quot;[object Symbol]&quot;</span><br></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let nicole &#x3D; new person()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let programmer &#x3D; function () &#123;&#125;</span><br><span class="line">programmer.prototype &#x3D; new person()</span><br><span class="line">let nicole &#x3D; new programmer()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br><span class="line">nicole instanceof programmer &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function new_instance_of(leftVaule, rightVaule) &#123; </span><br><span class="line">    let rightProto &#x3D; rightVaule.prototype; &#x2F;&#x2F; 取右表达式的 prototype 值</span><br><span class="line">    leftVaule &#x3D; leftVaule.__proto__; &#x2F;&#x2F; 取左表达式的__proto__值</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    if (leftVaule &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftVaule &#x3D;&#x3D;&#x3D; rightProto) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule &#x3D; leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><p>看几个很有趣的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Function &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Foo &#x2F;&#x2F; false</span><br><span class="line">Foo instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Function &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p><p>关于原型继承的原理，我简单用一张图来表示</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p><ul><li><p><code>Object instanceof Object</code></p><p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Object.__proto__ &#x3D; Function.prototype;</span><br><span class="line">rightValue &#x3D; Object.prototype;</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p></li><li><p><code>Foo instanceof Foo</code></p><p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p><p>我们用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Foo</span><br><span class="line">leftValue &#x3D; Foo.__proto &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Foo.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Object.prototype &#x3D; null</span><br><span class="line">&#x2F;&#x2F; 第三次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; null</span><br><span class="line">&#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Object</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Object</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Function</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Function</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Function.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p><h1 id="9-bind实现"><a href="#9-bind实现" class="headerlink" title="9.bind实现"></a>9.bind实现</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 bind:</p><blockquote><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p></blockquote><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回了一个函数</span><br><span class="line">var bindFoo &#x3D; bar.bind(foo); </span><br><span class="line"></span><br><span class="line">bindFoo(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，来写第一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，之所以 <code>return self.apply(context)</code>，是考虑到绑定函数可能是有返回值的，依然是这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">return this.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo);</span><br><span class="line">console.log(bindFoo()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line">bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 获取bind2函数从第二个参数到最后一个参数</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个时候的arguments是指bind返回的函数传入的参数</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    this.habit &#x3D; &#39;shopping&#39;;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend &#x3D; &#39;kevin&#39;;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br><span class="line">console.log(obj.habit);</span><br><span class="line">console.log(obj.friend);</span><br><span class="line">&#x2F;&#x2F; shopping</span><br><span class="line">&#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        &#x2F;&#x2F; 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span><br><span class="line">        &#x2F;&#x2F; 以上面的是 demo 为例，如果改成 &#96;this instanceof fBound ? null : context&#96;，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span><br><span class="line">        &#x2F;&#x2F; 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span><br><span class="line">        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span><br><span class="line">    fBound.prototype &#x3D; this.prototype;</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p><h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p><p><strong>1.apply 这段代码跟 MDN 上的稍有不同</strong></p><p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, args.concat(bindArgs))</span><br></pre></td></tr></table></figure><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    bar: bar.bind(null)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p><p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p><p><strong>2.调用 bind 的不是函数咋办？</strong></p><p>不行，我们要报错！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.我要在线上用</strong></p><p>那别忘了做个兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; Function.prototype.bind || function () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然最好是用 <a href="https://github.com/es-shims/es5-shim">es5-shim</a> 啦。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试够用版"><a href="#面试够用版" class="headerlink" title="面试够用版"></a>面试够用版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function (context, ...args) &#123;</span><br><span class="line">&#x2F;&#x2F; 环境</span><br><span class="line">    context &#x3D; context || window;</span><br><span class="line">    &#x2F;&#x2F; 创建一个Symbol变量，让当前环境指向当前位置</span><br><span class="line">    const fnSymbol &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">    &#x2F;&#x2F; 配置环境</span><br><span class="line">    context[fnSymbol] &#x3D; this;</span><br><span class="line">&#x2F;&#x2F; 返回闭包函数</span><br><span class="line">    return function (..._args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 与当前参数组合</span><br><span class="line">        args &#x3D; args.concat(_args);</span><br><span class="line">&#x2F;&#x2F; 执行函数</span><br><span class="line">        context[fnSymbol](...args);</span><br><span class="line">        &#x2F;&#x2F; 避免闭包的内存泄露</span><br><span class="line">        delete context[fnSymbol];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-call和apply"><a href="#10-call和apply" class="headerlink" title="10.call和apply"></a>10.call和apply</h1><h2 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h2><p>它们的共同点是，都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p><p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p><p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p><h2 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h2><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p><h4 id="call-的写法"><a href="#call-的写法" class="headerlink" title="call 的写法"></a>call 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.call(obj,[param1[,param2[,…[,paramN]]]])</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>调用 call 的对象，必须是个函数 Function。</li><li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li><li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func (a,b,c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, 1,2,3)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.call(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure><h4 id="apply-的写法"><a href="#apply-的写法" class="headerlink" title="apply 的写法"></a>apply 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure><h4 id="什么是类数组？"><a href="#什么是类数组？" class="headerlink" title="什么是类数组？"></a>什么是类数组？</h4><p>先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。</p><p>那么，类数组是什么呢？顾名思义，就是<strong>具备与数组特征类似的对象</strong>。比如，下面的这个对象，就是一个类数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。</p><p>类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。</p><p>但是需要注意的是：<strong>类数组无法使用 forEach、splice、push 等数组原型链上的方法</strong>，毕竟它不是真正的数组。</p><h2 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h2><p>下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。</p><h4 id="call-的使用场景"><a href="#call-的使用场景" class="headerlink" title="call 的使用场景"></a>call 的使用场景</h4><p><strong>1、对象的继承</strong>。如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function superClass () &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">    this.print &#x3D; function () &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subClass () &#123;</span><br><span class="line">    superClass.call(this);</span><br><span class="line">    this.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass();</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p><p><strong>2、借用方法</strong>。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</span><br></pre></td></tr></table></figure><p>这样，domNodes 就可以应用 Array 下的所有方法了。</p><h4 id="apply-的一些妙用"><a href="#apply-的一些妙用" class="headerlink" title="apply 的一些妙用"></a>apply 的一些妙用</h4><p><strong>1、Math.max</strong>。用它来获取数组中最大的一项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let max &#x3D; Math.max.apply(null, array);</span><br></pre></td></tr></table></figure><p>同理，要获取数组中最小的一项，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let min &#x3D; Math.min.apply(null, array);</span><br></pre></td></tr></table></figure><p><strong>2、实现两个数组合并</strong>。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; [1, 2, 3];</span><br><span class="line">let arr2 &#x3D; [4, 5, 6];</span><br><span class="line"></span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h2 id="手写apply和bind"><a href="#手写apply和bind" class="headerlink" title="手写apply和bind"></a>手写apply和bind</h2><p>call的手写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">  context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply的手写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; apply</span><br><span class="line">Function.prototype.myApply &#x3D; function (context &#x3D; window, argsArr) &#123;</span><br><span class="line">  const fn &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 重点代码，利用this指向，相当于context.caller(...args)</span><br><span class="line">  context[fn](...argsArr);</span><br><span class="line">  delete context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-函数柯里化"><a href="#11-函数柯里化" class="headerlink" title="11.函数柯里化"></a>11.函数柯里化</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对柯里化 (Currying) 的定义为：</p><blockquote><p>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p></blockquote><p>翻译成中文：</p><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行 add 函数，一次传入两个参数即可</span><br><span class="line">add(1, 2) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设有一个 curry 函数可以做到柯里化</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1)(2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>我们会讲到如何写出这个 curry 函数，并且会将这个 curry 函数写的很强大，但是在编写之前，我们需要知道柯里化到底有什么用？</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示意而已</span><br><span class="line">function ajax(type, url, data) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 虽然 ajax 这个函数非常通用，但在重复调用的时候参数冗余</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test2.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test3.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用 curry</span><br><span class="line">var ajaxCurry &#x3D; curry(ajax);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求数据</span><br><span class="line">var post &#x3D; ajaxCurry(&#39;POST&#39;);</span><br><span class="line">post(&#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求来自于 www.test.com 的数据</span><br><span class="line">var postFromTest &#x3D; post(&#39;www.test.com&#39;);</span><br><span class="line">postFromTest(&quot;name&#x3D;kevin&quot;);</span><br></pre></td></tr></table></figure><p>想想 jQuery 虽然有 $.ajax 这样通用的方法，但是也有 $.get 和 $.post 的语法糖。</p><p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p><p>可是即便如此，是不是依然感觉没什么用呢？</p><p>如果我们仅仅是把参数一个一个传进去，意义可能不大，但是如果我们是把柯里化后的函数传给其他函数比如 map 呢？</p><p>举个例子：</p><p>比如我们有这样一段数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; [&#123;name: &#39;kevin&#39;&#125;, &#123;name: &#39;daisy&#39;&#125;]</span><br></pre></td></tr></table></figure><p>如果我们要获取所有的 name 值，我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; person.map(function (item) &#123;</span><br><span class="line">    return item.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过如果我们有 curry 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var prop &#x3D; curry(function (key, obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var name &#x3D; person.map(prop(&#39;name&#39;))</span><br></pre></td></tr></table></figure><p>我们为了获取 name 属性还要再编写一个 prop 函数，是不是又麻烦了些？</p><p>但是要注意，prop 函数编写一次后，以后可以多次使用，实际上代码从原本的三行精简成了一行，而且你看代码是不是更加易懂了？</p><p><code>person.map(prop(&#39;name&#39;))</code> 就好像直白的告诉你：person 对象遍历(map)获取(prop) name 属性。</p><p>是不是感觉有点意思了呢？</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>未来我们会接触到更多有关柯里化的应用，不过那是未来的事情了，现在我们该编写这个 curry 函数了。</p><p>一个经常会看到的 curry 函数的实现为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        return fn.apply(this, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry &#x3D; curry(add, 1, 2);</span><br><span class="line">addCurry() &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add, 1);</span><br><span class="line">addCurry(2) &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1, 2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。</p><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function sub_curry(fn) &#123;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(this, args.concat([].slice.call(arguments)));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length) &#123;</span><br><span class="line"></span><br><span class="line">    length &#x3D; length || fn.length;</span><br><span class="line"></span><br><span class="line">    var slice &#x3D; Array.prototype.slice;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        if (arguments.length &lt; length) &#123;</span><br><span class="line">            var combined &#x3D; [fn].concat(slice.call(arguments));</span><br><span class="line">            return curry(sub_curry.apply(this, combined), length - arguments.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们验证下这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    return [a, b, c];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>效果已经达到我们的预期，然而这个 curry 函数的实现好难理解呐……</p><p>为了让大家更好的理解这个 curry 函数，我给大家写个极简版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sub_curry(fn)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length)&#123;</span><br><span class="line">    length &#x3D; length || 4;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if (length &gt; 1) &#123;</span><br><span class="line">            return curry(sub_curry(fn), --length)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn0 &#x3D; function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0)</span><br><span class="line"></span><br><span class="line">fn1()()()() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>大家先从理解这个 curry 函数开始。</p><p>当执行 fn1() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(fn0))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return (function()&#123;</span><br><span class="line">        return fn0()</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跟 fn1()() 的分析过程一样</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()()() 时，因为此时 length &gt; 2 为 false，所以执行 fn()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0()</span><br><span class="line">&#x2F;&#x2F; 执行 fn0 函数，打印 1</span><br></pre></td></tr></table></figure><p>再回到真正的 curry 函数，我们以下面的例子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn0 &#x3D; function(a, b, c, d) &#123;</span><br><span class="line">    return [a, b, c, d];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0);</span><br><span class="line"></span><br><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;)(&quot;d&quot;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”) 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(fn0)(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(sub_curry(fn0, &quot;a&quot;, &quot;b&quot;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">&#x2F;&#x2F; 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为 fn0 后面的参数传入</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”) 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;), &quot;c&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return (function(...) &#123;return fn0(&quot;a&quot;, &quot;b&quot;, ...)&#125;)(&quot;c&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">     return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”)(“d”) 时，此时 arguments.length &lt; length 为 false ，执行 fn(arguments)，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)(&quot;d&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br></pre></td></tr></table></figure><p>函数执行结束。</p><p>所以，其实整段代码又很好理解：</p><p>sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(…)(…) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。</p><p>如果要明白 curry 函数的运行原理，大家还是要动手写一遍，尝试着分析执行步骤。</p><h2 id="更易懂的实现"><a href="#更易懂的实现" class="headerlink" title="更易懂的实现"></a>更易懂的实现</h2><p>当然了，如果你觉得还是无法理解，你可以选择下面这种实现方式，可以实现同样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">    var length &#x3D; fn.length;</span><br><span class="line"></span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line"></span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line"></span><br><span class="line">            arg, i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line"></span><br><span class="line">            _args.push(arg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>或许大家觉得这种方式更好理解，又能实现一样的效果，为什么不直接就讲这种呢？</p><p>因为想给大家介绍各种实现的方法嘛，不能因为难以理解就不给大家介绍呐~</p><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>curry 函数写到这里其实已经很完善了，但是注意这个函数的传参顺序必须是从左到右，根据形参的顺序依次传入，如果我不想根据这个顺序传呢？</p><p>我们可以创建一个占位符，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, _, &quot;c&quot;)(&quot;b&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>我们直接看第三版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function curry(fn, args, holes) &#123;</span><br><span class="line">    length &#x3D; fn.length;</span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line">    holes &#x3D; holes || [];</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line">            _holes &#x3D; holes.slice(0),</span><br><span class="line">            argsLen &#x3D; args.length,</span><br><span class="line">            holesLen &#x3D; holes.length,</span><br><span class="line">            arg, i, index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标</span><br><span class="line">            if (arg &#x3D;&#x3D;&#x3D; _ &amp;&amp; holesLen) &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index &gt; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                    _holes.push(argsLen - 1 + index - holesLen)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1)(_) 这种情况</span><br><span class="line">            else if (arg &#x3D;&#x3D;&#x3D; _) &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">                _holes.push(argsLen + i);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(_, 2)(1) 这种情况</span><br><span class="line">            else if (holesLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(_, 3)</span><br><span class="line">                if (index &gt;&#x3D; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(1) 用参数 1 替换占位符</span><br><span class="line">                else &#123;</span><br><span class="line">                    _args.splice(_holes[index], 1, arg);</span><br><span class="line">                    _holes.splice(index, 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_holes.length || _args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args, _holes);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c, d, e) &#123;</span><br><span class="line">    console.log([a, b, c, d, e]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证 输出全部都是 [1, 2, 3, 4, 5]</span><br><span class="line">fn(1, 2, 3, 4, 5);</span><br><span class="line">fn(_, 2, 3, 4, 5)(1);</span><br><span class="line">fn(1, _, 3, 4, 5)(2);</span><br><span class="line">fn(1, _, 3)(_, 4)(2)(5);</span><br><span class="line">fn(1, _, _, 4)(_, 3)(2)(5);</span><br><span class="line">fn(_, 2)(_, _, 4)(1)(3)(5)</span><br></pre></td></tr></table></figure><h2 id="面试够用版-1"><a href="#面试够用版-1" class="headerlink" title="面试够用版"></a>面试够用版</h2><p>就是第二版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        if (newArgs.length &lt; fn.length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="12-V8引擎的垃圾回收"><a href="#12-V8引擎的垃圾回收" class="headerlink" title="12.V8引擎的垃圾回收"></a>12.V8引擎的垃圾回收</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>作为目前最流行的JavaScript引擎，V8引擎从出现的那一刻起便广泛受到人们的关注，我们知道，JavaScript可以高效地运行在浏览器和Nodejs这两大宿主环境中，也是因为背后有强大的V8引擎在为其保驾护航，甚至成就了Chrome在浏览器中的霸主地位。不得不说，V8引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的<code>Full-codegen</code>和<code>Crankshaft</code>编译器升级为<code>Ignition</code>解释器和<code>TurboFan</code>编译器的强强组合，到隐藏类，内联缓存和<code>HotSpot</code>热点代码收集等一系列强有力的优化策略，V8引擎正在努力降低整体的内存占用和提升到更高的运行性能。</p><p>本篇主要是从V8引擎的垃圾回收机制入手，讲解一下在JavaScript代码执行的整个生命周期中V8引擎是采取怎样的垃圾回收策略来减少内存占比的，当然这部分的知识并不太影响我们写代码的流程，毕竟在一般情况下我们很少会遇到浏览器端出现内存溢出而导致程序崩溃的情况，但是至少我们对这方面有一定的了解之后，能增强我们在写代码过程中对减少内存占用，避免内存泄漏的主观意识，也许能够帮助你写出更加健壮和对V8引擎更加友好的代码。本文也是笔者在查阅资料巩固复习的过程中慢慢总结和整理出来的，若文中有错误的地方，还请指正。</p><h3 id="1、为何需要垃圾回收"><a href="#1、为何需要垃圾回收" class="headerlink" title="1、为何需要垃圾回收"></a>1、为何需要垃圾回收</h3><p>我们知道，在V8引擎逐行执行JavaScript代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。</p><blockquote><p>这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。</p></blockquote><p>但是JavaScript作为一门高级编程语言，并不像C语言或C++语言中需要手动地申请分配和释放内存，V8引擎已经帮我们自动进行了内存的分配和管理，好让我们有更多的精力去专注于业务层面的复杂逻辑，这对于我们前端开发人员来说是一项福利，但是随之带来的问题也是显而易见的，那就是由于不用去手动管理内存，导致写代码的过程中不够严谨从而容易引发内存泄漏(毕竟这是别人对你的好，你没有付出过，又怎能体会得到？)。</p><h3 id="2、V8引擎的内存限制"><a href="#2、V8引擎的内存限制" class="headerlink" title="2、V8引擎的内存限制"></a>2、V8引擎的内存限制</h3><p>虽然V8引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但V8引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8引擎在<code>64</code>位系统下最多只能使用约<code>1.4GB</code>的内存，在<code>32</code>位系统下最多只能使用约<code>0.7GB</code>的内存，在这样的限制下，必然会导致在node中无法直接操作大内存对象，比如将一个<code>2GB</code>大小的文件全部读入内存进行字符串分析处理，即使物理内存高达<code>32GB</code>也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？这个要回到V8引擎的设计之初，起初只是作为浏览器端JavaScript的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：</p><ul><li><code>JS单线程机制</code>：作为浏览器的脚本语言，JS的主要用途是与用户交互以及操作DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。试想如果JS是多线程的，一个线程在删除DOM元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。既然JS是单线程的，那么也就意味着在V8执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行JS逻辑。因此，由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</li></ul><blockquote><p>虽然JS是单线程的，但是为了能够充分利用操作系统的多核CPU计算能力，在HTML5中引入了新的Web Worker标准，其作用就是为JS创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker在后台运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被Worker线程负担，主线程(通常负责UI交互)就会很流畅，不会被阻塞或者拖慢。Web Worker不是JS的一部分，而是通过JS访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的API，例如操作DOM，因此这个新标准并没有改变JS单线程的本质。</p></blockquote><ul><li><code>垃圾回收机制</code>：垃圾回收本身也是一件非常耗时的操作，假设V8的堆内存为<code>1.5G</code>，那么V8做一次小的垃圾回收需要50ms以上，而做一次非增量式回收甚至需要1s以上，可见其耗时之久，而在这1s的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。</li></ul><p>基于以上两点，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景。但是在node端，涉及到的<code>I/O</code>操作可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，V8为我们提供了可配置项来让我们手动地调整内存大小，但是需要在node初始化的时候进行配置，我们可以通过如下方式来手动设置。</p><p>我们尝试在node命令行中输入以下命令：</p><blockquote><p>笔者本地安装的node版本为<code>v10.14.2</code>，可通过<code>node -v</code>查看本地node的版本号，不同版本可能会导致下面的命令会有所差异。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该命令可以用来查看node中可用的V8引擎的选项及其含义</span><br><span class="line">node --v8-options</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后我们会在命令行窗口中看到大量关于V8的选项，这里我们暂且只关注图中红色选框中的几个选项：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edeb6f141feaac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最小值，单位MB</span><br><span class="line">node --min-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最大值，单位MB</span><br><span class="line">node --max-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置老生代内存最大值，单位MB</span><br><span class="line">node --max-old-space-size&#x3D;2048 xxx.js</span><br></pre></td></tr></table></figure><p>通过以上方法便可以手动放宽V8引擎所使用的内存限制，同时node也为我们提供了<code>process.memoryUsage()</code>方法来让我们可以查看当前node进程所占用的实际内存大小。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edf18bb16af64d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在上图中，包含的几个字段的含义分别如下所示，单位均为字节：</p><ul><li><code>heapTotal</code>：表示V8当前申请到的堆内存总大小。</li><li><code>heapUsed</code>：表示当前内存使用量。</li><li><code>external</code>：表示V8内部的C++对象所占用的内存。</li><li><code>rss(resident set size)</code>：表示驻留集大小，是给这个node进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的JavaScript源代码存于代码段内存。使用Worker线程时，<code>rss</code>将会是一个对整个进程有效的值，而其他字段则只针对当前线程。</li></ul><blockquote><p>在JS中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过V8的限制为止。</p></blockquote><h3 id="3、V8的垃圾回收策略"><a href="#3、V8的垃圾回收策略" class="headerlink" title="3、V8的垃圾回收策略"></a>3、V8的垃圾回收策略</h3><p>V8的垃圾回收策略主要是基于<code>分代式垃圾回收机制</code>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h4 id="3-1-V8的内存结构"><a href="#3-1-V8的内存结构" class="headerlink" title="3.1 V8的内存结构"></a>3.1 V8的内存结构</h4><p>在V8引擎的堆结构组成中，其实除了<code>新生代</code>和<code>老生代</code>外，还包含其他几个部分，但是垃圾回收的过程主要出现在新生代和老生代，所以对于其他的部分我们没必要做太多的深入，有兴趣的小伙伴儿可以查阅下相关资料，V8的内存结构主要由以下几个部分组成：</p><ul><li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li><li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li><li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li><li><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li><li><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</li></ul><p>内存结构图如下所示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee12280b78399d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态，为什么会划分为两个部分呢，在下一小节我们会讲到。</p><h4 id="3-2-新生代"><a href="#3-2-新生代" class="headerlink" title="3.2 新生代"></a>3.2 新生代</h4><p>在V8引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个<code>semispace(半空间)</code>构成的，内存最大值在<code>64</code>位系统和<code>32</code>位系统上分别为<code>32MB</code>和<code>16MB</code>，在新生代的垃圾回收过程中主要采用了<code>Scavenge</code>算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><blockquote><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p></blockquote><p>基于以上算法，我们可以画出如下的流程图：</p><ul><li>假设我们在<code>From</code>空间中分配了三个对象A、B、C</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee172cf1a23c9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象A已经没有其他引用，则表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17a2fda2c461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，因此会被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17decd1d9ed2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>接下来将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1819dd9f5999?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>此时<code>From</code>空间中的内存已经清空，开始和<code>To</code>空间完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18439a76a3eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程在执行第二个任务时，在<code>From</code>空间中分配了一个新对象D</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1874b4c441d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>任务执行完毕后再次进入垃圾回收，发现对象D已经没有其他引用，表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18969e114bc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，再次被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18cd2bff353c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>再次将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18f4a21c517e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>From</code>空间和<code>To</code>空间继续完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee191560b716c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通过以上的流程图，我们可以很清楚地看到，<code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h4 id="3-3-对象晋升"><a href="#3-3-对象晋升" class="headerlink" title="3.3 对象晋升"></a>3.3 对象晋升</h4><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><p>默认情况下，我们创建的对象都会分配在<code>From</code>空间中，当进行垃圾回收时，在将对象从<code>From</code>空间复制到<code>To</code>空间之前，会先检查该对象的内存地址来判断是否已经经历过一次<code>Scavenge</code>算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到<code>To</code>空间，可以用以下的流程图来表示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c5634e61f9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如果对象没有经历过<code>Scavenge</code>算法，会被复制到<code>To</code>空间，但是如果此时<code>To</code>空间的内存占比已经超过<code>25%</code>，则该对象依旧会被转移到老生代，如下图所示:</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c90fedad146?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>之所以有<code>25%</code>的内存限制是因为<code>To</code>空间在经历过一次<code>Scavenge</code>算法后会和<code>From</code>空间完成角色互换，会变为<code>From</code>空间，后续的内存分配都是在<code>From</code>空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p><h4 id="3-4-老生代"><a href="#3-4-老生代" class="headerlink" title="3.4 老生代"></a>3.4 老生代</h4><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>来进行管理。</p><p>在早前我们可能听说过一种算法叫做<code>引用计数</code>，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建了两个对象obj1和obj2，其中obj2作为obj1的属性被obj1引用，因此不会被垃圾回收</span><br><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">    obj2: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj3并将obj1赋值给obj3，让两个对象指向同一个内存地址</span><br><span class="line">let obj3 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj1重新赋值，此时原来obj1指向的对象现在只由obj3来表示</span><br><span class="line">obj1 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj4并将obj3.obj2赋值给obj4</span><br><span class="line">&#x2F;&#x2F; 此时obj2所指向的对象有两个引用：一个是作为obj3的属性，另一个是变量obj4</span><br><span class="line">let obj4 &#x3D; obj3.obj2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj3重新赋值，此时本可以对obj3指向的对象进行回收，但是因为obj3.obj2被obj4所引用，因此依旧不能被回收</span><br><span class="line">obj3 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此时obj3.obj2已经没有指向它的引用，因此obj3指向的对象在此时可以被回收</span><br><span class="line">obj4 &#x3D; null;</span><br></pre></td></tr></table></figure><p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到<code>循环引用</code>的场景，就会出现问题，我们看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let a &#x3D; &#123;&#125;;</span><br><span class="line">    let b &#x3D; &#123;&#125;;</span><br><span class="line">    a.a1 &#x3D; b;</span><br><span class="line">    b.b1 &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这个例子中我们将对象<code>a</code>的<code>a1</code>属性指向对象<code>b</code>，将对象<code>b</code>的<code>b1</code>属性指向对象<code>a</code>，形成两个对象相互引用，在<code>foo</code>函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量<code>a</code>和<code>b</code>本应该可以被回收，但是因为采用了<code>引用计数</code>的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。</p><p>因此为了避免循环引用导致的内存泄漏问题，截至2012年所有的现代浏览器均放弃了这种算法，转而采用新的<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>算法。在上面循环引用的例子中，因为变量<code>a</code>和变量<code>b</code>无法从<code>window</code>全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p><p><code>Mark-Sweep(标记清除)</code>分为<code>标记</code>和<code>清除</code>两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。<code>Mark-Sweep</code>算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p><ul><li>垃圾回收器会在内部构建一个<code>根列表</code>，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，<code>window</code>全局对象可以看成一个根节点。</li><li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li><li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li></ul><blockquote><p>以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee468e85a1084d?imageslim" alt="img"></p><p>但是<code>Mark-Sweep</code>算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示：</p><ul><li>假设在老生代中有A、B、C、D四个对象</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee47d9f933bfc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>标记</code>阶段，将对象A和对象C标记为活动的</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee486ece5fda42?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>整理</code>阶段，将活动的对象往堆内存的一端移动</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee48f23fe98d7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>清除</code>阶段，将活动对象左侧的内存全部回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee490a8b9bf0af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>至此就完成了一次老生代垃圾回收的全部过程，我们在前文中说过，由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为<code>全停顿(stop-the-world)</code>。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p><p>因此，为了减少垃圾回收带来的停顿时间，V8引擎又引入了<code>Incremental Marking(增量标记)</code>的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像<code>React</code>框架中的<code>Fiber</code>架构，只有在浏览器的空闲时间才会去遍历<code>Fiber Tree</code>执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<code>延迟清理(lazy sweeping)</code>和<code>增量式整理(incremental compaction)</code>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入<code>并行标记</code>和<code>并行清理</code>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h3 id="4、如何避免内存泄漏"><a href="#4、如何避免内存泄漏" class="headerlink" title="4、如何避免内存泄漏"></a>4、如何避免内存泄漏</h3><p>在我们写代码的过程中，基本上都不太会关注写出怎样的代码才能有效地避免内存泄漏，或者说浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏问题，但是我们还是有必要了解一下常见的几种避免内存泄漏的方式，毕竟在面试过程中也是经常考察的要点。</p><h4 id="4-1-尽可能少地创建全局变量"><a href="#4-1-尽可能少地创建全局变量" class="headerlink" title="4.1 尽可能少地创建全局变量"></a>4.1 尽可能少地创建全局变量</h4><p>在ES5中以<code>var</code>声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到<code>window</code>全局对象上，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1; &#x2F;&#x2F; 等价于 window.a &#x3D; 1;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    window.a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>foo</code>函数中创建了一个变量<code>a</code>但是忘记使用<code>var</code>来声明，此时会意想不到地创建一个全局变量并挂载到window对象上，另外还有一种比较隐蔽的方式来创建全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">foo(); &#x2F;&#x2F; 相当于 window.foo()</span><br></pre></td></tr></table></figure><p>当<code>foo</code>函数在调用时，它所指向的运行上下文环境为<code>window</code>全局对象，因此函数中的<code>this</code>指向的其实是<code>window</code>，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为<code>window</code>对象可以作为根节点，在<code>window</code>上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为<code>null</code>从而触发回收机制。</p><h4 id="4-2-手动清除定时器"><a href="#4-2-手动清除定时器" class="headerlink" title="4.2 手动清除定时器"></a>4.2 手动清除定时器</h4><p>在我们的应用中经常会有使用<code>setTimeout</code>或者<code>setInterval</code>等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [];</span><br><span class="line">const foo &#x3D; function() &#123;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; 100000;i++) &#123;</span><br><span class="line">        numbers.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">window.setInterval(foo, 1000);</span><br></pre></td></tr></table></figure><p>在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的<code>numbers</code>变量也不会被垃圾回收，最终导致<code>numbers</code>数组长度无限递增，从而引发内存泄漏。</p><h4 id="4-3-少用闭包"><a href="#4-3-少用闭包" class="headerlink" title="4.3 少用闭包"></a>4.3 少用闭包</h4><p>闭包是JS中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let local &#x3D; 123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bar &#x3D; foo();</span><br><span class="line">console.log(bar()); &#x2F;&#x2F; -&gt; 123</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>foo</code>函数执行完毕后会返回一个匿名函数，该函数内部引用了<code>foo</code>函数中的局部变量<code>local</code>，并且通过变量<code>bar</code>来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在<code>foo</code>函数的外部作用域中访问到它的局部变量<code>local</code>。一般情况下，当<code>foo</code>函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致<code>local</code>变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。</p><h4 id="4-4-清除DOM引用"><a href="#4-4-清除DOM引用" class="headerlink" title="4.4 清除DOM引用"></a>4.4 清除DOM引用</h4><p>以往我们在操作DOM元素时，为了避免多次获取DOM元素，我们会将DOM元素存储在一个数据字典中，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;button&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们想调用<code>removeButton</code>方法来清除<code>button</code>元素，但是由于在<code>elements</code>字典中存在对<code>button</code>元素的引用，所以即使我们通过<code>removeChild</code>方法移除了<code>button</code>元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对<code>button</code>元素的引用才会被垃圾回收。</p><h4 id="4-5-弱引用"><a href="#4-5-弱引用" class="headerlink" title="4.5 弱引用"></a>4.5 弱引用</h4><p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在ES6中为我们新增了两个有效的数据结构<code>WeakMap</code>和<code>WeakSet</code>，就是为了解决内存泄漏的问题而诞生的。其表示<code>弱引用</code>，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心<code>WeakMap</code>中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在node中演示一下过程(参考阮一峰ES6标准入门中的示例，自己手动实现了一遍)。</p><p>首先打开node命令行，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --expose-gc &#x2F;&#x2F; --expose-gc 表示允许手动执行垃圾回收机制</span><br></pre></td></tr></table></figure><p>然后我们执行下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收保证内存数据准确</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前占用的内存，主要关心heapUsed字段，大小约为4.4MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 21626880,</span><br><span class="line">  heapTotal: 7585792,</span><br><span class="line">  heapUsed: 4708440,</span><br><span class="line">  external: 8710 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个WeakMap</span><br><span class="line">&gt; let wm &#x3D; new WeakMap();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个数组并赋值给变量key</span><br><span class="line">&gt; let key &#x3D; new Array(1000000);</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将WeakMap的键名指向该数组</span><br><span class="line">&#x2F;&#x2F; 此时该数组存在两个引用，一个是key，一个是WeakMap的键名</span><br><span class="line">&#x2F;&#x2F; 注意WeakMap是弱引用</span><br><span class="line">&gt; wm.set(key, 1);</span><br><span class="line">WeakMap &#123; [items unknown] &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次查看内存占用大小，heapUsed已经增加到约12MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 30232576,</span><br><span class="line">  heapTotal: 17694720,</span><br><span class="line">  heapUsed: 13068464,</span><br><span class="line">  external: 8688 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动清除变量key对数组的引用</span><br><span class="line">&#x2F;&#x2F; 注意这里并没有清除WeakMap中键名对数组的引用</span><br><span class="line">&gt; key &#x3D; null;</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次执行垃圾回收</span><br><span class="line">&gt; global.gc()</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看内存占用大小，发现heapUsed已经回到了之前的大小(这里约为4.8M，原来为4.4M，稍微有些浮动)</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 22110208,</span><br><span class="line">  heapTotal: 9158656,</span><br><span class="line">  heapUsed: 5089752,</span><br><span class="line">  external: 8698 &#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们发现虽然我们没有手动清除<code>WeakMap</code>中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>本文中主要讲解了一下V8引擎的垃圾回收机制，并分别从新生代和老生代讲述了不同分代中的垃圾回收策略以及对应的回收算法，之后列出了几种常见的避免内存泄漏的方式来帮助我们写出更加优雅的代码。如果你已经了解过垃圾回收相关的内容，那么这篇文章可以帮助你简单复习加深印象，如果没有了解过，那么笔者也希望这篇文章能够帮助到你了解一些代码层面之外的底层知识点，由于V8引擎的源码是用C++实现的，所以笔者也就没有做这方面的深入了，有兴趣的小伙伴儿可以自行探究，文中有错误的地方，还希望能够在评论区指正。</p><h1 id="13-浮点数精度"><a href="#13-浮点数精度" class="headerlink" title="13.浮点数精度"></a>13.浮点数精度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。</p><p>在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。</p><h2 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h2><p>我们来看下 1020 用十进制的表示：</p><blockquote><p>1020 = <strong>1</strong> * 10^3 + <strong>0</strong> * 10^2 + <strong>2</strong> * 10^1 + <strong>0</strong> * 10^0</p></blockquote><p>所以 1020 用十进制表示就是 1020……(哈哈)</p><p>如果 1020 用二进制来表示呢？</p><blockquote><p>1020 = <strong>1</strong> * 2^9 + <strong>1</strong> * 2^8 + <strong>1</strong> * 2^7 + <strong>1</strong> * 2^6 + <strong>1</strong> * 2^5 + <strong>1</strong> * 2^4 + <strong>1</strong> * 2^3 + <strong>1</strong> * 2^2 + <strong>0</strong> * 2^1 + <strong>0</strong> * 2^0</p></blockquote><p>所以 1020 的二进制为 <code>1111111100</code></p><p>那如果是 0.75 用二进制表示呢？同理应该是：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p></blockquote><p>因为使用的是二进制，这里的 abcd……的值的要么是 0 要么是 1。</p><p>那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4…</p></blockquote><p>两边同时乘以 2</p><blockquote><p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3… (所以 a = 1)</p></blockquote><p>剩下的：</p><blockquote><p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3…</p></blockquote><p>再同时乘以 2</p><blockquote><p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3… (所以 b = 1)</p></blockquote><p>所以 0.75 用二进制表示就是 0.ab，也就是 0.11</p><p>然而不是所有的数都像 0.75 这么好算，我们来算下 0.1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.1 &#x3D; a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...</span><br><span class="line"></span><br><span class="line">0 + 0.2 &#x3D; a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a &#x3D; 0)</span><br><span class="line">0 + 0.4 &#x3D; b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d &#x3D; 1)</span><br><span class="line">1 + 0.2 &#x3D; e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e &#x3D; 1)</span><br><span class="line">0 + 0.4 &#x3D; f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h &#x3D; 1)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……</p><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><p>虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式。</p><p>这个标准认为，一个浮点数 (Value) 可以这样表示：</p><blockquote><p>Value = sign * exponent * fraction</p></blockquote><p>看起来很抽象的样子，简单理解就是科学计数法……</p><p>比如 -1020，用科学计数法表示就是:</p><blockquote><p>-1 * 10^3 * 1.02</p></blockquote><p>sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02</p><p>对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：</p><p>可以表示为：</p><blockquote><p>1 * 2^-4 * 1.1001100110011……</p></blockquote><p>其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……</p><p>而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：</p><blockquote><p>V = (-1)^S * (1 + Fraction) * 2^E</p></blockquote><p>(如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了)</p><p>我们来一点点看：</p><p><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。</p><p>再看 <code>(1 + Fraction)</code>，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。</p><p>最后再看 <code>2^E</code></p><p>如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？</p><p>我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。</p><p>所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。</p><p>所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：</p><p><a href="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067"><img data-src="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067" alt="IEEE754"></a></p><p>在这个标准下：</p><p>我们会用 1 位存储 S，0 表示正数，1 表示负数。</p><p>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。</p><p>用 52 位存储 Fraction。</p><p>举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……</p><p>对应 64 个字节位的完整表示就是：</p><blockquote><p>0 01111111011 1001100110011001100110011001100110011001100110011010</p></blockquote><p>同理, 0.2 表示的完整表示是：</p><blockquote><p>0 01111111100 1001100110011001100110011001100110011001100110011010</p></blockquote><p>所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。</p><h2 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h2><p>关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。</p><p>首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 <code>1.1001100110011…… * 2^-4</code>，阶码是 -4，而 0.2 就是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 <code>0.11001100110011…… * 2^-3</code></p><p>接下来是尾数计算:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0.1100110011001100110011001100110011001100110011001101</span><br><span class="line">+ 1.1001100110011001100110011001100110011001100110011010</span><br><span class="line">————————————————————————————————————————————————————————</span><br><span class="line"> 10.0110011001100110011001100110011001100110011001100111</span><br></pre></td></tr></table></figure><p>我们得到结果为 <code>10.0110011001100110011001100110011001100110011001100111 * 2^-3</code></p><p>将这个结果处理一下，即结果规格化，变成 <code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code></p><p>括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。</p><p>再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0011001100110011001100110011001100110011001100110100 * 2^-2</span><br></pre></td></tr></table></figure><p>本来还有一个溢出判断，因为这里不涉及，就不讲了。</p><p>所以最终的结果存成 64 位就是</p><blockquote><p>0 01111111101 0011001100110011001100110011001100110011001100110100</p></blockquote><p>将它转换为10进制数就得到 <code>0.30000000000000004440892098500626</code></p><p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 十进制转二进制</span><br><span class="line">parseFloat(0.1).toString(2);</span><br><span class="line">&#x3D;&gt; &quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二进制转十进制</span><br><span class="line">parseInt(1100100,2)</span><br><span class="line">&#x3D;&gt; 100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定的精度返回该数值对象的字符串表示</span><br><span class="line">(0.1 + 0.2).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.300000000000000044409&quot;</span><br><span class="line">(0.3).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.299999999999999988898&quot;</span><br></pre></td></tr></table></figure><h1 id="14-new"><a href="#14-new" class="headerlink" title="14.new"></a>14.new</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 new:</p><blockquote><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p></blockquote><p>也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Otaku 御宅族，简称宅</span><br><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为缺乏锻炼的缘故，身体强度让人担忧</span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到，实例 person 可以：</p><ol><li>访问到 Otaku 构造函数里的属性</li><li>访问到 Otaku.prototype 中的属性</li></ol><p>接下来，我们可以尝试着模拟一下了。</p><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Otaku () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 new</span><br><span class="line">var person &#x3D; new Otaku(……);</span><br><span class="line">&#x2F;&#x2F; 使用 objectFactory</span><br><span class="line">var person &#x3D; objectFactory(Otaku, ……)</span><br></pre></td></tr></table></figure><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>分析：</p><p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。</p><p>在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 <strong>proto</strong> 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。</p><p>现在，我们可以尝试着写第一版了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">&#x2F;&#x2F; 新建对象</span><br><span class="line">    var obj &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 移除参数首个</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    &#x2F;&#x2F; 实例的 __proto__ 属性会指向构造函数的 prototype</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    &#x2F;&#x2F; 调用对象</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这一版中，我们：</p><ol><li>用new Object() 的方式新建了一个对象 obj</li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数</li><li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li><li>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</li><li>返回 obj</li></ol><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">https://github.com/mqyqingfeng/Blog/issues/16</a>)</p><p>复制以下的代码，到浏览器中，我们可以做一下测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; objectFactory(Otaku, &#39;Kevin&#39;, &#39;18&#39;)</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><h2 id="返回值效果实现"><a href="#返回值效果实现" class="headerlink" title="返回值效果实现"></a>返回值效果实现</h2><p>接下来我们再来看一种情况，假如构造函数有返回值，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        habit: &#39;Games&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p><p>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？</p><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#39;handsome boy&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p><p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p><p>再来看第二版的代码，也是最后一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版的代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    var ret &#x3D; Constructor.apply(obj, arguments);</span><br><span class="line">    return typeof ret &#x3D;&#x3D;&#x3D; &#39;object&#39; ? ret : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="15-Event-Loop（事件循环）机制"><a href="#15-Event-Loop（事件循环）机制" class="headerlink" title="15.Event Loop（事件循环）机制"></a>15.Event Loop（事件循环）机制</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p><p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p><p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><p>话说回来，前面提到javascript的另一个特点是“非阻塞”，那么javascript引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p><p><em>注：虽然nodejs中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</em></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a><strong>浏览器环境下js引擎的事件循环机制</strong></h2><h2 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a><strong>1.执行栈与事件队列</strong></h2><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p><p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p><p>下面这个图片非常直观的展示了这个过程，其中的global就是初次运行脚本时向执行栈中加入的代码：</p><p><img data-src="https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.jpg" alt="img"></p><p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p><p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p><p>这里还有一张图来展示这个过程：</p><p><img data-src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg" alt="img"></p><p>图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。</p><h2 id="2-macro-task与micro-task"><a href="#2-macro-task与micro-task" class="headerlink" title="2.macro task与micro task"></a><strong>2.macro task与micro task</strong></h2><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li><code>setInterval()</code></li><li><code>setTimeout()</code></li></ul><p>以下事件属于微任务</p><ul><li><code>new Promise()</code></li><li><code>new MutaionObserver()</code></li></ul><p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><p>我们只需记住<strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p><p>这样就能解释下面这段代码的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 </span><br></pre></td></tr></table></figure><h2 id="node环境下的事件循环机制"><a href="#node环境下的事件循环机制" class="headerlink" title="node环境下的事件循环机制"></a><strong>node环境下的事件循环机制</strong></h2><h2 id="1-与浏览器环境有何不同"><a href="#1-与浏览器环境有何不同" class="headerlink" title="1.与浏览器环境有何不同?"></a><strong>1.与浏览器环境有何不同?</strong></h2><p>在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</p><h2 id="2-事件循环模型"><a href="#2-事件循环模型" class="headerlink" title="2.事件循环模型"></a><strong>2.事件循环模型</strong></h2><p>下面是一个libuv引擎中的事件循环的模型:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><em>注：模型中的每一个方块代表事件循环的一个阶段</em></p><p>这个模型是node官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自与看看原文。</p><h2 id="3-事件循环各阶段详解"><a href="#3-事件循环各阶段详解" class="headerlink" title="3.事件循环各阶段详解"></a><strong>3.事件循环各阶段详解</strong></h2><p>从上面这个模型中，我们可以大致分析出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p><p>这些阶段大致的功能如下：</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和<code>setImmediate()</code>的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li><li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种close事件的回调。</li></ul><p>下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段：</p><h2 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a><strong>poll阶段</strong></h2><p>当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。</p><p>值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。</p><h2 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a><strong>check阶段</strong></h2><p>check阶段专门用来执行<code>setImmediate()</code>方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。</p><h2 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a><strong>close阶段</strong></h2><p>当一个socket连接或者一个handle被突然关闭时（例如调用了<code>socket.destroy()</code>方法），close事件会被发送到这个阶段执行回调。否则事件会用<code>process.nextTick（）</code>方法发送出去。</p><h2 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a><strong>timer阶段</strong></h2><p>这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。</p><h2 id="I-O-callback阶段"><a href="#I-O-callback阶段" class="headerlink" title="I/O callback阶段"></a><strong>I/O callback阶段</strong></h2><p>如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。</p><h2 id="4-process-nextTick-setTimeout与setImmediate的区别与使用场景"><a href="#4-process-nextTick-setTimeout与setImmediate的区别与使用场景" class="headerlink" title="4.process.nextTick,setTimeout与setImmediate的区别与使用场景"></a><strong>4.process.nextTick,setTimeout与setImmediate的区别与使用场景</strong></h2><p>在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate</p><p>这三者间存在着一些非常不同的区别：</p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><strong>process.nextTick()</strong></h2><p>尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用<code>process.nextTick()</code>方法会导致node进入一个死循环。。直到内存泄漏。</p><p>那么合适使用这个方法比较合适呢？下面有一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p><h2 id="setTimeout-和setImmediate"><a href="#setTimeout-和setImmediate" class="headerlink" title="setTimeout()和setImmediate()"></a><strong>setTimeout()和setImmediate()</strong></h2><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p><p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。</p><p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p><p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;immediate&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>答案永远是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。</p><p><strong>尾声</strong></p><p>javascrit的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p><h1 id="16-Promise-原理"><a href="#16-Promise-原理" class="headerlink" title="16.Promise 原理"></a>16.Promise 原理</h1><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        reject(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">&#125;,(data1)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;result2&#39;,data1)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result3&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3 undefined</span><br></pre></td></tr></table></figure><p>显然这里输出了不同的 data。由此可以看出几点：</p><ol><li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li><li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li><li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li></ol><p>基于以上几点，我们先写个基于 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123; &#x2F;&#x2F;桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span><br><span class="line">                onFulfilled, </span><br><span class="line">                resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            if(!callback.onFulfilled)&#123;</span><br><span class="line">                callback.resolve(value)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const ret &#x3D; callback.onFulfilled(value) &#x2F;&#x2F;处理回调</span><br><span class="line">            callback.resolve(ret) &#x2F;&#x2F;处理下一个 promise 的resolve</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0) &#x2F;&#x2F;基于 PromiseA+ 规范</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fulfiledFn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fulfiledFn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p><p>但是如果仅仅是例子中的情况，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    console.log(&#39;result3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3</span><br></pre></td></tr></table></figure><p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#123; test: 1 &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result1&#39;, data)</span><br><span class="line">  &#x2F;&#x2F;dosomething</span><br><span class="line">  return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">  return new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;基于第一个 Promise 模型，执行后的输出</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 Promise &#123;then: ƒ&#125;</span><br></pre></td></tr></table></figure><p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个模型，再测试我们的例子，就得到了正确的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F; result2 &#123; test: 2 &#125;</span><br></pre></td></tr></table></figure><p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p><p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p><p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p><p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p><table><thead><tr><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>P1</td><td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td></tr><tr><td>P2 (P1 调用 then 时产生)</td><td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td></tr><tr><td>P3 (P2 调用 then 时产生)</td><td>[]</td></tr><tr><td>P4 (执行c1中产生[调用 test ])</td><td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td></tr><tr><td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td><td>[]</td></tr></tbody></table><p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p><p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p><p>以上就是链式调用的原理了。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p><p>完整代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">        const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">        if(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(error)&#123;</span><br><span class="line"></span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; error</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    then.call(error,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;rejected&#39;;</span><br><span class="line">            value &#x3D; error</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p><p>handle代码改造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handle(callback)&#123;</span><br><span class="line">    if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        callbacks.push(callback)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">    if(!cb)&#123;</span><br><span class="line">        next(value)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        callback.reject(e);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).catch((ex) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;error&#39;, ex)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finally方法"><a href="#Finally方法" class="headerlink" title="Finally方法"></a>Finally方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    this.finally &#x3D; function (onDone)&#123;</span><br><span class="line">        this.then(onDone,onDone)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">Promise.reject(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">new Promise((resolve,reject) &#x3D;&gt; reject(&#123;name:&#39;winty&#39;&#125;))</span><br></pre></td></tr></table></figure><p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p><ul><li>无参数 [直接返回一个resolved状态的 Promise 对象]</li><li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li><li>一个Promise实例 [直接返回当前实例]</li><li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li></ul><p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.resolve &#x3D; function (value)&#123;</span><br><span class="line">        if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; else if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">            let then &#x3D; value.then;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">                then(resolve);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (value) &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve(value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Promise(fn)&#123; </span><br><span class="line">     ...</span><br><span class="line">     this.reject &#x3D; function (value)&#123;</span><br><span class="line">         return new Promise(function(resolve, reject) &#123;</span><br><span class="line">reject(value);</span><br><span class="line">&#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.all &#x3D; function (arr)&#123;</span><br><span class="line">        var args &#x3D; Array.prototype.slice.call(arr);</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        &#x2F;&#x2F; 长度为0返回结果</span><br><span class="line">            if(args.length &#x3D;&#x3D;&#x3D; 0) return resolve([]);</span><br><span class="line">            &#x2F;&#x2F; 剩余参数数组长度</span><br><span class="line">            var remaining &#x3D; args.length;</span><br><span class="line">&#x2F;&#x2F; 参数和值</span><br><span class="line">            function res(i, val) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">                        var then &#x3D; val.then;</span><br><span class="line">                        &#x2F;&#x2F; 进行参数分析</span><br><span class="line">                        if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                            then.call(val, function(val) &#123;</span><br><span class="line">                                res(i, val);</span><br><span class="line">                            &#125;, reject);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    args[i] &#x3D; val;</span><br><span class="line">                    if(--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        resolve(args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(ex) &#123;</span><br><span class="line">                    reject(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 遍历数组中的每个元素</span><br><span class="line">            for(var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                res(i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.race &#x3D; function(values) &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            for(var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://promisesaplus.com/">PromiseA+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li><li><a href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30分钟，让你彻底明白Promise原理</a></li></ul><h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  let state &#x3D; &#39;pending&#39;</span><br><span class="line">  let value &#x3D; null</span><br><span class="line">  const callbacks &#x3D; []</span><br><span class="line"></span><br><span class="line">  this.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.catch &#x3D; function (onError) &#123;</span><br><span class="line">    return this.then(null, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.finally &#x3D; function (onDone) &#123;</span><br><span class="line">    this.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">      return value</span><br><span class="line">    &#125; if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const &#123; then &#125; &#x3D; value</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; if (value) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.reject &#x3D; function (value) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.all &#x3D; function (arr) &#123;</span><br><span class="line">    const args &#x3D; Array.prototype.slice.call(arr)</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      if (args.length &#x3D;&#x3D;&#x3D; 0) return resolve([])</span><br><span class="line">      let remaining &#x3D; args.length</span><br><span class="line"></span><br><span class="line">      function res(i, val) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">            const &#123; then &#125; &#x3D; val</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">              then.call(val, (val) &#x3D;&gt; &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] &#x3D; val</span><br><span class="line">          if (--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.race &#x3D; function (values) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      for (let i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handle(callback) &#123;</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    if (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let ret;</span><br><span class="line">    try &#123;</span><br><span class="line">     ret &#x3D; cb(value)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  function resolve(newValue) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; newValue</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">          &#x2F;&#x2F; 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;fulfilled&#39;</span><br><span class="line">      value &#x3D; newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(error) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; error</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;rejected&#39;</span><br><span class="line">      value &#x3D; error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function handelCb() &#123;</span><br><span class="line">    while (callbacks.length) &#123;</span><br><span class="line">      const fn &#x3D; callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; catch(ex) &#123;</span><br><span class="line">reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-Generators原理"><a href="#17-Generators原理" class="headerlink" title="17.Generators原理"></a>17.Generators原理</h1><p>随着 Javascript 语言的发展，ES6 规范为我们带来了许多新的内容，其中生成器 Generators 是一项重要的特性。利用这一特性，我们可以简化迭代器的创建，更加令人兴奋的，是 Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。</p><p>本重点探讨 Generators 运行机制及在 ES5 的实现原理。</p><h2 id="1-Generators-简单介绍"><a href="#1-Generators-简单介绍" class="headerlink" title="1.Generators 简单介绍"></a><strong>1.Generators 简单介绍</strong></h2><p>一个简单的 Generator 函数示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter=example();</span><br><span class="line">iter.next();<span class="comment">//&#123;value:1，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:2，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:3，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:undefined，done:true&#125;</span></span><br></pre></td></tr></table></figure><p>​    上述代码中定义了一个生成器函数，当调用生成器函数 example() 时，并非立即执行该函数，而是返回一个生成器对象。每当调用生成器对象的.next() 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身。当抵达生成器函数的末尾时，返回结果中 done 的值为 true，value 的值为 undefined。我们将上述 example() 函数称之为生成器函数，与普通函数相比二者有如下区别</p><ul><li>普通函数使用 function 声明，生成器函数用 function*声明</li><li>普通函数使用 return 返回值，生成器函数使用 yield 返回值</li><li>普通函数是 run to completion 模式，即普通函数开始执行后，会一直执行到该函数所有语句完成，在此期间别的代码语句是不会被执行的；生成器函数是 run-pause-run 模式，即生成器函数可以在函数运行中被暂停一次或多次，并且在后面再恢复执行，在暂停期间允许其他代码语句被执行</li></ul><h2 id="2-Generators-in-C"><a href="#2-Generators-in-C" class="headerlink" title="2.Generators in C#"></a><strong>2.Generators in C#</strong></h2><p>生成器不是一个新的概念，我最初接触这一概念是在学习使用 C#时。C#从 2.0 版本便引入了 yield 关键字，使得我们可以更简单的创建枚举数和可枚举类型。不同的是 C#中未将其命名为生成器 Generators，而将其称之为迭代器。</p><p>本文不会介绍 C#中可枚举类 IEnumerable 和枚举数 IEnumerator 内容，如需了解推荐阅读《C#4.0 图解教程》相关章节。</p><p>2.1 C#迭代器介绍</p><p>让我们先看一个示例，下面方法声明实现了一个产生和返回枚举数的迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerable &lt;int&gt; Example()</span><br><span class="line">&#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义与 ES6 Generators 定义很接近，定义中声明返回了一个 int 类型的泛型可枚举类型，方法体内通过 yield return 语句返回值并将自身暂停执行。</p><p>使用迭代器来创建可枚举类型的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class YieldClass</span><br><span class="line">&#123;</span><br><span class="line">    public IEnumerable&lt;int&gt; Example()&#x2F;&#x2F;迭代器</span><br><span class="line">    &#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">YieldClass yc&#x3D;new YieldClass ();</span><br><span class="line">foreach(var a in yc.Example())</span><br><span class="line">Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会产生如下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>2.2 C#迭代器原理</p><p>在.Net 中，yield 并不是.Net runtime 的特性，而是一个语法糖，代码编译时，这一语法糖会被 C#编译器编译成简单的 IL 代码。</p><p>继续研究上述示例，通过 Reflector 反编译工具可以看到，编译器为我们生成了一个带有如下声明的内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[CompilerGenerated]</span><br><span class="line">private sealed class YieldEnumerator : </span><br><span class="line">   IEnumerable&lt;object&gt;, IEnumerator&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Fields字段</span><br><span class="line">    private int state;</span><br><span class="line">    private int current;</span><br><span class="line">    public YieldClass owner;</span><br><span class="line">    private int initialThreadId;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Methods方法</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    public YieldEnumerator(int state);</span><br><span class="line">    private bool MoveNext();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator&lt;int&gt; IEnumerable&lt;int&gt;.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    void IEnumerator.Reset();</span><br><span class="line">    void IDisposable.Dispose();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Properties属性</span><br><span class="line">    object IEnumerator&lt;object&gt;.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line"> </span><br><span class="line">    object IEnumerator.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始的 Example() 方法仅返回一个 YieldEnumerator 的实例，并将初始状态-2 传递给它自身和其引用者，每一个迭代器保存一个状态指示</p><ul><li>-2：初始化为可迭代类 Enumerable</li><li>-1: 迭代结束</li><li>0: 初始化为迭代器 Enumerator</li><li>1-n: 原始 Example() 方法中的 yield return 索引值</li></ul><p>Example() 方法中代码被转换为 YieldingEnumerator.MoveNext()，在我们的示例中转换后代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool MoveNext()</span><br><span class="line">&#123;</span><br><span class="line">    switch (state)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 1;</span><br><span class="line">            state &#x3D; 1;</span><br><span class="line">            return true;</span><br><span class="line">        case 1:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 2;</span><br><span class="line">            state &#x3D; 2;</span><br><span class="line">            return true;</span><br><span class="line">        case 2:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 3;</span><br><span class="line">            state &#x3D; 3;</span><br><span class="line">            return true;</span><br><span class="line">        case 3:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述的代码转换，编译器为我们生成了一个状态机，正是基于这一状态机模型，实现了 yield 关键字的特性。</p><p>迭代器状态机模型可如下图所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png" alt="statemachine"></a></p><ul><li>Before 为迭代器初始状态</li><li>Running 为调用 MoveNext 后进入这个状态。在这个状态，枚举数检测并设置下一项的位置。遇到 yield return、yield break 或者迭代结束时，退出该状态</li><li>Suspended 为状态机等待下次调用 MoveNext 的状态</li><li>After 为迭代结束的状态</li></ul><p><strong>3.Generators in Javascript</strong></p><p>通过阅读上文，我们了解了 Generator 在 C#中的使用，并且通过查看编译器生成的 IL 代码，得知编译器会生成一个内部类来保存上下文信息，然后将 yield return 表达式转换成 switch case，通过状态机模式实现 yield 关键字的特性。</p><p>3.1 Javascript Generators 原理浅析</p><p>yield 关键字在 Javascript 中如何实现呢？</p><p>首先，生成器不是线程。支持线程的语言中，多段不同的代码可以在同一时候运行，这经常会导致资源竞争，使用得当会有不错的性能提升。生成器则完全不同，Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。</p><p>既然生成器并非由引擎从底层提供额外的支持，我们可以沿用上文在 C#中对 yield 特性的原理探究的经验，将生成器视为一个语法糖，用一个辅助工具将生成器函数转换为普通的 Javascript 代码，在经过转换的代码中，有两个关键点，一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。</p><p>3.2 How Generators work in ES5</p><p><a href="https://facebook.github.io/regenerator/">Regenerator</a> 工具已经实现了上述思路，借助 Regenerator 工具，我们已经可以在原生 ES5 中使用生成器函数，本节我们来分析 Regenerator 实现方式以深入理解 Generators 运行原理。</p><p>通过<a href="http://babeljs.io/repl/">这个在线地址</a>可以方便的查看经过转换后的代码，仍然以文章初始为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* example() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">var iter&#x3D;example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>经过转换后为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var marked0$0 &#x3D; [example].map(regeneratorRuntime.mark);</span><br><span class="line">function example() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function example$(context$1$0) &#123;</span><br><span class="line">    while (1) switch (context$1$0.prev &#x3D; context$1$0.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        context$1$0.next &#x3D; 2;</span><br><span class="line">        return 1;</span><br><span class="line"> </span><br><span class="line">      case 2:</span><br><span class="line">        context$1$0.next &#x3D; 4;</span><br><span class="line">        return 2;</span><br><span class="line"> </span><br><span class="line">      case 4:</span><br><span class="line">        context$1$0.next &#x3D; 6;</span><br><span class="line">        return 3;</span><br><span class="line"> </span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return context$1$0.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, marked0$0[0], this);</span><br><span class="line">&#125;</span><br><span class="line">var iter &#x3D; example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>从转换后的代码中可以看到，与 C#编译器对 yield return 表达式的转换相似，Regenerator 将生成器函数中的 yield 表达式重写为 switch case，同时，在每个 case 中使用 context$1$0 来保存函数当前的上下文状态。</p><p>switch case 之外，迭代器函数 example 被 regeneratorRuntime.mark 包装，返回一个被 regeneratorRuntime.wrap 包装的迭代器对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  if (Object.setPrototypeOf) &#123;</span><br><span class="line">    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  &#125;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 mark 包装，将 example 包装成如下对象</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png" alt="example"></a></p><p>当调用生成器函数 example() 时，返回一个被 wrap 函数包装后的迭代器对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runtime.wrap&#x3D;function (innerFn, outerFn, self, tryLocsList) &#123;</span><br><span class="line">  &#x2F;&#x2F; If outerFn provided, then outerFn.prototype instanceof Generator.</span><br><span class="line">  var generator &#x3D; Object.create((outerFn || Generator).prototype);</span><br><span class="line">  var context &#x3D; new Context(tryLocsList || []);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; The ._invoke method unifies the implementations of the .next,</span><br><span class="line">  &#x2F;&#x2F; .throw, and .return methods.</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"> </span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的迭代器对象如下所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png" alt="iter"></a></p><p>当调用迭代器对象 iter.next() 方法时，因为有如下代码，所以会执行_invoke 方法，而根据前面 wrap 方法代码可知，最终是调用了迭代器对象的 makeInvokeMethod (innerFn, self, context); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">  [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">    prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">      return this._invoke(method, arg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 方法内容较多，这里选取部分分析。首先，我们发现生成器将自身状态初始化为“Suspended Start”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function makeInvokeMethod(innerFn, self, context) &#123;</span><br><span class="line">  var state &#x3D; GenStateSuspendedStart;</span><br><span class="line"> </span><br><span class="line">  return function invoke(method, arg) &#123;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 返回 invoke 函数，当我们执行.next 方法时，实际调用的是 invoke 方法中的下面语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br></pre></td></tr></table></figure><p>这里 tryCatch 方法中 fn 为经过转换后的 example$方法，arg 为上下文对象 context, 因为 invoke 函数内部对 context 的引用形成闭包引用，所以 context 上下文得以在迭代期间一直保持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tryCatch(fn, obj, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    return &#123; type: &quot;throw&quot;, arg: err &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryCatch 方法会实际调用 example$方法，进入转换后的 switch case, 执行代码逻辑。如果得到的结果是一个普通类型的值，我们将它包装成一个可迭代对象格式，并且更新生成器状态至 GenStateCompleted 或者 GenStateSuspendedYield</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br><span class="line">        if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">          &#x2F;&#x2F; If an exception is thrown from innerFn, we leave state &#x3D;&#x3D;&#x3D;</span><br><span class="line">          &#x2F;&#x2F; GenStateExecuting and loop back for another invocation.</span><br><span class="line">          state &#x3D; context.done</span><br><span class="line">            ? GenStateCompleted</span><br><span class="line">            : GenStateSuspendedYield;</span><br><span class="line"> </span><br><span class="line">          var info &#x3D; &#123;</span><br><span class="line">            value: record.arg,</span><br><span class="line">            done: context.done</span><br><span class="line">          &#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><p>通过对 Regenerator 转换后的生成器代码及工具源码分析，我们探究了生成器的运行原理。Regenerator 通过工具函数将生成器函数包装，为其添加如 next/return 等方法。同时也对返回的生成器对象进行包装，使得对 next 等方法的调用，最终进入由 switch case 组成的状态机模型中。除此之外，利用闭包技巧，保存生成器函数上下文信息。</p><p>上述过程与 C#中 yield 关键字的实现原理基本一致，都采用了编译转换思路，运用状态机模型，同时保存函数上下文信息，最终实现了新的 yield 关键字带来的新的语言特性。</p><p>参考文章</p><p>1.<a href="https://davidwalsh.name/es6-generators">ES6 Generators:Complete Series 系列文章</a></p><p>\2. <a href="http://www.infoq.com/cn/articles/es6-in-depth-generators">深入浅出 ES6 Generators</a></p><p>3.<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">《深入掌握 ECMAScript 6 异步编程》系列文章</a></p><p>4.<a href="http://x-team.com/2015/04/generators-work/">ES6 Generators:How do they work?</a></p><p>5.<a href="https://startbigthinksmall.wordpress.com/2008/06/09/behind-the-scenes-of-the-c-yield-keyword/">Behind the scenes of the C# yield keyword</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  &lt;a href=&quot;https://github.com/mqyqingfeng/Blog&quot;&gt;冴羽的博客&lt;/a&gt; ，内容丰富，适合有一定JS基础的人进行阅读&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Promise async Generator实现原理解析</title>
    <link href="https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2021-03-10T13:10:17.214Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://juejin.im/post/6844904096525189128">https://juejin.im/post/6844904096525189128</a> </p><p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：</p><ol><li><p><code>Promise</code>的实现原理</p></li><li><p><code>async/await</code>的实现原理</p></li><li><p><code>Generator</code>的实现原理</p></li></ol><span id="more"></span><h1 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h1><p>在成文过程中，笔者查阅了很多讲解Promise实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段Promise规范翻译，有的在Promise基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p><p>回归正题，文章开头我们先点一下Promise为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个Promise：</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Promise实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入resolve, reject函数参数</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>观察这个例子，我们分析Promise的调用流程：</p><ul><li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个executor回调</li><li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li><li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li><li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li></ul><p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在Promise里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出Promise的大致形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// then收集的执行成功的回调队列</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// then收集的执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 从成功队列里取出回调依次执行</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// 一秒后输出result</span></span><br></pre></td></tr></table></figure><p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在then方法的回调里取得异步操作的返回值，但我们这个Promise离最终实现还有很长的距离，下面我们来一步步补充这个Promise：</p><h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版Promise，但我们会看到很多文章和我们写的不一样，他们的Promise实现中还引入了各种状态控制，这是由于ES6的Promise实现需要遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对Promise的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p><blockquote><ol><li>Promise本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li><li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/2/26/161d2454e68ff07b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>根据规范，我们补充一下Promise的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">            <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._resolveQueue.length) &#123;    </span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-then的链式调用"><a href="#3-then的链式调用" class="headerlink" title="3. then的链式调用"></a>3. then的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是Promise实现的重点和难点，我们先来看一下then是如何链式调用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(2)</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">     &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">        return 3</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们思考一下如何实现这种链式调用：</p><ol><li>显然<code>.then()</code>需要返回一个Promise，这样才能找到then方法，所以我们会把then方法的返回值包装成Promise。</li><li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li><li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间return了一个Promise，但执行顺序仍要保证是1-&gt;2-&gt;3。我们要等待当前Promise状态变更后，再执行下一个then收集的回调，这就要求我们对then的返回值分类讨论</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法改进</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                <span class="comment">//这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span></span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reject同理</span></span><br><span class="line">        <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能测试一下链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p><ol><li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是function，那么我们应该忽略它。如果没有忽略，当then()回调不为function时将会抛出异常，导致链式调用中断</li><li><strong>处理状态为resolve/reject的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把then()回调push进resolve/reject的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行then回调：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span>? reason.message:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">            <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">            <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">            <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了then的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor是异步任务</strong>的前提上的，如果executor是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve的执行跑到then之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个setTimeout，让它异步执行。</p><blockquote><p>这里插一句，有关这个setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实Promise的默认实现是放进了微任务队列，我们的实现（包括大多数Promise手动实现和polyfill的转化）都是使用setTimeout放入了宏任务队列（当然我们也可以用MutationObserver模拟微任务）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">        this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">        this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">        this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">        let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">                &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">                while(this._resolveQueue.length) &#123;    </span><br><span class="line">                    const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 实现同resolve</span><br><span class="line">        let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">                while(this._rejectQueue.length) &#123;</span><br><span class="line">                    const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">    then(resolveFn, rejectFn) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">        typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">        typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">        throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">        &#125; : null</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return一个新的promise</span><br><span class="line">        return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">        const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">                let x &#x3D; resolveFn(value)</span><br><span class="line">                &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">                x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; reject同理</span><br><span class="line">            const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; rejectFn(error)</span><br><span class="line">                    x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (this._status) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">                case PENDING:</span><br><span class="line">                    this._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    this._rejectQueue.push(rejectedFn)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">                case FULFILLED:</span><br><span class="line">                    fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">                    break;</span><br><span class="line">                case REJECTED:</span><br><span class="line">                    rejectedFn(this._value)</span><br><span class="line">                    break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下这个Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)          <span class="comment">//同步executor测试</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>          <span class="comment">//链式调用测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then()             <span class="comment">//值穿透测试</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">3</span>)      <span class="comment">//返回Promise测试</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;reject测试&#x27;</span>)   <span class="comment">//reject测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// Error: reject测试</span></span><br></pre></td></tr></table></figure><p>到这里，我们已经实现了Promise的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote><p><code>finally()方法</code>返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">        value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">        reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变Promise状态，在finally()没有返回reject态Promise或throw错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对Promise的理解，大家可以在各个交流群里直接@我）</p><blockquote><p>参考资料：<a href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p></blockquote><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote><p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    result[i] = val</span><br><span class="line">                    <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                    <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                value =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._value = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> FULFILLED:</span><br><span class="line">                    fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                    rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            value =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">            reason =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> result = []</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    val =&gt; &#123;</span><br><span class="line">                        index++</span><br><span class="line">                        result[i] = val</span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的race方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒150多行的代码，到这里，我们终于可以给Promise的实现做一个结尾了。我们从一个最简单的Promise使用实例开始，通过对调用流程的分析，根据观察者模式实现了Promise的大致骨架，然后依据Promise/A+规范填充代码，重点实现了then 的链式调用，最后完成了Promise的静态/实例方法。其实Promise实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多Promise细节，因而很难写出一个符合规范的Promise实现，源码的实现过程，其实也是对Promise使用细节重新学习的过程。</p><h1 id="async-await实现"><a href="#async-await实现" class="headerlink" title="async/await实现"></a>async/await实现</h1><p>虽然前边花了这么多篇幅讲Promise的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下async/await的使用意义。 在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p><blockquote><p>设想一个这样的场景，异步任务a-&gt;b-&gt;c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b不往下执行到c，那么也不是很方便控制</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(a)</span><br><span class="line">    .then(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是如果通过async/await来实现这个场景，可读性和流程控制都会方便不少。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(a);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(b);</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要如何实现一个async/await呢，首先我们要知道，<strong>async/await实际上是对Generator（生成器）的封装</strong>，是一个语法糖。由于Generator出现不久就被async/await取代了，很多同学对Generator比较陌生，因此我们先来看看Generator的用法：</p><blockquote><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();  <span class="comment">// 获取迭代器</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>也可以通过给<code>next()</code>传参, 让yield具有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 输出test1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>)  <span class="comment">// 输出test2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>)  <span class="comment">// 输出test3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(<span class="string">&#x27;test1&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test2&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们看到Generator的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用next()就能自动执行下一步</li><li><code>async</code>函数返回值是Promise对象，而Generator返回的是生成器对象</li><li><code>await</code>能够返回Promise的resolve/reject的值</li></ul><p><strong>我们对async/await的实现，其实也就是对应以上三点封装Generator</strong></p><h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">        gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出1 2 3</span></span><br></pre></td></tr></table></figure><p>我们也可以通过给<code>gen.next()</code>传值的方式，让yield能返回resolve的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(val)</span></span><br><span class="line">    gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(val)</span></span><br><span class="line">        gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(val)</span></span><br><span class="line">            gen.next(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen()                     <span class="comment">// 由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;             <span class="comment">// 封装一个方法, 递归执行g.next()</span></span><br><span class="line">        <span class="keyword">var</span> res = g.next(val)           <span class="comment">// 获取迭代器对象，并返回resolve的值</span></span><br><span class="line">        <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">// 递归终止条件</span></span><br><span class="line">            res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">// Promise的then方法是实现自动迭代的前提</span></span><br><span class="line">            _next(val)                    <span class="comment">// 等待Promise完成就自动执行下一个next，并传入resolve的值</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    _next()  <span class="comment">//第一次执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们之前的例子，我们就能这样执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure><p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成<code>_next()</code>，每次Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入<code>gen.next()</code>，使得yield得以返回Promise的resolve的值</p><blockquote><p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接<code>thunk函数</code>，thunk函数不是一个新东西，所谓thunk函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰Thunk 函数的含义和用法</a>，无论是Promise还是thunk函数，其核心都是通过<strong>传入回调</strong>的方式来实现Generator的自动执行。thunk函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p></blockquote><h2 id="2-返回Promise-amp-异常处理"><a href="#2-返回Promise-amp-异常处理" class="headerlink" title="2.返回Promise &amp; 异常处理"></a>2.返回Promise &amp; 异常处理</h2><p>虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：</p><ol><li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li><li><strong>缺少错误处理</strong>：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的try-catch捕获到</li><li><strong>返回值是Promise</strong>：<code>async/await</code>的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise</li></ol><p>我们改造一下run方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把返回值包装成promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> res = g.next(val) </span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err); </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(res.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// res.value包装为promise，以兼容yield后面跟基本类型的情况</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(res.value).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    _next(val);</span><br><span class="line">                &#125;, </span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 抛出错误</span></span><br><span class="line">                    g.throw(err)</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        _next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)) </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = run(myGenerator)     <span class="comment">// result是一个Promise</span></span><br><span class="line"><span class="comment">// 输出 1 2 error</span></span><br></pre></td></tr></table></figure><p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下babel对async/await的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于我们的run()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> gen = fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于我们的_next()</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;next&#x27;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;throw&#x27;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">            _next(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">        <span class="keyword">var</span> value = info.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(value).then(_next, _throw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)                          <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道await到底是如何暂停执行的，有关await暂停执行的秘密，我们还要到Generator的实现中去寻找答案</p><h1 id="Generator实现"><a href="#Generator实现" class="headerlink" title="Generator实现"></a>Generator实现</h1><p>我们从一个简单的Generator使用实例开始，一步步探究Generator的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> gen = foo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br></pre></td></tr></table></figure><p>我们可以在<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel官网</a>上在线转化这段代码，看看ES5环境下是如何实现Generator的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _marked =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">foo$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    _context.next = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    _context.next = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    _context.next = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> _context.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = foo();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br></pre></td></tr></table></figure><p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自facebook的 regenerator 模块，完整代码在<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个runtime有700多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p><blockquote><p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p></blockquote><h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下runtime里mark()方法的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line">runtime.mark = <span class="function"><span class="keyword">function</span>(<span class="params">genFun</span>) </span>&#123;</span><br><span class="line">    genFun.__proto__ = GeneratorFunctionPrototype;</span><br><span class="line">    genFun.prototype = <span class="built_in">Object</span>.create(Gp);</span><br><span class="line">    <span class="keyword">return</span> genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在runtime里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p><h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面babel转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看wrap方法的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">innerFn, outerFn, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = <span class="built_in">Object</span>.create(outerFn.prototype);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> Context([]);</span><br><span class="line">    generator._invoke = makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrap方法先是创建了一个generator，并继承<code>outerFn.prototype</code>；然后new了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后return了generator。<strong>其实wrap()相当于是给generator增加了一个_invoke方法</strong></p><p>这段代码肯定让人产生很多疑问，outerFn.prototype是什么，Context又是什么，makeInvokeMethod又做了哪些操作。下面我们就来一一解答：</p><blockquote><p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p></blockquote><p>这个我们结合一下上面的代码就能知道</p><blockquote><p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ContinueSentinel = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    method: <span class="string">&quot;next&quot;</span>,</span><br><span class="line">    next: <span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    abrupt: <span class="function"><span class="keyword">function</span>(<span class="params">type, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> record = &#123;&#125;;</span><br><span class="line">        record.type = type;</span><br><span class="line">        record.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.complete(record);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span>(<span class="params">record, afterLoc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (record.type === <span class="string">&quot;return&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rval = <span class="built_in">this</span>.arg = record.arg;</span><br><span class="line">            <span class="built_in">this</span>.method = <span class="string">&quot;return&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ContinueSentinel;</span><br><span class="line">    &#125;,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>makeInvokeMethod<code>的定义如下，它return了一个</code>invoke方法<code>，invoke用于判断当前状态和执行下一步，其实就是我们调用的</code>next()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInvokeMethod</span>(<span class="params">innerFn, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态置为start</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">method, arg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已完成</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">&quot;completed&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.method = method;</span><br><span class="line">        context.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            state = <span class="string">&quot;executing&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> record = &#123;</span><br><span class="line">                type: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                arg: innerFn.call(self, context)    <span class="comment">// 执行下一步,并获取状态(其实就是switch里边return的值)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.type === <span class="string">&quot;normal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否已经执行完成</span></span><br><span class="line">                state = context.done ? <span class="string">&quot;completed&quot;</span> : <span class="string">&quot;yield&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ContinueSentinel其实是一个空对象,record.arg === &#123;&#125;则跳过return进入下一个循环</span></span><br><span class="line">                <span class="comment">// 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span></span><br><span class="line">                <span class="keyword">if</span> (record.arg === ContinueSentinel) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// next()的返回值</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: record.arg,</span><br><span class="line">                    done: context.done</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在runtime对于next()的定义中，next()其实就return了_invoke方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for defining the .next, .throw, and .return methods of the</span></span><br><span class="line"><span class="comment">// Iterator interface in terms of a single ._invoke method.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineIteratorMethods</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">    [<span class="string">&quot;next&quot;</span>, <span class="string">&quot;throw&quot;</span>, <span class="string">&quot;return&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">        prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._invoke(method, arg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure><h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的Generator，然后再回过头看源码，会得到更清晰的认识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.next = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                _context.next = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                _context.next = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版context  </span></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    next:<span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span> <span class="title">stop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.done = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版invoke</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            value = context.done ? <span class="literal">undefined</span>: gen$(context)</span><br><span class="line">            done = context.done</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试使用</span></span><br><span class="line"><span class="keyword">var</span> g = gen() </span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result1&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result2&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result3&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码并不难理解，我们分析一下调用流程：</p><ol><li>我们定义的<code>function*</code>生成器函数被转化为以上代码</li><li>转化后的代码分为三大块：<ul><li><code>gen$(_context)</code>由yield分割生成器函数代码而来</li><li><code>context对象</code>用于储存函数执行上下文</li><li><code>invoke()方法</code>定义next()，用于执行gen$(_context)来跳到下一步</li></ul></li><li>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果</li><li>当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></li></ol><p>从中我们可以看出，<strong>Generator实现的核心在于<code>上下文的保存</code>，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p><h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关Promise、async/await、Generator的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近9千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对await挂起机制的好奇，后来，从一个 “await是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p><p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在Generator机制上给予的解惑~</p><blockquote><p>前端技匠：<a href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a><br> 神三元：<a href="https://juejin.im/post/6844903702457925640">我如何实现Promise</a><br> winty：<a href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a><br> 冴羽：<a href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator   编译成了什么样子</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自 &lt;a href=&quot;https://juejin.im/post/6844904096525189128&quot;&gt;https://juejin.im/post/6844904096525189128&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;笔者刚接触&lt;code&gt;async/await&lt;/code&gt;时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Promise" scheme="https://hxy1997.xyz/tags/Promise/"/>
    
    <category term="async" scheme="https://hxy1997.xyz/tags/async/"/>
    
    <category term="Generator" scheme="https://hxy1997.xyz/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>JS基础</title>
    <link href="https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/"/>
    <id>https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-26T09:14:39.000Z</published>
    <updated>2020-10-26T13:44:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。</p><span id="more"></span><h2 id="1-如何在ES5环境下实现let"><a href="#1-如何在ES5环境下实现let" class="headerlink" title="1. 如何在ES5环境下实现let"></a>1. 如何在ES5环境下实现let</h2><blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageslim" alt="img"></p><p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数（闭包）来模拟块级作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  for(var i &#x3D; 0; i &lt; 5; i ++)&#123;</span><br><span class="line">    console.log(i)  &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(i)      &#x2F;&#x2F; Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p><ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li><li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li><li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li><li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ul><p>babel的转化，其实只实现了第2、3、5点</p><h2 id="2-如何在ES5环境下实现const"><a href="#2-如何在ES5环境下实现const" class="headerlink" title="2. 如何在ES5环境下实现const"></a>2. 如何在ES5环境下实现const</h2><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p><blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">obj</td><td align="center">要在其上定义属性的对象</td></tr><tr><td align="center">prop</td><td align="center">要定义或修改的属性的名称</td></tr><tr><td align="center">descriptor</td><td align="center">将被定义或修改的属性描述符</td></tr></tbody></table><table><thead><tr><th align="center">属性描述符</th><th align="left">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">value</td><td align="left">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">get</td><td align="left">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">set</td><td align="left">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td><td align="center">undefined</td></tr><tr><td align="center">writable</td><td align="left">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td><td align="center">false</td></tr><tr><td align="center">enumerable</td><td align="left">enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td><td align="center">false</td></tr><tr><td align="center">Configurable</td><td align="left">configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td><td align="center">false</td></tr></tbody></table><p>对于const不可修改的特性，我们通过设置writable属性来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var __const &#x3D; function __const (data, value) &#123;</span><br><span class="line">    window.data &#x3D; value &#x2F;&#x2F; 把要定义的data挂载到window下，并赋值value</span><br><span class="line">    Object.defineProperty(window, data, &#123; &#x2F;&#x2F; 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: false,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">        return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (data) &#123;</span><br><span class="line">            if (data !&#x3D;&#x3D; value) &#123; &#x2F;&#x2F; 当要对当前属性进行赋值时，则抛出错误！</span><br><span class="line">            throw new TypeError(&#39;Assignment to constant variable.&#39;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">_const(&#39;obj&#39;, &#123;a: 1&#125;)   &#x2F;&#x2F; 定义obj</span><br><span class="line">obj.b &#x3D; 2               &#x2F;&#x2F; 可以正常给obj的属性赋值</span><br><span class="line">obj &#x3D; &#123;&#125;                &#x2F;&#x2F; 无法赋值新对象 报错</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://juejin.im/post/6844903848008482824">如何在 ES5 环境下实现一个const ？</a></p><h2 id="3-模拟实现call"><a href="#3-模拟实现call" class="headerlink" title="3. 模拟实现call"></a>3. 模拟实现call</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call() 方法&#96;使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</span><br><span class="line"> 语法：&#96;function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></blockquote><p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行当前函数</span></span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟实现apply"><a href="#4-模拟实现apply" class="headerlink" title="4. 模拟实现apply"></a>4. 模拟实现apply</h2><blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br> 语法：func.apply(thisArg, [argsArray])</p></blockquote><p><code>apply()</code>和<code>call()</code>类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-模拟实现bind"><a href="#5-模拟实现bind" class="headerlink" title="5. 模拟实现bind"></a>5. 模拟实现bind</h2><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br> 语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><p>从用法上看，似乎给call/apply包一层function就实现了bind()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function(context &#x3D; window, ...args) &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">    this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但我们忽略了三点：</p><ol><li><p>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</p></li><li><p>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</p></li><li><p>没有保留原函数在原型链上的属性和方法</p></li></ol><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-手写一个防抖函数-debounce"><a href="#6-手写一个防抖函数-debounce" class="headerlink" title="6. 手写一个防抖函数(debounce)"></a>6. 手写一个防抖函数(debounce)</h2><p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p><blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function debounce (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存一个定时器id</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">    &#x2F;&#x2F; 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">    &#x2F;&#x2F; 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-手写一个节流函数-throttle"><a href="#7-手写一个节流函数-throttle" class="headerlink" title="7. 手写一个节流函数(throttle)"></a>7. 手写一个节流函数(throttle)</h2><blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle(func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if (!lastTime) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                lastTime &#x3D; null</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; 0;</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前时间</span><br><span class="line">        let now &#x3D; +new Date()</span><br><span class="line">        &#x2F;&#x2F; 将当前时间和上一次执行函数时间对比</span><br><span class="line">        &#x2F;&#x2F; 如果差值大于设置的等待时间就执行函数</span><br><span class="line">        if (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime &#x3D; now</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8. 数组扁平化"></a>8. 数组扁平化</h2><blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>这样的一维数组呢：</p></blockquote><p><strong>1.直接调用ES6的flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">arr.flat(Infinity)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>2.序列化后正则</strong></p><p>把所有<code>[</code>和<code>]</code>去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">const str &#x3D; &#96;[$&#123;JSON.stringify(arr).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;)&#125;]&#96;</span><br><span class="line">JSON.parse(str)   &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>3.递归</strong><br> 对于树状结构的数据，最直接的处理方式就是递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr) &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>4.reduce()递归</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; &#123;</span><br><span class="line">    return prev.concat(cur instanceof Array ? flat(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>5.迭代+展开运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]</span><br><span class="line">&#x2F;&#x2F; 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并</span><br><span class="line">let arr &#x3D; [1, [1,2], [1,2,3,[4,4,4]]]</span><br><span class="line">while (arr.some(Array.isArray)) &#123;</span><br><span class="line">  arr &#x3D; [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3, 4, 4, 4]</span><br></pre></td></tr></table></figure><h2 id="9-手写一个Promise"><a href="#9-手写一个Promise" class="headerlink" title="9. 手写一个Promise"></a>9. 手写一个Promise</h2><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现一个符合规范的Promise篇幅比较长，建议阅读文章：<a href="https://juejin.im/post/6844904096525189128">异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-24T16:02:39.000Z</published>
    <updated>2020-10-26T06:17:51.766Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。</p><span id="more"></span><h1 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h1><h2 id="1-1-本地安装hexo"><a href="#1-1-本地安装hexo" class="headerlink" title="1.1.本地安装hexo"></a>1.1.本地安装hexo</h2><p>首先保证你电脑上有node环境，这个不懂的可以自定百度。</p><p>控制台输入node -v出现版本号说明安装成功。</p><p>有了node就可以安装hexo了，控制台输入如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure><p>同样控制台输入hexo -v出现版本号说明安装成功。</p><p>然后开始初始化项目，控制台输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>生成的目录：</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules：是依赖包</span><br><span class="line">public：存放的是生成的页面</span><br><span class="line">scaffolds：命令生成文章等的模板</span><br><span class="line">source：用命令创建的各种文章</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml：整个博客的配置</span><br><span class="line">db.json：source解析所得到的</span><br><span class="line">package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-本地运行"><a href="#1-2-本地运行" class="headerlink" title="1.2.本地运行"></a>1.2.本地运行</h2><p>首先在本地跑起来你的代码</p><p>控制台安装hexo-server</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-server</span><br></pre></td></tr></table></figure><p>然后运行 hexo-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<a href="http://localhost:4000/">http://localhost:4000</a>  就可以看到你本定运行的页面了</p><p>这时你可以在本地调试一下你的blog。</p><h2 id="1-3-github配置"><a href="#1-3-github配置" class="headerlink" title="1.3.github配置"></a>1.3.github配置</h2><p>首先要创建一个github账号</p><p>并配置好ssh</p><p>这些不懂的可以自行百度。</p><p>创建一个repo，名称为yourname.github.io, 其中 yourname 是你的github名称，按照这个规则创建github page才会生效。</p><p>修改_config.yml中的git配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:  https:<span class="comment">//github.com/yourname/yourname.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="1-4-部署上传"><a href="#1-4-部署上传" class="headerlink" title="1.4.部署上传"></a>1.4.部署上传</h2><p>在本地安装上传工具</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>依次执行如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean     //删除上次打包</span><br><span class="line">hexo generate   //打包</span><br><span class="line">hexo deploy    /上传</span><br></pre></td></tr></table></figure><p>这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。</p><p>在浏览器中输入 <a href="https://yourname.github.io/">https://yourname.github.io/</a> 就可以看到你的个人博客了！</p><h2 id="1-5-README-md配置"><a href="#1-5-README-md配置" class="headerlink" title="1.5 README.md配置"></a>1.5 README.md配置</h2><p>1.首先在source文件夹下建立一个README.md</p><p>2.修改_config.yml</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><h1 id="二、绑定二人域名"><a href="#二、绑定二人域名" class="headerlink" title="二、绑定二人域名"></a>二、绑定二人域名</h1><h2 id="2-1购买一个域名"><a href="#2-1购买一个域名" class="headerlink" title="2.1购买一个域名"></a>2.1购买一个域名</h2><p>这里我选择的是阿里云，挑选一个自己喜欢的域名购买。</p><h2 id="2-2域名解析"><a href="#2-2域名解析" class="headerlink" title="2.2域名解析"></a>2.2域名解析</h2><p>进入控制台添加域名解析。</p><p>按照如下规则添加两条记录。</p><p>解析好的域名404，说明域名解析没有问题，接下来进入github进行配置</p><h2 id="2-3-hexo配置"><a href="#2-3-hexo配置" class="headerlink" title="2.3 hexo配置"></a>2.3 hexo配置</h2><p>在本地的博客目录中找到source文件夹。</p><p>新建一个没有后缀名的文件CNAME</p><p>在文件中添加你的域名，如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisq.xyz</span><br></pre></td></tr></table></figure><p>保存后重新生成，并提交你的博客。</p><h2 id="2-4-github配置"><a href="#2-4-github配置" class="headerlink" title="2.4 github配置"></a>2.4 github配置</h2><p>在github中找到你的博客仓库。</p><p>点击<code>Setting</code></p><p>找到<code>Custom domain</code></p><p>输入你的域名点击save</p><p>然后你就可以在浏览器用你的域名愉快的访问啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Github" scheme="https://hxy1997.xyz/tags/Github/"/>
    
    <category term="博客" scheme="https://hxy1997.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://hxy1997.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-25T06:02:29.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><h2 id="1-为什么要学习设计模式？"><a href="#1-为什么要学习设计模式？" class="headerlink" title="1.为什么要学习设计模式？"></a>1.为什么要学习设计模式？</h2><p>在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。</p><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="2-什么是设计模式。"><a href="#2-什么是设计模式。" class="headerlink" title="2.什么是设计模式。"></a>2.什么是设计模式。</h2><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p><p>设计模式主要是为了解决对象的生成和整合问题。</p><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p><h2 id="3-设计模式的发展历史"><a href="#3-设计模式的发展历史" class="headerlink" title="3.设计模式的发展历史"></a>3.设计模式的发展历史</h2><p>设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。</p><p>四人帮把这本书分成两部分：</p><p>第一部分解释面向对象编程的优缺点。</p><p>第二部分是关于 23 个经典设计模式的演变。</p><p>自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。</p><h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.设计模式分类"></a>4.设计模式分类</h2><p>根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p>接下来将概述属于这三种类型的 23 种设计模式的主要概念。</p><span id="more"></span><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="this、new、bind、call、apply"><a href="#this、new、bind、call、apply" class="headerlink" title="this、new、bind、call、apply"></a>this、new、bind、call、apply</h2><h3 id="1-this-指向的类型"><a href="#1-this-指向的类型" class="headerlink" title="1. this 指向的类型"></a><strong>1. this 指向的类型</strong></h3><h4 id="this-在函数的指向有以下几种场景："><a href="#this-在函数的指向有以下几种场景：" class="headerlink" title="this 在函数的指向有以下几种场景："></a><strong>this 在函数的指向有以下几种场景：</strong></h4><ul><li>作为构造函数被 new 调用；</li><li>作为对象的方法使用；</li><li>作为函数直接调用；</li><li>被 <code>call</code>、<code>apply</code>、<code>bind</code> 调用；</li><li>箭头函数中的 <code>this</code>；</li></ul><h4 id="1-1-new-绑定"><a href="#1-1-new-绑定" class="headerlink" title="1.1 new 绑定"></a><strong>1.1 new 绑定</strong></h4><blockquote><p>函数如果作为构造函数使用 <code>new</code> 调用时， <code>this</code> 绑定的是新创建的构造函数的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()       <span class="comment">// 输出: Foo 实例，this 就是 bar</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上使用 <code>new</code> 调用构造函数时，会依次执行下面的操作：</p></blockquote><ul><li>创建一个新对象；</li><li>构造函数的 <code>prototype</code> 被赋值给这个新对象的 <code>__proto__</code>；</li><li>将新对象赋给当前的 <code>this</code>；</li><li>执行构造函数；</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象，如果返回的不是对象将被忽略；</li></ul><h4 id="1-2-显式绑定"><a href="#1-2-显式绑定" class="headerlink" title="1.2 显式绑定"></a><strong>1.2 显式绑定</strong></h4><blockquote><p>通过 <code>call</code>、<code>apply</code>、<code>bind</code> 我们可以修改函数绑定的 <code>this</code>，使其成为我们指定的对象。通过这些方法的第一个参数我们可以显式地绑定 <code>this</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">category, name, price</span>) </span>&#123;</span><br><span class="line">    foo.call(<span class="built_in">this</span>, name, price)       <span class="comment">// call 方式调用</span></span><br><span class="line">    <span class="comment">// foo.apply(this, [name, price])    // apply 方式调用</span></span><br><span class="line">    <span class="built_in">this</span>.category = category</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Food(<span class="string">&#x27;食品&#x27;</span>, <span class="string">&#x27;汉堡&#x27;</span>, <span class="string">&#x27;5块钱&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &#123;name: &quot;汉堡&quot;, price: &quot;5块钱&quot;, category: &quot;食品&quot;&#125;</span></span><br><span class="line">call 和 apply 的区别是 call 方法接受的是参数列表，而 apply 方法接受的是一个参数数组。</span><br><span class="line"></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)        <span class="comment">// call 用法</span></span><br><span class="line">func.apply(thisArg, [arg1, arg2, ...])     <span class="comment">// apply 用法</span></span><br></pre></td></tr></table></figure><blockquote><p>而 <code>bind</code> 方法是设置 <code>this</code> 为给定的值，并返回一个新的函数，且在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])    <span class="comment">// bind 用法</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> food = &#123;</span><br><span class="line">    name: <span class="string">&#x27;汉堡&#x27;</span>,</span><br><span class="line">    price: <span class="string">&#x27;5块钱&#x27;</span>,</span><br><span class="line">    getPrice: <span class="function"><span class="keyword">function</span>(<span class="params">place</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(place + <span class="built_in">this</span>.price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">food.getPrice(<span class="string">&#x27;KFC &#x27;</span>)   <span class="comment">// 浏览器中输出: &quot;KFC 5块钱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice1 = food.getPrice.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;鸡腿&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;7块钱&#x27;</span> &#125;, <span class="string">&#x27;肯打鸡 &#x27;</span>)</span><br><span class="line">getPrice1()       <span class="comment">// 浏览器中输出: &quot;肯打鸡 7块钱&quot;</span></span><br><span class="line">关于 bind 的原理，我们可以使用 apply 方法自己实现一个 bind 看一下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params">...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, [...rest1, ...rest2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ES6</code> 方式用了一些 <code>ES6</code> 的知识比如 <code>rest</code> 参数、数组解构</p></blockquote><p><strong>注意：</strong> 如果你把 <code>null</code> 或 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code>、<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="literal">null</span>)         <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind(this)</code>链式调用，实际上后几项未执行，实质上 <code>this</code> 指向第一个绑定</p><h4 id="1-3-隐式绑定"><a href="#1-3-隐式绑定" class="headerlink" title="1.3 隐式绑定"></a>1.3 隐式绑定</h4><blockquote><p>函数是否在某个上下文对象中调用，如果是的话 <code>this</code> 绑定的是那个上下文对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()       <span class="comment">// 浏览器中输出: &quot;world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>foo</code> 方法是作为对象的属性调用的，那么此时 <code>foo</code> 方法执行时，<code>this</code> 指向 <code>obj</code> 对象。也就是说，此时 <code>this</code> 指向调用这个方法的对象，如果嵌套了多个对象，那么指向最后一个调用这个方法的对象：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">        foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.b.foo()      <span class="comment">// 浏览器中输出: &quot;China&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>最后一个对象是 <code>obj</code> 上的 <code>b</code>，那么此时 <code>foo</code> 方法执行时，其中的 <code>this</code> 指向的就是 <code>b</code> 对象。</p></blockquote><h4 id="1-4-默认绑定"><a href="#1-4-默认绑定" class="headerlink" title="1.4 默认绑定"></a><strong>1.4 默认绑定</strong></h4><blockquote><p>函数独立调用，直接使用不带任何修饰的函数引用进行调用，也是上面几种绑定途径之外的方式。非严格模式下 this 绑定到全局对象（浏览器下是 <code>winodw</code>，<code>node</code> 环境是 <code>global</code>），严格模式下 <code>this</code> 绑定到 <code>undefined</code> （因为严格模式不允许 <code>this</code> 指向全局对象）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()             <span class="comment">// 相当于执行 window.foo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 浏览器中输出: Window 对象</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 <code>a</code> 被声明在全局作用域，成为全局对象 <code>window</code> 的一个同名属性。函数 <code>foo</code> 被执行时，<code>this</code> 此时指向的是全局对象，因此打印出来的 <code>a</code> 是全局对象的属性。</p></blockquote><p>注意有一种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"></span><br><span class="line">bar()              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时 <code>bar</code> 函数，也就是 <code>obj</code> 上的 <code>foo</code> 方法为什么又指向了全局对象呢，是因为 <code>bar</code> 方法此时是作为函数独立调用的，所以此时的场景属于默认绑定，而不是隐式绑定。这种情况和把方法作为回调函数的场景类似：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(obj.foo)              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数传递实际上也是一种隐式的赋值，只不过这里 <code>obj.foo</code> 方法是被隐式赋值给了函数 <code>func</code> 的形参 <code>fn</code>，而之前的情景是自己赋值，两种情景实际上类似。这种场景我们遇到的比较多的是 <code>setTimeout</code> 和 <code>setInterval</code>，如果回调函数不是箭头函数，那么其中的 <code>this</code> 指向的就是全局对象.</li><li>其实我们可以把默认绑定当作是隐式绑定的特殊情况，比如上面的 <code>bar()</code>，我们可以当作是使用 <code>window.bar()</code> 的方式调用的，此时 bar 中的 <code>this</code> 根据隐式绑定的情景指向的就是 <code>window</code>。</li></ul><h3 id="2-this-绑定的优先级"><a href="#2-this-绑定的优先级" class="headerlink" title="2. this 绑定的优先级"></a><strong>2. this 绑定的优先级</strong></h3><blockquote><p><code>this</code> 存在多个使用场景，那么多个场景同时出现的时候，<code>this</code> 到底应该如何指向呢。这里存在一个优先级的概念，<code>this</code> 根据优先级来确定指向。<strong>优先级：new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p></blockquote><p><strong>所以 this 的判断顺序：</strong></p><ul><li><code>new</code> 绑定： 函数是否在 <code>new</code> 中调用？如果是的话 <code>this</code> 绑定的是新创建的对象；</li><li>显式绑定： 函数是否是通过 <code>bind</code>、<code>call</code>、<code>apply</code> 调用？如果是的话，<code>this</code> 绑定的是指定的对象；</li><li>隐式绑定： 函数是否在某个上下文对象中调用？如果是的话，<code>this</code> 绑定的是那个上下文对象；</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象；</li></ul><h3 id="3-箭头函数中的-this"><a href="#3-箭头函数中的-this" class="headerlink" title="3. 箭头函数中的 this"></a><strong>3. 箭头函数中的 this</strong></h3><ul><li>箭头函数 是根据其声明的地方来决定 <code>this</code> 的</li><li>箭头函数的 <code>this</code> 绑定是无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 被修改的，且因为箭头函数没有构造函数 <code>constructor</code>，所以也不可以使用 new 调用，即不能作为构造函数，否则会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()             <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-一个-this-的小练习"><a href="#4-一个-this-的小练习" class="headerlink" title="4. 一个 this 的小练习"></a><strong>4. 一个 this 的小练习</strong></h3><p>用一个小练习来实战一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 20</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li><code>var a = 20</code> 这句在全局变量 <code>window</code> 上创建了个属性 <code>a</code> 并赋值为 <code>20</code>；</li><li>首先执行的是 <code>obj.foo()</code>，这是一个箭头函数，箭头函数不创建新的函数作用域直接沿用语句外部的作用域，因此 <code>obj.foo()</code> 执行时箭头函数中 <code>this</code> 是全局 <code>window</code>，首先打印出 window 上的属性 a 的值 20，箭头函数返回了一个原型上有个值为 <code>50</code> 的属性 <code>a</code> 的函数对象 <code>func</code> 给 <code>bar</code>；</li><li>继续执行的是 <code>bar()</code>，这里执行的是刚刚箭头函数返回的闭包 <code>func</code>，其内部的 <code>this</code> 指向 <code>window</code>，因此 <code>this.a</code> 修改了 <code>window.a</code> 的值为 <code>60</code> 并打印出来；</li><li>然后执行的是 <code>new bar()</code>，根据之前的表述，<code>new</code> 操作符会在 <code>func</code> 函数中创建一个继承了 <code>func</code> 原型的实例对象并用 <code>this</code> 指向它，随后 <code>this.a = 60</code> 又在实例对象上创建了一个属性 <code>a</code>，在之后的打印中已经在实例上找到了属性 <code>a</code>，因此就不继续往对象原型上查找了，所以打印出第三个 <code>60</code>；</li><li>如果把上面例子的箭头函数换成普通函数呢，结果会是什么样？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 40</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><h2 id="闭包与高阶函数"><a href="#闭包与高阶函数" class="headerlink" title="闭包与高阶函数"></a>闭包与高阶函数</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a><strong>1. 闭包</strong></h3><h4 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a><strong>1.1 什么是闭包</strong></h4><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>我们首先来看一个闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line"></span><br><span class="line">baz()            <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><ul><li><code>foo</code> 函数传递出了一个函数 <code>bar</code>，传递出来的 <code>bar</code> 被赋值给 <code>baz</code> 并调用，虽然这时 <code>baz</code> 是在 <code>foo</code> 作用域外执行的，但 <code>baz</code> 在调用的时候可以访问到前面的 <code>bar</code> 函数所在的 <code>foo</code> 的内部作用域。</li><li>由于 <code>bar</code> 声明在 <code>foo</code> 函数内部，<code>bar</code> 拥有涵盖 <code>foo</code> 内部作用域的闭包，使得 <code>foo</code> 的内部作用域一直存活不被回收。一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 <code>JavaScript</code> 的 <code>GC</code>（Garbage Collection）垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 <code>GC</code>，比如本例中 <code>foo()</code> 执行完，因为返回的 <code>bar</code> 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。</li><li>注意： 如果不是必须使用闭包，那么尽量避免创建它，因为闭包在处理速度和内存消耗方面对性能具有负面影响。</li></ul><h4 id="1-2-利用闭包实现结果缓存（备忘模式）"><a href="#1-2-利用闭包实现结果缓存（备忘模式）" class="headerlink" title="1.2 利用闭包实现结果缓存（备忘模式）"></a><strong>1.2 利用闭包实现结果缓存（备忘模式）</strong></h4><blockquote><p>备忘模式就是应用闭包的特点的一个典型应用。比如有个函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多次运行 <code>add()</code> 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。</li><li>所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>ES6</code> 的方式会更优雅一些：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li>备忘函数中用 <code>JSON.stringify</code> 把传给 <code>adder</code> 函数的参数序列化成字符串，把它当做 <code>cache</code> 的索引，将 <code>add</code> 函数运行的结果当做索引的值传递给 <code>cache</code>，这样 <code>adder</code> 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 <code>fn.apply(fn, args)</code>，再返回计算的结果。</li><li>当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：</li><li>缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 <code>n</code> 个；</li><li>在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 <code>cookie</code>、<code>localStorage</code> 等；</li><li>这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。</li><li>复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。</li></ul><blockquote><p>注意： <code>cache</code> 不可以是 <code>Map</code>，因为 <code>Map</code> 的键是使用 <code>===</code> 比较的，因此当传入引用类型值作为键时，虽然它们看上去是相等的，但实际并不是，比如 <code>[1]!==[1]</code>，所以还是被存为不同的键。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  X 错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(args) || cache.set(args, fn.apply(fn, args)).get(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)    <span class="comment">// 3    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2, [ 2 ] =&gt; 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a><strong>2. 高阶函数</strong></h3><blockquote><p>高阶函数就是输入参数里有函数，或者输出是函数的函数。</p></blockquote><h4 id="2-1-函数作为参数"><a href="#2-1-函数作为参数" class="headerlink" title="2.1 函数作为参数"></a><strong>2.1 函数作为参数</strong></h4><blockquote><p>如果你用过 <code>setTimeout</code>、<code>setInterval</code>、<code>ajax</code> 请求，那么你已经用过高阶函数了，这是我们最常看到的场景：回调函数，因为它将函数作为参数传递给另一个函数。</p></blockquote><blockquote><p>比如 <code>ajax</code> 请求中，我们通常使用回调函数来定义请求成功或者失败时的操作逻辑：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">&quot;/request/url&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Array</code>、<code>Object</code>、<code>String</code> 等等基本对象的原型上有很多操作方法，可以接受回调函数来方便地进行对象操作。这里举一个很常用的 <code>Array.prototype.filter()</code> 方法，这个方法返回一个新创建的数组，包含所有回调函数执行后返回 <code>true</code> 或真值的数组元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word.length &gt; <span class="number">6</span></span><br><span class="line">&#125;)  <span class="comment">// 输出: [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数还有一个应用就是钩子，如果你用过 Vue 或者 React 等框架，那么你应该对钩子很熟悉了，它的形式是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 一些操作</span></span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-函数作为返回值"><a href="#2-2-函数作为返回值" class="headerlink" title="2.2 函数作为返回值"></a><strong>2.2 函数作为返回值</strong></h4><blockquote><p>另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要是利用闭包来保持着作用域：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num = num + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder = add()</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)     <span class="comment">// 输出: 1</span></span><br><span class="line">adder(<span class="number">2</span>)     <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h5 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a><strong>1. 柯里化</strong></h5><ul><li>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的原函数变换成接受一个单一参数（原函数的第一个参数）的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。</li><li>核心思想是把多参数传入的函数拆成单（或部分）参数函数，内部再返回调用下一个单（或部分）参数函数，依次处理剩余的参数。</li></ul><p><strong>柯里化有 3 个常见作用：</strong></p><ul><li>参数复用</li><li>提前返回</li><li>延迟计算/运行</li></ul><p>先来看看柯里化的通用实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要记住 ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把剩余参数与当前参数拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用它将一个 <code>sayHello</code> 函数柯里化试试：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg1 = currying(sayHello, <span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">curryingShowMsg1(<span class="number">22</span>, <span class="string">&#x27;苹果&#x27;</span>)           <span class="comment">// 输出: 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg2 = currying(sayHello, <span class="string">&#x27;小衰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">curryingShowMsg2(<span class="string">&#x27;西瓜&#x27;</span>)               <span class="comment">// 输出: 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br></pre></td></tr></table></figure><blockquote><p>更高阶的用法参见：JavaScript 函数式编程技巧 - 柯里化</p></blockquote><h5 id="2-反柯里化"><a href="#2-反柯里化" class="headerlink" title="2. 反柯里化"></a><strong>2. 反柯里化</strong></h5><ul><li>柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</li><li>而反柯里化，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</li></ul><p>先来看看反柯里化的通用实现吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你觉得把函数放在 Function 的原型上不太好，也可以这样：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tar</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        rest.shift()</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">tar, ...argu</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, argu)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单说，函数柯里化就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)              // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3</span>)        // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3, arg4</span>)  // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)(<span class="params">arg4</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argn</span>)   // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)…(<span class="params">argn</span>)</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>而反柯里化就是反过来，增加适用范围，让方法使用场景更大。使用反柯里化, 可以把原生方法借出来，让任何对象拥有原生对象的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(arg1, arg2)        <span class="comment">// =&gt; func(obj, arg1, arg2)</span></span><br></pre></td></tr></table></figure><p><strong>可以这样理解柯里化和反柯里化的区别：</strong></p><ul><li>柯里化是在运算前提前传参，可以传递多个参数；</li><li>反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</li><li>更高阶的用法参见：JavaScript 函数式编程技巧 - 反柯里化</li></ul><h5 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3. 偏函数"></a><strong>3. 偏函数</strong></h5><blockquote><p>偏函数是创建一个调用另外一个部分（参数或变量已预制的函数）的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的逻辑代码，只是根据传入的参数返回其他的函数，返回的函数中才有真正的处理逻辑比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">&#x27;Function&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样就用偏函数快速创建了一组判断对象类型的方法~</p></blockquote><p><strong>偏函数和柯里化的区别：</strong></p><ul><li>柯里化是把一个接受 <code>n</code> 个参数的函数，由原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行，例如：<code>add = (x, y, z) =&gt; x + y + z→curryAdd = x =&gt; y =&gt; z =&gt; x + y + z；</code></li><li>偏函数固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个；</li><li>当一个柯里化函数只接受两次参数时，比如 <code>curry()()</code>，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote><p>在前文我们介绍了面向对象三大特性之继承，本文将主要介绍面向对象六大原则中的单一职责原则（SRP）、开放封闭原则（OCP）、最少知识原则（LKP）。</p></blockquote><blockquote><p>设计原则是指导思想，从思想上给我们指明程序设计的正确方向，是我们在开发设计过程中应该尽力遵守的准则。而设计模式是实现手段，因此设计模式也应该遵守这些原则，或者说，设计模式就是这些设计原则的一些具体体现。要达到的目标就是高内聚低耦合，高内聚是说模块内部要高度聚合，是模块内部的关系，低耦合是说模块与模块之间的耦合度要尽量低，是模块与模块间的关系。</p></blockquote><p><strong>注意</strong>，遵守设计原则是好，但是过犹不及，在实际项目中我们不要刻板遵守，需要根据实际情况灵活运用</p><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1. 单一职责原则 SRP"></a><strong>1. 单一职责原则 SRP</strong></h3><ul><li>单一职责原则 （Single Responsibility Principle, SRP）是指对一个类（方法、对象，下文统称对象）来说，应该仅有一个引起它变化的原因。也就是说，一个对象只做一件事。</li><li>单一职责原则可以让我们对对象的维护变得简单，如果一个对象具有多个职责的话，那么如果一个职责的逻辑需要修改，那么势必会影响到其他职责的代码。如果一个对象具有多种职责，职责之间相互耦合，对一个职责的修改会影响到其他职责的实现，这就是属于模块内低内聚高耦合的情况。负责的职责越多，耦合越强，对模块的修改就越来越危险。</li></ul><p><strong>优点：</strong></p><ul><li>降低单个类（方法、对象）的复杂度，提高可读性和可维护性，功能之间的界限更清晰； 类（方法、对象）之间根据功能被分为更小的粒度，有助于代码的复用；</li><li>缺点： 增加系统中类（方法、对象）的个数，实际上也增加了这些对象之间相互联系的难度，同时也引入了额外的复杂度。</li></ul><h3 id="2-开放封闭原则-OCP"><a href="#2-开放封闭原则-OCP" class="headerlink" title="2. 开放封闭原则 OCP"></a><strong>2. 开放封闭原则 OCP</strong></h3><blockquote><p>开放封闭原则 （Open－Close Principle, OCP）是指一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的，也就是对扩展开放，对修改封闭。</p></blockquote><blockquote><p>当需要增加需求的时候，则尽量通过扩展新代码的方式，而不是修改已有代码。因为修改已有代码，则会给依赖原有代码的模块带来隐患，因此修改之后需要把所有依赖原有代码的模块都测试一遍，修改一遍测试一遍，带来的成本很大，如果是上线的大型项目，那么代价和风险可能更高。</p></blockquote><p><strong>优点</strong>：</p><ul><li>增加可维护性，避免因为修改给系统带来的不稳定性。</li></ul><h3 id="3-最少知识原则-LKP"><a href="#3-最少知识原则-LKP" class="headerlink" title="3. 最少知识原则 LKP"></a><strong>3. 最少知识原则 LKP</strong></h3><ul><li>最少知识原则 （Least Knowledge Principle, LKP）又称为迪米特原则 （Law of Demeter, LOD），一个对象应该对其他对象有最少的了解。</li><li>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li><li>通常为了减少对象之间的联系，是通过引入一个第三者来帮助进行通信，阻隔对象之间的直接通信，从而减少耦合。</li></ul><p><strong>优点：</strong></p><ul><li>降低类（方法、对象）之间不必要的依赖，减少耦合。</li></ul><p><strong>缺点：</strong></p><ul><li>类（方法、对象）之间不直接通信也会经过一个第三者来通信，那么就要权衡引入第三者带来的复杂度是否值得。</li></ul><h1 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到，本节我们一起来学习一下。</li><li>单例模式 （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</li></ul><p>经营游戏单例示例代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ManageGame() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    ManageGame._schedule &#x3D; this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ManageGame.getInstance &#x3D; function() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    return ManageGame._schedule &#x3D; new ManageGame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const schedule1 &#x3D; new ManageGame()</span><br><span class="line">const schedule2 &#x3D; ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line">console.log(schedule1 &#x3D;&#x3D;&#x3D; schedule2)</span><br></pre></td></tr></table></figure><blockquote><p>稍微解释一下，这个构造函数在内部维护（或者直接挂载自己身上）一个实例，第一次执行 new 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。我们可以用 <code>ES6</code> 的 <code>class</code> 语法改造一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> _schedule = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        <span class="keyword">return</span> ManageGame._schedule = <span class="keyword">new</span> ManageGame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        ManageGame._schedule = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schedule1 = <span class="keyword">new</span> ManageGame()</span><br><span class="line"><span class="keyword">const</span> schedule2 = ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(schedule1 === schedule2)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面方法的缺点在于维护的实例作为静态属性直接暴露，外部可以直接修改。</p><p>可以使用闭包或块状作用域隐藏内部变量：</p><p><strong>单例模式赋能</strong></p><blockquote><p>之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据单一职责原则，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p></blockquote><p><strong>惰性单例、懒汉式-饿汉式</strong></p><ul><li>有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用惰性创建，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</li></ul><p><strong>单例模式的优缺点</strong></p><p>单例模式主要解决的问题就是节约资源，保持访问一致性。</p><p><strong>简单分析一下它的优点：</strong></p><ul><li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li><li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li><li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li></ul><p><strong>单例模式也是有缺点的</strong></p><ul><li>单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；</li><li>与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li></ul><p><strong>单例模式的使用场景</strong></p><p>那我们应该在什么场景下使用单例模式呢：</p><ul><li>当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；</li><li>当项目中需要一个公共的状态，那么需要使用单例模式来保证访问一致性；</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>访问者只需要知道产品名，就可以从工厂获得对应实例；</li><li>访问者不关心实例创建过程；</li></ul><p><strong>代码实现</strong></p><blockquote><p>如果你使用过 <code>document.createElement</code> 方法创建过 <code>DOM</code> 元素，那么你已经使用过工厂方法了，虽然这个方法实际上很复杂，但其使用的就是工厂方法的思想：访问者只需提供标签名（如 <code>div</code>、<code>img</code>），那么这个方法就会返回对应的 DOM 元素。</p></blockquote><p>我们可以使用 JavaScript 将上面饭馆例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restaurant</span>(<span class="params">menu</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDin</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDin.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法中这里使用 <code>switch-case</code> 语法，你也可以用 <code>if-else</code>，都可以。</p></blockquote><p>下面使用 ES6 的 class 语法改写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.getMenu(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.getMenu(<span class="string">&#x27;红烧排骨&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>这样就完成了一个工厂模式，但是这个实现有一个问题：工厂方法中包含了很多与创建产品相关的过程，如果产品种类很多的话，这个工厂方法中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应修改在工厂方法，违反了开闭原则，也导致这个工厂方法变得臃肿、高耦合。</li><li>严格上这种实现在面向对象语言中叫做简单工厂模式。适用于产品种类比较少，创建逻辑不复杂的时候使用。</li><li>工厂模式的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类，所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。关于抽象类的有关内容，可以参看抽象工厂模式。</li><li>然而作为灵活的 JavaScript，我们不必如此较真，可以把易变的参数提取出来：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.menuData = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu])</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; type, message &#125; = <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Menu(type, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加菜品种类 */</span></span><br><span class="line">    <span class="function"><span class="title">addMenu</span>(<span class="params">menu, type, message</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.menuData[menu]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.Info(<span class="string">&#x27;已经有这个菜了!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.menuData[menu] = &#123; type, message &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移除菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">removeMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu]) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="built_in">this</span>.message) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restaurant = <span class="keyword">new</span> Restaurant()</span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>, <span class="string">&#x27;鱼香肉丝&#x27;</span>, <span class="string">&#x27; 真香~&#x27;</span>)<span class="comment">// 注册菜品</span></span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;GongBaoJiDin&#x27;</span>, <span class="string">&#x27;宫保鸡丁&#x27;</span>, <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant.getMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant.getMenu(<span class="string">&#x27;HongSaoPaiGu&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>我们还给 Restaurant 类增加了 <code>addMenu/removeMenu</code> 私有方法，以便于扩展。</li><li>当然这里如果菜品参数不太一致，可以在 <code>addMenu</code> 时候注册构造函数或者类，创建的时候返回 <code>new</code> 出的对应类实例，灵活变通即可。</li></ul><p> <strong>工厂模式的优缺点</strong></p><p>工厂模式将对象的创建和实现分离，这带来了优点：</p><ul><li>良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下；</li><li>扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则；</li><li>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</li><li>工厂模式的缺点：带来了额外的系统复杂度，增加了抽象性；</li></ul><p><strong>工厂模式的使用场景</strong></p><p>那么什么时候使用工厂模式呢：</p><ul><li>对象的创建比较复杂，而访问者无需知道创建的具体流程；</li><li>处理大量具有相同属性的小对象；</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>抽象工厂 （Abstract Factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。</li><li>我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA、C#、C++ 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。</li></ul><p><strong>代码实现</strong></p><blockquote><p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 <code>new.target</code> 来判断 new 的类，在父类方法中 <code>throw new Error()</code>，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 抽象类，ES6 class 方式 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">operate</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象类，ES5 构造函数方式 */</span></span><br><span class="line"><span class="keyword">var</span> AbstractClass2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 抽象方法，使用原型方式添加 */</span></span><br><span class="line">AbstractClass2.prototype.operate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>下面用 JavaScript 将上面介绍的饭店例子实现一下。</p><p>首先使用原型方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Restaurant</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Restaurant.orderDish = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDing()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;紫菜蛋汤&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZiCaiDanTang()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dish</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象方法 */</span></span><br><span class="line">Dish.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDing</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br><span class="line">使用 <span class="class"><span class="keyword">class</span> 语法改写一下：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">orderDish</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Dish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish0 = <span class="keyword">new</span> Dish()  <span class="comment">// 输出: Error 抽象方法不能调用!</span></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br></pre></td></tr></table></figure><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>抽象模式的优点：</strong></p><blockquote><p>抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；</p></blockquote><p><strong>抽象模式的缺点：</strong></p><ul><li>扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；</li><li>带来了系统复杂度，增加了新的类，和新的继承关系；</li></ul><p><strong>抽象工厂模式的使用场景</strong></p><blockquote><p>如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。</p></blockquote><p> <strong>抽象工厂模式与工厂模式</strong></p><p>工厂模式和抽象工厂模式的区别：</p><ul><li>工厂模式 主要关注单独的产品实例的创建；</li><li>抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；根据场景灵活使用即可。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>建造者模式（Builder Pattern）又称生成器模式，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的构建层与其表示层分离。</p></blockquote><ul><li>在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。</li></ul><p>汽车装配代码模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">function CarBuilder(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">    this.color &#x3D; color</span><br><span class="line">    this.weight &#x3D; weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，轮胎</span><br><span class="line">CarBuilder.prototype.buildTyre &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，发动机</span><br><span class="line">CarBuilder.prototype.buildEngine &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 奔驰厂家，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">function benChiDirector(tyre, engine, param) &#123;</span><br><span class="line">    var _car &#x3D; new CarBuilder(param)</span><br><span class="line">    _car.buildTyre(tyre)</span><br><span class="line">    _car.buildEngine(engine)</span><br><span class="line">    return _car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">var benchi1 &#x3D; benChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>ES6写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">class CarBuilder &#123;</span><br><span class="line">    constructor(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">        this.weight &#x3D; weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，轮胎 *&#x2F;</span><br><span class="line">    buildTyre(type) &#123;</span><br><span class="line">        const tyre &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.tyre &#x3D; tyre</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，发动机 *&#x2F;</span><br><span class="line">    buildEngine(type) &#123;</span><br><span class="line">        const engine &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.engine &#x3D; engine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 指挥者，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">class BenChiDirector &#123;</span><br><span class="line">    constructor(tyre, engine, param) &#123;</span><br><span class="line">        const _car &#x3D; new CarBuilder(param)</span><br><span class="line">        _car.buildTyre(tyre)</span><br><span class="line">        _car.buildEngine(engine)</span><br><span class="line">        return _car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">const benchi1 &#x3D; new BenChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来完成部件的装配</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者，汽车部件厂家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">&#123; color = <span class="string">&#x27;white&#x27;</span>, weight = <span class="string">&#x27;0&#x27;</span> &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，轮胎 */</span></span><br><span class="line">    <span class="function"><span class="title">buildTyre</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tyre = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;小号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用小号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;中号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用中号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;大号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用大号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.tyre = tyre</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，发动机 */</span></span><br><span class="line">    <span class="function"><span class="title">buildEngine</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> engine = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;小马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用小马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;中马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用中马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;大马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用大马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车装配，获得产品实例</span></span><br><span class="line"><span class="keyword">const</span> benchi1 = <span class="keyword">new</span> CarBuilder(&#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">weight</span>: <span class="string">&#x27;1600kg&#x27;</span> &#125;)</span><br><span class="line">    .buildTyre(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    .buildEngine(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(benchi1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line"><span class="comment">//   weight: &quot;1600kg&quot;</span></span><br><span class="line"><span class="comment">//   tyre: Tyre &#123;tyre: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span></span><br><span class="line"><span class="comment">//   engine: Engine &#123;engine: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这样将最终产品的创建流程使用链模式来实现，相当于将指挥者退化，指挥的过程通过链模式让用户自己实现，这样既增加了灵活性，装配过程也一目了然。如果希望扩展产品的部件，那么在建造者上增加部件实现方法，再适当修改链模式即可。</p></blockquote><p><strong>建造者模式的优点：</strong></p><ul><li>使用建造者模式可以使产品的构建流程和产品的表现分离，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节；</li><li>扩展方便，如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；</li><li>更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性；</li></ul><p><strong>建造者模式的缺点：</strong></p><ul><li>建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；</li><li>实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；</li></ul><p> <strong>建造者模式的适用场景</strong></p><ul><li>相同的方法，不同的执行顺序，产生不一样的产品时，可以采用建造者模式；</li><li>产品的组成部件类似，通过组装不同的组件获得不同产品时，可以采用建造者模式；</li></ul><p><strong>建造者模式与工厂模式</strong></p><ul><li>建造者模式和工厂模式最终都是创建一个完整的产品，但是在建造者模式中我们更关心对象创建的过程，将创建对象的方法模块化，从而更好地复用这些模块。</li><li>当然建造者模式与工厂模式也是可以组合使用的，比如建造者中一般会提供不同的部件实现，那么这里就可以使用工厂模式来提供具体的部件对象，再通过指挥者来进行装配。</li></ul><p>** 建造者模式与模版方法模式**</p><ul><li>指挥者的实现可以和模版方法模式相结合。也就是说，指挥者中部件的装配过程，可以使用模版方法模式来固定装配算法，把部件实现方法分为模板方法和基本方法，进一步提取公共代码，扩展可变部分。</li><li>是否采用模版方法模式看具体场景，如果产品的部件装配顺序很明确，但是具体的实现是未知的、灵活的，那么你可以适当考虑是否应该将算法骨架提取出来。</li></ul><h1 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a><strong>三、结构型模式</strong></h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理模式 （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。</p></blockquote><ul><li>代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。</li></ul><p><strong>实例的代码实现</strong></p><p>我们使用 JavaScript 来将上面的明星例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">var</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">ad</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">var</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">reward, ad</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            SuperStar.playAdvertisement(ad)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br></pre></td></tr></table></figure><ul><li>我们可以升级一下，比如如果明星没有档期的话，可以通过经纪人安排档期，当明星有空的时候才让明星来拍广告。这里通过 <code>Promise</code> 的方式来实现档期的安排：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">const</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">ad</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">const</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">scheduleTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;小鲜鲜有空了&#x27;</span>)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;, <span class="number">2000</span>)                        <span class="comment">// 发现明星有空了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">reward, ad</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            ProxyAssistant.scheduleTime()   <span class="comment">// 安排上了</span></span><br><span class="line">                .then(<span class="function">() =&gt;</span> SuperStar.playAdvertisement(ad))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">1000001</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没问题，我们小鲜鲜最喜欢拍广告了！</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line"><span class="comment">// 输出： 小鲜鲜有空了</span></span><br><span class="line"><span class="comment">// 输出： 纯蒸酸牛奶，味道纯纯，尽享纯蒸</span></span><br></pre></td></tr></table></figure><p>这里就简单实现了经纪人对请求的过滤，对明星档期的安排，实现了一个代理对象的基本功能。</p><p><strong>代理模式的优缺点</strong></p><p><strong>代理模式的主要优点有：</strong></p><ul><li>代理对象在访问者与目标对象之间可以起到中介和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将访问者与目标对象分离，在一定程度上降低了系统的耦合度，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则；</li><li>代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（十八线明星就别请经纪人了）</li></ul><p><strong>其他相关模式</strong></p><p>很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。</p><p><strong>代理模式与适配器模式</strong></p><p>代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：</p><ul><li>适配器模式： 主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口；</li><li>代理模式： 提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口；</li></ul><p><strong>代理模式与装饰者模式</strong></p><p>装饰者模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p><ul><li>装饰者模式： 目的是为了方便地给目标对象添加功能，也就是动态地添加功能；</li><li>代理模式： 主要目的是控制其他访问者对目标对象的访问；</li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。</p></blockquote><blockquote><p>享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。</p></blockquote><p>Fly 意为苍蝇，Flyweight 指轻蝇量级，指代对象粒度很小。</p><p><strong>代码实现</strong></p><p>首先假设考生的 ID 为奇数则考的是手动档，为偶数则考的是自动档。如果给所有考生都 new 一个驾考车，那么这个系统中就会创建了和考生数量一致的驾考车对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = <span class="keyword">new</span> ExamCar(candidateId % <span class="number">2</span>)</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 10</span></span><br></pre></td></tr></table></figure><blockquote><p>如果考生很多，那么系统中就会存在更多个驾考车对象实例，假如驾考车对象比较复杂，那么这些新建的驾考车实例就会占用大量内存。这时我们将同种类型的驾考车实例进行合并，手动档和自动档档驾考车分别引用同一个实例，就可以节约大量内存：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manualExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> autoExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = candidateId % <span class="number">2</span> ? manualExamCar : autoExamCar</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 2</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到我们使用 2 个驾考车实例就实现了刚刚 10 个驾考车实例实现的功能。这是仅有 10 个考生的情况，如果有几百上千考生，这时我们节约的内存就比较可观了，这就是享元模式要达到的目的。</p></blockquote><p><strong>享元模式的优缺点</strong></p><p><strong>享元模式的优点：</strong></p><ul><li>由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度；</li><li>外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；</li></ul><p><strong>享元模式的缺点：</strong></p><ul><li>引入了共享对象，使对象结构变得复杂；</li><li>共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；</li></ul><p><strong>享元模式的适用场景</strong></p><ul><li>如果一个程序中大量使用了相同或相似对象，那么可以考虑引入享元模式；</li><li>如果使用了大量相同或相似对象，并造成了比较大的内存开销；</li><li>对象的大多数状态可以被转变为外部状态；</li><li>剥离出对象的外部状态后，可以使用相对较少的共享对象取代大量对象；</li><li>在一些程序中，如果引入享元模式对系统的性能和内存的占用影响不大时，比如目标对象不多，或者场景比较简单，则不需要引入，以免适得其反。</li></ul><p><strong>其他相关模式</strong></p><ul><li>享元模式和单例模式、工厂模式、组合模式、策略模式、状态模式等等经常会一起使用。</li></ul><p><strong>享元模式和工厂模式、单例模式</strong></p><ul><li>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</li></ul><p> <strong>享元模式和组合模式</strong></p><ul><li>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</li></ul><p><strong>享元模式和策略模式</strong></p><blockquote><p>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p></blockquote><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>适配器模式（Adapter Pattern）又称包装器模式，将一个类（对象）的接口（方法、属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。</li><li>主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说，访问者需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已。</li></ul><p><strong>代码实现</strong></p><p>我们可以实现一下电源适配器的例子，一开始我们使用的中国插头标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chinaPlug.chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><blockquote><p>但是我们出国旅游了，到了日本，需要增加一个日本插头到中国插头的电源适配器，来将我们原来的电源线用起来：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> japanPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;日本插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">japanInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日本插头电源适配器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">japanPlugAdapter</span>(<span class="params">plug</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> plug.japanInPlug()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">japanPlugAdapter(japanPlug).chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><p><strong>适配器模式的优缺点</strong></p><p><strong>适配器模式的优点：</strong></p><ul><li>已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</li><li>可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；</li><li>灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；</li><li>适配器模式的缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。</li></ul><p><strong>适配器模式的适用场景</strong></p><ul><li>当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。</li><li>如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；</li><li>如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；</li></ul><p><strong>其他相关模式</strong></p><blockquote><p>适配器模式和代理模式、装饰者模式看起来比较类似，都是属于包装模式，也就是用一个对象来包装另一个对象的模式，他们之间的异同在代理模式中已经详细介绍了，这里再简单对比一下。</p></blockquote><p><strong>适配器模式与代理模式</strong></p><ul><li>适配器模式： 提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；</li><li>代理模式： 提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；</li></ul><p><strong>适配器模式、装饰者模式与代理模式</strong></p><ul><li>适配器模式： 功能不变，只转换了原有接口访问格式；</li><li>装饰者模式： 扩展功能，原有功能不变且可直接使用；</li><li>代理模式： 原有功能不变，但一般是经过限制访问的；</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>装饰者模式 （Decorator Pattern）又称装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能。</p></blockquote><blockquote><p>本质是功能动态组合，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。</p></blockquote><p>我们可以使用 JavaScript 来将装修房子的例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OriginHouse</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">OriginHouse.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Furniture</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Furniture.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Painting</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Painting.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> house = <span class="keyword">new</span> OriginHouse() <span class="comment">// 毛坯房</span></span><br><span class="line">house = <span class="keyword">new</span> Furniture(house) <span class="comment">// 搬入家具</span></span><br><span class="line">house = <span class="keyword">new</span> Painting(house) <span class="comment">// 墙壁刷漆</span></span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br><span class="line">使用 ES6 的 Class 语法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> house = <span class="keyword">new</span> OriginHouse()</span><br><span class="line">house = <span class="keyword">new</span> Furniture(house)</span><br><span class="line">house = <span class="keyword">new</span> Painting(house)</span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><blockquote><p>是不是感觉很麻烦，装饰个功能这么复杂？我们 JSer 大可不必走这一套面向对象花里胡哨的，毕竟 JavaScript 的优点就是灵活：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="keyword">var</span> originHouse = &#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">furniture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">painting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 搬入家具 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        furniture()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 墙壁刷漆 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        painting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">originHouse.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><p>简洁明了，且更符合前端日常使用的场景。</p><p><strong>装饰者模式的优缺点</strong></p><p><strong>装饰者模式的优点：</strong></p><ul><li>我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下动态地修饰对象，添加功能，装饰者和被装饰者之间松耦合，可维护性好；</li><li>被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；</li><li>装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；</li><li>可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；</li></ul><p><strong>装饰者模式的缺点：</strong></p><ul><li>使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；</li><li>由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐；</li></ul><p><strong>装饰者模式的适用场景</strong></p><ul><li>如果不希望系统中增加很多子类，那么可以考虑使用装饰者模式；</li><li>需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，这时采用装饰者模式可以很好实现；</li><li>当对象的功能要求可以动态地添加，也可以动态地撤销，可以考虑使用装饰者模式；</li></ul><p><strong>其他相关模式</strong> </p><p>** 装饰者模式与适配器模式**</p><blockquote><p>装饰者模式和适配器模式都是属于包装模式，然而他们的意图有些不一样：</p></blockquote><ul><li>装饰者模式： 扩展功能，原有功能还可以直接使用，一般可以给目标对象多次叠加使用多个装饰者；</li><li>适配器模式： 功能不变，但是转换了原有接口的访问格式，一般只给目标对象使用一次；</li></ul><p><strong>装饰者模式与组合模式</strong></p><p>这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰者模式看做是只有一个组件的组合模式。</p><ul><li>装饰者模式： 动态地给对象增加功能；</li><li>组合模式： 管理组合对象和叶子对象，为它们提供一致的操作接口给客户端，方便客户端的使用；</li></ul><p><strong>装饰者模式与策略模式</strong></p><p>装饰者模式和策略模式都包含有许多细粒度的功能模块，但是他们的使用思路不同：</p><ul><li>装饰者模式： 可以递归调用，使用多个功能模式，功能之间可以叠加组合使用；</li><li>策略模式： 只有一层选择，选择某一个功能；</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>外观模式 （Facade Pattern）又叫门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。</p></blockquote><p>外观模式在源码中使用很多，具体可以参考后文中源码阅读部分。</p><p><strong>简化版本的代码： 无人机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uav = &#123;</span><br><span class="line">    <span class="comment">/* 电子调速器 */</span></span><br><span class="line">    diantiao1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 电机 */</span></span><br><span class="line">    dianji1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遥控器 */</span></span><br><span class="line">    controller: &#123;</span><br><span class="line">        <span class="comment">/* 上升 */</span></span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.up()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 前进 */</span></span><br><span class="line">        <span class="function"><span class="title">forward</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 下降 */</span></span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.down()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 左转 */</span></span><br><span class="line">        <span class="function"><span class="title">left</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操纵无人机 */</span></span><br><span class="line">uav.controller.down()    <span class="comment">// 发送下降指令</span></span><br><span class="line">uav.controller.left()    <span class="comment">// 发送左转指令</span></span><br></pre></td></tr></table></figure><p>无人机系统是比较复杂，但是可以看到无人机的操纵却比较简单，正是因为有遥控器这个外观的存在。</p><p><strong>外观模式的优点：</strong></p><ul><li>访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；</li><li>减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；</li><li>通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；</li></ul><p><strong>外观模式的缺点：</strong></p><ul><li>不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；</li><li>不需要或不合理的使用外观会让人迷惑，过犹不及；</li></ul><p><strong>外观模式的适用场景</strong></p><ul><li>维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可；</li><li>你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能；</li><li>团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间；</li><li>如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>外观模式与中介者模式</strong></p><ul><li>外观模式： 封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用；</li><li>中介者模式： 封装子系统间各模块之间的直接交互，松散模块间的耦合；</li></ul><p><strong>外观模式与单例模式</strong></p><blockquote><p>有时候一个系统只需要一个外观，比如之前举的 <code>Axios</code> 的 <code>HTTP</code> 模块例子。这时我们可以将外观模式和单例模式可以一起使用，把外观实现为单例。</p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>组合模式 （Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象</p></blockquote><p><strong>你曾见过的组合模式</strong></p><p>大家电脑里的文件夹结构相比很熟悉了，文件夹下面可以有子文件夹，也可以有文件，子文件夹下面还可以有文件夹和文件，以此类推，共同组成了一个文件树，结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Folder <span class="number">1</span></span><br><span class="line">├── Folder <span class="number">2</span></span><br><span class="line">│   ├── File <span class="number">1.</span>txt</span><br><span class="line">│   ├── File <span class="number">2.</span>txt</span><br><span class="line">│   └── File <span class="number">3.</span>txt</span><br><span class="line">└── Folder <span class="number">3</span></span><br><span class="line">    ├── File <span class="number">4.</span>txt</span><br><span class="line">    ├── File <span class="number">5.</span>txt</span><br><span class="line">    └── File <span class="number">6.</span>txt</span><br></pre></td></tr></table></figure><blockquote><p>文件夹是树形结构的容器节点，容器节点可以继续包含其他容器节点，像树枝上还可以有其他树枝一样；也可以包含文件，不再增加新的层级，就像树的叶子一样处于末端，因此被称为叶节点。本文中，叶节点又称为叶对象，容器节点因为可以包含容器节点和非容器节点，又称为组合对象。</p></blockquote><p><strong>代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的文件夹例子实现一下。</p><p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">var</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(fileOrFolder)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">                child.scan(cb)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">var</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子文件夹，并放入根文件夹</span></span><br><span class="line"><span class="keyword">var</span> foldMarvelMovies = createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldMarvelMovies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldDCMovies = createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldDCMovies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个子文件夹分别添加电影</span></span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>))</span><br><span class="line"></span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line">foldMovies.scan(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + item.name + <span class="string">&#x27; size:&#x27;</span> + item.size + <span class="string">&#x27;GB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来进行改造一下，让我们添加子文件更加直观和方便。对链模式还不熟悉的同学可以看一下后面有一篇单独介绍链模式的文章～</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">const</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹  */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(...fileOrFolder)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">const</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line">  .add(</span><br><span class="line">    createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)),</span><br><span class="line">    createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码比较 JavaScript 特色，如果我们使用传统的类呢，也是可以实现的，下面使用 ES6 的 class 语法来改写一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件夹类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, children</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.children = children</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.push(...fileOrFolder)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        cb(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = <span class="keyword">new</span> Folder(<span class="string">&#x27;电影&#x27;</span>, [</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;漫威英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)]),</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;DC英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><p>在传统的语言中，为了保证叶对象和组合对象的外观一致，还会让他们实现同一个抽象类或接口。</p><p><strong>组合模式的优缺点</strong> <strong>组合模式的优点：</strong></p><ul><li>由于组合对象和叶对象具有同样的接口，因此调用的是组合对象还是叶对象对使用者来说没有区别，使得使用者面向接口编程；</li><li>如果想在组合模式的树中增加一个节点比较容易，在目标组合对象中添加即可，不会影响到其他对象，对扩展友好，符合开闭原则，利于维护；</li></ul><p><strong>组合模式的缺点：</strong></p><ul><li>增加了系统复杂度，如果树中对象不多，则不一定需要使用；</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起；</li></ul><p><strong>组合模式的适用场景</strong></p><ul><li>如果对象组织呈树形结构就可以考虑使用组合模式，特别是如果操作树中对象的方法比较类似时；</li><li>使用者希望统一对待树形结构中的对象，比如用户不想写一堆 if-else 来处理树中的节点时，可以使用组合模式；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>组合模式和职责链模式</strong></p><p>正如前文所说，组合模式是天生实现了职责链模式的。</p><ul><li>组合模式： 请求在组合对象上传递，被深度遍历到组合对象的所有子孙叶节点具体执行；</li><li>职责链模式： 实现请求的发送者和接受者之间的解耦，把多个接受者组合起来形成职责链，请求在链上传递，直到有接受者处理请求为止；</li></ul><p><strong>组合模式和迭代器模式</strong></p><p>组合模式可以结合迭代器模式一起使用，在遍历组合对象的叶节点的时候，可以使用迭代器模式来遍历。</p><p><strong>组合模式和命令模式</strong></p><blockquote><p>命令模式里有一个用法「宏命令」，宏命令就是组合模式和命令模式一起使用的结果，是组合模式组装而成</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li>桥接模式（Bridge Pattern）又称桥梁模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。</li><li>抽象部分和实现部分可能不太好理解，举个例子，香蕉、苹果、西瓜，它们共同的抽象部分就是水果，可以吃，实现部分就是不同的水果实体。再比如黑色手提包、红色钱包、蓝色公文包，它们共同的抽象部分是包和颜色，这部分的共性就可以被作为抽象提取出来。</li></ul><p><strong>实例的代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的变频洗衣机例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Washer</span>(<span class="params">motorType, rollerType, transducerType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">    <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">    <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Washer.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor.run()</span><br><span class="line">    <span class="built_in">this</span>.roller.run()</span><br><span class="line">    <span class="built_in">this</span>.transducer.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Motor</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Motor.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Roller</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Roller.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Transducer</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transducer.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建洗衣机</span></span><br><span class="line"><span class="keyword">var</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br><span class="line">由于产品部件可以独立变化，所以创建新的洗衣机产品就非常容易：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> washerD = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;中功率&#x27;</span>)</span><br><span class="line">washerD.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      中功率变频器开始工作</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到由于洗衣机的结构被分别抽象为几个部件的组合，部件的实例化是在部件类各自的构造函数中完成，因此部件之间的实例化不会相互影响，新产品的创建也变得容易，这就是桥接模式的好处。</p></blockquote><p>下面我们用 ES6 的 Class 语法实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">motorType, rollerType, transducerType</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">        <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">        <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始使用 */</span></span><br><span class="line">    <span class="function"><span class="title">work</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor.run()</span><br><span class="line">        <span class="built_in">this</span>.roller.run()</span><br><span class="line">        <span class="built_in">this</span>.transducer.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Roller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br></pre></td></tr></table></figure><ul><li>如果再精致一点，可以让电机、滚筒、变频器等部件实例继承自各自的抽象类，将面向抽象进行到底，但是桥接模式在 JavaScript 中应用不多，适当了解即可，不用太死扣。</li><li>有时候为了更复用部件，可以将部件的实例化拿出来，对于洗衣机来说一个实体部件当然不能用两次，这里使用皮包的例子：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 皮包 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 展示 */</span></span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="built_in">this</span>.color.show() + <span class="built_in">this</span>.type.show()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.typeType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.typeType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包颜色 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colorType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.colorType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象实例化 */</span></span><br><span class="line"><span class="keyword">const</span> redColor = <span class="keyword">new</span> Color(<span class="string">&#x27;红色&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> walletType = <span class="keyword">new</span> Type(<span class="string">&#x27;钱包&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> briefcaseType = <span class="keyword">new</span> Type(<span class="string">&#x27;公文包&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagA = <span class="keyword">new</span> Bag(walletType, redColor)</span><br><span class="line">bagA.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色钱包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagB = <span class="keyword">new</span> Bag(briefcaseType, redColor)</span><br><span class="line">bagB.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色公文包</span></span><br></pre></td></tr></table></figure><h1 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a><strong>四、行为型模式</strong></h1><p>暂时搞不懂，后续理解</p><h1 id="五、其他模式"><a href="#五、其他模式" class="headerlink" title="五、其他模式"></a><strong>五、其他模式</strong></h1><h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><blockquote><p>在下文中，如果某些内容和你看的某本书或者某个帖子上的不一样，不要惊慌，多看几本书，多打开几个帖子，你会发现每个都不一样，所以模式具体是如何表现并不重要，重要的是，了解这三个模式主要的目的和思想是什么：</p></blockquote><ul><li><code>MVC</code> 模式： 从大锅烩时代进化，引入了分层的概念，但是层与层之间耦合明显，维护起来不容易；</li><li><code>MVP</code> 模式： 在 MVC 基础上进一步解耦，视图层和模型层完全隔离，交互只能通过管理层来进行，问题是更新视图需要管理层手动来进行；</li><li><code>MVVM</code> 模式： 引入双向绑定机制，帮助实现一些更新视图层和模型层的工作，让开发者可以更专注于业务逻辑，相比于之前的模式，可以使用更少的代码量完成更复杂的交互； MVC、MVP、MVVM 模式是我们经常遇到的概念，其中 MVVM 是最常用到的，在实际项目中往往没有严格按照模式的定义来设计的系统，开发中也不一定要纠结自己用的到底是哪个模式，合适的才是最好的。</li></ul><h3 id="1-MVC-（Model-View-Controller）"><a href="#1-MVC-（Model-View-Controller）" class="headerlink" title="1. MVC （Model View Controller）"></a><strong>1. MVC （Model View Controller）</strong></h3><blockquote><p><code>MVC</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、控制器（<code>Controller</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 业务数据的处理和存储，数据更新后更新；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Controller</code> 控制器层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，接受并处理 <code>View</code> 层触发的事件，并在 <code>Model</code> 层的数据状态变动时更新 <code>View</code> 层；</li><li><code>MVC</code> 模式的目的是通过引入 <code>Controller</code> 层来将 <code>Model</code> 层和 <code>View</code> 层分离，分层的引入是原来大锅烩方式的改进，使得系统在可维护性和可读性上有了进步。</li><li><code>MVC</code> 模式提出已经有四十余年，<code>MVC</code> 模式在各个书、各个教程、<code>WIKI</code> 的解释有各种版本，甚至 <code>MVC</code> 模式在不同系统中的具体表现也不同，这里只介绍典型 <code>MVC</code> 模式的思路。</li></ul><blockquote><p>典型思路是 <code>View</code> 层通过事件通知到 <code>Controller</code> 层，<code>Controller</code> 层经过对事件的处理完成相关业务逻辑，要求 <code>Model</code> 层改变数据状态，<code>Model</code> 层再将新数据更新到 <code>View</code>层。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，以通过事件通知 <code>Controller</code> 层，经过处理后修改 <code>Model</code> 层的数据，<code>Model</code> 层使用最新数据更新 <code>View</code>。</p><p>用户也可以直接触发 <code>Controller</code> 去更新 <code>Model</code> 层状态，再更新 View 层</p><p>某些场景下，<code>View</code> 层直接采用观察者/发布订阅模式监听 <code>Model</code> 层的变化，这样 <code>View</code>层和 <code>Model</code> 层相互持有、相互操作，导致紧密耦合，在可维护性上有待提升。由此，<code>MVP</code> 模式应运而生 。</p><h3 id="2-MVP-（Model-View-Presenter）"><a href="#2-MVP-（Model-View-Presenter）" class="headerlink" title="2. MVP （Model View Presenter）"></a><strong>2. MVP （Model View Presenter）</strong></h3><blockquote><p><code>MVP</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、管理层（<code>Presenter</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 只负责存储数据，与 <code>View</code> 呈现无关，也与 <code>UI</code> 处理逻辑无关，发生更新也不用主动通知 <code>View</code>；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Presenter</code> 管理层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，处理 <code>View</code> 层的事件，负责获取数据并将获取的数据经过处理后更新 <code>View</code>；</li><li><code>MVC</code> 模式的 <code>View</code> 层和 <code>Model</code> 层存在耦合，为了解决这个问题，<code>MVP</code> 模式将 <code>View</code> 层和 <code>Model</code> 层解耦，之间的交互只能通过 <code>Presenter</code> 层，实际上，<code>MVP</code> 模式的目的就是将 <code>View</code> 层和 Model 层完全解耦，使得对 <code>View</code> 层的修改不会影响到 <code>Model</code> 层，而对 <code>Model</code> 层的数据改动也不会影响到<code>View</code> 层。</li></ul><blockquote><p>典型流程是 <code>View</code> 层触发的事件传递到 <code>Presenter</code> 层中处理，<code>Presenter</code> 层去操作 <code>Model</code> 层，并且将数据返回给 <code>View</code>层，这个过程中，<code>View</code> 层和 <code>Model</code> 层没有直接联系。而 <code>View</code> 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 <code>Presenter</code> 层来更新自己，被称为「被动视图」。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，<code>View</code> 层通知 <code>Presenter</code> 层，<code>Presenter</code> 层操作 <code>Model</code> 层的数据，<code>Presenter</code> 层获取到数据之后更新 <code>View</code>。</p><ul><li>由于 <code>Presenter</code> 层负责了数据获取、数据处理、交互逻辑、<code>UI</code> 效果等等功能，所以 <code>Presenter</code> 层就变得强大起来，相应的，<code>Model</code> 层只负责数据存储，而 <code>View</code> 层只负责视图，<code>Model</code> 和 <code>View</code> 层的责任纯粹而单一，如果我们需要添加或修改功能模块，只需要修改 <code>Presenter</code> 层就够了。由于 <code>Presenter</code> 层需要调用 <code>View</code> 层的方法更新视图，<code>Presenter</code> 层直接持有 <code>View</code> 层导致了 <code>Presenter</code> 对 <code>View</code> 的依赖。</li></ul><blockquote><p>正如上所说，更新视图需要 <code>Presenter</code> 层直接持有 <code>View</code> 层，并通过调用 <code>View</code> 层中的方法来实现，还是需要一系列复杂操作，有没有什么机制自动去更新视图而不用我们手动去更新呢，所以，<code>MVVM</code> 模式应运而生。</p></blockquote><h3 id="3-MVVM-（Model-View-ViewModel）"><a href="#3-MVVM-（Model-View-ViewModel）" class="headerlink" title="3. MVVM （Model View ViewModel）"></a><strong>3. MVVM （Model View ViewModel）</strong></h3><blockquote><p><code>MVVM</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、视图模型（<code>View-Model</code>）。</p></blockquote><p>和 <code>MVP</code> 模式类似，<code>Model</code> 层和 <code>View</code> 层也被隔离开，彻底解耦，<code>ViewModel</code> 层相当于 <code>Presenter</code> 层，负责绑定 <code>Model</code> 层和 <code>View</code> 层，相比于 <code>MVP</code> 增加了双向绑定机制。</p><blockquote><p><code>MVVM</code> 模式的特征是 <code>ViewModel</code> 层和 <code>View</code> 层采用双向绑定的形式（Binding），<code>View</code> 层的变动，将自动反映在 <code>ViewModel</code> 层，反之亦然。</p></blockquote><ul><li>但是双向绑定给调试和错误定位带来困难，<code>View</code> 层的异常可能是 <code>View</code> 的代码有问题，也有可能是 <code>Model</code> 层的问题。数据绑定使得一个位置的 <code>Bug</code> 被传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li><li>对简单<code>UI</code> 来说，实现 <code>MVVM</code> 模式的开销是不必要的，而对于大型应用来说，引入 MVVM 模式则会节约大量手动更新视图的复杂过程，是否使用，还是看使用场景。</li></ul><p>这是为什么呢，因为 <code>MVVM</code> 模式要求 <code>Model</code> 层和 <code>View</code> 层完全解耦，但是由于 <code>Vue</code> 还提供了 <code>ref</code> 这样的 <code>API</code>，使得 <code>Model</code> 也可以直接持有 <code>View</code>：</p><p>但是大多数帖子都说直接称呼 <code>Vue</code> 为 <code>MVVM</code> 框架，可见这些模式的划分也不是那么严格。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见设计模式&quot;&gt;&lt;a href=&quot;#常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式&quot;&gt;&lt;/a&gt;常见设计模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#1-为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要学习设计模式？&quot;&gt;&lt;/a&gt;1.为什么要学习设计模式？&lt;/h2&gt;&lt;p&gt;在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。&lt;/p&gt;
&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;2-什么是设计模式。&quot;&gt;&lt;a href=&quot;#2-什么是设计模式。&quot; class=&quot;headerlink&quot; title=&quot;2.什么是设计模式。&quot;&gt;&lt;/a&gt;2.什么是设计模式。&lt;/h2&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;h2 id=&quot;3-设计模式的发展历史&quot;&gt;&lt;a href=&quot;#3-设计模式的发展历史&quot; class=&quot;headerlink&quot; title=&quot;3.设计模式的发展历史&quot;&gt;&lt;/a&gt;3.设计模式的发展历史&lt;/h2&gt;&lt;p&gt;设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。&lt;/p&gt;
&lt;p&gt;四人帮把这本书分成两部分：&lt;/p&gt;
&lt;p&gt;第一部分解释面向对象编程的优缺点。&lt;/p&gt;
&lt;p&gt;第二部分是关于 23 个经典设计模式的演变。&lt;/p&gt;
&lt;p&gt;自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。&lt;/p&gt;
&lt;h2 id=&quot;4-设计模式分类&quot;&gt;&lt;a href=&quot;#4-设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;4.设计模式分类&quot;&gt;&lt;/a&gt;4.设计模式分类&lt;/h2&gt;&lt;p&gt;根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来将概述属于这三种类型的 23 种设计模式的主要概念。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Weppack面试题整理</title>
    <link href="https://hxy1997.xyz/2020/10/20/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2020/10/20/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2021-03-12T02:09:49.508Z</updated>
    
    <content type="html"><![CDATA[<p>这一块知识是我的盲区（话说我的盲区也太多了吧，根本就是眼瞎😭）直接复制人家整理好的吧 <a href="https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打Webpack面试题</a>，感觉自己啥也不会，就知道它是用来打包的工具</p><span id="more"></span><p>本文已收录在<code>Github</code> <a href="https://github.com/Geekhyt/front-end-canteen/">github.com/Geekhyt</a>，欢迎Star。</p><p>从头发的浓密程度和干练的走路姿势我察觉到，面前坐着的这位面试官也是一把好手。我像以往一样，准备花3分钟的时间进行自我介绍。在此期间，我的目光被16寸的MacBook Pro所吸引，这次的自我介绍我做足了准备，很有信心征服面试官。不出我所料，面试官被我引入了我擅长的领域。</p><blockquote><p>❝</p><p>看来你对Webpack很熟悉，那我来考考你</p><p>❞</p></blockquote><h1 id="0-有哪些常见的Loader？你用过哪些Loader？"><a href="#0-有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="0.有哪些常见的Loader？你用过哪些Loader？"></a>0.有哪些常见的Loader？你用过哪些Loader？</h1><p>(我开始熟悉的报起了菜名)</p><ul><li><code>raw-loader</code>：加载文件原始内容（utf-8）</li><li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li><li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li><li><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</li><li><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</li><li><code>image-loader</code>：加载并且压缩图片文件</li><li><code>json-loader</code> 加载 JSON 文件（默认包含）</li><li><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</li><li><code>babel-loader</code>：把 ES6 转换成 ES5</li><li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li><li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li><li><code>sass-loader</code>：将SCSS/SASS代码转换成CSS</li><li><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</li><li><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li><li><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</li><li><code>mocha-loader</code>：加载 Mocha 测试用例的代码</li><li><code>coverjs-loader</code>：计算测试的覆盖率</li><li><code>vue-loader</code>：加载 Vue.js 单文件组件</li><li><code>i18n-loader</code>: 国际化</li><li><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ul><p>更多 Loader 请参考<a href="https://webpack.docschina.org/loaders/">官网</a></p><p>(面试官：挺好，知道的还挺多)</p><h1 id="1-有哪些常见的Plugin？你用过哪些Plugin？"><a href="#1-有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="1.有哪些常见的Plugin？你用过哪些Plugin？"></a>1.有哪些常见的Plugin？你用过哪些Plugin？</h1><p>(这大兄弟好像听上瘾了，继续开启常规操作)</p><ul><li><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li><code>ignore-plugin</code>：忽略部分文件</li><li><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</li><li><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li><li><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</li><li><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</li><li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li><li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</li><li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</li><li><code>clean-webpack-plugin</code>: 目录清理</li><li><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</li><li><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li><li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li></ul><p>更多 Plugin 请参考<a href="https://webpack.docschina.org/plugins/">官网</a></p><p>(Double Kill)</p><h1 id="2-那你再说一说Loader和Plugin的区别？"><a href="#2-那你再说一说Loader和Plugin的区别？" class="headerlink" title="2.那你再说一说Loader和Plugin的区别？"></a>2.那你再说一说Loader和Plugin的区别？</h1><p>(就知道你会问这个，我用手掩盖着嘴角的微笑)</p><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h1 id="3-Webpack构建流程简单说一下"><a href="#3-Webpack构建流程简单说一下" class="headerlink" title="3.Webpack构建流程简单说一下"></a>3.Webpack构建流程简单说一下</h1><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li><li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><p>简单说</p><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li><li>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><p>对源码感兴趣的同学可以移步我的另一篇专栏<a href="https://juejin.im/post/6844904046294204429">从源码窥探Webpack4.x原理</a></p><h1 id="4-使用webpack开发时，你用过哪些可以提高效率的插件？"><a href="#4-使用webpack开发时，你用过哪些可以提高效率的插件？" class="headerlink" title="4.使用webpack开发时，你用过哪些可以提高效率的插件？"></a>4.使用webpack开发时，你用过哪些可以提高效率的插件？</h1><p>(这道题还蛮注重实际，用户的体验还是要从小抓起的)</p><ul><li><code>webpack-dashboard</code>：可以更友好的展示相关打包信息。</li><li><code>webpack-merge</code>：提取公共配置，减少重复配置代码</li><li><code>speed-measure-webpack-plugin</code>：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li><code>size-plugin</code>：监控资源体积变化，尽早发现问题</li><li><code>HotModuleReplacementPlugin</code>：模块热替换</li></ul><h1 id="5-source-map是什么？生产环境怎么用？"><a href="#5-source-map是什么？生产环境怎么用？" class="headerlink" title="5.source map是什么？生产环境怎么用？"></a>5.source map是什么？生产环境怎么用？</h1><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p><p>map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li><li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h1 id="6-模块打包原理知道吗？"><a href="#6-模块打包原理知道吗？" class="headerlink" title="6.模块打包原理知道吗？"></a>6.模块打包原理知道吗？</h1><p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p><h1 id="7-文件监听原理呢？"><a href="#7-文件监听原理呢？" class="headerlink" title="7.文件监听原理呢？"></a>7.文件监听原理呢？</h1><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p><p>Webpack开启监听模式，有两种方式：</p><ul><li>启动 webpack 命令时，带上 –watch 参数</li><li>在配置 webpack.config.js 中设置 watch:true</li></ul><p>缺点：每次需要手动刷新浏览器</p><p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <code>aggregateTimeout</code> 后再执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.export &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认false,也就是不开启</span><br><span class="line">    watch: true,</span><br><span class="line">    &#x2F;&#x2F; 只有开启监听模式时，watchOptions才有意义</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为空，不监听的文件或者文件夹，支持正则匹配</span><br><span class="line">        ignored: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 监听到变化发生后会等300ms再去执行，默认300ms</span><br><span class="line">        aggregateTimeout:300,</span><br><span class="line">        &#x2F;&#x2F; 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次</span><br><span class="line">        poll:1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-说一下-Webpack-的热更新原理吧"><a href="#8-说一下-Webpack-的热更新原理吧" class="headerlink" title="8.说一下 Webpack 的热更新原理吧"></a>8.说一下 Webpack 的热更新原理吧</h1><p>(敲黑板，这道题必考)</p><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><p>细节请参考<a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></p><p>(面试官：不错不错，小伙子表达能力不错)</p><p>(基操，勿6)</p><h1 id="9-如何对bundle体积进行监控和分析？"><a href="#9-如何对bundle体积进行监控和分析？" class="headerlink" title="9.如何对bundle体积进行监控和分析？"></a>9.如何对bundle体积进行监控和分析？</h1><p><code>VSCode</code> 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，还可以使用 <code>webpack-bundle-analyzer</code> 生成 <code>bundle</code> 的模块组成图，显示所占体积。</p><p><code>bundlesize</code> 工具包可以进行自动化资源体积监控。</p><h1 id="10-文件指纹是什么？怎么用？"><a href="#10-文件指纹是什么？怎么用？" class="headerlink" title="10.文件指纹是什么？怎么用？"></a>10.文件指纹是什么？怎么用？</h1><p>文件指纹是打包后输出的文件名的后缀。</p><ul><li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</li><li><code>Chunkhash</code>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</li><li><code>Contenthash</code>：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</li></ul><h2 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h2><p>设置 output 的 filename，用 chunkhash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;scr&#x2F;app.js&#39;,</span><br><span class="line">        search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;[name][chunkhash:8].js&#39;,</span><br><span class="line">        path:__dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h2><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;scr&#x2F;app.js&#39;,</span><br><span class="line">        search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;[name][chunkhash:8].js&#39;,</span><br><span class="line">        path:__dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#96;[name][contenthash:8].css&#96;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h2><p>设置file-loader的name，使用hash。</p><p>占位符名称及含义</p><ul><li>ext 资源后缀名</li><li>name 文件名称</li><li>path 文件的相对路径</li><li>folder 文件所在的文件夹</li><li>contenthash 文件的内容hash，默认是md5生成</li><li>hash 文件内容的hash，默认是md5生成</li><li>emoji 一个随机的指代文件内容的emoj</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename:&#39;bundle.js&#39;,</span><br><span class="line">        path:path.resolve(__dirname, &#39;dist&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:&#x2F;\.(png|svg|jpg|gif)$&#x2F;,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:&#39;file-loader&#39;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    name:&#39;img&#x2F;[name][hash:8].[ext]&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"><a href="#11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？" class="headerlink" title="11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"></a>11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？</h1><p>可以使用 <code>enforce</code> 强制执行 <code>loader</code> 的作用顺序，<code>pre</code> 代表在所有正常 loader 之前执行，<code>post</code> 是所有 loader 之后执行。(inline 官方不推荐使用)</p><h1 id="12-如何优化-Webpack-的构建速度？"><a href="#12-如何优化-Webpack-的构建速度？" class="headerlink" title="12.如何优化 Webpack 的构建速度？"></a>12.如何优化 Webpack 的构建速度？</h1><p>(这个问题就像能不能说一说<strong>「从URL输入到页面显示发生了什么」</strong>一样）</p><p>(我只想说：您希望我讲多长时间呢？)</p><p>(面试官：。。。)</p><ul><li>使用<code>高版本</code>的 Webpack 和 Node.js</li><li><code>多进程/多实例构建</code>：HappyPack(不维护了)、thread-loader</li><li><code>压缩代码</code><ul><li>多进程并行压缩<ul><li>webpack-paralle-uglify-plugin</li><li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li><li>terser-webpack-plugin 开启 parallel 参数</li></ul></li><li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li></ul></li><li><code>图片压缩</code><ul><li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li><li>配置 image-webpack-loader</li></ul></li><li><code>缩小打包作用域</code>：<ul><li>exclude/include (确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li>IgnorePlugin (完全排除模块)</li><li>合理使用alias</li></ul></li><li><code>提取页面公共资源</code>：<ul><li>基础包分离：<ul><li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li><li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</li></ul></li></ul></li><li><code>DLL</code>：<ul><li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li><li>HashedModuleIdsPlugin 可以解决模块数字id问题</li></ul></li><li><code>充分利用缓存提升二次构建速度</code>：<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li><code>Tree shaking</code><ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul><li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li></ul></li></ul></li><li><code>Scope hoisting</code><ul><li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li><li>必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li></ul></li><li><code>动态Polyfill</code><ul><li>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li></ul></li></ul><p>更多优化请参考<a href="https://www.webpackjs.com/guides/build-performance/">官网-构建性能</a></p><h1 id="13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"><a href="#13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？" class="headerlink" title="13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"></a>13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？</h1><p>代码分割的本质其实就是在<code>源代码直接上线</code>和<code>打包成唯一脚本main.bundle.js</code>这两种极端方案之间的一种更适合实际场景的中间状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阿卡丽：荣耀剑下取，均衡乱中求</span><br></pre></td></tr></table></figure><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><p>(Easy peezy right)</p><h1 id="14-是否写过Loader？简单描述一下编写loader的思路？"><a href="#14-是否写过Loader？简单描述一下编写loader的思路？" class="headerlink" title="14.是否写过Loader？简单描述一下编写loader的思路？"></a>14.是否写过Loader？简单描述一下编写loader的思路？</h1><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><p><a href="https://www.webpackjs.com/api/loaders/">Loader的API</a> 可以去官网查阅</p><ul><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<ul><li>Npm link</li><li>ResolveLoader</li></ul></li></ul><h1 id="15-是否写过Plugin？简单描述一下编写Plugin的思路？"><a href="#15-是否写过Plugin？简单描述一下编写Plugin的思路？" class="headerlink" title="15.是否写过Plugin？简单描述一下编写Plugin的思路？"></a>15.是否写过Plugin？简单描述一下编写Plugin的思路？</h1><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><p><a href="https://www.webpackjs.com/api/plugins/">Plugin的API</a> 可以去官网查阅</p><ul><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>找出合适的事件点去完成想要的功能<ul><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</li><li>watch-run 当依赖的文件发生变化时会触发</li></ul></li><li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li></ul><h1 id="16-聊一聊Babel原理吧"><a href="#16-聊一聊Babel原理吧" class="headerlink" title="16.聊一聊Babel原理吧"></a>16.聊一聊Babel原理吧</h1><p>大多数JavaScript Parser遵循 <code>estree</code> 规范，Babel 最初基于 <code>acorn</code> 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p><ul><li>解析：将代码转换成 AST<ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ul><li><a href="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15">Taro</a>就是利用 babel 完成的小程序语法转换</li></ul></li><li>生成：以新的 AST 为基础生成代码</li></ul><p>想了解如何一步一步实现一个编译器的同学可以移步 Babel 官网曾经推荐的开源项目 <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">the-super-tiny-compiler</a></p><blockquote><p>❝</p><p>面试官：(我听的口渴了，咱们休息一会，一会进行下半场)</p><p>❞</p></blockquote><p>面试官拿起旁边已经凉透的龙井，喝了一口。</p><p>(这小伙子有点东西)</p><p><strong>「持续更新……」</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>深入浅出 Webpack</li><li>Webpack 实战</li><li>玩转 Webpack</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一块知识是我的盲区（话说我的盲区也太多了吧，根本就是眼瞎😭）直接复制人家整理好的吧 &lt;a href=&quot;https://juejin.cn/post/6844904094281236487&quot;&gt;「吐血整理」再来一打Webpack面试题&lt;/a&gt;，感觉自己啥也不会，就知道它是用来打包的工具&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Weppack" scheme="https://hxy1997.xyz/tags/Weppack/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="打包" scheme="https://hxy1997.xyz/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js函数手写</title>
    <link href="https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/"/>
    <id>https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2021-03-12T02:22:23.176Z</updated>
    
    <content type="html"><![CDATA[<p>手写常见js函数，面试必备，多练几遍，争取手撕</p><span id="more"></span><h1 id="1-手动实现call-apply-bind"><a href="#1-手动实现call-apply-bind" class="headerlink" title="1.手动实现call,apply,bind"></a>1.手动实现call,apply,bind</h1><h2 id="模拟实现call"><a href="#模拟实现call" class="headerlink" title="模拟实现call"></a>模拟实现call</h2><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>r5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除Symbol，防止内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h2><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>获取函数中的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    fn(...args);</span><br><span class="line">    fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以广泛应用于异步编程，它可以代替我们传统的回调函数</li><li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li><li>取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。</li><li>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</li></ul><h2 id="Nodejs的EventEmitter"><a href="#Nodejs的EventEmitter" class="headerlink" title="Nodejs的EventEmitter"></a>Nodejs的EventEmitter</h2><p><code>Nodejs</code>的<code>EventEmitter</code>就是观察者模式的典型实现，<code>Nodejs</code>的<code>events</code>模块只提供了一个对象： <code>events.EventEmitter``。EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。</p><blockquote><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p></blockquote><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p><strong>addListener(event, listener)</strong></p><p>为指定事件添加一个监听器，默认添加到监听器数组的尾部。</p><p><strong>removeListener(event, listener)</strong></p><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><p><strong>setMaxListeners(n)</strong></p><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p><p><strong>once(event, listener)</strong></p><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p><p><strong>emit(event, [arg1], [arg2], […])</strong></p><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，调用一次，处理函数为 listener2</span></span><br><span class="line">eventEmitter.once(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="手动实现EventEmitter"><a href="#手动实现EventEmitter" class="headerlink" title="手动实现EventEmitter"></a>手动实现EventEmitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件</span></span><br><span class="line"><span class="comment">// prepend为true表示向事件队列头部添加事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, prepend</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].unshift(listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type] = [listener];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某个事件</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>._events[type]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type] = <span class="built_in">this</span>._events[type].filter(<span class="function"><span class="params">e</span> =&gt;</span> e !== listener &amp;&amp; e.origin !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件，只执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> only = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="built_in">this</span>.addListener(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某类事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大事件监听个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.maxListeners = count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceListener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我只能被执行一次&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我是一个listener&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">&#x27;click&#x27;</span>, onceListener);</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">emitter.removeListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JavaScript自定义事件"><a href="#JavaScript自定义事件" class="headerlink" title="JavaScript自定义事件"></a>JavaScript自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建事件</span></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;myEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册事件监听器</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;myEvent&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、触发事件</span></span><br><span class="line">elem.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><h1 id="3-防抖-debounce"><a href="#3-防抖-debounce" class="headerlink" title="3.防抖(debounce)"></a>3.防抖(debounce)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><blockquote><p>按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</p></blockquote><h1 id="4-节流-throttle"><a href="#4-节流-throttle" class="headerlink" title="4.节流(throttle)"></a>4.节流(throttle)</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><blockquote><ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器<code>resize</code></li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul></blockquote><h1 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="简单版："><a href="#简单版：" class="headerlink" title="简单版："></a>简单版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a><strong>局限性：</strong></h3><ul><li>他无法实现对函数 、RegExp等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用,会报错</li></ul><h3 id="面试版-递归"><a href="#面试版-递归" class="headerlink" title="面试版:递归"></a>面试版:递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">let res </span><br><span class="line">&#x2F;&#x2F; 判断是否是简单数据类型</span><br><span class="line">if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">&#x2F;&#x2F; 复杂数据类型</span><br><span class="line">res &#x3D; object.constructor &#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">res[i] &#x3D; typeof obj[i] &#x3D;&#x3D; &quot;object&quot; ? deepCopy(obj[i]) : obj[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 简单数据类型 直接 &#x3D;&#x3D; 赋值</span><br><span class="line">res &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-数组去重、扁平、最值"><a href="#6-数组去重、扁平、最值" class="headerlink" title="6.数组去重、扁平、最值"></a>6.数组去重、扁平、最值</h1><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique (array) &#123;</span><br><span class="line">    let container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-filter"><a href="#indexOf-filter" class="headerlink" title="indexOf + filter"></a>indexOf + filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return  [...new Set(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>递归调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用reduce简化"><a href="#使用reduce简化" class="headerlink" title="使用reduce简化"></a>使用reduce简化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(</span><br><span class="line">        (target, current) =&gt; <span class="built_in">Array</span>.isArray(current) ? target.concat(flatten(current)) : target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_flat = arr.flat(<span class="literal">Infinity</span>);</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ary &#x3D; arr.toSting()).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;).split(&#39;,&#39;);</span><br></pre></td></tr></table></figure><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n));</span><br></pre></td></tr></table></figure><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null, array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">        target.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="7-数组乱序-洗牌算法"><a href="#7-数组乱序-洗牌算法" class="headerlink" title="7.数组乱序-洗牌算法"></a>7.数组乱序-洗牌算法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disorder</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> current = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> random;</span><br><span class="line">    <span class="keyword">while</span> (current &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">        [array[current], array[random]] = [array[random], array[current]];</span><br><span class="line">        current--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-函数柯里化"><a href="#8-函数柯里化" class="headerlink" title="8.函数柯里化"></a>8.函数柯里化</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args &#x3D; []) &#123;</span><br><span class="line">    let length &#x3D; fn.length;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        newArgs &#x3D; args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">        if (newArgs.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function multiFn(a, b, c) &#123;</span><br><span class="line">    return a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var multi &#x3D; curry(multiFn);</span><br><span class="line"></span><br><span class="line">multi(2)(3)(4);</span><br><span class="line">multi(2,3,4);</span><br><span class="line">multi(2)(3,4);</span><br><span class="line">multi(2,3)(4)</span><br></pre></td></tr></table></figure><h3 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const curry &#x3D; (fn, arr &#x3D; []) &#x3D;&gt; (...args) &#x3D;&gt; (</span><br><span class="line">  arg &#x3D;&gt; arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, arg)</span><br><span class="line">)([...arr, ...args])</span><br><span class="line"></span><br><span class="line">let curryTest&#x3D;curry((a,b,c,d) &#x3D;&gt; a + b + c + d)</span><br><span class="line">curryTest(1,2,3)(4) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(4)(3) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(3,4) &#x2F;&#x2F; 返回10</span><br></pre></td></tr></table></figure><h3 id="简单写法版"><a href="#简单写法版" class="headerlink" title="简单写法版"></a>简单写法版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, ...args) &#123;</span><br><span class="line">    if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span><br><span class="line">    return fn(...args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回currying函数</span><br><span class="line">    return (...args2) &#x3D;&gt; currying(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-手动实现JSONP"><a href="#9-手动实现JSONP" class="headerlink" title="9.手动实现JSONP"></a>9.手动实现JSONP</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p><ul><li>1.将传入的data数据转化为url字符串形式</li><li>2.处理url中的回调函数</li><li>3.创建一个script标签并插入到页面中</li><li>4.挂载回调函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp &#x3D; function (url, data, callback) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        &#x2F;&#x2F; 例子&#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">        var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">        &#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">        dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.$jsonp &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用script属性</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">&#x27;http://xxx&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="10-模拟实现promise"><a href="#10-模拟实现promise" class="headerlink" title="10.模拟实现promise"></a>10.模拟实现promise</h1><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="11-手动实现ES5继承"><a href="#11-手动实现ES5继承" class="headerlink" title="11.手动实现ES5继承"></a>11.手动实现ES5继承</h1><p>Child继承Parent</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote><p>子类的原型指向父类。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p><h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><blockquote><p>在子类构造函数中调用父类构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>使用构造继承继承父类参数，使用原型继承继承父类函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><blockquote><p>将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure><h2 id="寄生组合继承优化"><a href="#寄生组合继承优化" class="headerlink" title="寄生组合继承优化"></a>寄生组合继承优化</h2><p>父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>最推荐的一种方式，接近完美的继承。</p><h1 id="12-手动实现instanceof"><a href="#12-手动实现instanceof" class="headerlink" title="12.手动实现instanceof"></a>12.手动实现instanceof</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>按照target原型链的向上查找，直到找到 origin 或 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = target.__proto__;</span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.prototype == proto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myInstanceof(proto, origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改用循环而不是递归  </p><pre><code>// target instanceof origin// 变量origin的原型 存在于变量target的原型链上function myInstanceof(target, origin)&#123;        // 验证如果为基本数据类型，就直接返回false    const baseType = [&#39;string&#39;, &#39;number&#39;,&#39;boolean&#39;,&#39;undefined&#39;,&#39;symbol&#39;]    if(baseType.includes(typeof(target))) return false;    let oP  = origin.prototype;  // 取 origin 的显示原型    proto = target.__proto__;       // 取 target 的隐式原型    while(true)&#123;           // 无线循环的写法（也可以使 for(;;) ）        if(proto === null)&#123;    // 找到最顶层            return false;        &#125;        if(proto === oP)&#123;       // 严格相等            return true;        &#125;        proto = proto.__proto__;  //没找到继续向上一层原型链查找    &#125;&#125;</code></pre><h1 id="13-基于Promise的ajax封装"><a href="#13-基于Promise的ajax封装" class="headerlink" title="13.基于Promise的ajax封装"></a>13.基于Promise的ajax封装</h1><p>基于把原生<code>ajax</code>封装为<code>Promise</code>形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">const</span> paramString = getStringParam(param);</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;get&#x27;</span> &amp;&amp; paramString) &#123;</span><br><span class="line">        url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? url += paramString : url += <span class="string">`?<span class="subst">$&#123;paramString&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = &#123;</span><br><span class="line">                status: xhr.status,</span><br><span class="line">                statusText: xhr.statusText,</span><br><span class="line">                headers: xhr.getAllResponseHeaders(),</span><br><span class="line">                data: xhr.response || xhr.responseText</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="comment">// 跨域携带cookie</span></span><br><span class="line">        xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求出错&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.timeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求超时&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求被终止&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        xhr.send(paramString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringParam</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> param) &#123;</span><br><span class="line">    dataString += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;param[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-单例模式"><a href="#14-单例模式" class="headerlink" title="14.单例模式"></a>14.单例模式</h1><p>在合适的时候才创建对像，并且只创建唯一的一个。创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。使用闭包实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Singleton (name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Single.getInstance &#x3D; (function(name) &#123;</span><br><span class="line">let instance;</span><br><span class="line">return function(name) &#123;</span><br><span class="line">if (!instance) &#123;</span><br><span class="line">instance &#x3D; new Singleton(name);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a &#x3D; Singleton.getInstance(&#39;ConardLi&#39;);</span><br><span class="line">var b &#x3D; Singleton.getInstance(&#39;ConardLi2&#39;);</span><br><span class="line"></span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><blockquote><p>另一种实现方式，核心要点: 用闭包和Proxy属性拦截</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">      <span class="title">constructor</span> (<span class="params">target, args</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="built_in">Reflect</span>.constructor(fun, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-异步循环打印"><a href="#15-异步循环打印" class="headerlink" title="15.异步循环打印"></a>15.异步循环打印</h1><p>使用<code>promise + async await</code>实现异步循环打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(i);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><h1 id="16-图片懒加载"><a href="#16-图片懒加载" class="headerlink" title="16.图片懒加载"></a>16.图片懒加载</h1><h2 id="监听图片高度"><a href="#监听图片高度" class="headerlink" title="监听图片高度"></a>监听图片高度</h2><p>图片，用一个其他属性存储真正的图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="built_in">window</span>.innerHeight; <span class="comment">//可见区域高度</span></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; img.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">        <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><blockquote><p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">    <span class="keyword">let</span> lazyImageObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> lazyImage = entry.target;</span><br><span class="line">            <span class="comment">// 如果元素可见            </span></span><br><span class="line">            <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyImage.getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                    lazyImage.src = lazyImage.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; img.length; i++) &#123;</span><br><span class="line">        lazyImageObserver.observe(img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-模拟Object-create"><a href="#17-模拟Object-create" class="headerlink" title="17.模拟Object.create"></a>17.模拟Object.create</h1><blockquote><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-实现一个JSON-stringify"><a href="#18-实现一个JSON-stringify" class="headerlink" title="18.实现一个JSON.stringify"></a>18.实现一个JSON.stringify</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是字符串 undefined 和 function 类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">            obj = <span class="string">&#x27;&quot;&#x27;</span> + obj + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// JSON为空数组</span></span><br><span class="line">        <span class="keyword">let</span> json = []</span><br><span class="line">        <span class="comment">// 是否为数组</span></span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">let</span> v = obj[k];</span><br><span class="line">            <span class="keyword">let</span> type = <span class="keyword">typeof</span> v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">                v = <span class="string">&#x27;&quot;&#x27;</span> + v + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                v = jsonStringify(v);</span><br><span class="line">            &#125;</span><br><span class="line">            json.push((arr ? <span class="string">&quot;&quot;</span> : <span class="string">&#x27;&quot;&#x27;</span> + k + <span class="string">&#x27;&quot;:&#x27;</span>) + <span class="built_in">String</span>(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonStringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;) <span class="comment">// &quot;&#123;&quot;x&quot;:5&#125;&quot;</span></span><br><span class="line">jsonStringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]) <span class="comment">// &quot;[1,&quot;false&quot;,false]&quot;</span></span><br><span class="line">jsonStringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;) <span class="comment">// &quot;&#123;&quot;b&quot;:&quot;undefined&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="19-实现一个JSON-parse"><a href="#19-实现一个JSON-parse" class="headerlink" title="19.实现一个JSON.parse"></a>19.实现一个JSON.parse</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text[, reviver])</span><br></pre></td></tr></table></figure><blockquote><p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p></blockquote><h2 id="方法1：直接调用-eval"><a href="#方法1：直接调用-eval" class="headerlink" title="方法1：直接调用 eval"></a>方法1：直接调用 eval</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function jsonParse(opt) &#123;</span><br><span class="line">    return eval(&#39;(&#39; + opt + &#39;)&#39;);</span><br><span class="line">&#125;</span><br><span class="line">jsonParse(jsonStringify(&#123;x : 5&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; x: 5&#125;</span><br><span class="line">jsonParse(jsonStringify([1, &quot;false&quot;, false]))</span><br><span class="line">&#x2F;&#x2F; [1, &quot;false&quot;, falsr]</span><br><span class="line">jsonParse(jsonStringify(&#123;b: undefined&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; b: &quot;undefined&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p></blockquote><p>如果你只想记这个方法，就得对参数json做校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json</span><br><span class="line">            .replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：Function"><a href="#方法2：Function" class="headerlink" title="方法2：Function"></a>方法2：Function</h2><blockquote><p>核心：Function与eval有相同的字符串参数特性</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var func = new Function(arg1, arg2, ..., functionBody);</span><br></pre></td></tr></table></figure><p>在转换JSON的实际应用中，只需要这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> json = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))();</span><br></pre></td></tr></table></figure><blockquote><p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p></blockquote><h1 id="20-解析-URL-Params-为对象"><a href="#20-解析-URL-Params-为对象" class="headerlink" title="20.解析 URL Params 为对象"></a>20.解析 URL Params 为对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line">parseParam(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">        <span class="comment">// 分割 key 和 value</span></span><br><span class="line">        <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 递归调用解码</span></span><br><span class="line">        val = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="comment">// 判断是否转为数字</span></span><br><span class="line">        val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">            paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">        paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21-模板引擎实现"><a href="#21-模板引擎实现" class="headerlink" title="21.模板引擎实现"></a>21.模板引擎实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template &#x3D; &#39;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;姓名&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); &#x2F;&#x2F; 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">     <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        template = template.replace(reg, data[name]);</span><br><span class="line">        <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="22-转化为驼峰命名"><a href="#22-转化为驼峰命名" class="headerlink" title="22.转化为驼峰命名"></a>22.转化为驼峰命名</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span></span><br><span class="line"><span class="comment">// 转化为 getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 首字母大写</span></span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="23-查找字符串中出现最多的字符和个数"><a href="#23-查找字符串中出现最多的字符和个数" class="headerlink" title="23.查找字符串中出现最多的字符和个数"></a>23.查找字符串中出现最多的字符和个数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 自己用哈希表</span></span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.replace(re, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; $<span class="number">0.</span>length)&#123;</span><br><span class="line">        num = $<span class="number">0.</span>length;</span><br><span class="line">        char = $<span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure><h1 id="24-字符串查找"><a href="#24-字符串查找" class="headerlink" title="24.字符串查找"></a>24.字符串查找</h1><blockquote><p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p></blockquote><p>暴力解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var strStr &#x3D; function(haystack, needle) &#123;</span><br><span class="line">    let m &#x3D;  haystack.length;</span><br><span class="line">    let n &#x3D; needle.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt;&#x3D; m - n; i++) &#123;</span><br><span class="line">        let j;</span><br><span class="line">        for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (needle[j] !&#x3D;&#x3D; haystack[i + j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; needle子串全都匹配了</span><br><span class="line">        if (j &#x3D;&#x3D;&#x3D; n) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; haystack中不存在needle</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = -<span class="number">1</span>, n = haystack.length, p = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="built_in">Array</span>(p).fill(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算next数组</span></span><br><span class="line">    calNext(needle, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; -<span class="number">1</span> &amp;&amp; needle[k + <span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">            <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] == haystack[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == p - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数- 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calNext</span>(<span class="params">needle, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>, p = -<span class="number">1</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; -<span class="number">1</span> &amp;&amp; needle[p + <span class="number">1</span>] != needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p + <span class="number">1</span>] == needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 位置j处更新最长前缀</span></span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>马拉车水平不够</p><h1 id="25-实现千位分隔符"><a href="#25-实现千位分隔符" class="headerlink" title="25.实现千位分隔符"></a>25.实现千位分隔符</h1><p>正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    return (n + &#39;&#39;).replace(&#x2F;(?!^)(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g, &#39;.&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    let ans &#x3D; &quot;&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        let cur &#x3D; n % 10;</span><br><span class="line">        n &#x3D; Math.floor(n &#x2F; 10);</span><br><span class="line">        ans +&#x3D; cur;</span><br><span class="line">        count++;</span><br><span class="line">        if (count % 3 &#x3D;&#x3D; 0 &amp;&amp; n) &#123;</span><br><span class="line">            ans +&#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (n);</span><br><span class="line">    return ans.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="26-判断是否是电话号码"><a href="#26-判断是否是电话号码" class="headerlink" title="26.判断是否是电话号码"></a>26.判断是否是电话号码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isPhone(tel) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;</span><br><span class="line">    return regx.test(tel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="27-验证是否是邮箱"><a href="#27-验证是否是邮箱" class="headerlink" title="27.验证是否是邮箱"></a>27.验证是否是邮箱</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEmail(email) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^([a-zA-Z0-9_\-]+@([a-zA-Z0-9_\-]+)+$&#x2F;;</span><br><span class="line">    return regx.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="28-用ES5实现数组的map方法"><a href="#28-用ES5实现数组的map方法" class="headerlink" title="28.用ES5实现数组的map方法"></a>28.用ES5实现数组的map方法</h1><ul><li>回调函数的参数有哪些，返回值如何处理</li><li>不修改原来的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.MyMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 由于是ES5所以就不用...展开符了</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> mappedArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        mappedArr.push(fn.call(context, arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29-用ES5实现数组的reduce方法"><a href="#29-用ES5实现数组的reduce方法" class="headerlink" title="29.用ES5实现数组的reduce方法"></a>29.用ES5实现数组的reduce方法</h1><ul><li>初始值不传怎么处理</li><li>回调函数的参数有哪些，返回值如何处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce &#x3D; function(fn, initialValue) &#123;</span><br><span class="line">    let arr &#x3D; Array.prototpye.slice.call(this);</span><br><span class="line">    let res, startIndex;</span><br><span class="line">    res &#x3D; initialValue ? initialValue : arr[0];</span><br><span class="line">    startIndex &#x3D; initialValue ? 0 : 1;</span><br><span class="line">    for (let i &#x3D; startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res &#x3D; fn.call(null, res, arr[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于普通函数，绑定this指向</li><li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li></ul><h1 id="30-请实现一个-add-函数，满足以下功能"><a href="#30-请实现一个-add-函数，满足以下功能" class="headerlink" title="30.请实现一个 add 函数，满足以下功能"></a>30.请实现一个 add 函数，满足以下功能</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> fn_args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">returm args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="31-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒"><a href="#31-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒" class="headerlink" title="31.实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒"></a>31.实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sleep &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">return new Promise(resolve &#x3D;&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(1000).then(() &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 这里写你的函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="32-实现-5-add-3-minus-2-功能"><a href="#32-实现-5-add-3-minus-2-功能" class="headerlink" title="32.实现 (5).add(3).minus(2) 功能"></a>32.实现 (5).add(3).minus(2) 功能</h1><blockquote><p>例： 5 + 3 - 2，结果为 6</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="33-实现一个双向绑定"><a href="#33-实现一个双向绑定" class="headerlink" title="33.实现一个双向绑定"></a>33.实现一个双向绑定</h1><p><strong>defineProperty 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">Object.defineProperty(data, &#39;text&#39;, &#123;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">set(newVal) &#123;</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">data.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>proxy 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">set(target, key, value) &#123;</span><br><span class="line">target[key] &#x3D; value;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(data, handler);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图更改 --&gt; 数据变化</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">proxy.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="34-Array-isArray-实现"><a href="#34-Array-isArray-实现" class="headerlink" title="34.Array.isArray 实现"></a>34.Array.isArray 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.myIsArray &#x3D; function(o) &#123;</span><br><span class="line">return Object.prototype.toString.call(Object(o)) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Array.myIsArray([])); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="35-实现一个函数判断数据类型"><a href="#35-实现一个函数判断数据类型" class="headerlink" title="35.实现一个函数判断数据类型"></a>35.实现一个函数判断数据类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    <span class="comment">// 对象类型 &quot;[object XXX]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="string">&#x27;[object &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase() : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getType(<span class="literal">null</span>); <span class="comment">// -&gt; null</span></span><br><span class="line">getType(<span class="literal">undefined</span>); <span class="comment">// -&gt; undefined</span></span><br><span class="line">getType(&#123;&#125;); <span class="comment">// -&gt; object</span></span><br><span class="line">getType([]); <span class="comment">// -&gt; array</span></span><br><span class="line">getType(<span class="number">123</span>); <span class="comment">// -&gt; number</span></span><br><span class="line">getType(<span class="literal">true</span>); <span class="comment">// -&gt; boolean</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// -&gt; string</span></span><br><span class="line">getType(<span class="regexp">/123/</span>); <span class="comment">// -&gt; regexp</span></span><br><span class="line">getType(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// -&gt; date</span></span><br></pre></td></tr></table></figure><h2 id="36-实现Event-event-bus"><a href="#36-实现Event-event-bus" class="headerlink" title="36. 实现Event(event bus)"></a>36. 实现Event(event bus)</h2><blockquote><p>event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础</p></blockquote><p><strong>简单版：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmeitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">this</span>._events || <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 储存事件/回调键值对</span></span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="built_in">this</span>._maxListeners || <span class="number">10</span>; <span class="comment">// 设立监听上限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class="line">  <span class="keyword">let</span> handler = <span class="built_in">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handler.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._events.get(type)) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.set(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>面试版：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmeitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">this</span>._events || <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 储存事件/回调键值对</span></span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="built_in">this</span>._maxListeners || <span class="number">10</span>; <span class="comment">// 设立监听上限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler;</span><br><span class="line">  <span class="comment">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class="line">  handler = <span class="built_in">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handler.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._events.get(type)) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.set(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler;</span><br><span class="line">  handler = <span class="built_in">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="comment">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        handler[i].apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler[i].call(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单个函数的情况我们直接触发即可</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      handler.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="built_in">this</span>._events.get(type); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.set(type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果handler是函数说明只有一个监听者</span></span><br><span class="line">    <span class="built_in">this</span>._events.set(type, [handler, fn]); <span class="comment">// 多个监听者我们需要用数组储存</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.push(fn); <span class="comment">// 已经有多个监听者,那么直接往数组里push函数即可</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmeitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="built_in">this</span>._events.get(type); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是函数,说明只被监听了一次</span></span><br><span class="line">  <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.delete(type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> postion;</span><br><span class="line">    <span class="comment">// 如果handler是数组,说明被监听多次要找到对应的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handler[i] === fn) &#123;</span><br><span class="line">        postion = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postion = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到匹配的函数,从数组中清除</span></span><br><span class="line">    <span class="keyword">if</span> (postion !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到数组对应的位置,直接清除此回调</span></span><br><span class="line">      handler.splice(postion, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span></span><br><span class="line">      <span class="keyword">if</span> (handler.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events.set(type, handler[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;手写常见js函数，面试必备，多练几遍，争取手撕&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
</feed>
