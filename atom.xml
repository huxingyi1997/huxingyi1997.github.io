<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hxy的博客</title>
  
  <subtitle>Mia san Mia!</subtitle>
  <link href="https://hxy1997.xyz/atom.xml" rel="self"/>
  
  <link href="https://hxy1997.xyz/"/>
  <updated>2021-03-30T03:02:11.322Z</updated>
  <id>https://hxy1997.xyz/</id>
  
  <author>
    <name>hxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES2021(ES12)</title>
    <link href="https://hxy1997.xyz/2021/03/29/ES2021(ES12)%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>https://hxy1997.xyz/2021/03/29/ES2021(ES12)%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2021-03-29T05:37:27.000Z</published>
    <updated>2021-03-30T03:02:11.322Z</updated>
    
    <content type="html"><![CDATA[<p>js又双叒叕更新了！这一版的新功能看上去真不戳，总共详细介绍了5 个新特性，replaceAll()真方便，可以不要每次都利用正则表达式里的g后缀来做替换了，剑指的替换空格又有了新的替换方法，赞美一下。Chrome浏览器已经支持了，力扣用过了也能顺利通过，<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p>采用replaceAll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> * 库函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.replaceAll(&#39; &#39;, &#39;%20&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="1-String-prototype-replaceAll"><a href="#1-String-prototype-replaceAll" class="headerlink" title="1.String.prototype.replaceAll()"></a>1.String.prototype.replaceAll()</h1><p>在 JavaScript 中，通常会使用 <code>String.prototype.replace()</code> 方法来完成字符串的替换，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaaa&#x27;</span>.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// baaa</span></span><br></pre></td></tr></table></figure><p>在 <code>String.prototype.replace()</code> 方法中，当第一个参数是字符串类型时，只替换第一个匹配的字符串，相关细节可以参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">MDN 文档</a>。因此，在上面的代码中，只有第一个 <code>a</code> 被替换成了 <code>b</code>，第二个 <code>a</code> 保持不变。如果要将匹配的字符串全部替换，传统方法只能通过正则表达式实现，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaaa&#x27;</span>.replace(<span class="regexp">/a/g</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// bbbb</span></span><br></pre></td></tr></table></figure><p>为了方便字符串的全局替换，ES2021 将支持 <code>String.prototype.replaceAll()</code> 方法，可以不用写正则表达式就可以完成字符串的全局替换，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaaa&#x27;</span>.replaceAll(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// bbbb</span></span><br></pre></td></tr></table></figure><p>更多阅读</p><ul><li><a href="https://stackoverflow.com/questions/1144783/how-to-replace-all-occurrences-of-a-string">stackoverflow.com/questions/1…</a></li><li><a href="https://github.com/tc39/proposal-string-replaceall">github.com/tc39/propos…</a></li><li><a href="https://v8.dev/features/string-replaceall">v8.dev/features/st…</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceall">developer.mozilla.org/en-US/docs/…</a></li><li><a href="https://caniuse.com/?search=replaceAll">caniuse.com/?search=rep…</a></li></ul><h1 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2.Promise.any"></a>2.Promise.any</h1><p>ES6引入<code>Promise</code> ，当时支持<code>Promise.all</code>和<code>Promise.race</code>2种方法：</p><ul><li><code>Promise.all</code>: 只要有一个 promise 是 rejected，则立即返回一个 rejected promise；所有的 promise 都是 fulfilled 时，则返回一个 resolved promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, result))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;error:&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: 1</span></span><br></pre></td></tr></table></figure><ul><li><code>Promise.race</code>: 只要有 promise 是 fulfilled 或 rejected，则立即返回一个 resolved 或 rejected的promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, result))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;error:&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: 1</span></span><br></pre></td></tr></table></figure><p>ES2020（ES11）引入了<code>Promise.allSettled</code>方法</p><ul><li><code>Promise.allSettled</code>: 无论每一个 promise 是fulfilled 还是 rejected，返回值都是一个 resolved promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, result))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;error:&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// [&#123; status: &quot;rejected&quot;, reason: 1 &#125;,</span></span><br><span class="line"><span class="comment">// &#123; status: &quot;fulfilled&quot;, value: 2 &#125;]</span></span><br></pre></td></tr></table></figure><p>最新的ES2021（ES12）引入了<code>Promise.any</code>方法</p><ul><li><code>Promise.any</code>: 只要有一个 promise 是 fulfilled 时，则返回一个 resolved promise；所有的 promise 都是 rejected 时，则返回一个 rejected promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, result))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;error:&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 2</span></span><br></pre></td></tr></table></figure><p>更多阅读</p><ul><li><a href="https://github.com/tc39/proposal-promise-any">github.com/tc39/propos…</a></li><li><a href="https://v8.dev/features/promise-combinators">v8.dev/features/pr…</a></li></ul><h1 id="3-逻辑赋值运算符"><a href="#3-逻辑赋值运算符" class="headerlink" title="3.逻辑赋值运算符"></a>3.逻辑赋值运算符</h1><p>逻辑赋值运算符由逻辑运算符和赋值表达式组合而成：</p><ul><li><p>or or equals (||=)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a ||= b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a ||= b 等价</span></span><br><span class="line">a || (a = b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a ||= b 等价</span></span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>and and equals (&amp;&amp;=)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp;= b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a &amp;&amp;= b 等价</span></span><br><span class="line">a &amp;&amp; (a = b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a &amp;&amp;= b 等价</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>question question equals (??=)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a ??= b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a ??= b 等价</span></span><br><span class="line">a ?? (a = b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 a ??= b 等价</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span> || a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用法示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.x ??= <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">obj.x ||= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">obj.x &amp;&amp;= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a || b; <span class="comment">// 与 a ||= b 不等价</span></span><br><span class="line">a = a &amp;&amp; b; <span class="comment">// 与 a &amp;&amp;= b 不等价</span></span><br><span class="line">a = a ?? b; <span class="comment">// 与 a ??= b 不等价</span></span><br></pre></td></tr></table></figure><p>不等价的原因在于，无论上面的每个逻辑表达式结果如何，都会进行赋值运算；而逻辑赋值运算符只会在条件成立的情况下进行赋值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter called&#x27;</span>);</span><br><span class="line">    x = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This always logs &quot;setter called&quot;</span></span><br><span class="line">obj.x += <span class="number">1</span>;</span><br><span class="line">assert.equal(obj.x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical operators do not call setters unnecessarily</span></span><br><span class="line"><span class="comment">// This will not log.</span></span><br><span class="line">obj.x ||= <span class="number">2</span>;</span><br><span class="line">assert.equal(obj.x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// But setters are called if the operator does not short circuit</span></span><br><span class="line"><span class="comment">// &quot;setter called&quot;</span></span><br><span class="line">obj.x &amp;&amp;= <span class="number">3</span>;</span><br><span class="line">assert.equal(obj.x, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>更多阅读</p><ul><li><a href="https://github.com/tc39/proposal-logical-assignment">github.com/tc39/propos…</a></li></ul><h1 id="4-数字分隔符"><a href="#4-数字分隔符" class="headerlink" title="4.数字分隔符"></a>4.数字分隔符</h1><p>使用 <code>_</code> 对数字进行分割，提高数字的可读性，例如在日常生活中数字通常是每三位数字之间会用 <code>,</code> 分割，以方便人快速识别数字。在代码中，也需要程序员较便捷的对数字进行辨识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1000000000 不易辨识</span></span><br><span class="line"><span class="keyword">const</span> count1 = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1_000_000_000 很直观</span></span><br><span class="line"><span class="keyword">const</span> count2 = <span class="number">1_000_000_000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count1 === count2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>更多案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const goldstack1 &#x3D; 785_00;</span><br><span class="line">const gemstack &#x3D; 1_000_000_000;</span><br><span class="line">console.log(goldstack1);                &#x2F;&#x2F; 78500</span><br><span class="line">console.log(gemstack);                  &#x2F;&#x2F; 1000000000</span><br><span class="line">console.log(goldstack1 &#x3D;&#x3D;&#x3D; 78500);      &#x2F;&#x2F; true</span><br><span class="line">console.log(gemstack &#x3D;&#x3D;&#x3D; 1000000000);   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>我们通过在数字相符的组之间放置分隔符使数字值更加的可读，分隔符适用于十进制表示法的数字以及二进制或十六进制表示法的数字，以及ES2020中引入的BigInt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const goldStack &#x3D; 0b1111_1111_1110_0101;</span><br><span class="line">console.log(goldStack);                        &#x2F;&#x2F; 65509</span><br><span class="line">console.log(goldStack &#x3D;&#x3D;&#x3D; 0b1111111111100101); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">const goldStack &#x3D; 0xFF_AC_C1;</span><br><span class="line">console.log(goldStack);                 &#x2F;&#x2F; 16755905</span><br><span class="line">console.log(goldStack &#x3D;&#x3D;&#x3D; 0xFF_AC_C1);  &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">const goldtstack &#x3D; 1_000_000_000_000_000n;</span><br><span class="line">console.log(goldtstack);                            &#x2F;&#x2F; 1000000000000000n</span><br><span class="line">console.log(goldtstack &#x3D;&#x3D;&#x3D; BigInt(10 ** 15)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 分隔符不会影响<code>===</code>操作符比较两个值</p><h1 id="5-WeakRefs"><a href="#5-WeakRefs" class="headerlink" title="5.WeakRefs"></a>5.WeakRefs</h1><p>ES6实现了<code>WeakSet</code>和<code>WeakMap</code>。<code>WeakSet</code>是对象的集合，<code>WeakMap</code>是键值对的集合，键必须是一个对象。它们之间的联系属于弱引用，也就是说这些对象作为垃圾回收的一部分，如果没有其他强引用，可以从内存中被移除。一个对象的弱引用是不会阻止垃圾回收器移除内存中的这个对象。相反，一个普通（强）引用的对象会保留这个对象在内存中。</p><p>ES2021将可以实现人为使用<code>WeakRef</code>对象而不用<code>WeakSet</code>和<code>WeakMap</code>来创建一个对象的若引用。这个符合需要的提案警告你在使用<code>WeakRef</code>时一定要小心。总之，使用之前一定有合理理由。根本上来说，我们应该尽可能的避免使用<code>WeakRef</code>。垃圾回收器已经够复杂和系统依赖的，所以这很难去预测垃圾回收器的具体行为。</p><p><code>WeakRef</code> 实例可以作为对象的弱引用，对象的弱引用是指当该对象应该被 GC 回收时不会阻止 GC 的回收行为。而与此相反的，一个普通的引用（默认是强引用）会将与之对应的对象保存在内存中。只有当该对象没有任何的强引用时，JavaScript 引擎 GC 才会销毁该对象并且回收该对象所占的内存空间。因此，访问弱引用指向的对象时，很有可能会出现该对象已经被回收，<code>WeakRef</code> 使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="keyword">new</span> WeakRef(&#123; <span class="attr">name</span>: <span class="string">&#x27;koofe&#x27;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ref.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> obj = ref.deref();</span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name); <span class="comment">// koofe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于 WeakRef 对象的使用要慎重考虑，能不使用就尽量不要使用</p></blockquote><p>更多阅读</p><ul><li><a href="https://github.com/tc39/proposal-weakrefs">github.com/tc39/propos…</a></li><li><a href="https://github.com/tc39/proposal-weakrefs/blob/master/reference.md">github.com/tc39/propos…</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef">developer.mozilla.org/en-US/docs/…</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;js又双叒叕更新了！这一版的新功能看上去真不戳，总共详细介绍了5 个新特性，replaceAll()真方便，可以不要每次都利用正则表达式里的g后缀来做替换了，剑指的替换空格又有了新的替换方法，赞美一下。Chrome浏览器已经支持了，力扣用过了也能顺利通过，&lt;a href=&quot;https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/&quot;&gt;剑指 Offer 05. 替换空格&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请实现一个函数，把字符串 &lt;code&gt;s&lt;/code&gt; 中的每个空格替换成”%20”。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;We are happy.&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;We%20are%20happy.&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; &lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;&amp;#x3D; s 的长度 &amp;lt;&amp;#x3D; 10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;采用replaceAll&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param &amp;#123;string&amp;#125; s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @return &amp;#123;string&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 库函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var replaceSpace &amp;#x3D; function(s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return s.replaceAll(&amp;#39; &amp;#39;, &amp;#39;%20&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES12" scheme="https://hxy1997.xyz/tags/ES12/"/>
    
    <category term="ES2021" scheme="https://hxy1997.xyz/tags/ES2021/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://hxy1997.xyz/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hxy1997.xyz/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-27T13:49:00.000Z</published>
    <updated>2021-03-30T12:49:41.748Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍操作系统，作为非科班同学，这一块应该好好学习，不仅仅是应付面试，之前就突击了线程、进程、死锁的知识，别的就是一窍不通了，这次尽可能了解完整的操作系统知识体系。一个简单的例子：</p><ul><li>在我们的JS代码里，只需要输入 <code>console.log(1 + 1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?</li><li>首先键盘输入代码<code>1 + 1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备），将获取的<code>1 + 1</code>指令放入内存</li><li>然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1 + 1</code>的加法运算</li><li>此时CPU的控制将控制CPU的运算器做<code>1 + 1</code>的加法运算，并得出结果<code>2</code></li><li>最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li></ul><p>好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。</p><span id="more"></span><h1 id="1-操作系统简介"><a href="#1-操作系统简介" class="headerlink" title="1. 操作系统简介"></a>1. 操作系统简介</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><p><strong>操作系统是管理硬件和软件的一种应用程序</strong>。操作系统是运行在计算机上最重要的一种<code>软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fec6568320e47e79917d456871e1509~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统保证这些访问和交互能够准确无误的进行。</p><p>操作系统是一种软件，它的主要目的有三种</p><ul><li>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。</li><li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li><li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li></ul><h2 id="1-2-操作系统的主要功能"><a href="#1-2-操作系统的主要功能" class="headerlink" title="1.2 操作系统的主要功能"></a>1.2 操作系统的主要功能</h2><p>一般来说，现代操作系统主要提供下面几种功能</p><ul><li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li><li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li><li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li><li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li><li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li></ul><h2 id="1-3-操作系统的四个特征"><a href="#1-3-操作系统的四个特征" class="headerlink" title="1.3 操作系统的四个特征"></a>1.3 操作系统的四个特征</h2><p>操作系统有以下四个特征：</p><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><p>接下来，我们分别来搞定每一个特征。</p><h3 id="1-3-1-并发是什么？和并行有啥区别？"><a href="#1-3-1-并发是什么？和并行有啥区别？" class="headerlink" title="1.3.1 并发是什么？和并行有啥区别？"></a>1.3.1 并发是什么？和并行有啥区别？</h3><p>举个例子，假如你在语音跟同学玩英雄联盟：</p><ul><li>你一边用鼠标移动打游戏，同时语音嘴里说”队友挂机，真坑！”, 这叫并行（边移动鼠标边语音BB）</li><li>你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发（先离开鼠标然后砸键盘）</li></ul><p>并发只是把时间分成若干段，<code>使多个任务交替的执行</code>。 并行的关键是你有<code>同时处理</code>多个任务的能力。</p><ul><li>所以我认为它们最关键的点就是：<code>是否是『同时』</code></li></ul><p>那么对于操作系统而言，操作系统的并发性指计算机系统中<code>同时存在多个运行着的程序</code>。</p><ul><li>比如说以前的计算机是单核CPU，那么如何在操作系统上同时运行QQ、浏览器，记事本、ppt等多个程序呢，这就需要操作系统具有并发性</li><li><code>CPU时间片</code>（操作系统分配给每个正在运行的进程微观上的一段CPU时间）轮着给进程执行的时间，因为执行速度很快，<code>看起来就像</code>浏览器能同时执行任务一样。</li><li>有人会说，现在都多核CPU了，还需要并发吗，答案肯定是需要的，比如你有8核CPU，但是桌面要执行的任务很可能超过8个。</li></ul><h3 id="1-3-2-共享是什么？共享和并发有什么关系？"><a href="#1-3-2-共享是什么？共享和并发有什么关系？" class="headerlink" title="1.3.2 共享是什么？共享和并发有什么关系？"></a>1.3.2 共享是什么？共享和并发有什么关系？</h3><p>举一个例子： 你同时用QQ和微信发”年终述职.ppt”文件给领导，这时候QQ和微信都在读取这个ppt文件</p><ul><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性） 如果没有并发，也就是只有一个进程在运行，那就没有共享了。如果没有共享，QQ和微信就不能同时发文件，无法同时访问硬盘资源，也就无法并发。</li></ul><p>其中共享分为两种情况：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/3/170a0efc437c62c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>上面的例子，QQ和微信都要访问同一个文件，属于<code>同时共享</code>。</li><li>对于互斥共享，比如打印机，<code>只能同一时刻被一个进程控制</code>，如打印机，虽然他可以提供多个进程使用，但是试想，同时打印多个东西，会造成打印结果的混乱，因此规定，某些资源在进行使用的时候，必须要先让某进程先使用，等使用完之后，再同一其他进程进行访问。</li><li>我们把一段时间内只允许一个进程访问的资源称为<code>独占资源</code>，或<code>临界资源</code>。</li></ul><h3 id="1-3-3-虚拟是什么？"><a href="#1-3-3-虚拟是什么？" class="headerlink" title="1.3.3 虚拟是什么？"></a>1.3.3 虚拟是什么？</h3><p>先举例，再说定义。</p><p>假如一个叫<code>范桶</code>的货车司机在玩英雄联盟，平时因为酒驾太多，自己装了很多次别人的车，住院也花了不少钱，所以家里没钱，只能买个<code>1G内存</code>的二手电脑玩游戏。可<code>英雄联盟</code>至少需要<code>2G内存</code>，这就奇怪了，老司机虽然一到团战就卡死，但是还是能运行英雄联盟。为什么需要<code>2G内存</code>的游戏，<code>1G电脑</code>还能运行呢？</p><p>这就是虚拟存储器技术。实际上<code>只有1G内存</code>，在用户看来<code>远远大于1G</code>。</p><p>还有，<code>范桶</code>的电脑还是<code>单核的</code>，但<code>范桶</code>居然能一边迅雷下着爱情动作片，一边听着网易云音乐，还在QQ上撩妹子，既然一个程序要被分配CPU才能正常执行，按道理来说同一时间只有1个程序在运行，为啥电脑能同时运行这么多程序呢？</p><p>这就是虚拟处理器技术。实际上只有<code>一个CPU</code>，在用户看来有<code>3个CPU</code>在同时服务。（因为CPU来回切换进程的速度特别块，感觉就像很多CPU在为我们服务）</p><p>虚拟这块的总结如下:</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a3cc61eee1cd6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="1-3-4-异步性是什么"><a href="#1-3-4-异步性是什么" class="headerlink" title="1.3.4 异步性是什么?"></a>1.3.4 异步性是什么?</h3><p>异步在JS里是很常见的，比如<code>ajax请</code>求，我们发出请求后并不是立马得到信息，也不会去等待<code>ajax</code>结果返回，而是继续执行下面的代码，等ajax结果回来，通知<code>JS线程</code>。这就跟<code>CPU处理进程</code>很类似。</p><p>比如，CPU正在执行一个进程，进程需要读取文件，读取文件可能要<code>1个小时</code>，那CPU不可能一直等一个小时，CPU会继续把时间片分给别的进程，等文件读取完成了（类似ajax返回结果了），<code>CPU再继续执行</code>之前被<code>中断</code>的进程。</p><p>所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。</p><h2 id="1-4-软件访问硬件的几种方式"><a href="#1-4-软件访问硬件的几种方式" class="headerlink" title="1.4 软件访问硬件的几种方式"></a>1.4 软件访问硬件的几种方式</h2><p>软件访问硬件其实就是一种 IO 操作，软件访问硬件的方式，也就是 I/O 操作的方式有哪些。</p><p>硬件在 I/O 上大致分为<strong>并行和串行</strong>，同时也对应串行接口和并行接口。</p><p>随着计算机技术的发展，I/O 控制方式也在不断发展。选择和衡量 I/O 控制方式有如下三条原则</p><blockquote><p>（1） 数据传送速度足够快，能满足用户的需求但又不丢失数据；</p><p>（2） 系统开销小，所需的处理控制程序少；</p><p>（3） 能充分发挥硬件资源的能力，使 I/O 设备尽可能忙，而 CPU 等待时间尽可能少。</p></blockquote><p>根据以上控制原则，I/O 操作可以分为四类</p><ul><li><code>直接访问</code>：直接访问由用户进程直接控制主存或 CPU 和外围设备之间的信息传送。直接程序控制方式又称为忙/等待方式。</li><li><code>中断驱动</code>：为了减少程序直接控制方式下 CPU 的等待时间以及提高系统的并行程度，系统引入了中断机制。中断机制引入后，外围设备仅当操作正常结束或异常结束时才向 CPU 发出中断请求。在 I/O 设备输入每个数据的过程中，由于无需 CPU 的干预，一定程度上实现了 CPU 与 I/O 设备的并行工作。</li></ul><p>上述两种方法的特点都是以 <code>CPU</code> 为中心，数据传送通过一段程序来实现，软件的传送手段限制了数据传送的速度。接下来介绍的这两种 I/O 控制方式采用硬件的方法来显示 I/O 的控制</p><ul><li><code>DMA 直接内存访问</code>：为了进一步减少 CPU 对 I/O 操作的干预，防止因并行操作设备过多使 CPU 来不及处理或因速度不匹配而造成的数据丢失现象，引入了 DMA 控制方式。</li><li><code>通道控制方式</code>：通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</li></ul><h2 id="1-5-常见的操作系统"><a href="#1-5-常见的操作系统" class="headerlink" title="1.5 常见的操作系统"></a>1.5 常见的操作系统</h2><p>常见的操作系统只有三种：<strong>Windows、macOS 和 Linux</strong>。</p><h3 id="1-5-1-Linux应用程序可以直接在Windows下运行吗"><a href="#1-5-1-Linux应用程序可以直接在Windows下运行吗" class="headerlink" title="1.5.1 Linux应用程序可以直接在Windows下运行吗"></a>1.5.1 Linux应用程序可以直接在Windows下运行吗</h3><p>Linux 系统下的应用程序不能直接在 Windows 下运行，其中一点是因为 Linux 系统和 Windows 系统的格式不同，<strong>格式就是协议</strong>，就是在固定位置有意义的数据。Linux 下的可执行程序文件格式是 <code>elf</code>，可以使用 <code>readelf</code> 命令查看 elf 文件头。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1574a4e2f02c483c908fb9556c482af0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>而 Windows 下的可执行程序是 <code>PE</code> 格式，它是一种可移植的可执行文件。</p><p>还有一点是因为 Linux 系统和 Windows 系统的 <code>API</code> 不同，这个 API 指的就是操作系统的 API，Linux 中的 API 被称为<code>系统调用</code>，是通过 <code>int 0x80</code> 这个软中断实现的。而 Windows 中的 API 是放在动态链接库文件中的，也就是 Windows 开发人员所说的 <code>DLL</code> ，这是一个库，里面包含代码和数据。Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。</p><h3 id="1-5-2-Linux-操作系统的启动过程"><a href="#1-5-2-Linux-操作系统的启动过程" class="headerlink" title="1.5.2 Linux 操作系统的启动过程"></a>1.5.2 Linux 操作系统的启动过程</h3><p>当计算机电源通电后，<code>BIOS</code>会进行<code>开机自检(Power-On-Self-Test, POST)</code>，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 <code>MBR(Master Boot Record)</code> 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。</p><p>复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。</p><p>内核启动代码是使用<code>汇编语言</code>完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。</p><p>这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。</p><p>然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。</p><p>配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 <code>init 进程(进程 1 )</code> 和 <code>守护进程(进程 2)</code>。</p><p>init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。</p><p>然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 <code>getty</code> 的程序。</p><p>getty 程序会在终端上输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login:</span><br></pre></td></tr></table></figure><p>等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 <code>/bin/login</code> 开始运行。login 程序需要输入密码，并与保存在 <code>/etc/passwd</code> 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。</p><p>整个系统启动过程如下</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aab9e83fd9946a0be42d6554b57d11f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="1-5-3-实时系统"><a href="#1-5-3-实时系统" class="headerlink" title="1.5.3 实时系统"></a>1.5.3 实时系统</h3><p>实时操作系统对时间做出了严格的要求，实时操作系统分为两种：<strong>硬实时和软实时</strong></p><p><code>硬实时操作系统</code>规定某个动作必须在规定的时刻内完成或发生，比如汽车生产车间，焊接机器必须在某一时刻内完成焊接，焊接的太早或者太晚都会对汽车造成永久性伤害。</p><p><code>软实时操作系统</code>虽然不希望偶尔违反最终的时限要求，但是仍然可以接受。并且不会引起任何永久性伤害。比如数字音频、多媒体、手机都是属于软实时操作系统。</p><p>你可以简单理解硬实时和软实时的两个指标：<strong>是否在时刻内必须完成以及是否造成严重损害</strong>。</p><h2 id="1-6-操作系统结构"><a href="#1-6-操作系统结构" class="headerlink" title="1.6 操作系统结构"></a>1.6 操作系统结构</h2><h3 id="1-6-1-单体系统"><a href="#1-6-1-单体系统" class="headerlink" title="1.6.1 单体系统"></a>1.6.1 单体系统</h3><p>在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序，这种系统称为单体系统。</p><p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p><p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca5bf6a988942cf8f2c0f5649620b0b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p><h3 id="1-6-2-分层系统"><a href="#1-6-2-分层系统" class="headerlink" title="1.6.2 分层系统"></a>1.6.2 分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8221b4f6af5a4098b0d186bda0af7bf5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="1-6-3-微内核"><a href="#1-6-3-微内核" class="headerlink" title="1.6.3 微内核"></a>1.6.3 微内核</h3><p>为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p><p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b4acbaaf16f4572b0f03b28f7011c6a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p><h3 id="1-6-4-客户-服务器模式"><a href="#1-6-4-客户-服务器模式" class="headerlink" title="1.6.4 客户-服务器模式"></a>1.6.4 客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p><p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ce896feb7f4699b9d755c3cb83a7dd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p><h2 id="1-7-操作系统运行机制和体系结构"><a href="#1-7-操作系统运行机制和体系结构" class="headerlink" title="1.7 操作系统运行机制和体系结构"></a>1.7 操作系统运行机制和体系结构</h2><p>预备知识： 什么是指令</p><p>比如说，如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a4342ae392e20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>a+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成汇编语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 意思是将内存的16号单元数据，放到A寄存器，</span><br><span class="line">LOAD A, 16</span><br><span class="line">&#x2F;&#x2F; 意思是将内存的16号单元数据，放到B寄存器</span><br><span class="line">LOAD B, 17</span><br><span class="line">&#x2F;&#x2F; 存器里的A,B数据相加，得到C</span><br><span class="line">ADD C, A, B</span><br></pre></td></tr></table></figure><p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p><h3 id="1-7-1-两种指令、两种处理器状态、两种程序"><a href="#1-7-1-两种指令、两种处理器状态、两种程序" class="headerlink" title="1.7.1 两种指令、两种处理器状态、两种程序"></a>1.7.1 两种指令、两种处理器状态、两种程序</h3><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a447e4751bf4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图:</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a44da4cba4ed1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>CPU通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。</p><ul><li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li><li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li></ul><blockquote><p>那么为什么要有用户态和内核态呢？</p></blockquote><p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p><h4 id="必背考点：内核态与用户态概念"><a href="#必背考点：内核态与用户态概念" class="headerlink" title="必背考点：内核态与用户态概念"></a>必背考点：内核态与用户态概念</h4><ul><li>内核态：cpu 可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu 也可以将自己从一个程序切换到另一个程序。</li><li>用户态：只能受限的访问内存，且不允许访问外围设备，占用 cpu 的能力被剥夺，cpu 资源可以被其他程序获取。</li></ul><h4 id="用户态和内核态是如何切换的？"><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h4><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p><p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p><p>他们的工作流程如下：</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b6ab407a3294608a04bf7b7767c807a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li><li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li><li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li><li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li><li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li><li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li><li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li></ul><p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a581fb91ee433?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="必背考点：用户态到内核态的切换"><a href="#必背考点：用户态到内核态的切换" class="headerlink" title="必背考点：用户态到内核态的切换"></a>必背考点：用户态到内核态的切换</h4><ul><li>异常事件： 当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li><li>外围设备的中断：当外围设备完成用户的请求操作后，会像 CPU 发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li></ul><h3 id="1-7-2-操作系统内核简单介绍"><a href="#1-7-2-操作系统内核简单介绍" class="headerlink" title="1.7.2 操作系统内核简单介绍"></a>1.7.2 操作系统内核简单介绍</h3><p>从下图，我们先看看操作系统内核包含哪些</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a5a014655ce2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>在计算机中，内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容</strong>。内核通常是在 boot loader 装载程序之前加载的第一个程序。</p><p>这里还需要了解一下什么是 <code>boot loader</code>。</p><blockquote><p>boot loader 又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一些初始测试，然后将控制权转移到引导加载程序所在的<code>主引导记录(MBR)</code> 。</p></blockquote><p>操作系统内核中跟硬件紧密相关的部分有：</p><ul><li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li><li>中断处理</li><li>原语。可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li></ul><h3 id="1-7-3-陷入内核"><a href="#1-7-3-陷入内核" class="headerlink" title="1.7.3 陷入内核"></a>1.7.3 陷入内核</h3><p>如果把软件结构进行分层说明的话，应该是这个样子的，最外层是应用程序，里面是操作系统内核。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c0707f849940caa35f5f1adcda7515~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>应用程序处于特权级 3，操作系统内核处于特权级 0 。如果用户程序想要访问操作系统资源时，会发起系统调用，陷入内核，这样 CPU 就进入了内核态，执行内核代码。至于为什么是陷入，我们看图，内核是一个凹陷的构造，有陷下去的感觉，所以称为陷入。</p><h2 id="1-8-中断"><a href="#1-8-中断" class="headerlink" title="1.8 中断"></a>1.8 中断</h2><h3 id="1-8-1-什么是中断"><a href="#1-8-1-什么是中断" class="headerlink" title="1.8.1 什么是中断"></a>1.8.1 什么是中断</h3><ul><li>在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a64d4316feb29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第一个应用程序在用户态执行了一段时间后</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a64d9fe429957?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接着操作系统切换到核心态，处理中断信号</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a653c025a0a46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li><li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li><li><code>进程</code>2需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li><li>打印机开始工作，此时<code>进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到<code>第三个应用程序</code>执行</li><li>等到打印机准备好了，此时打印机通过I/O控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把CPU给程序2继续执行。</li></ul><p>好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?</p><ul><li>“用户态 —&gt; 核心态”是通过中断实现的。<code>并且中断是实现其的唯一途径</code>。</li><li>“核心态 —&gt; 用户态”的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。</li></ul><h3 id="1-8-2-中断的分类"><a href="#1-8-2-中断的分类" class="headerlink" title="1.8.2 中断的分类"></a>1.8.2 中断的分类</h3><p>举一个例子，什么是内中断和外中断：</p><p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p><p>官方解释如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170ab316637293c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li><li>外中断常见的情况如<code>I/O中断</code>（由I/O控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I/O中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。</li></ul><h3 id="1-8-3-系统调用"><a href="#1-8-3-系统调用" class="headerlink" title="1.8.3 系统调用"></a>1.8.3 系统调用</h3><blockquote><p>为什么需要系统调用？</p></blockquote><ul><li>比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时CPU在<code>内核态</code>去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li><li>这里就引出系统调用的概念和作用。</li><li>应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li></ul><p>以下内容简单看一下即可，系统调用的分类：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170ab453215e0426?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p><ul><li>库是可重用的模块 <code>处于用户态</code></li><li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li></ul><p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入创建子进程的模块</span><br><span class="line">const childProcess &#x3D; require(&#39;child_process&#39;)</span><br><span class="line">&#x2F;&#x2F; 获取cpu的数量</span><br><span class="line">const cpuNum &#x3D; require(&#39;os&#39;).cpus().length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建与cpu数量一样的子进程</span><br><span class="line">for (let i &#x3D; 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">childProcess.fork(&#39;.&#x2F;worker.js&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><h2 id="2-1-多处理系统的优势"><a href="#2-1-多处理系统的优势" class="headerlink" title="2.1 多处理系统的优势"></a>2.1 多处理系统的优势</h2><p>随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52dde03332984dc9b9b3b6b0e9472b1a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。</p><h2 id="2-2-为什么要引入进程"><a href="#2-2-为什么要引入进程" class="headerlink" title="2.2 为什么要引入进程"></a>2.2 为什么要引入进程</h2><ul><li><p>早期的计算机只支持<strong>单道程序</strong>（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae1ed19358374?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</p></li><li><p>拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</p></li><li><p>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</p></li></ul><h2 id="2-3-进程和进程控制块的定义"><a href="#2-3-进程和进程控制块的定义" class="headerlink" title="2.3 进程和进程控制块的定义"></a>2.3 进程和进程控制块的定义</h2><h3 id="2-3-1-进程"><a href="#2-3-1-进程" class="headerlink" title="2.3.1 进程"></a>2.3.1 进程</h3><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>(强调动态性)，换而言之，<code>进程</code>就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。</p><p>操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用 CPU，操作系统还会为每个进程分配特定的资源。</p><h4 id="必背考点"><a href="#必背考点" class="headerlink" title="必背考点"></a>必背考点</h4><ul><li>进程是程序在一个数据集合上运行的过程。</li><li>进程实体 = 程序段 + 数据段 + PCB</li><li>进程资源分配和资源调度的基本单位。</li><li>孤儿进程和僵尸进程<ul><li>孤儿进程：<ul><li>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>孤儿进程并不会有什么危害。</li></ul></li><li>僵尸进程：<ul><li>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li><li>进程号就会一直被占用，但是系统所能使用的进程号是有限的。</li></ul></li></ul></li></ul><h3 id="2-3-2-进程控制块"><a href="#2-3-2-进程控制块" class="headerlink" title="2.3.2 进程控制块"></a>2.3.2 进程控制块</h3><p>操作系统为了跟踪每个进程的活动状态，维护了一个<code>进程控制块</code>。在进程控制块的内部，列出了每个进程的状态以及每个进程使用的资源等。</p><p>分别说明一下</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae2cd01ca96d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，<code>用于区分不同的进程</code>。</li><li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li><li>进程当前状态和优先级下一小节会详细介绍</li><li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li><li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li><li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li><li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来</li></ul><h2 id="2-4-进程的状态"><a href="#2-4-进程的状态" class="headerlink" title="2.4 进程的状态"></a>2.4 进程的状态</h2><h3 id="2-4-1-进程的组织"><a href="#2-4-1-进程的组织" class="headerlink" title="2.4.1 进程的组织"></a>2.4.1 进程的组织</h3><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae8d9a26f1029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="2-4-2-进程的状态模型"><a href="#2-4-2-进程的状态模型" class="headerlink" title="2.4.2 进程的状态模型"></a>2.4.2 进程的状态模型</h3><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><h4 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h4><p>当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ee05d2b123420b8e6172131abc8108~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>进程的三种基本状态详细图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9b1af241626?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>图中会涉及三种状态</p><ol><li><code>运行态</code>：运行态指的就是进程实际占用 CPU 时间片运行时</li><li><code>就绪态</code>：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li><code>阻塞态</code>：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。</li></ol><p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p><p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p><blockquote><p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p></blockquote><p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p><h4 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h4><p>在三态模型的基础上，增加了两个状态，即 <code>新建</code> 和 <code>终止</code> 状态。</p><p>进程的另<code>新建</code> 和 <code>终止</code> 状态：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9c18688717f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a2bb469deeb4cb78b03a0aff606d29b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>新建态：进程的新建态就是进程刚创建出来的时候</li></ul><blockquote><p>创建进程需要两个步骤：即为新进程分配所需要的资源和空间，设置进程为就绪态，并等待调度执行。</p></blockquote><ul><li>终止态：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。</li></ul><blockquote><p>终止一个进程需要两个步骤：</p><ol><li>先等待操作系统或相关的进程进行善后处理。</li><li>然后回收占用的资源并被系统删除。</li></ol></blockquote><h3 id="2-4-3-进程状态的转换"><a href="#2-4-3-进程状态的转换" class="headerlink" title="2.4.3 进程状态的转换"></a>2.4.3 进程状态的转换</h3><p>进程的状态并不是一成不变的，在一定情况下会动态转换。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9cde4d8ffde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫<code>原语</code>。</p><ul><li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aee393ffd0e82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p><ul><li>首先执行关中断指令</li><li>然后外部来了中断信号，不予以处理</li><li>等到开中断指令执行后，其他中断信号才有机会处理。</li></ul><h3 id="2-4-4-进程的终止"><a href="#2-4-4-进程的终止" class="headerlink" title="2.4.4 进程的终止"></a>2.4.4 进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li><code>正常退出(自愿的)</code></li><li><code>错误退出(自愿的)</code></li><li><code>严重错误(非自愿的)</code></li><li><code>被其他进程杀死(非自愿的)</code></li></ul><h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p><h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></figure><p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p><h2 id="2-5-进程的通信"><a href="#2-5-进程的通信" class="headerlink" title="2.5 进程的通信"></a>2.5 进程的通信</h2><blockquote><p>为什么需要进程间通信呢？</p></blockquote><p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aef6e29ddaf75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>进程间的通信方式比较多，首先你需要理解下面这几个概念</p><ul><li><p>竞态条件：即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为<code>竞态条件(race condition)</code>。</p></li><li><p>临界区：不仅<code>共享资源</code>会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p><p>一个好的解决方案，应该包含下面四种条件</p><ol><li>任何时候两个进程不能同时处于临界区</li><li>不应对 CPU 的速度和数量做任何假设</li><li>位于临界区外的进程不得阻塞其他进程</li><li>不能使任何进程无限等待进入临界区</li></ol><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1dffc1075d42eeb00619ea4fe3e8b1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p></li><li><p>忙等互斥：当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。</p></li></ul><p>进程间的通信用专业一点的术语来表示就是 <code>Inter Process Communication，IPC</code>，它主要有下面 7种通信方式</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47292fc492ee437d8c48a6b6fccb19ee~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="必背考点：进程有哪些通信方式"><a href="#必背考点：进程有哪些通信方式" class="headerlink" title="必背考点：进程有哪些通信方式"></a>必背考点：进程有哪些通信方式</h4><ul><li><code>消息传递</code>：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方</li><li><code>先进先出队列</code>：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式</li><li><code>管道</code>：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。</li><li><code>直接通信</code>：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。</li><li><code>间接通信</code>：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。</li><li><code>消息队列</code>：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。</li><li><code>共享内存</code>：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。</li><li>套接字： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li><li>信号：用于Linux系统中，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li></ul><p>详细介绍3种</p><h3 id="2-5-1-进程通信方法—共享内存"><a href="#2-5-1-进程通信方法—共享内存" class="headerlink" title="2.5.1 进程通信方法—共享内存"></a>2.5.1 进程通信方法—共享内存</h3><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aef9d07c0a489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中，介绍一下基于存储区的共享。</p><ul><li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li></ul><h3 id="2-5-2-进程通信方法—管道（匿名管道）"><a href="#2-5-2-进程通信方法—管道（匿名管道）" class="headerlink" title="2.5.2 进程通信方法—管道（匿名管道）"></a>2.5.2 进程通信方法—管道（匿名管道）</h3><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af037199fbd9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li><li>如果没写满就不允许读。如果都没空就不允许写。</li><li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li></ul><h3 id="2-5-3-进程通信方法—消息传递"><a href="#2-5-3-进程通信方法—消息传递" class="headerlink" title="2.5.3 进程通信方法—消息传递"></a>2.5.3 进程通信方法—消息传递</h3><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>&quot;发送消息/接收消息&quot;</code>两个原语进行数据交换。</p><p>其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0a32298a1f62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布-订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0a75d10bd130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="2-6-进程的同步和互斥"><a href="#2-6-进程的同步和互斥" class="headerlink" title="2.6 进程的同步和互斥"></a>2.6 进程的同步和互斥</h2><blockquote><p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p></blockquote><p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图1所示。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101701a8b5229d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p></blockquote><p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程B才可以继续执行。概念如图3所示。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101706689b2238?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="必背考点：进程同步的原则"><a href="#必背考点：进程同步的原则" class="headerlink" title="必背考点：进程同步的原则"></a>必背考点：进程同步的原则</h4><ul><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ul><h3 id="2-6-1-信号量（了解概念即可）"><a href="#2-6-1-信号量（了解概念即可）" class="headerlink" title="2.6.1 信号量（了解概念即可）"></a>2.6.1 信号量（了解概念即可）</h3><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p><p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*记录型信号量的定义*&#x2F;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int value; &#x2F;&#x2F; 剩余资源</span><br><span class="line">    Struct process *L &#x2F;&#x2F; 等待队列</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure><p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。</p><p><code>Struct process *L</code>意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*P 操作，也就是记录型信号量的请求资源操作*&#x2F;</span><br><span class="line">void wait (semaphore S) &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    if (S.value &lt; 0)&#123;</span><br><span class="line">        block (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*V 操作，也就是记录型信号量的释放资源操作*&#x2F;</span><br><span class="line">void singal (semaphore S) &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    if (S.value &lt;&#x3D; 0)&#123;</span><br><span class="line">        wakeup (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。</p><h3 id="2-6-2-生产者消费者问题（了解概念即可）"><a href="#2-6-2-生产者消费者问题（了解概念即可）" class="headerlink" title="2.6.2 生产者消费者问题（了解概念即可）"></a>2.6.2 生产者消费者问题（了解概念即可）</h3><p>为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101d0ebef25336?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>这里我们需要两个同步信号量和一个互斥信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 同步信号量，表示目前还可以生产几个产品</span><br><span class="line">semaphore empty &#x3D; n;</span><br><span class="line">&#x2F;&#x2F; 同步信号量，表示目前可以消耗几个产品</span><br><span class="line">semaphore full &#x3D; 0;</span><br></pre></td></tr></table></figure><p>生产者代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生产一个产品</span><br><span class="line">        P(empty);</span><br><span class="line">        &#x2F;&#x2F; 对缓冲区加锁</span><br><span class="line">        P(mutex);</span><br><span class="line">        这里的代码是生产一个产品</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        V(mutex);</span><br><span class="line">        &#x2F;&#x2F; 产出一个产品</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 消费一个产品</span><br><span class="line">        P(full);</span><br><span class="line">        &#x2F;&#x2F; 对缓冲区加锁</span><br><span class="line">        P(mutex);</span><br><span class="line">        这里的代码是消费一个产品</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        V(mutex);</span><br><span class="line">        &#x2F;&#x2F; 消费一个产品</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-线程和协程"><a href="#2-7-线程和协程" class="headerlink" title="2.7 线程和协程"></a>2.7 线程和协程</h2><h3 id="2-7-1-为什么要引入线程"><a href="#2-7-1-为什么要引入线程" class="headerlink" title="2.7.1 为什么要引入线程"></a>2.7.1 为什么要引入线程</h3><ul><li>比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能<code>同一时间做一件事情</code>（比如QQ打字聊天）</li><li>但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ<code>没有多线程并发能力</code>，QQ能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0c6245723138?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>引入线程后带来的变化</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0cdff976f56b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="2-7-2-线程的定义"><a href="#2-7-2-线程的定义" class="headerlink" title="2.7.2 线程的定义"></a>2.7.2 线程的定义</h3><p>我们上面说到进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中的某些属性，所以线程又被称为轻量级的进程。浏览器如果是一个进程的话，那么浏览器下面的每个 tab 页可以看作是一个个的线程。</p><p>下面是线程和进程持有资源的区别</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55ee47325c448bd833d30e34aa6b856~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>线程不像进程那样具有很强的独立性，线程之间会共享数据</p><p>创建线程的开销要比进程小很多，因为创建线程仅仅需要<code>堆栈指针</code>和<code>程序计数器</code>就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。</p><h4 id="必背考点：什么是线程？"><a href="#必背考点：什么是线程？" class="headerlink" title="必背考点：什么是线程？"></a>必背考点：什么是线程？</h4><ul><li>CPU调度的基本单位。</li><li>更小的能独立运行的基本单位。</li><li>一个进程中可以有多个线程。<ul><li>内核支持线程KST（Kernel Supported Threads）<ul><li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行。</li><li>如果进程中的一个线程被阻塞了，内核可以知晓，并分配处理机给该进程中的其他线程。</li><li>线程切换快，开销小。</li><li>但是对于用户的线程切换，需要从用户态切换到内核态，开销大。</li></ul></li><li>用户级线程ULT（User Level Threads）<ul><li>线程的创建、撤销、同步、通信都无需内核的支持，内核甚至完全不知道用户级线程的存在。</li><li>用户的线程阻塞了，则会导致整个进程阻塞，因为内核只知道进程，不知道线程，就会认为是这个进程阻塞了。</li></ul></li></ul></li></ul><h4 id="必背考点：进程和线程的区别"><a href="#必背考点：进程和线程的区别" class="headerlink" title="必背考点：进程和线程的区别"></a>必背考点：进程和线程的区别</h4><ul><li>基本单位：进程是资源分配和调度的基本单位，线程是CPU调度的基本单位。</li><li>系统开销：进程的切换涉及进程上下文的切换，线程切换的代价远小于进程切换。</li><li>拥有资源：线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源（程序计数器PC、一组寄存器和栈）。此外还允许多个线程共享该进程所拥有的资源。而进程拥有比线程更多的资源。</li><li>独立性：线程间的独立性比进程间的独立性要低得多，因为线程是提高并发性而合作的，它们共享进程的内存地址空间和资源。而进程一般是独占某块内存。</li></ul><h3 id="2-7-3-什么是上下文切换"><a href="#2-7-3-什么是上下文切换" class="headerlink" title="2.7.3 什么是上下文切换"></a>2.7.3 什么是上下文切换</h3><p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 <strong>将 CPU 资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p><h3 id="2-7-4-使用多线程的好处是什么"><a href="#2-7-4-使用多线程的好处是什么" class="headerlink" title="2.7.4 使用多线程的好处是什么"></a>2.7.4 使用多线程的好处是什么</h3><p>多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处</p><ul><li>能够提高对用户的响应顺序</li><li>在流程中的资源共享</li><li>比较经济适用</li><li>能够对多线程架构有深入的理解</li></ul><h3 id="2-7-5-协程是什么"><a href="#2-7-5-协程是什么" class="headerlink" title="2.7.5 协程是什么"></a>2.7.5 协程是什么</h3><ul><li>协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。</li><li>不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。</li><li>协程属于用户态，协程之间的切换不需要系统调用，</li><li>其本质就是控制流主动让出和恢复机制，让控制流更加流畅</li></ul><h3 id="2-7-6-线程和协程的区别"><a href="#2-7-6-线程和协程的区别" class="headerlink" title="2.7.6 线程和协程的区别"></a>2.7.6 线程和协程的区别</h3><ul><li>调度方式：线程是操作系统调度，协程是应用程序自己调度（用户态）</li><li>栈空间：协程的栈空间是可以动态调整的</li><li>并发/并行：<ul><li>协程是协作式多任务，只能并发</li><li>线程是抢占式多任务，可以并发也可以并行</li></ul></li></ul><h2 id="2-8-调度算法"><a href="#2-8-调度算法" class="headerlink" title="2.8 调度算法"></a>2.8 调度算法</h2><h3 id="2-8-1-调度算法有哪些"><a href="#2-8-1-调度算法有哪些" class="headerlink" title="2.8.1 调度算法有哪些"></a>2.8.1 调度算法有哪些</h3><p>调度算法分为三大类：批处理中的调度、交互系统中的调度、实时系统中的调度</p><h4 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h4><p>先来先服务</p><p>很像是先到先得。。。可能最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380e331a1d0e4422b8a79e186248d3ec~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p><p>不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。</p><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30b66758daf74316b725cf3b00039b7f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，平均时间内为 14 分钟。</p><p>现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。</p><blockquote><p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p></blockquote><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p><h3 id="2-8-2-交互式系统中的调度"><a href="#2-8-2-交互式系统中的调度" class="headerlink" title="2.8.2 交互式系统中的调度"></a>2.8.2 交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p><h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c466a876ef043068fc4bcd8a14aa0b8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>事实情况是不是所有的进程都是优先级相等的。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c96f6a295d4e4386a8cbbc9120daa9ac~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p><p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p><h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12b88d9f80b74c7b834fda64f9f70514~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p><p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。他的基本思想为进程提供各种系统资源的<code>彩票</code>。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得资源。比如在 CPU 进行调度时，系统可以每秒持有 50 次抽奖，每个中奖进程会获得额外运行时间的奖励。</p><blockquote><p>可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 <code>速度之靴</code> 的效果。</p></blockquote><h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p><p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p><h3 id="2-8-3-影响调度程序的指标"><a href="#2-8-3-影响调度程序的指标" class="headerlink" title="2.8.3 影响调度程序的指标"></a>2.8.3 影响调度程序的指标</h3><p>会有下面几个因素决定调度程序的好坏</p><ul><li><h4 id="CPU-使用率："><a href="#CPU-使用率：" class="headerlink" title="CPU 使用率："></a>CPU 使用率：</h4></li></ul><p>CPU 正在执行任务（即不处于空闲状态）的时间百分比。</p><ul><li><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4></li></ul><p>这是进程轮流执行的时间，也就是进程切换的时间</p><ul><li><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4></li></ul><p>单位时间内完成进程的数量</p><ul><li><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4></li></ul><p>这是从提交流程到获得有用输出所经过的时间。</p><ul><li><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4></li></ul><p>从提交流程到完成流程所经过的时间。</p><h3 id="2-8-4-RR-调度算法"><a href="#2-8-4-RR-调度算法" class="headerlink" title="2.8.4 RR 调度算法"></a>2.8.4 RR 调度算法</h3><p><code>RR(round-robin)</code> 调度算法主要针对分时系统，RR 的调度算法会把时间片以相同的部分并循环的分配给每个进程，RR 调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片，并不存在线程饥饿的问题</p><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><h2 id="3-1-内存的基础知识和概念"><a href="#3-1-内存的基础知识和概念" class="headerlink" title="3.1 内存的基础知识和概念"></a>3.1 内存的基础知识和概念</h2><blockquote><p>为什么需要内存</p></blockquote><p>内存是计算机<code>其它硬件设备</code>与<code>CPU沟通</code>的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。</p><h3 id="3-1-1-cpu如何区分执行程序的数据在内存的什么地方"><a href="#3-1-1-cpu如何区分执行程序的数据在内存的什么地方" class="headerlink" title="3.1.1 cpu如何区分执行程序的数据在内存的什么地方"></a>3.1.1 cpu如何区分执行程序的数据在内存的什么地方</h3><ul><li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li><li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里<code>let a = 1</code>这段代码。</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17124ab5c2726806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="3-1-2-内存管理-内存空间的分配与回收"><a href="#3-1-2-内存管理-内存空间的分配与回收" class="headerlink" title="3.1.2 内存管理-内存空间的分配与回收"></a>3.1.2 内存管理-内存空间的分配与回收</h3><ul><li>内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li><li>这里我们只讲连续分配中的<code>动态分区分配</code>。</li><li>什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB…，现在我们有几个进程要装入内存，如下图）</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17133a8c513bbc25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li></ul><p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17133ad6cd968301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？</p><p>我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/171360901ecc8590?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。</p><p>这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17136299db333910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p><p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p><p>进程的页与内存的页框有着一一对应的关系。各个页不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><h2 id="3-2-虚拟内存"><a href="#3-2-虚拟内存" class="headerlink" title="3.2 虚拟内存"></a>3.2 虚拟内存</h2><h3 id="3-2-1-什么是虚拟内存"><a href="#3-2-1-什么是虚拟内存" class="headerlink" title="3.2.1 什么是虚拟内存"></a>3.2.1 什么是虚拟内存</h3><p><code>虚拟内存</code>是一种内存分配方案，是一项可以用来辅助内存分配的机制。我们知道，应用程序是按页装载进内存中的。但并不是所有的页都会装载到内存中，计算机中的硬件和软件会将数据从 RAM 临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你将计算机内存填满后，计算机会对你说，<strong>对不起，您无法再加载任何应用程序，请关闭另一个应用程序以加载新的应用程序</strong>。对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后将其复制到硬盘上。复制是自动进行的，你无法感知到它的存在。</p><h3 id="3-2-2-虚拟内存的实现方式"><a href="#3-2-2-虚拟内存的实现方式" class="headerlink" title="3.2.2 虚拟内存的实现方式"></a>3.2.2 虚拟内存的实现方式</h3><p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或<code>永久</code>的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p><ul><li>请求分页存储管理。</li><li>请求分段存储管理。</li><li>请求段页式存储管理。</li></ul><p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p><ul><li>一定容量的内存和外存。</li><li>页表机制（或段表机制），作为主要的数据结构。</li><li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li><li>地址变换机构，逻辑地址到物理地址的变换。</li></ul><h3 id="3-2-3-按需分页"><a href="#3-2-3-按需分页" class="headerlink" title="3.2.3 按需分页"></a>3.2.3 按需分页</h3><p>在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种<code>虚拟内存</code>的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了<code>缺页异常</code>，操作系统才会将磁盘页面复制到内存中。</p><h2 id="3-3-内存管理"><a href="#3-3-内存管理" class="headerlink" title="3.3 内存管理"></a>3.3 内存管理</h2><h3 id="3-3-1-分析内存为什么要分段"><a href="#3-3-1-分析内存为什么要分段" class="headerlink" title="3.3.1 分析内存为什么要分段"></a>3.3.1 分析内存为什么要分段</h3><p>内存是随机访问设备，对于内存来说，不需要从头开始查找，只需要直接给出地址即可。内存的分段是从 <code>8086 CPU</code> 开始的，8086 的 CPU 还是 16 位的寄存器宽，16 位的寄存器可以存储的数字范围是 2 的 16 次方，即 64 KB，8086 的 CPU 还没有 <code>虚拟地址</code>，只有物理地址，也就是说，如果两个相同的程序编译出来的地址相同，那么这两个程序是无法同时运行的。为了解决这个问题，操作系统设计人员提出了让 CPU 使用 <code>段基址 + 段内偏移</code> 的方式来访问任意内存。这样的好处是让程序可以 <code>重定位</code>，<strong>这也是内存为什么要分段的第一个原因</strong>。</p><blockquote><p>那么什么是重定位呢？</p></blockquote><p>简单来说就是将程序中的指令地址改为另一个地址，地址处存储的内容还是原来的。</p><p>CPU 采用段基址 + 段内偏移地址的形式访问内存，就需要提供专门的寄存器，这些专门的寄存器就是 <strong>CS、DS、ES 等</strong>。</p><p>也就是说，程序中需要用到哪块内存，就需要先加载合适的段到段基址寄存器中，再给出相对于该段基址的段偏移地址即可。CPU 中的地址加法器会将这两个地址进行合并，从地址总线送入内存。</p><p>8086 的 CPU 有 20 根地址总线，最大的寻址能力是 1MB，而段基址所在的寄存器宽度只有 16 位，最大为你 64 KB 的寻址能力，64 KB 显然不能满足 1MB 的最大寻址范围，所以就要把内存分段，每个段的最大寻址能力是 64KB，但是仍旧不能达到最大 1 MB 的寻址能力，所以这时候就需要 <code>偏移地址</code>的辅助，偏移地址也存入寄存器，同样为 64 KB 的寻址能力，这么一看还是不能满足 1MB 的寻址，所以 CPU 的设计者对地址单元动了手脚，将段基址左移 4 位，然后再和 16 位的段内偏移地址相加，就达到了 1MB 的寻址能力。<strong>所以内存分段的第二个目的就是能够访问到所有内存</strong>。</p><h3 id="3-3-2-物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><a href="#3-3-2-物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别" class="headerlink" title="3.3.2 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"></a>3.3.2 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</h3><p>物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p><p>在<code>实模式</code>下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为<code>物理地址</code>。</p><p>但是在<code>保护模式</code>下，段基址 + 段内偏移被称为<code>线性地址</code>，不过此时的段基址不能称为真正的地址，而是会被称作为一个<code>选择子</code>的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是<code>虚拟地址</code>。</p><p>不论在实模式还是保护模式下，段内偏移地址都叫做<code>有效地址</code>。有效地址也是逻辑地址。</p><p>线性地址可以看作是<code>虚拟地址</code>，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e19d5e052c4d2aa40c0c7fd0112e8b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3-3-3-空闲内存管理的方式"><a href="#3-3-3-空闲内存管理的方式" class="headerlink" title="3.3.3 空闲内存管理的方式"></a>3.3.3 空闲内存管理的方式</h3><p>操作系统在动态分配内存时（malloc，new），需要对空间内存进行管理。一般采用了两种方式：位图和空闲链表。</p><h4 id="使用位图进行管理"><a href="#使用位图进行管理" class="headerlink" title="使用位图进行管理"></a>使用位图进行管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed60e922592e4fdc9d798cafb87a945c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>图 a 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 b 表示对应的位图；图 c 表示用链表表示同样的信息</p></blockquote><p>分配单元的大小是一个重要的设计因素，分配单位越小，位图越大。然而，即使只有 4 字节的分配单元，32 位的内存也仅仅只需要位图中的 1 位。<code>32n</code> 位的内存需要 n 位的位图，所以<strong>1 个位图只占用了 1/32 的内存</strong>。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。</p><p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p><h4 id="使用空闲链表"><a href="#使用空闲链表" class="headerlink" title="使用空闲链表"></a>使用空闲链表</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p><p>在这个例子中，<code>段链表(segment list)</code>是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e4680bebd4e4762af719d8860f3cb80~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。</p><ul><li>首次适配算法：在链表中进行搜索，直到找到最初的一个足够大的空闲区，将其分配。除非进程大小和空间区大小恰好相同，否则会将空闲区分为两部分，一部分为进程使用，一部分成为新的空闲区。该方法是速度很快的算法，因为索引链表结点的个数较少。</li><li>下次适配算法：工作方式与首次适配算法相同，但每次找到新的空闲区位置后都记录当前位置，下次寻找空闲区从上次结束的地方开始搜索，而不是与首次适配放一样从头开始；</li><li>最佳适配算法：搜索整个链表，找出能够容纳进程分配的最小的空闲区。这样存在的问题是，尽管可以保证为进程找到一个最为合适的空闲区进行分配，但大多数情况下，这样的空闲区被分为两部分，一部分用于进程分配，一部分会生成很小的空闲区，而这样的空闲区很难再被进行利用。</li><li>最差适配算法：与最佳适配算法相反，每次分配搜索最大的空闲区进行分配，从而可以使得空闲区拆分得到的新的空闲区可以更好的被进行利用。</li></ul><h3 id="3-3-4-分页和分段式的存储管理方式"><a href="#3-3-4-分页和分段式的存储管理方式" class="headerlink" title="3.3.4 分页和分段式的存储管理方式"></a>3.3.4 分页和分段式的存储管理方式</h3><h4 id="分页式"><a href="#分页式" class="headerlink" title="分页式"></a>分页式</h4><ul><li>页内碎片：内零头</li><li>页（逻辑）</li><li>块（物理）</li><li>页表：系统为每个进程建立的一张页面映射表，页-&gt;块（页号-&gt;块号）</li><li>快表：高速缓冲寄存器，存放最近访问的页号/块号映射对。</li><li>寻址（逻辑地址 -&gt; 物理地址）</li><li>两级/多级页表</li></ul><p><img data-src="https://range0122.github.io/imgs/page1.png" alt="image"></p><p><img data-src="https://range0122.github.io/imgs/page2.png" alt="image"></p><h4 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h4><ul><li>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</li><li>每个段都有自己的名字。</li><li>每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</li><li>段表：段号，该段在内存中的起始地址（基址），段的长度。</li></ul><p><img data-src="https://range0122.github.io/imgs/segment.png" alt="image"></p><h4 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h4><p>外零头：可变分区时，可能会形成大量较小的，难以再分配的分区。动态划分没有内零头，静态划分有内零头</p><table><thead><tr><th align="left">分页</th><th>分段</th></tr></thead><tbody><tr><td align="left">信息的物理单位，减少外零头，提高内存利用率。</td><td>段是信息的逻辑单位，方便用户。</td></tr><tr><td align="left">大小固定，由系统决定</td><td>长度不固定，取决于用户所编写的程序。</td></tr><tr><td align="left">作业地址空间是一维的，因为页是连续的，逻辑地址空间是一维的，一张页表走到底就行了。（直接根据逻辑地址可以算出页号和页内地址，取余和除法取整）</td><td>作业地址空间是二维的，数据段、代码段、堆栈段等段号连续，但物理地址空间不连续。（二维：哪个段+段内地址）</td></tr><tr><td align="left">减少了外零头，但不能避免内零头</td><td>内零头不清楚，但是因为物理地址空间不连续，可能会产生一些外零头</td></tr></tbody></table><h4 id="段页式的存储管理方式"><a href="#段页式的存储管理方式" class="headerlink" title="段页式的存储管理方式"></a>段页式的存储管理方式</h4><p>先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。（先分段，段内再分页）</p><p><img data-src="https://range0122.github.io/imgs/page&segment.png" alt="image"></p><p>段号-&gt;段表-&gt;页表地址-&gt; + 页号-&gt;块号-&gt; +页内地址 =&gt; 物理地址</p><h2 id="3-4-页面置换算法"><a href="#3-4-页面置换算法" class="headerlink" title="3.4 页面置换算法"></a>3.4 页面置换算法</h2><p>在地址映射过程中，如果在页面中发现所要访问的页面不在内存中，那么就会产生一条缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，那么操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><p>下面我汇总的这些页面置换算法比较齐全，只给出简单介绍，算法具体的实现和原理读者可以自行了解。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3d27b068b124589baee535da749bcc0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="3-4-1-最佳置换算法-OPT，Optlmal"><a href="#3-4-1-最佳置换算法-OPT，Optlmal" class="headerlink" title="3.4.1 最佳置换算法(OPT，Optlmal)"></a>3.4.1 最佳置换算法(OPT，Optlmal)</h3><p>最佳置换算法又称作<code>最优算法</code>，在当前页面中置换最后要访问的页面。是所选择被淘汰的页面，将是以后永不使用的，或许是在最长时间内不再被访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，理想化，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</p><h3 id="3-4-2最近未使用算法-NRU"><a href="#3-4-2最近未使用算法-NRU" class="headerlink" title="3.4.2最近未使用算法(NRU)"></a>3.4.2最近未使用算法(NRU)</h3><p><code>NRU</code> 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</p><h3 id="3-4-3-先进先出置换算法（FIFO，First-In-First-Out）"><a href="#3-4-3-先进先出置换算法（FIFO，First-In-First-Out）" class="headerlink" title="3.4.3 先进先出置换算法（FIFO，First In First Out）"></a>3.4.3 先进先出置换算法（FIFO，First In First Out）</h3><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰 。跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面</p><p>页面调入的先后并不能反映页面的使用情况。所以这个效率差。</p><p><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</p><h3 id="3-4-4-最近最久未使用置换算法（LRU，Least-Recently-Used）"><a href="#3-4-4-最近最久未使用置换算法（LRU，Least-Recently-Used）" class="headerlink" title="3.4.4 最近最久未使用置换算法（LRU，Least Recently Used）"></a>3.4.4 最近最久未使用置换算法（LRU，Least Recently Used）</h3><ul><li>选择最近最久未使用的页面予以淘汰。</li><li>硬件支持：寄存器 和 栈</li></ul><p><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</p><ul><li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li><li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择。使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</li></ul><h3 id="3-4-5-最不经常使用算法（Least-Frequently-Used，LFU）"><a href="#3-4-5-最不经常使用算法（Least-Frequently-Used，LFU）" class="headerlink" title="3.4.5 最不经常使用算法（Least Frequently Used，LFU）"></a>3.4.5 最不经常使用算法（Least Frequently Used，LFU）</h3><p>使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</p><h3 id="3-4-6-时钟置换算法（Clock）："><a href="#3-4-6-时钟置换算法（Clock）：" class="headerlink" title="3.4.6 时钟置换算法（Clock）："></a>3.4.6 时钟置换算法（Clock）：</h3><ul><li>每页设置一个访问位，该页第一次装入内存或者被重新访问到时，置 = 1</li><li>置换时，检查每一页：<ul><li>若 = 1，则置 = 0；</li><li>若 = 0，则换出。</li></ul></li><li>其实就是多给被访问过的页面一次机会。</li></ul><p><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</p><h3 id="3-4-7-改进的时钟置换算法（Clock）："><a href="#3-4-7-改进的时钟置换算法（Clock）：" class="headerlink" title="3.4.7 改进的时钟置换算法（Clock）："></a>3.4.7 改进的时钟置换算法（Clock）：</h3><ul><li><p>除了访问位，还要考虑是否被修改过：</p><ul><li>访问过，修改过：别搞我</li><li>访问过，未修改：最好也别搞我</li><li>未访问，但修改过：也还是别搞我</li><li>未访问，也未修改：搞我搞我</li></ul></li><li><p>扫描：</p><ul><li>先扫描第一遍：找第四种，</li><li>没有的话扫描第二遍，访问位置0，寻找未访问，但修改过的。</li><li>没有的话第三遍，这个时候一定能成功</li></ul><p>是时钟置换算法的一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</p></li></ul><p><strong>最好的算法是老化算法和WSClock算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p><h1 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h1><h2 id="4-1-文件的定义和属性"><a href="#4-1-文件的定义和属性" class="headerlink" title="4.1 文件的定义和属性"></a>4.1 文件的定义和属性</h2><p>文件就是一组有意义的<code>信息/数据</code>集合。</p><p>计算机中存放了各种各样的文件，文件的属性包括：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171265b304cd6988?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li><li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li><li>类型。文件的类型。</li><li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li><li>创建时间、上次修改时间、文件所有者就是字面意思。</li><li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li></ul><h2 id="4-2-文件的组织方式"><a href="#4-2-文件的组织方式" class="headerlink" title="4.2 文件的组织方式"></a>4.2 文件的组织方式</h2><p>文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p><h3 id="4-2-1-文件内部数据如何组织在一起"><a href="#4-2-1-文件内部数据如何组织在一起" class="headerlink" title="4.2.1 文件内部数据如何组织在一起"></a>4.2.1 文件内部数据如何组织在一起</h3><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171266931ce296e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="4-2-2-文件之间如何组织起来"><a href="#4-2-2-文件之间如何组织起来" class="headerlink" title="4.2.2 文件之间如何组织起来"></a>4.2.2 文件之间如何组织起来</h3><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171266eca83a1fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p><h3 id="4-2-3-文件的逻辑结构"><a href="#4-2-3-文件的逻辑结构" class="headerlink" title="4.2.3 文件的逻辑结构"></a>4.2.3 文件的逻辑结构</h3><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171267e499b86cba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code></p><ul><li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li><li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li></ul><p>接下来我了解一下有结构文件的三种逻辑结构</p><h4 id="4-2-3-1-顺序文件"><a href="#4-2-3-1-顺序文件" class="headerlink" title="4.2.3.1 顺序文件"></a>4.2.3.1 顺序文件</h4><blockquote><p>什么是顺序文件</p></blockquote><p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code></p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/30/1712958537512c5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li><li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li><li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li></ul><p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/30/1712987dbb104bf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="4-2-3-2-索引文件"><a href="#4-2-3-2-索引文件" class="headerlink" title="4.2.3.2 索引文件"></a>4.2.3.2 索引文件</h4><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录，但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code></p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712f7c62e640c55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li><li>其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。</li><li>但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li></ul><h4 id="4-2-3-3-索引顺序文件"><a href="#4-2-3-3-索引顺序文件" class="headerlink" title="4.2.3.3 索引顺序文件"></a>4.2.3.3 索引顺序文件</h4><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712f97d9c361d47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="4-2-4-文件目录"><a href="#4-2-4-文件目录" class="headerlink" title="4.2.4 文件目录"></a>4.2.4 文件目录</h3><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712fa51d0e2cd5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p><p>文件目录的结构通常是<code>树状的</code>，例如linux里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712faea7fb6a47a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）</li><li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li></ul><h3 id="4-2-5-文件存储空间管理"><a href="#4-2-5-文件存储空间管理" class="headerlink" title="4.2.5 文件存储空间管理"></a>4.2.5 文件存储空间管理</h3><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1713015837097fc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/171301b2fb9a17b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130b5dbd9375ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li><li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li></ul><p>如何回收磁盘块呢，主要分为以下4中情况</p><ul><li>回收区的前后没有相邻空闲区</li><li>回收区前后都是空闲区</li><li>回收区前面是空前去</li><li>回收区后面是空闲区</li></ul><p>最重要的是要注意表项合并的问题。(比如说回收区前后都有空闲区就将其一起合并为一个空闲区)</p><h2 id="4-3-文件共享"><a href="#4-3-文件共享" class="headerlink" title="4.3 文件共享"></a>4.3 文件共享</h2><p>文件共享分为两种</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130c781a0ab962?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li><li>软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li><li>硬链接可以理解为js里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li></ul><h2 id="4-4-文件保护"><a href="#4-4-文件保护" class="headerlink" title="4.4 文件保护"></a>4.4 文件保护</h2><p>操作系统需要保护文件的安全，一般有如下3种方式：</p><ul><li>口令保护。是指为文件设置一个<code>“口令”</code>（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li><li>加密保护。使用某个<code>&quot;密码&quot;</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li><li>访问控制。在每个文件的FCB或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130f1a1ebbde6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="4-5-提高文件系统性能的方式"><a href="#4-5-提高文件系统性能的方式" class="headerlink" title="4.5 提高文件系统性能的方式"></a>4.5 提高文件系统性能的方式</h2><p>访问磁盘的效率要比内存慢很多，是时候又祭出这张图了</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62ac3982ff84a12af120b76dd8da95b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p><h3 id="4-5-1-高速缓存"><a href="#4-5-1-高速缓存" class="headerlink" title="4.5.1 高速缓存"></a>4.5.1 高速缓存</h3><p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p><p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p><p>高速缓存的操作如下图所示</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08c9eaae7d44d76975cb790dbbff765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作。然后在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p><p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似。</p><h3 id="4-5-2-块提前读"><a href="#4-5-2-块提前读" class="headerlink" title="4.5.2 块提前读"></a>4.5.2 块提前读</h3><p>第二个明显提高文件系统的性能是<strong>在需要用到块之前试图提前将其写入高速缓存从而提高命中率</strong>。许多文件都是<code>顺序读取</code>。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p><p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p><h3 id="4-5-3-减少磁盘臂运动"><a href="#4-5-3-减少磁盘臂运动" class="headerlink" title="4.5.3 减少磁盘臂运动"></a>4.5.3 减少磁盘臂运动</h3><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p><p>不过，即使采用空闲表，也可以使用 <code>块簇</code> 技术。即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有 512 个字节，有可能系统采用 1 KB 的块（2 个扇区），但却按每 2 块（4 个扇区）一个单位来分配磁盘存储区。这和 2 KB 的磁盘块并不相同，因为在高速缓存中它仍然使用 1 KB 的块，磁盘与内存数据之间传送也是以 1 KB 进行，但在一个空闲的系统上顺序读取这些文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方法的变体。在分配块时，系统尽量把一个文件中的连续块存放在同一个柱面上。</p><p>在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：<strong>一次是访问 inode，一次是访问块</strong>。通常情况下，inode 的放置如下图所示</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d93b28049444348a2fb25650dc3b6b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。</p><p>一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表，如上图 b 所示。</p><p>当然，只有在磁盘中装有磁盘臂的情况下，讨论寻道时间和旋转时间才是有意义的。现在越来越多的电脑使用 <code>固态硬盘(SSD)</code>，对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问和顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。但是也引发了新的问题。</p><h3 id="4-5-4-磁盘碎片整理"><a href="#4-5-4-磁盘碎片整理" class="headerlink" title="4.5.4 磁盘碎片整理"></a>4.5.4 磁盘碎片整理</h3><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p><p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p><p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p><h2 id="4-6-磁盘臂调度算法"><a href="#4-6-磁盘臂调度算法" class="headerlink" title="4.6 磁盘臂调度算法"></a>4.6 磁盘臂调度算法</h2><p>一般情况下，影响磁盘快读写的时间由下面几个因素决定</p><ul><li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li><li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li><li>实际数据的读取或者写入时间</li></ul><p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p><p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p><p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p><p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p><p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/184e699da9aa45d6af274952d81c476e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a63f65a6f9483dabe5b951a5915c98~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p><p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p><p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p><p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN </code>时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p><p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3917654aeb4f65ab0ecde925675531~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p><p>电梯算法通常情况下不如 SSF 算法。</p><p>一些磁盘控制器为软件提供了一种检查磁头下方当前扇区号的方法，使用这样的控制器，能够进行另一种优化。如果对一个相同的柱面有两个或者多个请求正等待处理，驱动程序可以发出请求读写下一次要通过磁头的扇区。</p><blockquote><p>这里需要注意一点，当一个柱面有多条磁道时，相继的请求可能针对不同的磁道，这种选择没有代价，因为选择磁头不需要移动磁盘臂也没有旋转延迟。</p></blockquote><p>对于磁盘来说，最影响性能的就是寻道时间和旋转延迟，所以一次只读取一个或两个扇区的效率是非常低的。出于这个原因，许多磁盘控制器总是读出多个扇区并进行高速缓存，即使只请求一个扇区时也是这样。一般情况下读取一个扇区的同时会读取该扇区所在的磁道或者是所有剩余的扇区被读出，读出扇区的数量取决于控制器的高速缓存中有多少可用的空间。</p><p>磁盘控制器的高速缓存和操作系统的高速缓存有一些不同，磁盘控制器的高速缓存用于缓存没有实际被请求的块，而操作系统维护的高速缓存由显示地读出的块组成，并且操作系统会认为这些块在近期仍然会频繁使用。</p><p>当同一个控制器上有多个驱动器时，操作系统应该为每个驱动器都单独的维护一个未完成的请求表。一旦有某个驱动器闲置时，就应该发出一个寻道请求来将磁盘臂移到下一个被请求的柱面。如果下一个寻道请求到来时恰好没有磁盘臂处于正确的位置，那么驱动程序会在刚刚完成传输的驱动器上发出一个新的寻道命令并等待，等待下一次中断到来时检查哪个驱动器处于闲置状态。</p><h2 id="4-7-RAID-的不同级别"><a href="#4-7-RAID-的不同级别" class="headerlink" title="4.7 RAID 的不同级别"></a>4.7 RAID 的不同级别</h2><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p><p>RAID 有不同的级别</p><ul><li>RAID 0 - 无容错的条带化磁盘阵列</li><li>RAID 1 - 镜像和双工</li><li>RAID 2 - 内存式纠错码</li><li>RAID 3 - 比特交错奇偶校验</li><li>RAID 4 - 块交错奇偶校验</li><li>RAID 5 - 块交错分布式奇偶校验</li><li>RAID 6 - P + Q冗余</li></ul><h1 id="5-IO设备"><a href="#5-IO设备" class="headerlink" title="5. IO设备"></a>5. IO设备</h1><h2 id="5-1-I-O设备的定义与分类"><a href="#5-1-I-O设备的定义与分类" class="headerlink" title="5.1 I/O设备的定义与分类"></a>5.1 I/O设备的定义与分类</h2><h3 id="5-1-1-I-O设备定义"><a href="#5-1-1-I-O设备定义" class="headerlink" title="5.1.1 I/O设备定义"></a>5.1.1 I/O设备定义</h3><p>I/O就是<code>输入输出</code>(Input/Output)的意思，I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171255f53e94df47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="5-1-2-I-O设备分类——按使用特性"><a href="#5-1-2-I-O设备分类——按使用特性" class="headerlink" title="5.1.2 I/O设备分类——按使用特性"></a>5.1.2 I/O设备分类——按使用特性</h3><ul><li>人机交互类设备，这类设备传输数据的速度慢</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/1712560a47c66aba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>存储设备，这类设备传输数据的速度较快</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17125616ebd6d68d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li></ul><h3 id="5-1-3-设备驱动程序"><a href="#5-1-3-设备驱动程序" class="headerlink" title="5.1.3 设备驱动程序"></a>5.1.3 设备驱动程序</h3><p>在计算机中，设备驱动程序是一种计算机程序，它能够控制或者操作连接到计算机的特定设备。驱动程序提供了与硬件进行交互的软件接口，使操作系统和其他计算机程序能够访问特定设备，不用需要了解其硬件的具体构造。</p><h3 id="5-1-4-五种I-O模型"><a href="#5-1-4-五种I-O模型" class="headerlink" title="5.1.4 五种I/O模型"></a>5.1.4 五种I/O模型</h3><p><img data-src="https://range0122.github.io/imgs/IO.png" alt="image"></p><h2 id="5-2-I-O控制"><a href="#5-2-I-O控制" class="headerlink" title="5.2 I/O控制"></a>5.2 I/O控制</h2><h3 id="5-2-1-I-O控制器"><a href="#5-2-1-I-O控制器" class="headerlink" title="5.2.1 I/O控制器"></a>5.2.1 I/O控制器</h3><p>CPU无法直接控制<code>I/O设备的机械部件</code>，因此I/O设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现CPU对设备的控制。这个电子部件就是<code>I/O控制器</code>。I/O控制器是一个<code>可编址</code>的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；如果I/O控制器控制多个可连接设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。</p><p>I/O控制器主要分为两种：字符设备和块设备</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171258cd27939935?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>接收和识别CPU发出的指令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li><li>向cpu报告设备的状态是指，I/O控制器会有相应的<code>状态寄存器</code>，用来记录I/O设备<code>是否空闲</code>或者<code>忙碌</code></li><li>数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li><li>地址识别：为了区分I/O控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器地址唯一。I/O控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器</li><li>差错检测：I/O控制器还具有对设备传递过来的数据进行检测的功能。</li></ul><h3 id="5-2-2-I-O控制方式"><a href="#5-2-2-I-O控制方式" class="headerlink" title="5.2.2 I/O控制方式"></a>5.2.2 I/O控制方式</h3><ul><li><p>这里我们指讲一下目前比较先进的方式，通道控制方式。</p></li><li><p>通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。</p></li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17125a5e38698d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><br>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向CPU发出<code>中断</code>，不需要轮询来问I/O设备是否完成CPU下达的任务。</p><h2 id="5-3-操作系统中的时钟"><a href="#5-3-操作系统中的时钟" class="headerlink" title="5.3 操作系统中的时钟"></a>5.3 操作系统中的时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p><h4 id="5-3-1-时钟硬件"><a href="#5-3-1-时钟硬件" class="headerlink" title="5.3.1 时钟硬件"></a>5.3.1 时钟硬件</h4><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p><ul><li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li><li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li></ul><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b460cfde9e48df86195e34aeea1ea3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p><h2 id="5-4-操作系统的中断处理过程"><a href="#5-4-操作系统的中断处理过程" class="headerlink" title="5.4 操作系统的中断处理过程"></a>5.4 操作系统的中断处理过程</h2><p>中断处理方案有很多种，下面是 《<strong>ARM System Developer’s Guide</strong></p><p><strong>Designing and Optimizing System Software</strong>》列出来的一些方案</p><ul><li><code>非嵌套</code>的中断处理程序按照顺序处理各个中断，非嵌套的中断处理程序也是最简单的中断处理</li><li><code>嵌套</code>的中断处理程序会处理多个中断而无需分配优先级</li><li><code>可重入</code>的中断处理程序可使用优先级处理多个中断</li><li><code>简单优先级</code>中断处理程序可处理简单的中断</li><li><code>标准优先级</code>中断处理程序比低优先级的中断处理程序在更短的时间能够处理优先级更高的中断</li><li><code>高优先级</code> 中断处理程序在短时间能够处理优先级更高的任务，并直接进入特定的服务例程。</li><li><code>优先级分组</code>中断处理程序能够处理不同优先级的中断任务</li></ul><p>下面是一些通用的中断处理程序的步骤，不同的操作系统实现细节不一样</p><ul><li>保存所有没有被中断硬件保存的寄存器</li><li>为中断服务程序设置上下文环境，可能包括设置 <code>TLB</code>、<code>MMU</code> 和页表，如果不太了解这三个概念，请参考另外一篇文章</li><li>为中断服务程序设置栈</li><li>对中断控制器作出响应，如果不存在集中的中断控制器，则继续响应中断</li><li>把寄存器从保存它的地方拷贝到进程表中</li><li>运行中断服务程序，它会从发出中断的设备控制器的寄存器中提取信息</li><li>操作系统会选择一个合适的进程来运行。如果中断造成了一些优先级更高的进程变为就绪态，则选择运行这些优先级高的进程</li><li>为进程设置 MMU 上下文，可能也会需要 TLB，根据实际情况决定</li><li>加载进程的寄存器，包括 PSW 寄存器</li><li>开始运行新的进程</li></ul><p>上面我们罗列了一些大致的中断步骤，不同性质的操作系统和中断处理程序能够处理的中断步骤和细节也不尽相同，下面是一个嵌套中断的具体运行步骤</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55f7584a42543ff92cb0214a70ba6b0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="5-5-DMA-直接内存访问"><a href="#5-5-DMA-直接内存访问" class="headerlink" title="5.5 DMA(直接内存访问)"></a>5.5 DMA(直接内存访问)</h2><p>DMA 的中文名称是<code>直接内存访问</code>，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。</p><p>DMA 方式有如下特点：</p><ul><li>数据传送以数据块为基本单位</li><li>所传送的数据从设备直接送入主存，或者从主存直接输出到设备上</li><li>仅在传送一个或多个数据块的开始和结束时才需 CPU 的干预，而整块数据的传送则是在控制器的控制下完成。</li></ul><p>DMA 方式和中断驱动控制方式相比，减少了 CPU 对 I/O 操作的干预，进一步提高了 CPU 与 I/O 设备的并行操作程度。</p><p>DMA 方式的线路简单、价格低廉，适合高速设备与主存之间的成批数据传送，小型、微型机中的快速设备均采用这种方式，但其功能较差，不能满足复杂的 I/O 要求。</p><h1 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h1><h2 id="6-1-产生死锁的原因"><a href="#6-1-产生死锁的原因" class="headerlink" title="6.1 产生死锁的原因"></a>6.1 产生死锁的原因</h2><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p><h4 id="必背考点：死锁产生的原因"><a href="#必背考点：死锁产生的原因" class="headerlink" title="必背考点：死锁产生的原因"></a>必背考点：死锁产生的原因</h4><ul><li>死锁：进程间因为竞争资源而导致的一种僵持状态。</li><li>竞争资源（不可抢占性资源、可消耗性资源）</li><li>进程间推进顺序非法。（进程在运行过程中，请求和释放资源的顺序不当）</li></ul><h2 id="6-2-死锁的原因"><a href="#6-2-死锁的原因" class="headerlink" title="6.2 死锁的原因"></a>6.2 死锁的原因</h2><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p><p>资源死锁可能出现的情况主要有</p><ul><li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li><li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li><li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li><li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ul><h4 id="必背考点：死锁产生的必要条件"><a href="#必背考点：死锁产生的必要条件" class="headerlink" title="必背考点：死锁产生的必要条件"></a>必背考点：死锁产生的必要条件</h4><ul><li>互斥：进程对所分配的资源排他性使用</li><li>请求和保持：进程有一/多个资源了，还在请求新的资源</li><li>不可抢占：进程所分配的资源，用完之前不能被剥夺，只能在用完的时候进程自己释放。</li><li>循环等待：发生死锁的时候，必然存在一个进程与资源的环形链</li></ul><h2 id="6-3-死锁的恢复方式"><a href="#6-3-死锁的恢复方式" class="headerlink" title="6.3 死锁的恢复方式"></a>6.3 死锁的恢复方式</h2><p>所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p><h3 id="6-3-1-通过抢占进行恢复"><a href="#6-3-1-通过抢占进行恢复" class="headerlink" title="6.3.1 通过抢占进行恢复"></a>6.3.1 通过抢占进行恢复</h3><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><h3 id="6-3-2-通过回滚进行恢复"><a href="#6-3-2-通过回滚进行恢复" class="headerlink" title="6.3.2 通过回滚进行恢复"></a>6.3.2 通过回滚进行恢复</h3><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p><p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><h3 id="6-3-3-杀死进程恢复"><a href="#6-3-3-杀死进程恢复" class="headerlink" title="6.3.3 杀死进程恢复"></a>6.3.3 杀死进程恢复</h3><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p><p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p><h2 id="6-4-如何破坏死锁"><a href="#6-4-如何破坏死锁" class="headerlink" title="6.4 如何破坏死锁"></a>6.4 如何破坏死锁</h2><p>和死锁产生的必要条件一样，如果要破坏死锁，也是从下面四种方式进行破坏。</p><h3 id="6-4-1-破坏互斥条件"><a href="#6-4-1-破坏互斥条件" class="headerlink" title="6.4.1 破坏互斥条件"></a>6.4.1 破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p><p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p><p>因此，尽量做到尽可能少的进程可以请求资源。</p><h3 id="6-4-2-破坏保持等待的条件"><a href="#6-4-2-破坏保持等待的条件" class="headerlink" title="6.4.2 破坏保持等待的条件"></a>6.4.2 破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p><p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p><p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p><h3 id="6-4-3-破坏不可抢占条件"><a href="#6-4-3-破坏不可抢占条件" class="headerlink" title="6.4.3 破坏不可抢占条件"></a>6.4.3 破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过<code>虚拟化</code>的方式来避免这种情况。</p><h3 id="6-4-4-破坏循环等待条件"><a href="#6-4-4-破坏循环等待条件" class="headerlink" title="6.4.4 破坏循环等待条件"></a>6.4.4 破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。</p><p>另一种方式是将所有的资源统一编号，如下图所示</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55249c1fb9734d1ebd5af53a63bc128a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c332cc68dd79441ebe50b6f99c85735a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h4 id="必背考点-预防死锁"><a href="#必背考点-预防死锁" class="headerlink" title="必背考点 预防死锁"></a>必背考点 预防死锁</h4><ul><li><p><strong>“互斥”</strong>：必不可少，无法打破。</p></li><li><p>“请求和保持”</p><p>：一次性分配所有所需的资源</p><ul><li>（或者 需要什么就请求什么，不再需要什么就释放什么）</li><li>简单、易实现、安全</li><li>资源被浪费、进程延迟运行</li></ul></li><li><p>“不可抢占”</p><p>：进程已经获得一些资源的时候，如果请求新的资源失败，则放弃当前已经拥有的资源</p><ul><li>实现复杂、代价大，可能前功尽弃、进程前后两次运行的信息不连续</li></ul></li><li><p>“循环等待”</p><p>：系统将资源按类型先行排序，并且赋予不同的序号。进程对资源的请求必须严格按照资源的序号递增的次序提出，这样就不会出现环路。</p><ul><li>进程使用资源的顺序，可能与系统规定的顺序不同，造成资源的浪费。</li><li>序号稳定之后，限制了新设备的增加</li></ul></li></ul><h2 id="6-5-孤儿进程和僵尸进程"><a href="#6-5-孤儿进程和僵尸进程" class="headerlink" title="6.5 孤儿进程和僵尸进程"></a>6.5 孤儿进程和僵尸进程</h2><h3 id="6-5-1-父进程与子进程"><a href="#6-5-1-父进程与子进程" class="headerlink" title="6.5.1 父进程与子进程"></a>6.5.1 父进程与子进程</h3><p>在学习接下来的内容之前，需要对父进程和子进程有一个清晰的认识</p><p>在Linux里，除了进程0（即PID=0的进程）以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。</p><p>fork函数包含在unistd.h库中，其最主要的特点是，调用一次，返回两次，当父进程fork()创建子进程失败时，fork()返回-1，当父进程fork()创建子进程成功时，此时，父进程会返回子进程的pid，而子进程返回的是0。所以可以根据返回值的不同让父进程和子进程执行不同的代码</p><p><img data-src="https://pic3.zhimg.com/80/v2-ecd96829be63c2c7fdfba106413c9396_720w.jpg" alt="img"></p><p>如上图所示，当fork()函数调用后，父进程中的变量pid赋值成子进程的pid(pid&gt;0)，所以父进程会执行else里的代码，打印出”This is the parent”，而子进程的变量pid赋值成0，所以子进程执行if(pid == 0)里的代码，打印出”This is the child”</p><p>现在我们知道，在Linux中，正常情况下，子进程是通过父进程创建的，子进程再创建新的子进程。但是子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p><p>知道了这些，我们再来了解两种特殊的进程</p><h3 id="6-5-2-僵尸进程"><a href="#6-5-2-僵尸进程" class="headerlink" title="6.5.2 僵尸进程"></a>6.5.2 僵尸进程</h3><p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。僵尸进程通常发生在父子关系的进程中，由于父进程仍需要读取其子进程的退出状态所造成的。</p><blockquote><p>当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程</p></blockquote><p>简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程</p><p>上文中提到的进程的僵死状态Z(zombie)就是僵尸进程对应的状态</p><p>我们可以写一个程序来查看一下僵尸进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>,getpid());</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//这段代码只有子进程能够运行到，因为在子进程中fork的返回值为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the child!pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//退出进程</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//这段代码只有父进程能运行到</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the parent!pid = %d\n&quot;</span>,getpid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当fork成功时下面的代码父子进程都会运行到</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ ./zombie </span><br><span class="line">pid = 24816</span><br><span class="line">This is the parent!pid = 24816</span><br><span class="line">-------------pid = 24816</span><br><span class="line">This is the child!pid = 24817</span><br><span class="line">-------------pid = 24816</span><br><span class="line">-------------pid = 24816</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>在程序开始运行时立即查看进程：</p><p><em>(这里我分别运行了两次，分别使用ps -ef和ps -aux查看了进程状态，所以两次的进程PID是不同的)</em></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -ef | grep -v grep | grep zombie</span><br><span class="line">ubuntu   23797 15818  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line">ubuntu   23798 23797  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -aux | grep -v grep | grep zombie</span><br><span class="line">ubuntu   24288  0.0  0.0   4352   648 pts/0    S+   14:56   0:00 ./zombie</span><br><span class="line">ubuntu   24289  0.0  0.0   4352    80 pts/0    S+   14:56   0:00 ./zombie</span><br></pre></td></tr></table></figure><p>在进程运行五秒后再次查看进程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -ef | grep -v grep | grep zombie</span><br><span class="line">ubuntu   23797 15818  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line">ubuntu   23798 23797  0 14:53 pts/0    00:00:00 [zombie] &lt;defunct&gt;</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -aux | grep -v grep | grep zombie</span><br><span class="line">ubuntu   24288  0.0  0.0   4352   648 pts/0    S+   14:56   0:00 ./zombie</span><br><span class="line">ubuntu   24289  0.0  0.0      0     0 pts/0    Z+   14:56   0:00 [zombie] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>可以看出当进程运行五秒后，子进程状态变成Z，就是僵死状态，子进程就成了僵尸进程</p><p>其实，僵尸进程是有危害的。进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，当一个进程一直处于Z状态，那么它的PCB也就一直都要被维护。因为PCB本身就是一个结构体会占用空间，僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生</p><h3 id="6-5-3-孤儿进程"><a href="#6-5-3-孤儿进程" class="headerlink" title="6.5.3 孤儿进程"></a>6.5.3 孤儿进程</h3><p>孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>来段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the child!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());<span class="comment">//父进程退出前的pid和ppid</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\npid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());<span class="comment">//父进程退出后的pid和ppid</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the father!\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process is exited!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ ./orphan </span><br><span class="line">This is the father!</span><br><span class="line">This is the child!</span><br><span class="line">pid = 2338,ppid = 2337</span><br><span class="line">father process is exited!</span><br><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ </span><br><span class="line">pid = 2338,ppid = 1</span><br></pre></td></tr></table></figure><p>我们可以看到结果和我们预见的是一样的，孤儿进程在父进程退出后会被init进程领养，直到自己运行结束为止。这个程序很容易理解,先输出子进程的pid和父进程的pid，再然后子进程开始睡眠父进程退出，这时候子进程变成孤儿进程，再次输出时，该进程的父进程变为init</p><p>孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害。</p><h2 id="6-6-死锁类型"><a href="#6-6-死锁类型" class="headerlink" title="6.6 死锁类型"></a>6.6 死锁类型</h2><h3 id="6-6-1-两阶段加锁"><a href="#6-6-1-两阶段加锁" class="headerlink" title="6.6.1 两阶段加锁"></a>6.6.1 两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p><p>一种解决方式是使用 <code>两阶段提交(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p><p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p><p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p><h3 id="6-6-2-通信死锁"><a href="#6-6-2-通信死锁" class="headerlink" title="6.6.2 通信死锁"></a>6.6.2 通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p><p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p><p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p><p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p><p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d399e4206ebb4ae49c7037c77f8a91e0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p><h3 id="6-6-3-活锁"><a href="#6-6-3-活锁" class="headerlink" title="6.6.3 活锁"></a>6.6.3 活锁</h3><p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p><p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p><h3 id="6-6-4-饥饿"><a href="#6-6-4-饥饿" class="headerlink" title="6.6.4 饥饿"></a>6.6.4 饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p><p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p><h1 id="7-Linux常用命令"><a href="#7-Linux常用命令" class="headerlink" title="7. Linux常用命令"></a>7. Linux常用命令</h1><h2 id="7-1-Linux系统"><a href="#7-1-Linux系统" class="headerlink" title="7.1 Linux系统"></a>7.1 Linux系统</h2><ul><li><code>pwd</code> 打印当前工作目录</li><li><code>cd</code> 改变目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin  绝对路径从根目录出发，到达目标目录</span><br><span class="line">cd .&#x2F;usr 相对路径从工作目录出发，到达目标目录</span><br><span class="line">cd .. 到达父目录</span><br><span class="line">cd(cd ~) 到达家目录，如果未root用户，pwd会打印出 &#x2F;root，其上一层为 根目录&#x2F;</span><br><span class="line">cd &#x2F; (cd -) 回到根目录</span><br></pre></td></tr></table></figure><ul><li><code>ls</code> 列出目录内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -l 使用长格式显示结果</span><br><span class="line">ls -t 按修改时间排序</span><br><span class="line">ls -r 以相反的顺序显示</span><br><span class="line">ls -S 按文件大小对结果进行排序</span><br><span class="line">ls -R [文件夹] 列出文件树</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li><code>file</code> 确定文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure><ul><li><code>less</code> 查看文件内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><ul><li><code>touch</code> 新建文件</li></ul><h2 id="7-2-操作文件与目录"><a href="#7-2-操作文件与目录" class="headerlink" title="7.2 操作文件与目录"></a>7.2 操作文件与目录</h2><ul><li><code>mkdir</code> 创建目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1              创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3    创建多个目录</span><br><span class="line">mkdir -p dir&#123;1..9&#125;      创建多个目录a1到a9</span><br><span class="line">mkdir -p a&#123;1..3&#125;&#x2F;b&#123;1..3&#125;创建多个目录a1到a3，并且在每个目录下创建b1到b3</span><br></pre></td></tr></table></figure><ul><li><code>cp</code> 复制文件或目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2          将文件file1复制到file2中,file2内容将会被覆盖</span><br><span class="line">cp -r dir1 dir2         复制目录时一定要加 -r，如果dir2目录存在，则会复制到dir2目录下和mv是一样的道理</span><br><span class="line">cp file1 file2 dir1     将多个文件复制到一个目录下</span><br></pre></td></tr></table></figure><p><code>cp</code>命令选项</p><p><code>cp</code>在覆盖已存在的文件时默认情况下是 <code>cp -i</code>，即需要用户确认，我们可以这样 <code>\cp</code> 即可无需确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-r          递归复制目录及其内容。复制目录时需要这个选项</span><br><span class="line">-u          将文件从一个目录复制到另一个目录时，只会复制目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          复制文件时显示信息性消息</span><br></pre></td></tr></table></figure><ul><li><code>mv</code> 重命名或移动文件和目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv item1 item2              将文件或目录item1移动或重命名为item2</span><br><span class="line">mv item1 item2 item3 dir1   将多个条目移动到dir1目录下</span><br></pre></td></tr></table></figure><p><code>mv</code>命令选项与<code>cp</code>大致相同，<code>mv</code>没有<code>-r</code>选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-u          将文件从一个目录移动到另一个目录时，只会移动目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          移动时显示信息性消息</span><br></pre></td></tr></table></figure><ul><li><code>rm</code> 删除文件或目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r item1 item2 item3         删除item1,item2,item3,删除目录时需要-r</span><br><span class="line">rm *.html                       删除以.html结尾的文件</span><br></pre></td></tr></table></figure><p><code>rm</code>命令选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          删除前提示用户确认</span><br><span class="line">-r          递归删除目录及其内容。删除目录时需要这个选项</span><br><span class="line">-f          忽略不存在的文件，并无需提示确认</span><br><span class="line">-v          删除时显示信息性消息</span><br></pre></td></tr></table></figure><ul><li><code>ln</code> 创建硬链接和符号链接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln file hard-link-name      创建file文件的硬链接</span><br><span class="line">ln -s file sym-link-name    创建file文件的符号链接，符号链接指向源文件，与源文件内容保持一致</span><br></pre></td></tr></table></figure><p><code>file</code>为相对于<code>sym-link-name</code>的文件，即为相对路径，当然也可以是绝对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ..&#x2F;file sym-link-name     file在当前目录的父目录中，即file相对于sym-link-name的位置</span><br></pre></td></tr></table></figure><h2 id="7-3-读写文件"><a href="#7-3-读写文件" class="headerlink" title="7.3 读写文件"></a>7.3 读写文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;I am fine&quot;                        打印 I am fine</span><br><span class="line">echo &quot;I am fine&quot; &gt; &#x2F;root&#x2F;test.txt       将 I am fine写入&#x2F;root&#x2F;test.txt中</span><br><span class="line">echo &quot;I am fine&quot; &gt;&gt; &#x2F;root&#x2F;test.txt      将 I am fine追加到&#x2F;root&#x2F;test.txt末尾</span><br><span class="line">grep &quot;关键字&quot; test.txt                  在test.txt中查找含有关键字的行并打印</span><br><span class="line">grep -v &quot;关键字&quot; test.txt               在test.txt中查找不含有关键字的行并打印</span><br><span class="line">grep ^&quot;关键字&quot; test.txt                 在test.txt中查找以关键字开头的行并打印</span><br><span class="line">grep $&quot;关键字&quot; test.txt                 在test.txt中查找以关键字结尾的行并打印</span><br></pre></td></tr></table></figure><h2 id="7-4-管道"><a href="#7-4-管道" class="headerlink" title="7.4 管道"></a>7.4 管道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &quot;关键字&quot; &gt; &#x2F;root&#x2F;test.txt  列出当前目录文件信息并交给grep过滤，最后写入&#x2F;root&#x2F;test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍操作系统，作为非科班同学，这一块应该好好学习，不仅仅是应付面试，之前就突击了线程、进程、死锁的知识，别的就是一窍不通了，这次尽可能了解完整的操作系统知识体系。一个简单的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们的JS代码里，只需要输入 &lt;code&gt;console.log(1 + 1)&lt;/code&gt;; 就可以在浏览器面板中看到&lt;code&gt;2&lt;/code&gt;，这其中发生了什么事情呢?&lt;/li&gt;
&lt;li&gt;首先键盘输入代码&lt;code&gt;1 + 1&lt;/code&gt;到显示器输出&lt;code&gt;2&lt;/code&gt;, 需要&lt;code&gt;CPU&lt;/code&gt;控制键盘（输入设备），将获取的&lt;code&gt;1 + 1&lt;/code&gt;指令放入内存&lt;/li&gt;
&lt;li&gt;然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个&lt;code&gt;1 + 1&lt;/code&gt;的加法运算&lt;/li&gt;
&lt;li&gt;此时CPU的控制将控制CPU的运算器做&lt;code&gt;1 + 1&lt;/code&gt;的加法运算，并得出结果&lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果&lt;code&gt;2&lt;/code&gt;返回给屏幕（输出设备）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础" scheme="https://hxy1997.xyz/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://hxy1997.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成</title>
    <link href="https://hxy1997.xyz/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <id>https://hxy1997.xyz/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</id>
    <published>2021-03-26T06:30:00.000Z</published>
    <updated>2021-03-30T03:00:00.875Z</updated>
    
    <content type="html"><![CDATA[<p>其实学习80C51单片机的时候已经学过了一些相关知识，觉得还算有趣，我们通常使用的计算机原来是怎么构成的，就是真实感受汇编语言不会编，记得大作业那个红绿灯搞了我很久，当时搞出来的时候我热泪盈眶。</p><p>上面是闲话，还是当越深入学习，越会发现计算机组成的重要性。</p><p>比如知道js里面<code>0.1 + 0.2</code> 是<code>不等于0.3</code>的，为什么呢？这就牵扯到计算机组成原理中<code>浮点数</code>的表示方法，以及<code>浮点数</code>的加减运算，当时学Verilog的大作业，对于浮点数来说，乘除法反而好些，加减法写了半天。</p><p>又例如从键盘输入<code>a+b</code>这个指令，如何通过<code>cpu</code>的调度输出到<code>屏幕上</code>呢？这就涉及到<code>冯诺依曼体系</code>，如果你是编程人员，都不清楚数据从键盘到屏幕的<code>基本流向</code>，输入、输出设备、中央处理器是做什么的都不知道，真的该下定决心补一补这些基础。</p><span id="more"></span><h1 id="1-计算机的基本组成"><a href="#1-计算机的基本组成" class="headerlink" title="1.计算机的基本组成"></a>1.计算机的基本组成</h1><h2 id="1-1-冯·诺依曼计算机的特点"><a href="#1-1-冯·诺依曼计算机的特点" class="headerlink" title="1.1 冯·诺依曼计算机的特点"></a>1.1 冯·诺依曼计算机的特点</h2><ul><li>计算机由运算器、存储器、控制器、输入设备和输出设备组成</li><li>指令由操作码（表示操作的性质）和地址码（表示操作数在存储器中的位置）组成</li><li>指令和数据皆用二进制表示</li><li>指令和数据以同等地位存放于存储器内，并可按地址寻访</li><li>指令在存储器内按顺序存放，通常是顺序执行的。但也可根据运算结果或设定的条件，改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器之间的数据传送通过运算器完成</li></ul><h2 id="1-2-计算机硬件框图"><a href="#1-2-计算机硬件框图" class="headerlink" title="1.2 计算机硬件框图"></a>1.2 计算机硬件框图</h2><p>现代计算机可认为由三大部分组成：CPU、I/O 设备及主存储器（Main Memory，MM），如下图所示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec1959586293?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="现代计算机的组成框图"></p><ul><li>M⋅M（Main Memory）：主存储器，也就是常说的内存，与CPU直接交换信息。此外还有辅存，如硬盘、U盘等;</li><li>ALU（Arithmetic Logic Unit）：算数逻辑运算单元；</li><li>CU（Contro Unit）：控制单元，解释存储器中的指令，并发出各种命令执行指令。</li></ul><h2 id="1-3-细化的计算机组成框图"><a href="#1-3-细化的计算机组成框图" class="headerlink" title="1.3 细化的计算机组成框图"></a>1.3 细化的计算机组成框图</h2><p>为了形象地了解计算机的工作过程，对现代计算机的组成框图进行细化：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec19595e1b31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="细化的计算机组成框图"></p><h3 id="1-3-1-运算器"><a href="#1-3-1-运算器" class="headerlink" title="1.3.1 运算器"></a>1.3.1 运算器</h3><p>运算器最少包含 3 个寄存器（现代计算机处理器内部往往设有通用寄存器组，如 ARM Cortex-A8 处理器，有 40 个 32bit 的寄存器（32 个通用寄存器，7 个状态寄存器，1 个程序计数器（PC，Program Counter）））和一个算数逻辑运算单元（ALU）。</p><ul><li>ACC（Accumulator）：累加器</li><li>MQ（Multiple-Quotient register）：乘商寄存器</li><li>X：操作数寄存器</li></ul><h3 id="1-3-2-控制器"><a href="#1-3-2-控制器" class="headerlink" title="1.3.2 控制器"></a>1.3.2 控制器</h3><p>控制器是计算机的神经中枢，由它指挥各部件自动、协调地运行。具体而言：</p><ol><li>读取指令：命令存储器读出一条指令</li><li>分析指令：指出该指令需要完成什么操作，并按寻址特征指出操作数的地址</li><li>执行指令：根据操作数所在地址以及指令的操作码，完成某种操作</li></ol><p>控制器由程序计数器（Program Counter，PC）、指令寄存器（Instruction Register，IR）和控制单元（CU）组成：</p><ul><li>PC：存放当前欲执行指令的地址，与主存的 MAR（Memory Address Register，存储器地址寄存器）有一条直接通路，且具备自动 +1 的功能，即可自动形成下一条指令的地址</li><li>IR：存放当前的指令，其内容来自主存的 MDR。IR 中的操作码 (OP(IR)) 送至CU，用来分析指令。其地址码 (Ad(IR)) 作为操作数的地址，送至存储器的 MAR</li><li>CU：分析当前指令所需完成的操作，并发出各种微操作序列，用以控制所有被控对象</li></ul><h3 id="1-3-3-主存储器"><a href="#1-3-3-主存储器" class="headerlink" title="1.3.3 主存储器"></a>1.3.3 主存储器</h3><p>主存储器（简称主存或内存）包括存储体M、各种逻辑部件和控制电路等。存储体由许多存储单元组成，每个存储单元又包含很多存储元件，每个存储元件可以存储一位二进制代码 0 或 1。可见一个存储单元可存储一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的位数称为存储字长。<strong>存储字长可以是 8 位、16 位、32 位等</strong>。一个存储字可代表一个二进制数、一串十六进制字符、两个 ASCII 码或者一条指令。</p><p>每个存储单元都有自己的地址，主存的工作方式就是按照存储单元的地址实现对存储字各位的读写，而 MAR、MDR 则用来实现按地址访问：</p><ul><li>MAR(Memory Address Register)：存储器地址寄存器，存放欲访问的存储单元的地址。其位数对应存储单元的个数，如 MAR 是 32 位，则共有 2^32 = 4 * 1024 * 1024 * 1024 (1024个记作 1K) 个存储单元</li><li>MDR(Memory Data Register)：存储器数据寄存器，存放从存储体读出的数据或准备写入存储体的数据（可以是代码，也可以是指令），其位数与存储字长相等</li></ul><p>当然，要想实现一个完整的读/写操作，CPU还需要给主存发送各种控制信号，如读命令、写命令、地址译码驱动信号等。随着硬件电路的发展，主存都制成大规模集成电路的芯片，<strong>而将MAR、MDR 集成在 CPU 芯片中。</strong></p><p>早期计算机的存储字长一般与机器的指令字长、数据字长相等，故访问一次主存便可取一条指令或一个数据。随着计算机应用范围的不断扩大，往往要求计算机的指令字长、数据字长是可变的。为了适应指令字长和数据字长的可变性，其长度不再由存储字长确定，而由字节的个数来表示。比如 4 字节的指令字长就是 32bit，2 字节的指令字长就是 16bit。至此，指令字长、数据字长和存储字长不必相等，但都必须是字节的整数倍。</p><p>下图为32位架构的ARM存储器组织结构，其基本数据类型有：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec1959a12b82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ARM存储器的组织结构"></p><ul><li>Byte：字节，8位；</li><li>HalfWord：半字，16位（半字必须与2字节边界对齐）；</li><li>Word：字，32位（字必须与4字节边界对齐）；</li><li>Double World（Cortex-A支持）：双字，64位（双字必须与8字节边界对齐）。</li></ul><h1 id="2-计算机的工作原理"><a href="#2-计算机的工作原理" class="headerlink" title="2. 计算机的工作原理"></a>2. 计算机的工作原理</h1><p>首先，计算机最基本的5大组成部分如下图，分别为：<code>输入设备</code>(比如键盘、鼠标), <code>存储器</code>(比如内存、硬盘), <code>运算器</code>(cpu), <code>控制器</code>(cpu)（两者合称中央处理器）, <code>输出设备</code>(显示器)。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706b694c2b484bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>工作原理如下</p><h2 id="2-1-控制器-—-gt-控制输入设备-—-gt-指令流向内存"><a href="#2-1-控制器-—-gt-控制输入设备-—-gt-指令流向内存" class="headerlink" title="2.1 控制器 —&gt; 控制输入设备 —-&gt; 指令流向内存"></a>2.1 控制器 —&gt; 控制输入设备 —-&gt; 指令流向内存</h2><p>当我们输入数据的时候，cpu里的<code>控制器</code>会让<code>输入设备</code>把这些指令存储到<code>存储器</code>(内存)上。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706b6d32a002249?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="2-2-控制器分析指令-—-gt-控制存储器-—-gt-把数据送到运算器"><a href="#2-2-控制器分析指令-—-gt-控制存储器-—-gt-把数据送到运算器" class="headerlink" title="2.2 控制器分析指令 —&gt; 控制存储器 —&gt; 把数据送到运算器"></a>2.2 控制器分析指令 —&gt; 控制存储器 —&gt; 把数据送到运算器</h2><p>控制器分析指令之后， 此时让<code>存储器</code>把数据发送到<code>运算器</code>里(<code>控制器</code>和<code>运算器</code>都在<code>cpu</code>里面)</p><p>这里需要注意，<code>存储器</code>既能<code>存储数据</code>，还能<code>存储指令</code></p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706b702defc6fe1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="2-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器"><a href="#2-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器" class="headerlink" title="2.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器"></a>2.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706bff6d4271172?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="2-4-控制器控制存储器将结果返回给输出设备"><a href="#2-4-控制器控制存储器将结果返回给输出设备" class="headerlink" title="2.4 控制器控制存储器将结果返回给输出设备"></a>2.4 控制器控制存储器将结果返回给输出设备</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c01bf8cca0fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="3-计算机硬件的主要技术指标"><a href="#3-计算机硬件的主要技术指标" class="headerlink" title="3.计算机硬件的主要技术指标"></a>3.计算机硬件的主要技术指标</h1><h2 id="3-1-机器字长"><a href="#3-1-机器字长" class="headerlink" title="3.1 机器字长"></a>3.1 机器字长</h2><p>机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。因为计算机中数的表示有定点数和浮点数之分，定点数又有定点整数和定点小数之分，这里所说的整数运算即定点整数运算。机器字长也就是运算器进行定点数运算的字长，<strong>即通用寄存器的位数</strong>。</p><p>主存字长一般等于机器字长，不等的情况下，一般是主存储器字长小于机器字长。例如机器字长是 32 位，主存储器字长可以是 32 位，也可以是 16 位。</p><p>Windows 64 位操作系统是针对 64 位机器字长的 CPU 设计的，目前 64 位架构实现技术主要有 AMD64、Intel EM64T 等。</p><h2 id="3-2-存储容量"><a href="#3-2-存储容量" class="headerlink" title="3.2 存储容量"></a>3.2 存储容量</h2><p>主存容量 = 存储单元数 * 存储字长</p><p>比如，若 MAR 是 32 位，则存储单元个数为： 2^32 = 4 * 1024 * 1024 * 1024个。若存储字长为 8 位，则存储容量 =  4 * 1024 * 1024 * 1024 * 8 bit，即 4G(4 Gigabyte) 。</p><h2 id="3-3-运算速度"><a href="#3-3-运算速度" class="headerlink" title="3.3 运算速度"></a>3.3 运算速度</h2><p>单位时间内执行的指令平均条数，单位 MIPS（Million Instruction Per Second）。</p><h1 id="4-CPU及其工作过程"><a href="#4-CPU及其工作过程" class="headerlink" title="4.CPU及其工作过程"></a>4.CPU及其工作过程</h1><p>CPU中比较重要的两个部件是<code>运算器</code>和<code>控制器</code>，我们先来看看运算器的主要作用</p><h2 id="4-1-运算器主要部件"><a href="#4-1-运算器主要部件" class="headerlink" title="4.1 运算器主要部件"></a>4.1 运算器主要部件</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c09a00c1bf76?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如上图，运算器里最重要的部件是<code>ALU</code>，中文叫<code>算术逻辑单元</code>，用来进行<code>算术</code>和<code>逻辑运算</code>的。其它的<code>MQ</code>,<code>ACC</code>这些我们不用管了，是一些<code>寄存器</code>。</p><h2 id="4-2-控制器主要部件"><a href="#4-2-控制器主要部件" class="headerlink" title="4.2 控制器主要部件"></a>4.2 控制器主要部件</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c0c704b4d5e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>控制器中最重要的部件是<code>CU</code>（控制单元），只要是<code>分析指令</code>，给出<code>控制信号</code>。</p><p><code>IR</code>（指令寄存器），存放当前需要执行的指令</p><p><code>PC</code>存放的指令的地址。</p><h2 id="4-3-举例-取数指令执行过程"><a href="#4-3-举例-取数指令执行过程" class="headerlink" title="4.3 举例 - 取数指令执行过程"></a>4.3 举例 - 取数指令执行过程</h2><p>首先，是取指令的过程如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c1c88439428c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>第一步，<code>PC</code>，也就是存放指令地址的地方，我们要知道下一条指令是什么，就必须去存储器拿，<code>CPU</code>才知道接下来做什么。<code>PC</code>去了存储器的<code>MAR</code>拿要执行的指令地址，<code>MAR</code>（存储器里专门存指令地址的地方）</li><li>第二步和第三步，<code>MAR</code>去存储体内拿到指令之后，将指令地址放入<code>MDR</code>(存储器里专门存数据的地方)</li><li>第四步<code>MDR</code>里的数据返回到<code>IR</code>里面，<code>IR</code>是存放指令的地方，我们把刚才从存储体里拿的指令放在这里</li></ul><p>然后，分析指令，执行指令的过程如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c2497c78ea7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>第五步， <code>IR</code>将指令放入<code>CU</code>中，来分析指令，比如说分析出是一个取数指令，接着就要执行指令了（这里取数指令，其实就是一个地址码，按着这个地址去存储体取数据）</li><li>第六步，第七步 <code>IR</code>就会接着去找存储体里的<code>MAR</code>（存储地址的地方），<code>MAR</code>就根据取数指令里的地址吗去存储体里去数据</li><li>第八步，取出的数据返回给<code>MDR</code>（存放数据的地方）</li><li>第九步，<code>MDR</code>里的数据放到运算器的寄存器里，这里的取指令的过程结束了。</li></ul><p>来个插曲，我们知道数据在<code>内存</code>里是<code>二进制</code>存着，也就是<code>0和1</code>, <code>0和1</code>怎么用表示呢？</p><p>我们拿其中一种存储0和1的方式来说明</p><ul><li><p>电容是否有电荷，有电荷代表1，无电荷代表0</p></li><li><p>如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c398612217b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c4a705a0c799?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="5-计算机编程语言"><a href="#5-计算机编程语言" class="headerlink" title="5.计算机编程语言"></a>5.计算机编程语言</h1><h2 id="5-1-机器语言"><a href="#5-1-机器语言" class="headerlink" title="5.1 机器语言"></a>5.1 机器语言</h2><p>存放一个数的指令，例如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706c9d470edc315?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们来看二进制代码 <code>0000，0000，000000010000</code></p><ul><li>其中第一个<code>0000</code>，表示的是汇编语言里的<code>LOAD</code>，也就是加载，加载什么呢</li><li>加载地址<code>000000010000</code>上的数据到第二个<code>0000</code>（寄存器的位置）。</li></ul><h2 id="5-2-汇编语言"><a href="#5-2-汇编语言" class="headerlink" title="5.2 汇编语言"></a>5.2 汇编语言</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706cbcf713a5daa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><code>LOAD A, 16</code>意思是将存储体内的16号单元数据，放到寄存器地址A中 <code>ADD C, A, B</code>意思是将寄存器里的A,B数据相加，得到C <code>STORE C, 17</code>意思是将寄存器里的数据存到存储体17号单元内</p><h2 id="5-3-高级语言"><a href="#5-3-高级语言" class="headerlink" title="5.3 高级语言"></a>5.3 高级语言</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706cc3a1c2ac0b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>高级语言是不是很简单，就一个<code>a+b</code>，你都不用去考虑<code>寄存器</code>，<code>存储体</code>这些事。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec19592d1486?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="多层次结构的计算机系统"></p><p>最初的计算机并没有微指令系统。由于 M0、M1 都是实际存在的，为了区分，这里分为微程序机器、传统机器。</p><p>将高级语言翻译成机器语言的程序叫做翻译程序，翻译程序分为编译程序与解释程序两种类型：</p><ul><li>编译程序：一次性将高级语言全部翻译成机器语言，直接借助<code>编译器</code>，将高级语言转换为<code>二进制</code>代码，比如<code>c</code>，这样<code>c</code>运行起来就特别快，因为编译后是机器语言，直接就能在系统上跑，但问题是，编译的速度可能会比较慢。</li><li>解释程序：翻译一句执行一句，重新执行需要再次翻译，比如 <code>js</code>，是将代码翻译一行成<code>机器语言</code>（中间可能会先翻译为<code>汇编</code>代码或者<code>字节码</code>），解释一行，执行一行</li></ul><p>需要注意的是，按照第一种将大量的高级代码翻译为机器语言，这其中就有很大的空间给<code>编译器</code>做代码优化，解释性语言就很难做这种优化，但是在<code>v8</code>引擎中，<code>js</code>还是要被优化的，在<code>编译阶段</code>（代码分<code>编译</code>和<code>执行</code>两个阶段）会对代码做一些优化，编译后立即执行的方式通常被称为 <code>JIT (Just In Time) Comipler</code>。</p><h1 id="6-进制转换"><a href="#6-进制转换" class="headerlink" title="6.进制转换"></a>6.进制转换</h1><h2 id="6-1-二进制如何转化为十进制"><a href="#6-1-二进制如何转化为十进制" class="headerlink" title="6.1 二进制如何转化为十进制"></a>6.1 二进制如何转化为十进制</h2><p>例如<code>2</code>进制<code>101.1</code>如何转化为<code>10</code>进制。（有些同学觉得可以用<code>parseInt(&#39;101.1&#39;, 2)</code>，这个是不行的，因为<code>parseInt</code>返回整数）</p><p>转化方法如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/22/1706d5e33596c8fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图的规则是什么呢？</p><p><code>二进制</code>的每个数去<code>乘以2</code>的相应次方,注意小数点后是乘以它的<code>负相应次方</code>。 再举一个例子你就明白了，</p><p>二进制<code>1101</code>转为十进制</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/1706ff11252cf012?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="6-2-十进制整数转为二进制"><a href="#6-2-十进制整数转为二进制" class="headerlink" title="6.2 十进制整数转为二进制"></a>6.2 十进制整数转为二进制</h2><p><code>JS</code>里面可以用<code>toString(2)</code>这个方法来转换。如果要用通用的方法，例如：将十进制数<code>（29）</code>转换成二进制数， 算法如下：</p><ul><li>把给定的十进制数29除以2，商为14，所得的余数1是二进制数的最低位的数码</li><li>再将14除以2，商为7，余数为0</li><li>再将7除以2，商为3，余数为1，再将3除以2，商为1，余数为1</li><li>再将1除以2，商为0，余数为1是二进制数的最高位的数码</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/1707000f2236ced5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其结果为：11101</p><h2 id="6-3-十进制小数转为二进制"><a href="#6-3-十进制小数转为二进制" class="headerlink" title="6.3 十进制小数转为二进制"></a>6.3 十进制小数转为二进制</h2><p>方式是采用“乘2取整，顺序排列”法。具体做法是：</p><ul><li>用2乘十进制小数，可以得到积，将积的整数部分取出-</li><li>再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出-</li><li>如此进行，直到积中的小数部分为零，或者达到所要求的精度为止</li></ul><p>我们具体举一个例子</p><p>如: 十进制 0.25 转为二进制</p><ul><li><code>0.25 * 2 = 0.5</code>   取出整数部分：<code>0</code></li><li><code>0.5 * 2 = 1.0</code>  取出整数部分1</li></ul><p>即十进制<code>0.25</code>的二进制为 <code>0.01</code> ( 第一次所得到为最高位,最后一次得到为最低位)</p><p>此时我们可以试试十进制<code>0.1</code>和<code>0.2</code>如何转为二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0.1(十进制) &#x3D; 0.0001100110011001(二进制)</span><br><span class="line">十进制数0.1转二进制计算过程：</span><br><span class="line">0.1*2＝0.2……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。</span><br><span class="line">0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span><br><span class="line">0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。</span><br><span class="line">0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。</span><br><span class="line">0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span><br><span class="line">0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span><br><span class="line">0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。</span><br><span class="line">0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。</span><br><span class="line">0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span><br><span class="line">0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span><br><span class="line">0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。</span><br><span class="line">0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">所以，得到的整数依次是：“0”，“0”，“0”，“1”，“1”，“0”，“0”，“1”，“1”，“0”，“0”，“1”……。</span><br><span class="line">由此，大家肯定能看出来，整数部分出现了无限循环。</span><br></pre></td></tr></table></figure><p>接下来看<code>0.2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.2化二进制是</span><br><span class="line">0.2*2&#x3D;0.4,整数位为0</span><br><span class="line">0.4*2&#x3D;0.8,整数位为0</span><br><span class="line">0.8*2&#x3D;1.6,整数位为1,去掉整数位得0.6</span><br><span class="line">0.6*2&#x3D;1.2,整数位为1,去掉整数位得0.2</span><br><span class="line">0.2*2&#x3D;0.4,整数位为0</span><br><span class="line">0.4*2&#x3D;0.8.整数位为0</span><br><span class="line">就这样推下去！小数*2整,一直下去就行</span><br><span class="line">这个数整不断</span><br><span class="line">0.0011001</span><br></pre></td></tr></table></figure><p>所以<code>0.1</code>和<code>0.2</code>都无法完美转化为二进制，所以它们相加当然不是<code>0.3</code>了</p><h1 id="7-定点数和浮点数"><a href="#7-定点数和浮点数" class="headerlink" title="7.定点数和浮点数"></a>7.定点数和浮点数</h1><p>首先，什么是定点数呢？</p><h2 id="7-1-定点数"><a href="#7-1-定点数" class="headerlink" title="7.1 定点数"></a>7.1 定点数</h2><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/170704847227a313?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如上图，举例纯整数的二进制<code>1011</code>和<code>-1011</code>，如果是<code>整数</code>，符号位用<code>0</code>表示，如果是<code>负数</code>符号为用<code>1</code>表示</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/170705cec4efdbbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>同理，纯小数表示举例如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/170705db54658733?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>那如果不是<code>纯小数</code>或者<code>纯整数</code>，该怎么表示呢？</p><p>比如<code>10.1</code>, 可以乘以一个比例因子，将<code>10.1 ---&gt; 101</code> 比例因子是<code>10</code>, 或者<code>10.1 ---&gt; 0.101</code>比例因子是<code>100</code></p><p>定点数很简单，接下来我们介绍浮点数，在JS里面，数字都是用<code>双精度的浮点数</code>，所以学习浮点数对我们理解JS的数字有帮助。</p><h2 id="7-2-浮点数"><a href="#7-2-浮点数" class="headerlink" title="7.2 浮点数"></a>7.2 浮点数</h2><p>那么浮点数怎么表示呢？</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17070a5d364385ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上面是<code>十进制</code>的科学计数法，从中我们需要了解几个概念，一个是<code>尾数</code>，<code>基数</code>和<code>阶码</code></p><ul><li><code>尾数</code>必须是纯小数，所以上图中<code>1.2345</code>不满足尾数的格式，需要改成<code>0.12345</code></li><li><code>基数</code>，在二进制里面是<code>2</code></li><li><code>阶码</code>就是多少次方</li></ul><p>所以<code>浮点数</code>的<code>通用</code>表示格式如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17070ac01d4adfbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>S代表尾数</li><li>r代表基数</li><li>j代表阶码</li></ul><p>这里需要注意的是，浮点数的加减运算，并不是像我们上面介绍的那样简单，会经过以下几个步骤完成</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/170713830fa5eb8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这些名词大家感兴趣的话，可以去网上查询，我们只要了解到<code>浮点数加减运算</code>很麻烦就行了，但如果你要做一个浮点数运算的库，你肯定是要完全掌握的。</p><h1 id="8-局部性原理和cache"><a href="#8-局部性原理和cache" class="headerlink" title="8.局部性原理和cache"></a>8.局部性原理和cache</h1><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec195b23428e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="缓存-主存层次和主存-辅存层次"></p><p>在虚拟存储系统中，程序员的编程地址范围与虚拟存储器的地址空间相对应。例如机器指令地址码是 32 位，那么虚拟存储器的存储单元个数可达 2^32 = 4 * 1024 * 1024 * 1024 个，若存储字长为 8 位，则存储容量为 4 Gegabyte，这可能比主存实际的存储单元个数多得多。这类指令地址码称为虚拟地址或逻辑地址，主存的实际地址称为物理地址。虚拟地址到物理地址的转换由操作系统负责实现，比如 Windows 操作系统通过页目和页表来实现虚拟地址到物理地址的转换。若虚拟地址指向的内容在主存，则可被 CPU 直接使用，否则必须先传到主存，然后才能被 CPU 访问。</p><p>选择下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17071e09c7aa0ec0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>（说明一下，<code>MDR</code>和<code>MAR</code>虽然逻辑上属于主存，但是在<code>电路实现</code>的时候，<code>MDR</code>和<code>MAR</code>离<code>CPU</code>比较近）</p><p>上图是在执行一串代码,可以理解为js的for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const n &#x3D; 1000;</span><br><span class="line">const a &#x3D; [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">for(let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">a[i] &#x3D; a[i] + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现</p><ul><li>数组的数据有时候在内存是连续存储的</li><li>如果我们要取数据，比如从内存取出a[0]的数据需要1000ns(ns是纳秒的意思),那么取出a[0]到a[7]就需要1000 * 8 = 8000 ns</li><li>如果我们cpu发现这是取数组数据，那么我就把就近的数据块a[0]到a[7]全部存到缓存上多好，这样只需要取一次数据，消耗1000ns</li></ul><p><code>cache</code>就是<code>局部性原理</code>的一个应用</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17071f8af2c754fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>空间局部性</code>：在最近的未来要用到的信息（<code>指令</code>和<code>数据</code>），很可能与现在正在使用的信息在<code>存储空间</code>上是邻近的</li><li><code>时间局部性</code>：在最近的未来要用到的信息，很可能是现在<code>正在使用的信息</code></li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17071fac43ab80f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>可以看到<code>cache</code>一次性取了<code>a[0]</code>到<code>a[9]</code>存储体上的数据，只需要<code>1000ns</code>，因为<code>cache</code>是<code>高速存储器</code>，跟<code>cpu</code>交互速度就比<code>cpu</code>跟<code>主存</code>交互速度快很多。</p><h1 id="9-I-O设备的演变"><a href="#9-I-O设备的演变" class="headerlink" title="9.I/O设备的演变"></a>9.I/O设备的演变</h1><p>I/O是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入&#x2F;输出（Input &#x2F;Output ,简称I&#x2F;O），指的是一切操作、程序或设备与计算机之间发生的数据传输过程。</span><br></pre></td></tr></table></figure><p>比如文件读写操作，就是典型的<code>I/O</code>操作。接下来我们看一下I/O设备的演进过程</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/1707206ef2336a07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在早期的计算机里，<code>CPU</code>如何知道<code>I/O设备</code>已经完成任务呢?比如说怎么知道<code>I/O设备</code>已经读取完一个文件的数据呢?<code>CPU</code>会不断查询<code>I/O设备</code>是否已经准备好。这时，<code>CPU</code>就处于等待状态。也就是<code>CPU</code>工作的时候，<code>I/O</code>系统是不工作的，<code>I/O</code>系统工作，<code>CPU</code>是不工作。</p><p>接着看第二阶段</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/17072561bbbaabd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>为了解决第一阶段<code>CPU</code>要等待<code>I/O设备</code>，<code>串行</code>的工作方式，所有<code>I/O设备</code>通过<code>I/O总线</code>来跟<code>CPU</code>打交道，一旦某个<code>I/O设备</code>完成任务，就会以<code>中断请求</code>的方式，通过<code>I/O总线</code>，告诉<code>CPU</code>，我已经准备好了。</li><li>但是对于<code>高速外设</code>，它们完成任务的速度很快，所以会频繁中断<code>CPU</code>, 为了解决这个问题，高速外设跟主存之间用一条直接数据通路，<code>DMA总线</code>连接，<code>CPU</code>只需要安排开始高速外设做什么，剩下的就不用管了，这样就可以防止频繁中断<code>CPU</code>。</li></ul><p>最后来看一下第三阶段</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/2/23/1707263d5cdbcf4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第三阶段，CPU通过通道控制部件来管理I/O设备，CPU不需要帮它安排任务，只需要简单的发出启动和停止类似的命令，通道部件就会自动的安排相应的I/O设备工作</p><h1 id="10-系统总线"><a href="#10-系统总线" class="headerlink" title="10.系统总线"></a>10.系统总线</h1><p>同一时刻只能有一个部件向总线发送信息，但是可以有多个部件接受信息，因为总线是各部件共享的。</p><h2 id="10-1-片内总线"><a href="#10-1-片内总线" class="headerlink" title="10.1 片内总线"></a>10.1 片内总线</h2><p>芯片内部的连线，比如寄存器之间、寄存器与 ALU 之间的连线等。</p><h2 id="10-2-系统总线"><a href="#10-2-系统总线" class="headerlink" title="10.2 系统总线"></a>10.2 系统总线</h2><ol><li><p>数据总线：双向传输，其条数称为数据总线宽度。数据总线宽度与机器字长、存储字长有关。比如总线宽度是 8 位，指令字长为 16 位，那么 CPU 取出一条指令，就需要访问两次主存。</p></li><li><p>地址总线：单向传输，指出数据总线上的源数据或目的数据所在存储单元的地址。地址总线的宽度与存储单元个数有关，比如 32 位的地址总线，可编址按字节寻址的存储单元个数为 2^32 = 4 * 1024 * 1024 * 1024  ，即 4 Gigabyte。</p><p>从存储器读一个字的数据时，首先由 CPU 将其地址经 MAR 通过地址总线送至主存，然后向主存发读命令。主存接到读命令后，将对应数据读出后，经数据总线送至 MDR。向存储器写一个字的数据时，CPU 先将目的地址经 MDR 通过地址总线送至主存，并将数据送至 MDR，然后向主存发写命令。主存接到写命令后，便可以将 MDR 中的数据经数据总线写至目的地址：</p></li></ol><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/2/1680ec195b3d9c27?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="主存与CPU的联系"></p><ol><li>控制总线：决策总线使用权，用来发出各种控制信号。I/O 设备通过控制总线向 CPU 发出总线请求，CPU 通过控制总线向 I/O 设备发出读写命令。</li><li>通信总线：用于计算机系统之间或计算机系统与其它系统（如控制仪表、移动通讯等）之间通信。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实学习80C51单片机的时候已经学过了一些相关知识，觉得还算有趣，我们通常使用的计算机原来是怎么构成的，就是真实感受汇编语言不会编，记得大作业那个红绿灯搞了我很久，当时搞出来的时候我热泪盈眶。&lt;/p&gt;
&lt;p&gt;上面是闲话，还是当越深入学习，越会发现计算机组成的重要性。&lt;/p&gt;
&lt;p&gt;比如知道js里面&lt;code&gt;0.1 + 0.2&lt;/code&gt; 是&lt;code&gt;不等于0.3&lt;/code&gt;的，为什么呢？这就牵扯到计算机组成原理中&lt;code&gt;浮点数&lt;/code&gt;的表示方法，以及&lt;code&gt;浮点数&lt;/code&gt;的加减运算，当时学Verilog的大作业，对于浮点数来说，乘除法反而好些，加减法写了半天。&lt;/p&gt;
&lt;p&gt;又例如从键盘输入&lt;code&gt;a+b&lt;/code&gt;这个指令，如何通过&lt;code&gt;cpu&lt;/code&gt;的调度输出到&lt;code&gt;屏幕上&lt;/code&gt;呢？这就涉及到&lt;code&gt;冯诺依曼体系&lt;/code&gt;，如果你是编程人员，都不清楚数据从键盘到屏幕的&lt;code&gt;基本流向&lt;/code&gt;，输入、输出设备、中央处理器是做什么的都不知道，真的该下定决心补一补这些基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机组成" scheme="https://hxy1997.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    <category term="基础" scheme="https://hxy1997.xyz/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript执行上下文和执行栈</title>
    <link href="https://hxy1997.xyz/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>https://hxy1997.xyz/2021/03/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</id>
    <published>2021-03-25T04:00:00.000Z</published>
    <updated>2021-03-25T03:52:50.345Z</updated>
    
    <content type="html"><![CDATA[<p>每个 JavaScript 开发者都需要 JavaScript 程序执行机制，这是一个非常考察计算机基础的概念，可以结合单片机的执行栈来解读，计算机组成我是囫囵吞枣看过了，感觉JS的和其他程序大同小异，不过仍然有其独特之处。<a href="https://juejin.cn/post/6844903798784131079">这篇文章</a>作者浪里行舟参考了国外大佬<a href="https://blog.bitsrc.io/@Sukhjinder?source=post_header_lockup">Sukhjinder Arora</a>的<a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a>，通俗易懂。</p><span id="more"></span><h2 id="一、执行上下文（Execution-Context）"><a href="#一、执行上下文（Execution-Context）" class="headerlink" title="一、执行上下文（Execution Context）"></a>一、执行上下文（Execution Context）</h2><h3 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文"></a>1.什么是执行上下文</h3><p>简而言之，执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行</p><h3 id="2-执行上下文的类型"><a href="#2-执行上下文的类型" class="headerlink" title="2.执行上下文的类型"></a>2.执行上下文的类型</h3><p>执行上下文总共有三种类型：</p><ul><li>全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li><li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li><li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</li></ul><h2 id="二、执行上下文的生命周期"><a href="#二、执行上下文的生命周期" class="headerlink" title="二、执行上下文的生命周期"></a>二、执行上下文的生命周期</h2><p>执行上下文的生命周期包括三个阶段：<strong>创建阶段→执行阶段→回收阶段</strong>，本文重点介绍创建阶段。</p><h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1.创建阶段"></a>1.创建阶段</h3><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。下文会详细说明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定this指向：包括多种情况，下文会详细说明</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。</p><h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>执行变量赋值、代码执行</p><h3 id="3-回收阶段"><a href="#3-回收阶段" class="headerlink" title="3.回收阶段"></a>3.回收阶段</h3><p>执行上下文出栈等待虚拟机回收执行上下文</p><h2 id="三、变量提升和this指向的细节"><a href="#三、变量提升和this指向的细节" class="headerlink" title="三、变量提升和this指向的细节"></a>三、变量提升和this指向的细节</h2><h3 id="1-变量声明提升"><a href="#1-变量声明提升" class="headerlink" title="1.变量声明提升"></a>1.变量声明提升</h3><p>大部分编程语言都是先声明变量再使用，但在JS中，事情有些不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)&#x2F;&#x2F; undefined</span><br><span class="line">var a &#x3D; 10</span><br></pre></td></tr></table></figure><p>上述代码正常输出<code>undefined</code>而不是报错<code>Uncaught ReferenceError: a is not defined</code>,这是因为声明提升（hoisting），相当于如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a; &#x2F;&#x2F;声明 默认值是undefined “准备工作”</span><br><span class="line">console.log(a);</span><br><span class="line">a &#x3D; 10; &#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure><h3 id="2-函数声明提升"><a href="#2-函数声明提升" class="headerlink" title="2.函数声明提升"></a>2.函数声明提升</h3><p>我们都知道，创建一个函数的方法有两种，一种是通过函数声明<code>function foo()&#123;&#125;</code> 另一种是通过函数表达式<code>var foo = function()&#123;&#125;</code> ,那这两种在函数提升有什么区别呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(f1) &#x2F;&#x2F; function f1()&#123;&#125;</span><br><span class="line">function f1() &#123;&#125; &#x2F;&#x2F; 函数声明</span><br><span class="line">console.log(f2) &#x2F;&#x2F; undefined</span><br><span class="line">var f2 &#x3D; function() &#123;&#125; &#x2F;&#x2F; 函数表达式</span><br></pre></td></tr></table></figure><p>接下来我们通过一个例子来说明这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    foo(); &#x2F;&#x2F; Uncaught TypeError &quot;foo is not a function&quot;</span><br><span class="line">    bar(); &#x2F;&#x2F; &quot;this will run!&quot;</span><br><span class="line">    var foo &#x3D; function () &#123; &#x2F;&#x2F; function expression assigned to local variable &#39;foo&#39;</span><br><span class="line">        alert(&quot;this won&#39;t run!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function bar() &#123; &#x2F;&#x2F; function declaration, given the name &#39;bar&#39;</span><br><span class="line">        alert(&quot;this will run!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>在上面的例子中，foo()调用的时候报错了，而bar能够正常调用。</p><p>我们前面说过变量和函数都会上升，遇到函数表达式 <code>var foo = function()&#123;&#125;</code>时，首先会将<code>var foo</code>上升到函数体顶部，然而此时的foo的值为undefined,所以执行<code>foo()</code>报错。</p><p>而对于函数<code>bar()</code>, 则是提升了整个函数，所以<code>bar()</code>才能够顺利执行。</p><p>有个细节必须注意：<strong>当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a); &#x2F;&#x2F; 输出：function a()&#123; alert(&#39;我是函数&#39;) &#125;</span><br><span class="line">function a()&#123; alert(&#39;我是函数&#39;) &#125; &#x2F;&#x2F;</span><br><span class="line">var a &#x3D; &#39;我是变量&#39;;</span><br><span class="line">alert(a); &#x2F;&#x2F; 输出：&#39;我是变量&#39;</span><br></pre></td></tr></table></figure><p>function声明的优先级比var声明高，也就意味着当两个同名变量同时被function和var声明时，function声明会覆盖var声明</p><p>这代码等效于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;alert(&#39;我是函数&#39;)&#125; </span><br><span class="line">var a;    &#x2F;&#x2F; hoisting</span><br><span class="line">alert(a);    &#x2F;&#x2F; 输出：function a()&#123; alert(&#39;我是函数&#39;) &#125;</span><br><span class="line">a &#x3D; &#39;我是变量&#39;;&#x2F;&#x2F; 赋值</span><br><span class="line">alert(a);   &#x2F;&#x2F; 输出：&#39;我是变量&#39;</span><br></pre></td></tr></table></figure><p>最后我们看个复杂点的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test(arg)&#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 形参 arg 是 &quot;hi&quot;</span><br><span class="line">    &#x2F;&#x2F; 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function</span><br><span class="line">    console.log(arg);  </span><br><span class="line">    var arg &#x3D; &#39;hello&#39;; &#x2F;&#x2F; 3.var arg 变量声明被忽略， arg &#x3D; &#39;hello&#39;被执行</span><br><span class="line">    function arg()&#123;</span><br><span class="line">console.log(&#39;hello world&#39;) </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg);  </span><br><span class="line">&#125;</span><br><span class="line">test(&#39;hi&#39;);</span><br><span class="line">&#x2F;* 输出：</span><br><span class="line">function arg()&#123;</span><br><span class="line">    console.log(&#39;hello world&#39;) </span><br><span class="line">&#125;</span><br><span class="line">hello </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：</p><ul><li>如果有形参，先给形参赋值</li><li>进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，<strong>但是可以重新赋值</strong></li><li>私有作用域中的代码从上到下执行</li></ul><h3 id="3-确定this的指向"><a href="#3-确定this的指向" class="headerlink" title="3.确定this的指向"></a>3.确定this的指向</h3><p>先搞明白一个很重要的概念 —— <strong>this的值是在执行的时候才能确认，定义的时候不能确认！</strong> 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 情况1</span><br><span class="line">function foo() &#123;</span><br><span class="line">console.log(this.a) &#x2F;&#x2F;1</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; 1</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况2</span><br><span class="line">function fn()&#123;</span><br><span class="line">console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj &#x3D; &#123;fn:fn&#125;;</span><br><span class="line">obj.fn(); &#x2F;&#x2F;this-&gt;obj</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况3</span><br><span class="line">function CreateJsPerson(name,age)&#123;</span><br><span class="line">    &#x2F;&#x2F; this是当前类的一个实例p1</span><br><span class="line">    this.name &#x3D; name; &#x2F;&#x2F; &#x3D;&gt;p1.name&#x3D;name</span><br><span class="line">    this.age &#x3D; age; &#x2F;&#x2F; &#x3D;&gt;p1.age&#x3D;age</span><br><span class="line">&#125;</span><br><span class="line">var p1&#x3D;new CreateJsPerson(&quot;尹华芝&quot;,48);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况4</span><br><span class="line">function add(c, d)&#123;</span><br><span class="line">return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; &#123;a:1, b:3&#125;;</span><br><span class="line">add.call(o, 5, 7); &#x2F;&#x2F; 1 + 3 + 5 + 7 &#x3D; 16</span><br><span class="line">add.apply(o, [10, 20]); &#x2F;&#x2F; 1 + 3 + 10 + 20 &#x3D; 34</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况5</span><br><span class="line">&lt;button id&#x3D;&quot;btn1&quot;&gt;箭头函数this&lt;&#x2F;button&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;   </span><br><span class="line">    let btn1 &#x3D; document.getElementById(&#39;btn1&#39;);</span><br><span class="line">    let obj &#x3D; &#123;</span><br><span class="line">        name: &#39;kobe&#39;,</span><br><span class="line">        age: 39,</span><br><span class="line">        getName: function () &#123;</span><br><span class="line">            btn1.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                console.log(this);&#x2F;&#x2F;obj</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.getName();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>接下来我们逐一解释上面几种情况</p><ul><li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li><li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li><li>在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</li><li>call、apply和bind：this 是第一个参数</li><li>箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/5/1694e75626c746d1?imageslim" alt="img"></p><h2 id="四、执行上下文栈（Execution-Context-Stack）"><a href="#四、执行上下文栈（Execution-Context-Stack）" class="headerlink" title="四、执行上下文栈（Execution Context Stack）"></a>四、执行上下文栈（Execution Context Stack）</h2><p>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p><p>JavaScript 引擎创建了执行上下文栈来管理执行上下文。<strong>可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/4/16949529105ae0a6?imageslim" alt="img"></p><p>从上面的流程图，我们需要记住几个关键点：</p><ul><li>JavaScript执行在单线程上，所有的代码都是排队执行。</li><li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li><li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li><li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li></ul><p>我们再来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var color &#x3D; &#39;blue&#39;;</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">    var anotherColor &#x3D; &#39;red&#39;;</span><br><span class="line">    function swapColors() &#123;</span><br><span class="line">        var tempColor &#x3D; anotherColor;</span><br><span class="line">        anotherColor &#x3D; color;</span><br><span class="line">        color &#x3D; tempColor;</span><br><span class="line">    &#125;</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>上述代码运行按照如下步骤：</p><ul><li><p>当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈</p></li><li><p>调用 changeColor函数时，此时changeColor函数内部代码还未执行，js执行引擎立即创建一个changeColor的执行上下文（简称EC），然后把这执行上下文压入到执行栈（简称ECStack）中。</p></li><li><p>执行changeColor函数过程中，调用swapColors函数，同样地，swapColors函数执行之前也创建了一个swapColors的执行上下文，并压入到执行栈中。</p></li><li><p>swapColors函数执行完成，swapColors函数的执行上下文出栈，并且被销毁。</p></li><li><p>changeColor函数执行完成，changeColor函数的执行上下文出栈，并且被销毁。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/10/16966f12b2ff5478?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/">了解JavaScript的执行上下文</a></li><li><a href="https://juejin.im/book/6844733763675488269/section/6844733763763568654">前端面试之道</a></li><li><a href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html">深入理解javascript原型和闭包系列</a></li><li><a href="https://juejin.im/post/6844903704466833421">【译】理解 Javascript 执行上下文和执行栈</a></li><li><a href="https://www.html.cn/archives/7255">深入理解JavaScript中的作用域和上下文</a></li><li><a href="https://segmentfault.com/a/1190000012646203">前端基础进阶（二）：执行上下文详细图解</a></li><li><a href="https://github.com/creeperyang/blog/issues/16">深入理解JS中声明提升、作用域（链）和<code>this</code>关键字</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;每个 JavaScript 开发者都需要 JavaScript 程序执行机制，这是一个非常考察计算机基础的概念，可以结合单片机的执行栈来解读，计算机组成我是囫囵吞枣看过了，感觉JS的和其他程序大同小异，不过仍然有其独特之处。&lt;a href=&quot;https://juejin.cn/post/6844903798784131079&quot;&gt;这篇文章&lt;/a&gt;作者浪里行舟参考了国外大佬&lt;a href=&quot;https://blog.bitsrc.io/@Sukhjinder?source=post_header_lockup&quot;&gt;Sukhjinder Arora&lt;/a&gt;的&lt;a href=&quot;https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0&quot;&gt;Understanding Execution Context and Execution Stack in Javascript&lt;/a&gt;，通俗易懂。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="执行上下文" scheme="https://hxy1997.xyz/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
    <category term="执行栈" scheme="https://hxy1997.xyz/tags/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>深究 JavaScript 数组 —— 演进&amp;性能</title>
    <link href="https://hxy1997.xyz/2021/03/22/%E6%B7%B1%E7%A9%B6%20JavaScript%20%E6%95%B0%E7%BB%84/"/>
    <id>https://hxy1997.xyz/2021/03/22/%E6%B7%B1%E7%A9%B6%20JavaScript%20%E6%95%B0%E7%BB%84/</id>
    <published>2021-03-22T04:30:27.000Z</published>
    <updated>2021-03-22T09:06:30.917Z</updated>
    
    <content type="html"><![CDATA[<p>用了这么久的js，多次使用js的数组，突然好奇，js数组到底是怎样的机制，很明显它与C语言的数组有很多不同，C语言数组就是内存中一块连续的区域，那么JS呢？感谢原作者：<a href="http://link.zhihu.com/?target=http://voidcanvas.com/author/paulshan/">Paul Shan</a> 原文：<a href="http://link.zhihu.com/?target=http://voidcanvas.com/javascript-array-evolution-performance/">Diving deep into JavaScript array - evolution &amp; performance</a> 以及辛苦的翻译人员</p><span id="more"></span><h2 id="深究-JavaScript-数组-——-演进-amp-性能"><a href="#深究-JavaScript-数组-——-演进-amp-性能" class="headerlink" title="深究 JavaScript 数组 —— 演进&amp;性能"></a>深究 JavaScript 数组 —— 演进&amp;性能</h2><p>写文章前我要说一下，这篇文章不是讲 JavaScript 数组基础的，也不会教相关的语法和用法。文章更多的是讲数组在内存中的存储方式、优化、不同语法导致的行为差异、性能和最近的改进。</p><p>我接触 JavaScript 的时候，已经对 C/C++/C# 等语言相当熟悉了。但和许多 C/C++使用者一样，第一次与 JavaScipt 的「约会」并不愉快。</p><p>我不喜欢 JavaScipt 的一个主要原因是它的Array。 JavaScript 的数组通过哈希映射或者字典的方式来实现，所以不是连续的。我觉得这是一门劣等语言：连数组都不能正确的实现。但时至今日， JavaScript 以及我对 JavaScript 的理解都有相当大的变化。</p><h2 id="为什么-JavaScript-数组不是真正的数组"><a href="#为什么-JavaScript-数组不是真正的数组" class="headerlink" title="为什么 JavaScript 数组不是真正的数组"></a><strong>为什么 JavaScript 数组不是真正的数组</strong></h2><p>在讲 JavaScript 相关的东西前，让我先告诉你什么是 Array。</p><p>数组( Array )在内存中用一串连续的区域来存放一些值。注意「连续」一词，它至关重要。</p><p><img data-src="https://user-gold-cdn.xitu.io/2017/9/5/c68a7cf972e76a0c7eabc638064e9139?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图表示存储在内存中的一个数组。存储4个4 bit 的元素,一共需要16 bit 存储区域，每个元素顺序保持一致。</p><p>假设，我声明了tinyInt arr[4]，它占用从1201位置开始的一溜存储区域。当某个时刻我尝试读取a[2]，那么只要做简单的计算，找到a[2]的位置就可以了。例如1201+(2X4)然后直接从1209位置读取数据。</p><p><img data-src="https://user-gold-cdn.xitu.io/2017/9/5/195788ff466cc6fcb7c9f481baa39508?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在 JavaScript 中，数组是哈希映射。它可以通过多种数据结构实现，其中一种是链表。所以，如果在 JavaScript 中声明var arr = new Array(4)；它会产生类似上图的结构。因此，如果你想在程序中某一处读取a[2]，它必须从1201位置开始溯寻a[2]的位置。</p><p>这就是 JavaScript 数组和真正的数组不同的地方。显然数学计算要比链表遍历花的时间少。遇到长点的数组，日子就不好过了啊。</p><h2 id="JavaScript-数组演进"><a href="#JavaScript-数组演进" class="headerlink" title="JavaScript 数组演进"></a><strong>JavaScript 数组演进</strong></h2><p>还记得以前如果某个朋友的电脑有 256MB RAM我们多嫉妒吗？但现在，8GB RAM 已经稀松平常了。</p><p>跟它一样，JavaScript 这门语言也进化了许多。由于V8 、SpiderMonkey、TC39以及日益增多的 web 用户的努力，世界已经离不开 JavaScript 了。拥有如此巨大的用户群体，性能提升也势在必行。</p><p>近些日子， JavaScript 引擎已经在为同种数据类型的数组分配连续的存储空间了。优秀的开发者总是保持数组的数据类型一致，这样即时编译器 (JIT) 就能像 C 编译器一样通过计算读取数组了。</p><p>但是，如果你想在同种类型的数组中插入不同类型的元素，JIT 会销毁整个数组然后用以前的办法重建。</p><p>所以，如果你没写垃圾代码的话，JavaScript 的Array对象会维护一个真正的数组，这对现代 JS 开发者来说是一件大好事。</p><p>另外，在 ES2015/ES6 中， 数组还有其它改进。 TC39 决定在 JavaScript 中引入类型化数组，所以如今我们有 ArrayBuffer了。</p><p>ArrayBuffer 会有一大块连续的存储位置，你能用它做任何你想做的事情。不过，直接处理内存涉及非常底层的操作，相当复杂。</p><p>所以我们有 <a href="http://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView">Views</a> 来处理 ArrayBuffer。已经有一些可用的 View 了，未来还会加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer &#x3D; new ArrayBuffer(8);</span><br><span class="line">var view  &#x3D;  new Int32Array(buffer);</span><br><span class="line">view[0]&#x3D;100;</span><br></pre></td></tr></table></figure><p><em>如果你想知道更多有关类型化数组的信息，可以去看看<a href="http://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">MDN 文档</a></em></p><p>类型化数组性能良好且非常高效。WebGL 开发者因为缺少高效处理二进制数据的手段而经常面临性能问题，所以提出了类型化数组。你还可以使用<a href="http://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a>在多个 web-workers 间共享内存数据来提升性能。</p><p>惊讶吗？从简单的哈希映射开始，我们现在已经在讨论SharedArrayBuffer了。</p><h2 id="旧数组-vs-类型化数组-性能"><a href="#旧数组-vs-类型化数组-性能" class="headerlink" title="旧数组 vs 类型化数组-性能"></a><strong>旧数组 vs 类型化数组-性能</strong></h2><p>我们已经讲了大量 JavaScript 数组的改进了。现在看看类型化数组的好处。我在Mac 上用 Node.js 8.4.0 跑了一些小测试：</p><p><strong>旧数组-插入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var LIMIT &#x3D; 10000000;</span><br><span class="line">var arr &#x3D; new Array(LIMIT);</span><br><span class="line">console.time(&#39;Array insertion time&#39;);</span><br><span class="line">for(var i&#x3D;0;i&lt;LIMIT; i++)&#123;</span><br><span class="line">    arr[i]&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;Array insertion time&#39;);</span><br></pre></td></tr></table></figure><p><strong>所需时间</strong>：55ms</p><p><strong>类型化数组-插入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var LIMIT &#x3D; 10000000;</span><br><span class="line">var buffer &#x3D; new ArrayBuffer(LIMIT * 4);</span><br><span class="line">var arr &#x3D; new Int32Array(buffer);</span><br><span class="line">console.time(&quot;ArrayBuffer insertion time&quot;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; LIMIT; i++) &#123;</span><br><span class="line">    arr[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&quot;ArrayBuffer insertion time&quot;);</span><br></pre></td></tr></table></figure><p><strong>所需时间</strong>：52ms</p><p>我擦，我看到了啥？旧数组和 ArraryBuffer 的性能一样？不。回顾一下，前面我已经说过了，如今编译器已经在为类型一致的数组分配连续的存储空间了。所以在第一个例子中，即使我用的是new Array(LIMIT)，它仍然维护的是一个类型化数组。</p><p>让我们把第一个例子改成类型不一致的数组看看性能有没有变化。</p><p><strong>旧数组-插入（类型不一致）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var LIMIT &#x3D; 10000000;</span><br><span class="line">var arr &#x3D; new Array(LIMIT);</span><br><span class="line">arr.push(&#123;a: 22&#125;);</span><br><span class="line">console.time(&#39;Array insertion time&#39;);</span><br><span class="line">for(var i&#x3D;0;i&lt;LIMIT; i++)&#123;</span><br><span class="line">    arr[i]&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&#39;Array insertion time&#39;);</span><br></pre></td></tr></table></figure><p><strong>所需时间</strong>：1207ms</p><p>我在上面第三行插入了一个表达式让数组的类型不一致，其它所有的都跟前面一模一样。但是性能上有了巨大的变化：慢了整整22倍。</p><p><strong>旧数组-读取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; new Array(LIMIT);</span><br><span class="line">arr.push(&#123;a: 22&#125;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; LIMIT; i++) &#123;</span><br><span class="line">    arr[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">var p;</span><br><span class="line">console.time(&quot;Array read time&quot;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; LIMIT; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F;arr[i] &#x3D; i;</span><br><span class="line">    p &#x3D; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&quot;Array read time&quot;);</span><br></pre></td></tr></table></figure><p><strong>所需时间</strong>：196ms</p><p><strong>类型化数组-读取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var LIMIT &#x3D; 10000000;</span><br><span class="line">var buffer &#x3D; new ArrayBuffer(LIMIT * 4);</span><br><span class="line">var arr &#x3D; new Int32Array(buffer);</span><br><span class="line">console.time(&quot;ArrayBuffer insertion time&quot;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; LIMIT; i++) &#123;</span><br><span class="line">    arr[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">console.time(&quot;ArrayBuffer read time&quot;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; LIMIT; i++) &#123;</span><br><span class="line">    var p &#x3D; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(&quot;ArrayBuffer read time&quot;);</span><br></pre></td></tr></table></figure><p><strong>所需时间</strong>:27ms</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>在 JavaScript 中引入类型化数组是一个巨大的进步，Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array 等都是类型化数组 view,按照原生的 byte 数排序。你也可以看看 <a href="http://link.zhihu.com/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView </a>创建自己的 view 窗口。希望在将来会有更多 DataView 库方便我们使用 ArrayBuffer。</p><p>JavaScript 对数组做的改进很棒。现在它们快速、高效并且在分配内存时足够聪明了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/is-javascript-really-interpreted-or-compiled-language/">Is JavaScript really interpreted or compiled language?</a></li><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/create-filter-an-array-to-have-only-unique-elements-in-it/">Create / filter an array to have only unique elements in it</a></li><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/object-entries-object-values-ecmascript2017-es8-examples/">Object.entries() &amp; Object.values() in EcmaScript2017 (ES8) with examples</a></li><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/import-vs-require/">import vs require – ESM &amp; commonJs module differences</a></li><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/deep-dive-ember-routers-ember-js-tutorial-part-5/">A deep dive into ember routers – Ember.js Tutorial part 5</a></li><li><a href="http://link.zhihu.com/?target=http://voidcanvas.com/myths-facts-javascript/">Myths and Facts of JavaScript</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;用了这么久的js，多次使用js的数组，突然好奇，js数组到底是怎样的机制，很明显它与C语言的数组有很多不同，C语言数组就是内存中一块连续的区域，那么JS呢？感谢原作者：&lt;a href=&quot;http://link.zhihu.com/?target=http://voidcanvas.com/author/paulshan/&quot;&gt;Paul Shan&lt;/a&gt; 原文：&lt;a href=&quot;http://link.zhihu.com/?target=http://voidcanvas.com/javascript-array-evolution-performance/&quot;&gt;Diving deep into JavaScript array - evolution &amp;amp; performance&lt;/a&gt; 以及辛苦的翻译人员&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="数组" scheme="https://hxy1997.xyz/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>工程化</title>
    <link href="https://hxy1997.xyz/2021/03/17/%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hxy1997.xyz/2021/03/17/%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-03-17T14:14:39.000Z</published>
    <updated>2021-03-22T07:25:49.047Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍Node相关知识，很遗憾没有做过一个完整的Node项目，掌握度不足，但Vue实战中的打包过程用了很多相关知识，赶紧补起来，这一块实战中由于脚手架的出现，已经相对遗忘了，要自己写一个配置，就需要好好掌握了</p><span id="more"></span><h1 id="1-浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#1-浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="1. 浏览器与Node的事件循环(Event Loop)有何区别?"></a>1. 浏览器与Node的事件循环(Event Loop)有何区别?</h1><h2 id="1-1-线程与进程"><a href="#1-1-线程与进程" class="headerlink" title="1.1 线程与进程"></a>1.1 线程与进程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p><p>官方的说法是：<strong>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/9/168333c14c85d794?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li><li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li><li>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li><li>多个工厂之间独立存在。</li></ul><h3 id="2-多进程与多线程"><a href="#2-多进程与多线程" class="headerlink" title="2.多进程与多线程"></a>2.多进程与多线程</h3><ul><li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li><li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul><p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h2 id="1-2-浏览器内核"><a href="#1-2-浏览器内核" class="headerlink" title="1.2 浏览器内核"></a>1.2 浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程</li><li>JavaScript引擎线程</li><li>定时触发器线程</li><li>事件触发线程</li><li>异步http请求线程</li></ul><h3 id="1-2-1-GUI渲染线程"><a href="#1-2-1-GUI渲染线程" class="headerlink" title="1.2.1 GUI渲染线程"></a>1.2.1 GUI渲染线程</h3><ul><li>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li><li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li><li>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li></ul><h3 id="1-2-2-JS引擎线程"><a href="#1-2-2-JS引擎线程" class="headerlink" title="1.2.2 JS引擎线程"></a>1.2.2 JS引擎线程</h3><ul><li>该线程当然是主要负责处理 JavaScript脚本，执行代码。</li><li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li><li>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li></ul><h3 id="1-2-3-定时器触发线程"><a href="#1-2-3-定时器触发线程" class="headerlink" title="1.2.3 定时器触发线程"></a>1.2.3 定时器触发线程</h3><ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li><li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul><h3 id="1-2-4事件触发线程"><a href="#1-2-4事件触发线程" class="headerlink" title="1.2.4事件触发线程"></a>1.2.4事件触发线程</h3><ul><li>主要负责将准备好的事件交给 JS引擎线程执行。</li></ul><p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p><h3 id="1-2-5-异步http请求线程"><a href="#1-2-5-异步http请求线程" class="headerlink" title="1.2.5 异步http请求线程"></a>1.2.5 异步http请求线程</h3><ul><li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li><li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li></ul><h2 id="1-3-浏览器中的-Event-Loop"><a href="#1-3-浏览器中的-Event-Loop" class="headerlink" title="1.3 浏览器中的 Event Loop"></a>1.3 浏览器中的 Event Loop</h2><h3 id="1-3-1-Micro-Task-与-Macro-Task"><a href="#1-3-1-Micro-Task-与-Macro-Task" class="headerlink" title="1.3.1 Micro-Task 与 Macro-Task"></a>1.3.1 Micro-Task 与 Macro-Task</h3><p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li><li>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li></ul><h3 id="1-3-2-Event-Loop-过程解析"><a href="#1-3-2-Event-Loop-过程解析" class="headerlink" title="1.3.2 Event Loop 过程解析"></a>1.3.2 Event Loop 过程解析</h3><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li><li>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li><li>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li><li><strong>执行渲染操作，更新界面</strong></li><li>检查是否存在 Web worker 任务，如果有，则对其进行处理</li><li>上述过程循环往复，直到两个队列都清空</li></ul><p>我们总结一下，每一次循环都是一个这样的过程：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/10/1683877ba9aab056?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p><p>接下来我们看道例子来介绍上面流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;Promise1&#39;)  </span><br><span class="line">  setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;setTimeout2&#39;)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout1&#39;)</span><br><span class="line">  Promise.resolve().then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;Promise2&#39;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure><p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li><li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li><li>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li><li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul><h2 id="1-4-Node-中的-Event-Loop"><a href="#1-4-Node-中的-Event-Loop" class="headerlink" title="1.4 Node 中的 Event Loop"></a>1.4 Node 中的 Event Loop</h2><h3 id="1-4-1-Node简介"><a href="#1-4-1-Node简介" class="headerlink" title="1.4.1 Node简介"></a>1.4.1 Node简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/11/1683d81674f076eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Node.js的运行机制如下:</p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><h3 id="1-4-2-六个阶段"><a href="#1-4-2-六个阶段" class="headerlink" title="1.4.2 六个阶段"></a>1.4.2 六个阶段</h3><p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/12/16841bd9860c1ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>从上图中，大致看出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p><ul><li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅node内部使用</li><li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p><p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p><h4 id="1-timer"><a href="#1-timer" class="headerlink" title="(1) timer"></a>(1) timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p><h4 id="2-poll"><a href="#2-poll" class="headerlink" title="(2) poll"></a>(2) poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><p>1.回到 timer 阶段执行回调</p><p>2.执行 I/O 回调</p><p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发生<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><h4 id="3-check阶段"><a href="#3-check阶段" class="headerlink" title="(3) check阶段"></a>(3) check阶段</h4><p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;start&#39;)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timer1&#39;)</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timer2&#39;)</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&#39;promise3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;end&#39;)</span><br><span class="line">&#x2F;&#x2F;start&#x3D;&gt;end&#x3D;&gt;promise3&#x3D;&gt;timer1&#x3D;&gt;timer2&#x3D;&gt;promise1&#x3D;&gt;promise2</span><br></pre></td></tr></table></figure><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li><li>然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li></ul><h3 id="1-4-3-Micro-Task-与-Macro-Task"><a href="#1-4-3-Micro-Task-与-Macro-Task" class="headerlink" title="1.4.3 Micro-Task 与 Macro-Task"></a>1.4.3 Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li><li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li></ul><h3 id="1-4-4-注意点"><a href="#1-4-4-注意点" class="headerlink" title="1.4.4 注意点"></a>1.4.4 注意点</h3><h4 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="(1) setTimeout 和 setImmediate"></a>(1) setTimeout 和 setImmediate</h4><p>二者非常相似，区别主要在于调用时机不同。</p><ul><li>setImmediate 设计在poll阶段完成时执行，即check阶段；</li><li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function timeout () &#123;</span><br><span class="line">  console.log(&#39;timeout&#39;);</span><br><span class="line">&#125;,0);</span><br><span class="line">setImmediate(function immediate () &#123;</span><br><span class="line">  console.log(&#39;immediate&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li><li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li><li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li></ul><p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">fs.readFile(__filename, () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;timeout&#39;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;immediate&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; immediate</span><br><span class="line">&#x2F;&#x2F; timeout</span><br></pre></td></tr></table></figure><p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p><h4 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="(2) process.nextTick"></a>(2) process.nextTick</h4><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line"> console.log(&#39;timer1&#39;)</span><br><span class="line"> Promise.resolve().then(function() &#123;</span><br><span class="line">   console.log(&#39;promise1&#39;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line"> console.log(&#39;nextTick&#39;)</span><br><span class="line"> process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;nextTick&#39;)</span><br><span class="line">   process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&#39;nextTick&#39;)</span><br><span class="line">     process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">       console.log(&#39;nextTick&#39;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; nextTick&#x3D;&gt;nextTick&#x3D;&gt;nextTick&#x3D;&gt;nextTick&#x3D;&gt;timer1&#x3D;&gt;promise1</span><br></pre></td></tr></table></figure><h2 id="1-5-Node与浏览器的-Event-Loop-差异"><a href="#1-5-Node与浏览器的-Event-Loop-差异" class="headerlink" title="1.5 Node与浏览器的 Event Loop 差异"></a>1.5 Node与浏览器的 Event Loop 差异</h2><p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>接下我们通过一个例子来说明两者区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;timer1&#39;)</span><br><span class="line">    Promise.resolve().then(function() &#123;</span><br><span class="line">        console.log(&#39;promise1&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;timer2&#39;)</span><br><span class="line">    Promise.resolve().then(function() &#123;</span><br><span class="line">        console.log(&#39;promise2&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure><p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p><p>浏览器端的处理过程如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/12/16841d6392e8f537?imageslim" alt="img"></p><p>Node端运行结果分两种情况：</p><ul><li>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li><li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li><li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li></ul></li></ul><p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p><p>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</p><p>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</p><p>Node端的处理过程如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/1/12/16841d5f85468047?imageslim" alt="img"></p><h2 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h2><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node端，microtask 在事件循环的各个阶段之间执行</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章于2019.1.16晚，对最后一个例子在node运行结果，重新修改！再次特别感谢<a href="https://juejin.im/user/1521379822801224">zy445566</a>的精彩点评，<strong>由于node版本更新到11，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致</strong>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://imweb.io/topic/58e3bfa845e5c13468f567d5">浏览器进程？线程？傻傻分不清楚！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555331&idx=1&sn=5a063db73329a9d8ea5c38d8eeb50741&chksm=802551c2b752d8d4020514337f9987cc6611ba878525c45507cbb9ceb52b92e060f50e76c48d&mpshare=1&scene=1&srcid=1115P2jpgUGueMlTaRe9UFYu#rd">事件循环机制的那些事</a></li><li><a href="https://juejin.im/book/6844733750048210957">前端性能优化原理与实践</a></li><li><a href="https://juejin.im/book/6844733763675488269/section/6844733763763568654#heading-3">前端面试之道</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs">深入理解js事件循环机制（Node.js篇）</a></li><li><a href="https://zhuanlan.zhihu.com/p/33058983">详解JavaScript中的Event Loop（事件循环）机制</a></li><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">event-loop-timers-and-nexttick</a></li><li><a href="https://github.com/nodejs/node/pull/22842">timers: run nextTicks after each immediate and timer</a></li></ul><h1 id="2-前端模块化"><a href="#2-前端模块化" class="headerlink" title="2.前端模块化"></a>2.<a href="https://segmentfault.com/a/1190000017466120">前端模块化</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。<br>本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p><p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳<a href="https://github.com/ljianshu/Blog">GitHub个人博客</a></strong></p><p><img data-src="https://segmentfault.com/img/remote/1460000017466123?w=1240&h=564" alt="模块化规范"></p><h2 id="2-1-模块化的理解"><a href="#2-1-模块化的理解" class="headerlink" title="2.1 模块化的理解"></a>2.1 模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul><li><strong>全局function模式 : 将不同的功能封装成不同的全局函数</strong><ul><li>编码: 将不同的功能封装成不同的全局函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>namespace模式 : 简单对象封装</strong><ul><li>作用: 减少了全局变量，解决命名冲突</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let myModule &#x3D; &#123;</span><br><span class="line">  data: &#39;www.baidu.com&#39;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(&#96;foo() $&#123;this.data&#125;&#96;)</span><br><span class="line">  &#125;,</span><br><span class="line">  bar() &#123;</span><br><span class="line">    console.log(&#96;bar() $&#123;this.data&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.data &#x3D; &#39;other data&#39; &#x2F;&#x2F;能直接修改模块内部的数据</span><br><span class="line">myModule.foo() &#x2F;&#x2F; foo() other data</span><br></pre></td></tr></table></figure><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><ul><li><strong>IIFE模式：匿名函数自调用(闭包)</strong><ul><li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html文件</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;module.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">    myModule.bar()</span><br><span class="line">    console.log(myModule.data) &#x2F;&#x2F;undefined 不能访问模块内部数据</span><br><span class="line">    myModule.data &#x3D; &#39;xxxx&#39; &#x2F;&#x2F;不是修改的模块内部的data</span><br><span class="line">    myModule.foo() &#x2F;&#x2F;没有改变</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F; module.js文件</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  let data &#x3D; &#39;www.baidu.com&#39;</span><br><span class="line">  &#x2F;&#x2F;操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    &#x2F;&#x2F;用于暴露有函数</span><br><span class="line">    console.log(&#96;foo() $&#123;data&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    &#x2F;&#x2F;用于暴露有函数</span><br><span class="line">    console.log(&#96;bar() $&#123;data&#125;&#96;)</span><br><span class="line">    otherFun() &#x2F;&#x2F;内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    &#x2F;&#x2F;内部私有的函数</span><br><span class="line">    console.log(&#39;otherFun()&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;暴露行为</span><br><span class="line">  window.myModule &#x3D; &#123; foo, bar &#125; &#x2F;&#x2F;ES6写法</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure><p>最后得到的结果：</p><p><img data-src="https://segmentfault.com/img/remote/1460000017466124?w=419&h=105" alt="img"></p><ul><li><strong>IIFE模式增强 : 引入依赖</strong></li></ul><p>这就是现代模块实现的基石</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; module.js文件</span><br><span class="line">(function(window, $) &#123;</span><br><span class="line">  let data &#x3D; &#39;www.baidu.com&#39;</span><br><span class="line">  &#x2F;&#x2F;操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    &#x2F;&#x2F;用于暴露有函数</span><br><span class="line">    console.log(&#96;foo() $&#123;data&#125;&#96;)</span><br><span class="line">    $(&#39;body&#39;).css(&#39;background&#39;, &#39;red&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    &#x2F;&#x2F;用于暴露有函数</span><br><span class="line">    console.log(&#96;bar() $&#123;data&#125;&#96;)</span><br><span class="line">    otherFun() &#x2F;&#x2F;内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    &#x2F;&#x2F;内部私有的函数</span><br><span class="line">    console.log(&#39;otherFun()&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;暴露行为</span><br><span class="line">  window.myModule &#x3D; &#123; foo, bar &#125;</span><br><span class="line">&#125;)(window, jQuery)</span><br><span class="line"> &#x2F;&#x2F; index.html文件</span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.10.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;module.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul><li>避免命名冲突(减少命名空间污染)</li><li>更好的分离, 按需加载</li><li>更高复用性</li><li>高可维护性</li></ul><h3 id="4-引入多个-lt-script-gt-后出现出现问题"><a href="#4-引入多个-lt-script-gt-后出现出现问题" class="headerlink" title="4. 引入多个&lt;script&gt;后出现出现问题"></a>4. 引入多个<code>&lt;script&gt;</code>后出现出现问题</h3><ul><li>请求过多</li></ul><p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p><ul><li>依赖模糊</li></ul><p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p><ul><li>难以维护</li></ul><p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。<br>模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。</p><h2 id="2-2-模块化规范"><a href="#2-2-模块化规范" class="headerlink" title="2.2 模块化规范"></a>2.2 模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul><li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径</li></ul><p>此处我们有个疑问：<strong>CommonJS暴露的模块到底是什么?</strong> CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的module.exports属性</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example.js</span><br><span class="line">var x &#x3D; 5;</span><br><span class="line">var addX &#x3D; function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.x &#x3D; x;</span><br><span class="line">module.exports.addX &#x3D; addX;</span><br></pre></td></tr></table></figure><p>上面代码通过module.exports输出变量x和函数addX。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var example &#x3D; require(&#39;.&#x2F;example.js&#39;);&#x2F;&#x2F;如果参数字符串以“.&#x2F;”开头，则表示加载的是一个位于相对路径</span><br><span class="line">console.log(example.x); &#x2F;&#x2F; 5</span><br><span class="line">console.log(example.addX(1)); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><p>require命令用于加载模块文件。<strong>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错</strong>。</p><h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">var counter &#x3D; 3;</span><br><span class="line">function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">var counter &#x3D; require(&#39;.&#x2F;lib&#39;).counter;</span><br><span class="line">var incCounter &#x3D; require(&#39;.&#x2F;lib&#39;).incCounter;</span><br><span class="line"></span><br><span class="line">console.log(counter);  &#x2F;&#x2F; 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。<strong>这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①下载安装node-js"><a href="#①下载安装node-js" class="headerlink" title="①下载安装node.js"></a>①下载安装node.js</h4><h4 id="②创建项目结构"><a href="#②创建项目结构" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><p><strong>注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-modules</span><br><span class="line">  |-module1.js</span><br><span class="line">  |-module2.js</span><br><span class="line">  |-module3.js</span><br><span class="line">|-app.js</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;commonJS-node&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="③下载第三方模块"><a href="#③下载第三方模块" class="headerlink" title="③下载第三方模块"></a>③下载第三方模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uniq --save &#x2F;&#x2F; 用于数组去重</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码"><a href="#④定义模块代码" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;module1.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  msg: &#39;module1&#39;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(this.msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;module2.js</span><br><span class="line">module.exports &#x3D; function() &#123;</span><br><span class="line">  console.log(&#39;module2&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;module3.js</span><br><span class="line">exports.foo &#x3D; function() &#123;</span><br><span class="line">  console.log(&#39;foo() module3&#39;)</span><br><span class="line">&#125;</span><br><span class="line">exports.arr &#x3D; [1, 2, 3, 3, 2]</span><br><span class="line">&#x2F;&#x2F; app.js文件</span><br><span class="line">&#x2F;&#x2F; 引入第三方库，应该放置在最前面</span><br><span class="line">let uniq &#x3D; require(&#39;uniq&#39;)</span><br><span class="line">let module1 &#x3D; require(&#39;.&#x2F;modules&#x2F;module1&#39;)</span><br><span class="line">let module2 &#x3D; require(&#39;.&#x2F;modules&#x2F;module2&#39;)</span><br><span class="line">let module3 &#x3D; require(&#39;.&#x2F;modules&#x2F;module3&#39;)</span><br><span class="line"></span><br><span class="line">module1.foo() &#x2F;&#x2F;module1</span><br><span class="line">module2() &#x2F;&#x2F;module2</span><br><span class="line">module3.foo() &#x2F;&#x2F;foo() module3</span><br><span class="line">console.log(uniq(module3.arr)) &#x2F;&#x2F;[ 1, 2, 3 ]</span><br></pre></td></tr></table></figure><h4 id="⑤通过node运行app-js"><a href="#⑤通过node运行app-js" class="headerlink" title="⑤通过node运行app.js"></a>⑤通过node运行app.js</h4><p>命令行输入<code>node app.js</code>，运行JS文件</p><h4 id="6-浏览器端实现-借助Browserify"><a href="#6-浏览器端实现-借助Browserify" class="headerlink" title="(6)浏览器端实现(借助Browserify)"></a>(6)浏览器端实现(借助Browserify)</h4><h4 id="①创建项目结构"><a href="#①创建项目结构" class="headerlink" title="①创建项目结构"></a>①创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist &#x2F;&#x2F;打包生成文件的目录</span><br><span class="line">  |-src &#x2F;&#x2F;源码所在的目录</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js &#x2F;&#x2F;应用主源文件</span><br><span class="line">|-index.html &#x2F;&#x2F;运行于浏览器上</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;browserify-test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="②下载browserify"><a href="#②下载browserify" class="headerlink" title="②下载browserify"></a>②下载browserify</h4><ul><li>全局: npm install browserify -g</li><li>局部: npm install browserify –save-dev</li></ul><h4 id="③定义模块代码-同服务器端"><a href="#③定义模块代码-同服务器端" class="headerlink" title="③定义模块代码(同服务器端)"></a>③定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p><h4 id="④打包处理js"><a href="#④打包处理js" class="headerlink" title="④打包处理js"></a>④打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p><h4 id="⑤页面使用引入"><a href="#⑤页面使用引入" class="headerlink" title="⑤页面使用引入"></a>⑤页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</strong>。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p><h4 id="1-AMD规范基本语法"><a href="#1-AMD规范基本语法" class="headerlink" title="(1)AMD规范基本语法"></a>(1)AMD规范基本语法</h4><p><strong>定义暴露模块</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义没有依赖的模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;定义有依赖的模块</span><br><span class="line">define([&#39;module1&#39;, &#39;module2&#39;], function(m1, m2)&#123;</span><br><span class="line">   return 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&#39;module1&#39;, &#39;module2&#39;], function(m1, m2)&#123;</span><br><span class="line">   使用m1&#x2F;m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-未使用AMD规范与使用require-js"><a href="#2-未使用AMD规范与使用require-js" class="headerlink" title="(2)未使用AMD规范与使用require.js"></a>(2)未使用AMD规范与使用require.js</h4><p>通过比较两者的实现方法，来说明使用AMD规范的好处。</p><ul><li>未使用AMD规范</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; dataService.js文件</span><br><span class="line">(function (window) &#123;</span><br><span class="line">  let msg &#x3D; &#39;www.baidu.com&#39;</span><br><span class="line">  function getMsg() &#123;</span><br><span class="line">    return msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  window.dataService &#x3D; &#123;getMsg&#125;</span><br><span class="line">&#125;)(window)</span><br><span class="line"> &#x2F;&#x2F; alerter.js文件</span><br><span class="line">(function (window, dataService) &#123;</span><br><span class="line">  let name &#x3D; &#39;Tom&#39;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#39;, &#39; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  window.alerter &#x3D; &#123;showMsg&#125;</span><br><span class="line">&#125;)(window, dataService)</span><br><span class="line">&#x2F;&#x2F; main.js文件</span><br><span class="line">(function (alerter) &#123;</span><br><span class="line">  alerter.showMsg()</span><br><span class="line">&#125;)(alerter)</span><br><span class="line">&#x2F;&#x2F; index.html文件</span><br><span class="line">&lt;div&gt;&lt;h1&gt;Modular Demo 1: 未使用AMD(require.js)&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;modules&#x2F;dataService.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;modules&#x2F;alerter.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>最后得到如下结果：<br><img data-src="https://segmentfault.com/img/remote/1460000017466125?w=508&h=170" alt="img"></p><p>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！</strong></p><ul><li>使用require.js</li></ul><p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。<br>接下来介绍AMD规范在浏览器实现的步骤：</p><h4 id="①下载require-js-并引入"><a href="#①下载require-js-并引入" class="headerlink" title="①下载require.js, 并引入"></a>①下载require.js, 并引入</h4><ul><li>官网: <code>http://www.requirejs.cn/</code></li><li>github : <code>https://github.com/requirejs/requirejs</code></li></ul><p>然后将require.js导入项目: js/libs/require.js</p><h4 id="②创建项目结构-1"><a href="#②创建项目结构-1" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-require.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure><h4 id="③定义require-js的模块代码"><a href="#③定义require-js的模块代码" class="headerlink" title="③定义require.js的模块代码"></a>③定义require.js的模块代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; dataService.js文件 </span><br><span class="line">&#x2F;&#x2F; 定义没有依赖的模块</span><br><span class="line">define(function() &#123;</span><br><span class="line">  let msg &#x3D; &#39;www.baidu.com&#39;</span><br><span class="line">  function getMsg() &#123;</span><br><span class="line">    return msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123; getMsg &#125; &#x2F;&#x2F; 暴露模块</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;alerter.js文件</span><br><span class="line">&#x2F;&#x2F; 定义有依赖的模块</span><br><span class="line">define([&#39;dataService&#39;], function(dataService) &#123;</span><br><span class="line">  let name &#x3D; &#39;Tom&#39;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#39;, &#39; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 暴露模块</span><br><span class="line">  return &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; main.js文件</span><br><span class="line">(function() &#123;</span><br><span class="line">  require.config(&#123;</span><br><span class="line">    baseUrl: &#39;js&#x2F;&#39;, &#x2F;&#x2F;基本路径 出发点在根目录下</span><br><span class="line">    paths: &#123;</span><br><span class="line">      &#x2F;&#x2F;映射: 模块标识名: 路径</span><br><span class="line">      alerter: &#39;.&#x2F;modules&#x2F;alerter&#39;, &#x2F;&#x2F;此处不能写成alerter.js,会报错</span><br><span class="line">      dataService: &#39;.&#x2F;modules&#x2F;dataService&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  require([&#39;alerter&#39;], function(alerter) &#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; index.html文件</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Modular Demo&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span><br><span class="line">    &lt;script data-main&#x3D;&quot;js&#x2F;main&quot; src&#x3D;&quot;js&#x2F;libs&#x2F;require.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="④页面引入require-js模块"><a href="#④页面引入require-js模块" class="headerlink" title="④页面引入require.js模块:"></a>④页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p><p><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; alerter.js文件</span><br><span class="line">define([&#39;dataService&#39;, &#39;jquery&#39;], function(dataService, $) &#123;</span><br><span class="line">  let name &#x3D; &#39;Tom&#39;</span><br><span class="line">  function showMsg() &#123;</span><br><span class="line">    alert(dataService.getMsg() + &#39;, &#39; + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(&#39;body&#39;).css(&#39;background&#39;, &#39;green&#39;)</span><br><span class="line">  &#x2F;&#x2F; 暴露模块</span><br><span class="line">  return &#123; showMsg &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; main.js文件</span><br><span class="line">(function() &#123;</span><br><span class="line">  require.config(&#123;</span><br><span class="line">    baseUrl: &#39;js&#x2F;&#39;, &#x2F;&#x2F;基本路径 出发点在根目录下</span><br><span class="line">    paths: &#123;</span><br><span class="line">      &#x2F;&#x2F;自定义模块</span><br><span class="line">      alerter: &#39;.&#x2F;modules&#x2F;alerter&#39;, &#x2F;&#x2F;此处不能写成alerter.js,会报错</span><br><span class="line">      dataService: &#39;.&#x2F;modules&#x2F;dataService&#39;,</span><br><span class="line">      &#x2F;&#x2F; 第三方库模块</span><br><span class="line">      jquery: &#39;.&#x2F;libs&#x2F;jquery-1.10.1&#39; &#x2F;&#x2F;注意：写成jQuery会报错</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  require([&#39;alerter&#39;], function(alerter) &#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。<br><strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p><h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p><h4 id="1-CMD规范基本语法"><a href="#1-CMD规范基本语法" class="headerlink" title="(1)CMD规范基本语法"></a>(1)CMD规范基本语法</h4><p><strong>定义暴露模块：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义没有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  exports.xxx &#x3D; value</span><br><span class="line">  module.exports &#x3D; value</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;定义有依赖的模块</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  &#x2F;&#x2F;引入依赖模块(同步)</span><br><span class="line">  var module2 &#x3D; require(&#39;.&#x2F;module2&#39;)</span><br><span class="line">  &#x2F;&#x2F;引入依赖模块(异步)</span><br><span class="line">    require.async(&#39;.&#x2F;module3&#39;, function (m3) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#x2F;&#x2F;暴露模块</span><br><span class="line">  exports.xxx &#x3D; value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>引入使用模块：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 &#x3D; require(&#39;.&#x2F;module1&#39;)</span><br><span class="line">  var m4 &#x3D; require(&#39;.&#x2F;module4&#39;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-sea-js简单使用教程"><a href="#2-sea-js简单使用教程" class="headerlink" title="(2)sea.js简单使用教程"></a>(2)sea.js简单使用教程</h4><h4 id="①下载sea-js-并引入"><a href="#①下载sea-js-并引入" class="headerlink" title="①下载sea.js, 并引入"></a>①下载sea.js, 并引入</h4><ul><li>官网: <a href="http://seajs.org/">http://seajs.org/</a></li><li>github : <a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li></ul><p>然后将sea.js导入项目: js/libs/sea.js</p><h4 id="②创建项目结构-2"><a href="#②创建项目结构-2" class="headerlink" title="②创建项目结构"></a>②创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure><h4 id="③定义sea-js的模块代码"><a href="#③定义sea-js的模块代码" class="headerlink" title="③定义sea.js的模块代码"></a>③定义sea.js的模块代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; module1.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  &#x2F;&#x2F;内部变量数据</span><br><span class="line">  var data &#x3D; &#39;atguigu.com&#39;</span><br><span class="line">  &#x2F;&#x2F;内部函数</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(&#39;module1 show() &#39; + data)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;向外暴露</span><br><span class="line">  exports.show &#x3D; show</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; module2.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    msg: &#39;I Will Back&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; module3.js文件</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  const API_KEY &#x3D; &#39;abc123&#39;</span><br><span class="line">  exports.API_KEY &#x3D; API_KEY</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; module4.js文件</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">  &#x2F;&#x2F;引入依赖模块(同步)</span><br><span class="line">  var module2 &#x3D; require(&#39;.&#x2F;module2&#39;)</span><br><span class="line">  function show() &#123;</span><br><span class="line">    console.log(&#39;module4 show() &#39; + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  exports.show &#x3D; show</span><br><span class="line">  &#x2F;&#x2F;引入依赖模块(异步)</span><br><span class="line">  require.async(&#39;.&#x2F;module3&#39;, function (m3) &#123;</span><br><span class="line">    console.log(&#39;异步引入依赖模块3  &#39; + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; main.js文件</span><br><span class="line">define(function (require) &#123;</span><br><span class="line">  var m1 &#x3D; require(&#39;.&#x2F;module1&#39;)</span><br><span class="line">  var m4 &#x3D; require(&#39;.&#x2F;module4&#39;)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="④在index-html中引入"><a href="#④在index-html中引入" class="headerlink" title="④在index.html中引入"></a>④在index.html中引入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;libs&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  seajs.use(&#39;.&#x2F;js&#x2F;modules&#x2F;main&#39;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>最后得到结果如下：</p><p><img data-src="https://segmentfault.com/img/remote/1460000017466126?w=430&h=84" alt="img"></p><h3 id="4-ES6模块化"><a href="#4-ES6模块化" class="headerlink" title="4.ES6模块化"></a>4.ES6模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="1-ES6模块化语法"><a href="#1-ES6模块化语法" class="headerlink" title="(1)ES6模块化语法"></a>(1)ES6模块化语法</h4><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 定义模块 math.js **&#x2F;</span><br><span class="line">var basicNum &#x3D; 0;</span><br><span class="line">var add &#x3D; function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, add &#125;;</span><br><span class="line">&#x2F;** 引用模块 **&#x2F;</span><br><span class="line">import &#123; basicNum, add &#125; from &#39;.&#x2F;math&#39;;</span><br><span class="line">function test(ele) &#123;</span><br><span class="line">    ele.textContent &#x3D; add(99 + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&#39;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; import-default.js</span><br><span class="line">import customName from &#39;.&#x2F;export-default&#39;;</span><br><span class="line">customName(); &#x2F;&#x2F; &#39;foo&#39;</span><br></pre></td></tr></table></figure><p>模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：</p><p><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p><p><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p><p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; lib.js</span><br><span class="line">export let counter &#x3D; 3;</span><br><span class="line">export function incCounter() &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import &#123; counter, incCounter &#125; from &#39;.&#x2F;lib&#39;;</span><br><span class="line">console.log(counter); &#x2F;&#x2F; 3</span><br><span class="line">incCounter();</span><br><span class="line">console.log(counter); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p><h4 id="3-ES6-Babel-Browserify使用教程"><a href="#3-ES6-Babel-Browserify使用教程" class="headerlink" title="(3) ES6-Babel-Browserify使用教程"></a>(3) ES6-Babel-Browserify使用教程</h4><p>简单来说就一句话：<strong>使用Babel将ES6编译为ES5代码，使用Browserify编译打包js</strong>。</p><h4 id="①定义package-json文件"><a href="#①定义package-json文件" class="headerlink" title="①定义package.json文件"></a>①定义package.json文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;es6-babel-browserify&quot;,</span><br><span class="line">  &quot;version&quot; : &quot;1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②安装babel-cli-babel-preset-es2015和browserify"><a href="#②安装babel-cli-babel-preset-es2015和browserify" class="headerlink" title="②安装babel-cli, babel-preset-es2015和browserify"></a>②安装babel-cli, babel-preset-es2015和browserify</h4><ul><li><p>npm install babel-cli browserify -g</p></li><li><p>npm install babel-preset-es2015 –save-dev</p></li><li><p>preset 预设(将es6转换成es5的所有插件打包)</p></li></ul><h4 id="③定义-babelrc文件"><a href="#③定义-babelrc文件" class="headerlink" title="③定义.babelrc文件"></a>③定义.babelrc文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④定义模块代码-1"><a href="#④定义模块代码-1" class="headerlink" title="④定义模块代码"></a>④定义模块代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;module1.js文件</span><br><span class="line">&#x2F;&#x2F; 分别暴露</span><br><span class="line">export function foo() &#123;</span><br><span class="line">  console.log(&#39;foo() module1&#39;)</span><br><span class="line">&#125;</span><br><span class="line">export function bar() &#123;</span><br><span class="line">  console.log(&#39;bar() module1&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;module2.js文件</span><br><span class="line">&#x2F;&#x2F; 统一暴露</span><br><span class="line">function fun1() &#123;</span><br><span class="line">  console.log(&#39;fun1() module2&#39;)</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">  console.log(&#39;fun2() module2&#39;)</span><br><span class="line">&#125;</span><br><span class="line">export &#123; fun1, fun2 &#125;</span><br><span class="line">&#x2F;&#x2F;module3.js文件</span><br><span class="line">&#x2F;&#x2F; 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span><br><span class="line">export default () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;默认暴露&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; app.js文件</span><br><span class="line">import &#123; foo, bar &#125; from &#39;.&#x2F;module1&#39;</span><br><span class="line">import &#123; fun1, fun2 &#125; from &#39;.&#x2F;module2&#39;</span><br><span class="line">import module3 from &#39;.&#x2F;module3&#39;</span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br></pre></td></tr></table></figure><h4 id="⑤-编译并在index-html中引入"><a href="#⑤-编译并在index-html中引入" class="headerlink" title="⑤ 编译并在index.html中引入"></a>⑤ 编译并在index.html中引入</h4><ul><li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : <code>babel js/src -d js/lib</code></li><li>使用Browserify编译js : <code>browserify js/lib/app.js -o js/lib/bundle.js</code></li></ul><p>然后在index.html文件中引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;lib&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>最后得到如下结果：</p><p><img data-src="https://segmentfault.com/img/remote/1460000017466127?w=437&h=102" alt="img"></p><p><strong>此外第三方库(以jQuery为例)如何引入呢</strong>？<br>首先安装依赖<code>npm install jquery@1</code><br>然后在app.js文件中引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;app.js文件</span><br><span class="line">import &#123; foo, bar &#125; from &#39;.&#x2F;module1&#39;</span><br><span class="line">import &#123; fun1, fun2 &#125; from &#39;.&#x2F;module2&#39;</span><br><span class="line">import module3 from &#39;.&#x2F;module3&#39;</span><br><span class="line">import $ from &#39;jquery&#39;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">bar()</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br><span class="line">module3()</span><br><span class="line">$(&#39;body&#39;).css(&#39;background&#39;, &#39;green&#39;)</span><br></pre></td></tr></table></figure><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><ul><li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul><h1 id="3-Tree-Shaking"><a href="#3-Tree-Shaking" class="headerlink" title="3.Tree-Shaking"></a>3.Tree-Shaking</h1><h2 id="3-1-什么是Tree-shaking"><a href="#3-1-什么是Tree-shaking" class="headerlink" title="3.1 什么是Tree-shaking"></a>3.1 什么是Tree-shaking</h2><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6b970411f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>先来看一下Tree-shaking原始的本意</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfdcf2a31ce4a?imageslim" alt="img"></p><p>上图形象的解释了Tree-shaking 的本意，本文所说的前端中的tree-shaking可以理解为通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6b8b552461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p><h2 id="3-2-tree-shaking的原理"><a href="#3-2-tree-shaking的原理" class="headerlink" title="3.2 tree-shaking的原理"></a>3.2 tree-shaking的原理</h2><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6b8cae9900?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。</p><p>Tree-shaking 是 DCE 的一种新的实现，Javascript同传统的编程语言不同的是，javascript绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对javascript来说更有意义。</p><p>Tree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注宇消除没有用到的代码。下面详细介绍一下DCE和Tree-shaking。</p><p><strong>（1）先来看一下DCE消除大法</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6b8b4818fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Dead Code 一般具有以下几个特征</p><p>•代码不会被执行，不可到达</p><p>•代码执行的结果不会被用到</p><p>•代码只会影响死变量（只写不读）</p><p>下面红框标示的代码就属于死码，满足以上特征</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6baf4b104b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>传统编译型的语言中，都是由编译器将Dead Code从AST（抽象语法树）中删除，那javascript中是由谁做DCE呢？</p><p>首先肯定不是浏览器做DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p><p>其实也不是上面提到的三个工具，rollup，webpack，cc做的，而是著名的代码压缩优化工具uglify，uglify完成了javascript的DCE，下面通过一个实验来验证一下。</p><blockquote><p>以下所有的示例代码都能在github中找到<a href="https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">github.com/lin-xi/tree…</a></p></blockquote><p><strong>分别用rollup和webpack将图4中的代码进行打包</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6baf24ec38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>中间是rollup打包的结果，右边是webpack打包的结果</p><p>可以发现，rollup将无用的代码foo函数和unused函数消除了，但是仍然保留了不会执行到的代码，而webpack完整的保留了所有的无用代码和不会执行到的代码。</p><p><strong>分别用rollup + uglify和 webpack + uglify 将图4中的代码进行打包</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bb11fd152?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>图6</p><p>中间是配置文件，右侧是结果</p><p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p><p><strong>(2) 再看一下Tree-shaking消除大法</strong></p><p>前面提到了tree-shaking更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p><p>先思考一个问题，为什么tree-shaking是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实tree-shaking的消除原理是依赖于ES6的模块特性。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bb8832182?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>ES6 module 特点：</p><ul><li>只能作为模块顶层的语句出现</li><li>import 的模块名只能是字符串常量</li><li>import binding 是 immutable的</li></ul><p>ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。</p><p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p><p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p><p>我们还是通过例子来详细了解一下</p><p>面向过程编程函数和面向对象编程是javascript最常用的编程模式和代码组织方式，从这两个方面来实验：</p><ul><li>函数消除实验</li><li>类消除实验</li></ul><p><strong>先看下函数消除实验</strong></p><p>utils中get方法没有被使用到，我们期望的是get方法最终被消除。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bc4a537f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>注意，uglify目前不会跨文件去做DCE，所以上面这种情况，uglify是不能优化的。</p><p><strong>先看看rollup的打包结果</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bd406dd90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>完全符合预期，最终结果中没有get方法</p><p><strong>再看看webpack的结果</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bcd7d371a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>也符合预期，最终结果中没有get方法</p><p>可以看到rollup打包的结果比webpack更优化</p><blockquote><p>函数消除实验中，rollup和webpack都通过，符合预期</p></blockquote><p><strong>再来看下类消除实验</strong></p><p>增加了对menu.js的引用，但其实代码中并没有用到menu的任何方法和变量，所以我们的期望是，最终代码中menu.js里的内容被消除</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bcd97b34f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>main.js</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bd77e84e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>menu.js</p><p><strong>rollup打包结果</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bd7406d51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>包中竟然包含了menu.js的全部代码</p><p><strong>webpack打包结果</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bdec358f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>包中竟然也包含了menu.js的全部代码</p><blockquote><p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p></blockquote><p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做tree-shaking吗？我当时一度怀疑自己的demo有问题，后来各种网上搜索，才明白demo没有错。</p><p>下面摘取了rollup核心贡献者的的一些回答：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bef36c293?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>图7</p><ul><li>rollup只处理函数和顶层的import/export变量，不能把没用到的类的方法消除掉</li><li>javascript动态语言的特性使得静态分析比较困难</li><li>图7下部分的代码就是副作用的一个例子，如果静态分析的时候删除里run或者jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li></ul><p>再举个例子说明下为什么不能消除menu.js，比如下面这个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure><p>如果删除里menu.js，那对Array的扩展也会被删除，就会影响功能。那也许你会问，难道rollup，webpack不能区分是定义Menu的proptotype 还是定义Array的proptotype吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Arr&#39; + &#39;ay&#39;</span><br><span class="line">var b</span><br><span class="line">if(a &#x3D;&#x3D; &#39;Array&#39;) &#123;</span><br><span class="line">    b &#x3D; Array</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b &#x3D; Menu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure><p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p><p>更多关于副作用的讨论，可以看这个</p><p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349"><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bef801e7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图标"></a></p><p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349">Tree shaking class methods · Issue #349 · rollup/rollupgithub.com</a></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bf23f1d6d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><p>tree-shaking对函数效果较好</p></blockquote><p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上babel默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p><p>我们开始说的三个工具，rollup和webpack表现不理想，那closure compiler又如何呢？</p><p>将示例中的代码用cc打包后得到的结果如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6c102e5ed1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p><blockquote><p>closure compiler， tree-shaking的结果完美！</p></blockquote><p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是cc的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bf5516b9d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>google定义一整套注解规范Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p><p>侵入式这个就让人很不爽，google Closure Compiler是java写的，和我们基于node的各种构建库不可能兼容（不过目前好像已经有nodejs版 Closure Compiler），Closure Compiler使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p><p><strong>说了这么多，总结一下：</strong></p><p>三大工具的tree-shaking对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler是最好的，但与我们日常的基于node的开发流很难兼容。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6c064d09f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>tree-shaking对web意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p><p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p><p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p><p>优化是一种态度，不因小而不为，不因艰而不攻。</p><h2 id="3-3-tree-shaking实践"><a href="#3-3-tree-shaking实践" class="headerlink" title="3.3 tree-shaking实践"></a>3.3 tree-shaking实践</h2><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2698a828b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>webpack2 发布，宣布支持tree-shaking，webpack 3发布，支持作用域提升，生成的bundle文件更小。 再没有升级webpack之前，增幻想我们的性能又要大幅提升了，对升级充满了期待。实际上事实是这样的</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde269ee60b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>升级完之后，bundle文件大小并没有大幅减少，当时有较大的心理落差，然后去研究了为什么效果不理想，原因见 <a href="https://juejin.im/post/6844903544756109319">Tree-Shaking性能优化实践 - 原理篇</a> 。</p><p>优化还是要继续的，虽然工具自带的tree-shaking不能去除太多无用代码，在去除无用代码这一方面也还是有可以做的事情。我们从三个方面做里一些优化。</p><h2 id="（1）对组件库引用的优化"><a href="#（1）对组件库引用的优化" class="headerlink" title="（1）对组件库引用的优化"></a>（1）对组件库引用的优化</h2><p>先来看一个问题</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde26a0b236a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>当我们使用组件库的时候，import {Button} from ‘element-ui’，相对于Vue.use(elementUI)，已经是具有性能意识，是比较推荐的做法，但如果我们写成右边的形式，具体到文件的引用，打包之后的区别是非常大的，以antd为例，右边形式bundle体积减少约80%。</p><p>这个引用也属于有副作用，webpack不能把其他组件进行tree-shaking。既然工具本身是做不了，那我们可以做工具把左边代码自动改成右边代码这种形式。这个工具antd库本身也是提供的。我在antd的工具基础上做了少量的修改，不用任何配置，原生支持我们自己的组件库， <a href="http://link.zhihu.com/?target=https://w-ui.github.io/%23/doc">wui</a> 和 <a href="http://link.zhihu.com/?target=https://wmfe.github.io/xcui/%23/home">xcui</a> 以及一些其他常用的库</p><p><strong>babel-plugin-import-fix ，缩小引用范围</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde26a2f7bcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix"><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bb878d28e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图标"></a></p><p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix">lin-xi/babel-plugin-import-fix</a></p><p>下面介绍一下原理</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde277e8ea5a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这是一个babel的插件，babel通过核心babylon将ES6代码转换成AST抽象语法树，然后插件遍历语法树找出类似import {Button} from ‘element-ui’这样的语句，进行转换，最后重新生成代码。</p><p>babel-plugin-import-fix默认支持antd，element，meterial-UI，wui，xcui和d3，只需要再.babelrc中配置插件本身就可以。</p><p>.babelrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;], &quot;react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;import-fix&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde276aaf2ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其实是想把所有常用的库都默认支持，但很多常用的库却不支持缩小引用范围。因为没有独立输出各个子模块，不能把引用修改为对单个子模块的引用。</p><h2 id="（2）CSS-Tree-shaking"><a href="#（2）CSS-Tree-shaking" class="headerlink" title="（2）CSS Tree-shaking"></a>（2）CSS Tree-shaking</h2><p>我们前面所说的tree-shaking都是针对js文件，通过静态分析，尽可能消除无用的代码，那对于css我们能做tree-shaking吗？</p><p>随着CSS3，LESS，SASS等各种css预处理语言的普及，css文件在整个工程中占比是不可忽视的。随着大项目功能的不停迭代，导致css中可能就存在着无用的代码。我实现了一个webpack插件来解决这个问题，找出css代码无用的代码。</p><p><strong><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">webpack-css-treeshaking-plugin</a>，对css进行tree-shaking</strong></p><p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix"><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfd6bb878d28e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图标"></a><br><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">webpack-css-treeshaking-plugin</a></p><p>下面介绍一下原理</p><p>整体思路是这样的，遍历所有的css文件中的selector选择器，然后去所有js代码中匹配，如果选择器没有在代码出现过，则认为该选择器是无用代码。</p><p><strong>首先面临的问题是，如何优雅的遍历所有的选择器呢？难道要用正则表达式很苦逼的去匹配分割吗？</strong></p><p>babel是js世界的福星，其实css世界也有利器，那就是postCss。</p><p>PostCSS 提供了一个解析器，它能够将 CSS 解析成AST抽象语法树。然后我们能写各种插件，对抽象语法树做处理，最终生成新的css文件，以达到对css进行精确修改的目的。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde28789c23f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>整体又是一个webpack的插件，架构图如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde288369a85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>主要流程：</p><ul><li>插件监听webapck编译完成事件，webpack编译完成之后，从compilation中找出所有的css文件和js文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(&#39;after-emit&#39;, (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      let styleFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.css$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      let jsFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.(js|jsx)$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将所有的css文件送至postCss处理，找出无用代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let tasks &#x3D; []</span><br><span class="line"> styleFiles.forEach((filename) &#x3D;&gt; &#123;</span><br><span class="line">     const source &#x3D; compilation.assets[filename].source()</span><br><span class="line">     let listOpts &#x3D; &#123;</span><br><span class="line">       include: &#39;&#39;,</span><br><span class="line">       source: jsContents,  &#x2F;&#x2F;传入全部js文件</span><br><span class="line">       opts: this.options   &#x2F;&#x2F;插件配置选项</span><br><span class="line">     &#125;</span><br><span class="line">     tasks.push(postcss(treeShakingPlugin(listOpts)).process(source).then(result &#x3D;&gt; &#123;       </span><br><span class="line">       let css &#x3D; result.toString()  &#x2F;&#x2F; postCss处理后的css AST  </span><br><span class="line">       &#x2F;&#x2F;替换webpack的编译产物compilation</span><br><span class="line">       compilation.assets[filename] &#x3D; &#123;</span><br><span class="line">         source: () &#x3D;&gt; css,</span><br><span class="line">         size: () &#x3D;&gt; css.length</span><br><span class="line">       &#125;</span><br><span class="line">       return result</span><br><span class="line">     &#125;))</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ul><li>postCss 遍历，匹配，删除过程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; postcss.plugin(&#39;list-selectors&#39;, function (options) &#123;</span><br><span class="line">   &#x2F;&#x2F; 从根节点开始遍历</span><br><span class="line">   cssRoot.walkRules(function (rule) &#123;</span><br><span class="line">     &#x2F;&#x2F; Ignore keyframes, which can log e.g. 10%, 20% as selectors</span><br><span class="line">     if (rule.parent.type &#x3D;&#x3D;&#x3D; &#39;atrule&#39; &amp;&amp; &#x2F;keyframes&#x2F;.test(rule.parent.name)) return</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 对每一个规则进行处理</span><br><span class="line">     checkRule(rule).then(result &#x3D;&gt; &#123;</span><br><span class="line">       if (result.selectors.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器全部被删除</span><br><span class="line">         let log &#x3D; &#39; ✂️ [&#39; + rule.selector + &#39;] shaked, [1]&#39;</span><br><span class="line">         console.log(log)</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           rule.remove()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器被部分删除</span><br><span class="line">         let shaked &#x3D; rule.selectors.filter(item &#x3D;&gt; &#123;</span><br><span class="line">           return result.selectors.indexOf(item) &#x3D;&#x3D;&#x3D; -1</span><br><span class="line">         &#125;)</span><br><span class="line">         if (shaked &amp;&amp; shaked.length &gt; 0) &#123;</span><br><span class="line">           let log &#x3D; &#39; ✂️ [&#39; + shaked.join(&#39; &#39;) + &#39;] shaked, [2]&#39;</span><br><span class="line">           console.log(log)</span><br><span class="line">         &#125;</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           &#x2F;&#x2F; 修改AST抽象语法树</span><br><span class="line">           rule.selectors &#x3D; result.selectors</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>checkRule 处理每一个规则核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let checkRule &#x3D; (rule) &#x3D;&gt; &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        let secs &#x3D; rule.selectors.filter(function (selector) &#123;</span><br><span class="line">          let result &#x3D; true</span><br><span class="line">          let processor &#x3D; parser(function (selectors) &#123;</span><br><span class="line">            for (let i &#x3D; 0, len &#x3D; selectors.nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">              let node &#x3D; selectors.nodes[i]</span><br><span class="line">              if (_.includes([&#39;comment&#39;, &#39;combinator&#39;, &#39;pseudo&#39;], node.type)) continue</span><br><span class="line">              for (let j &#x3D; 0, len2 &#x3D; node.nodes.length; j &lt; len2; j++) &#123;</span><br><span class="line">                let n &#x3D; node.nodes[j]</span><br><span class="line">                if (!notCache[n.value]) &#123;</span><br><span class="line">                  switch (n.type) &#123;</span><br><span class="line">                    case &#39;tag&#39;:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                    case &#39;id&#39;:</span><br><span class="line">                    case &#39;class&#39;:</span><br><span class="line">                      if (!classInJs(n.value)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用classInJs判断是否在JS中出现过</span><br><span class="line">                        notCache[n.value] &#x3D; true</span><br><span class="line">                        result &#x3D; false</span><br><span class="line">                        break</span><br><span class="line">                      &#125;</span><br><span class="line">                      break</span><br><span class="line">                    default:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  result &#x3D; false</span><br><span class="line">                  break</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          ...</span><br><span class="line">        &#125;)</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到其实我只处理里 id选择器和class选择器，id和class相对来说副作用小，引起样式异常的可能性相对较小。</p><p>判断css是否再js中出现过，是使用正则匹配。</p><p>其实，后续还可以继续优化，比如对tag类的选择器，可以配置是否再html，jsx，template中出现过，如果出现过，没有出现过也可以认为是无用代码。</p><p>当然，插件能正常工作还是的有一些前提和约束。我们可以在代码中动态改变css，比如再react和vue中，可以这么写</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde28dd70e3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这样是比较推荐的方式，选择器作为字符或变量名出现在代码中，下面这样动态生成选择器的情况就会导致匹配失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; &#39;state-&#39; + this.state &#x3D;&#x3D; 2 ? &#39;open&#39; : &#39;close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中这样情况很容易避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; this.state &#x3D;&#x3D; 2 ? &#39;state-open&#39; : &#39;state-close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以有一个好的编码规范的约束，插件能更好的工作。</p><h2 id="（3）webpack-bundle文件去重"><a href="#（3）webpack-bundle文件去重" class="headerlink" title="（3）webpack bundle文件去重"></a>（3）webpack bundle文件去重</h2><p>如果webpack打包后的bundle文件中存在着相同的模块，也属于无用代码的一种。也应该被去除掉</p><p>首先我们需要一个能对bundle文件定性分析的工具，能发现问题，能看出优化效果。</p><p>webpack-bundle-analyzer这个插件完全能满足我们的需求，他能以图形化的方式展示bundle中所有的模块的构成的各构成的大小。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde29710f82d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其次，需求对通用模块进行提取，CommonsChunkPlugin是最被人熟知的用于提供通用模块的插件。早期的时候，我并不完全了解他的功能，并没有发挥最大的功效。</p><p>下面介绍CommonsChunkPlugin的正确用法</p><p><strong>自动提取所有的node_moudles或者引用次数两次以上的模块</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2a12a6464?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>minChunks可以接受一个数值或者函数，如果是函数，可自定义打包规则</p><p>但使用上面记载的配置之后，并不能高枕无忧。因为这个配置只能提取所有entry打包后的文件中的通用模块。而现实是，有了提高性能，我们会按需加载，通过webpack提供的import（…）方法，这种按需加载的文件并不会存在于entry之中，所以按需加载的异步模块中的通用模块并没有提取。</p><p><strong>如何提取按需加载的异步模块里的通用模块呢？</strong></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2a3cd1f44?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>配置另一个CommonsChunkPlugin，添加async属性，async可以接受布尔值或字符串。当时字符串时，默认是输出文件的名称。</p><p>names是所有异步模块的名称</p><p>这里还涉及一个给异步模块命名的知识点。我是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Edit &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;EditPage&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Edit&#x2F;Edit&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const PublishPage &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Publish&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Publish&#x2F;Publish&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const Models &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Models&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Models&#x2F;Models&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const MediaUpload &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;MediaUpload&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Media&#x2F;MediaUpload&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const RealTime &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;RealTime&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;RealTime&#x2F;RealTime&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br></pre></td></tr></table></figure><p>没错，在import里添加注释。/* webpackChunkName: “EditPage” */ ，虽然看着不舒服，但是管用。</p><p>贴一个项目的优化效果对比图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2aa751805?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>优化效果还是比较明显。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2aa34e682?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>优化前bundle</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/1/4/160bfde2ae93d057?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>优化后bundle</p><p><strong>最后思考一个问题：</strong></p><p><strong>不同entry模块或按需加载的异步模块需不需要提取通用模块？</strong></p><p>这个需要看场景了，比如模块都是在线加载的，如果通用模块提取粒度过小，会导致首页首屏需要的文件变多，很多可能是首屏用不到的，导致首屏过慢，二级或三级页面加载会大幅提升。所以这个就需要根据业务场景做权衡，控制通用模块提取的粒度。</p><p>百度外卖的移动端应用场景是这样的，我们所有的移动端页面都做了离线化的处理。离线之后，加载本地的js文件，与网络无关，基本上可以忽略文件大小，所以更关注整个离线包的大小。离线包越小，耗费用户的流量就越小，用户体验更好，所以离线化的场景是非常适合最小粒提取通用模块的，即将所有entry模块和异步加载模块的引用大于2的模块都提取，这样能获得最小的输出文件，最小的离线包。</p><h1 id="4-uglify原理"><a href="#4-uglify原理" class="headerlink" title="4.uglify原理"></a>4.uglify原理</h1><h2 id="4-1-AST（抽象语法树）"><a href="#4-1-AST（抽象语法树）" class="headerlink" title="4.1  AST（抽象语法树）"></a>4.1  AST（抽象语法树）</h2><p>要想了解JS的压缩原理，需要首先了解AST。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象语法树：AST（Abstract Syntax Tree)，是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</span><br></pre></td></tr></table></figure><p>举个例子：</p><p><img data-src="https://www.h5w3.com/wp-content/uploads/2020/06/bVbHPdq.png" alt="image.png"></p><p><img data-src="https://www.h5w3.com/wp-content/uploads/2020/06/bVbHPdr.png" alt="image.png"></p><p>从上面两个例子中，可以看出AST是源代码根据其语法结构，省略一些细节（比如：括号没有生成节点），抽象成树形表达。抽象语法树在计算机科学中有很多应用，比如编译器、IDE、压缩代码、格式化代码等。[1]</p><h2 id="4-2-代码压缩原理"><a href="#4-2-代码压缩原理" class="headerlink" title="4.2 代码压缩原理"></a>4.2 代码压缩原理</h2><p>了解了AST之后，我们再分析一下JS的代码压缩原理。简单的说，就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将code转换成AST</span><br><span class="line">2. 将AST进行优化，生成一个更小的AST</span><br><span class="line">3. 将新生成的AST再转化成code</span><br></pre></td></tr></table></figure><p>PS：具体的AST树大家可以在astexplorer上在线获得</p><p>babel，eslint，v8的逻辑均与此类似，下图是我们引用了babel的转化示意图：<br><img data-src="https://www.h5w3.com/wp-content/uploads/2020/06/bVbDNYp.jpg" alt="1.jpg"></p><p>以我们之前被质疑的代码为例，看看它在uglify中是怎么样一步一步被压缩的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; uglify-js的版本需要为2.x, 3.0之后uglifyjs不再暴露Compressor api</span><br><span class="line">&#x2F;&#x2F; 2.x的uglify不能自动解析es6，所以这里先切换成es5</span><br><span class="line">&#x2F;&#x2F; npm install uglify-js@2.x</span><br><span class="line">var UglifyJS &#x3D; require(&#39;uglify-js&#39;);</span><br><span class="line">&#x2F;&#x2F; 原始代码</span><br><span class="line">var code &#x3D; &#96;var a;</span><br><span class="line">var x &#x3D; &#123; b: 123 &#125;;</span><br><span class="line">a &#x3D; 123,</span><br><span class="line">delete x&#96;;</span><br><span class="line">&#x2F;&#x2F; 通过 UglifyJS 把代码解析为 AST</span><br><span class="line">var ast &#x3D; UglifyJS.parse(code);</span><br><span class="line">ast.figure_out_scope();</span><br><span class="line">&#x2F;&#x2F; 转化为一颗更小的 AST 树</span><br><span class="line">compressor &#x3D; UglifyJS.Compressor();</span><br><span class="line">ast &#x3D; ast.transform(compressor);</span><br><span class="line">&#x2F;&#x2F; 再把 AST 转化为代码</span><br><span class="line">code &#x3D; ast.print_to_string();</span><br><span class="line">&#x2F;&#x2F; var a,x&#x3D;&#123;b:123&#125;;a&#x3D;123,delete x;</span><br><span class="line">console.log(&quot;code&quot;, code);</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了uglifyjs的代码压缩原理，但是还没有解决一个问题——为什么某些语句间的分号会被转换为逗号，某些不会转换。这就涉及到了uglifyjs的压缩规则。</p><h2 id="4-3-代码压缩规则"><a href="#4-3-代码压缩规则" class="headerlink" title="4.3 代码压缩规则"></a>4.3 代码压缩规则</h2><p>由于uglifyjs的代码压缩规则很多，我们这里只分析与本文中相关的部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uglifyjs的全部压缩规则可以参见：《[解读uglifyJS（四）——Javascript代码压缩](https:&#x2F;&#x2F;rapheal.sinaapp.com&#x2F;2014&#x2F;05&#x2F;22&#x2F;uglifyjs-squeeze&#x2F;#more-705)》</span><br></pre></td></tr></table></figure><p><img data-src="https://www.h5w3.com/wp-content/uploads/2020/06/bVbHPfO.png" alt="image.png"></p><p>PS：在线demo</p><p>这其中需要注意的是只有“表达式语句”才能被合并，那么什么是表达式语句呢？</p><p><strong>表达式 VS 语句 VS 表达式语句</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    a; &#x2F;&#x2F;返回a的值</span><br><span class="line">b + 3; &#x2F;&#x2F; 返回b+3的结果</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    if(x &gt; 0) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">for(var i &#x3D; 0;i &lt; arr.length; i ++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">const a &#x3D; 123;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    A();</span><br><span class="line">function() &#123;&#125;();</span><br><span class="line">delete x.b;</span><br><span class="line">b &#x3D; b + 3;</span><br></pre></td></tr></table></figure><p>综上所述，因为a = 123 和 delete x都是表达式语句，所以分号被转换为逗号。而var x = {b:123}则因为是声明语句，所以和a=123不会合并，分号不会被转换。但var x = {b:123}和第一行var a又触发了另外一条规则，</p><p>所以第一行和第二行会被合并为var a,x={b:123}</p><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p>在本文中，我们讨论了什么是抽象语法树，uglifyjs的压缩原理，以及相应的压缩规则，最终明晰了为什么代码会被压缩成我们得到的样子，希望对大家有所帮助。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]《抽象语法树在 JavaScript 中的应用》<br>[2]《javascript 代码是如何被压缩的》<br>[3]《[译]JavaScript中:表达式和语句的区别》<br>[4]《解读uglifyJS（四）——Javascript代码压缩》</p><h1 id="5-Babel原理"><a href="#5-Babel原理" class="headerlink" title="5.Babel原理"></a>5.<a href="https://my.oschina.net/u/4088983/blog/4545928">Babel原理</a></h1><h2 id="5-1-什么是-AST"><a href="#5-1-什么是-AST" class="headerlink" title="5.1 什么是 AST"></a>5.1 什么是 AST</h2><p>抽象语法树（<code>Abstract Syntax Tree</code>）简称 <code>AST</code>，是源代码的抽象语法结构的树状表现形式。<code>webpack</code>、<code>eslint</code> 等很多工具库的核心都是通过抽象语法树这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念</p><p>我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。</p><p><img data-src="https://oscimg.oschina.net/oscnet/d60e4800-53b4-466b-8cac-a78d3575d237.jpg" alt="img"></p><p>如上图中变量声明语句，转换为 AST 之后就是右图中显示的样式</p><p>左图中对应的：</p><ul><li><code>var</code> 是一个关键字</li><li><code>AST</code> 是一个定义者</li><li><code>=</code> 是 Equal 等号的叫法有很多形式，在后面我们还会看到</li><li><code>is tree</code> 是一个字符串</li><li><code>;</code> 就是 Semicoion</li></ul><p>首先一段代码转换成的抽象语法树是一个对象，该对象会有一个顶级的 type 属性 <code>Program</code>；第二个属性是 <code>body</code> 是一个数组。</p><p><code>body</code> 数组中存放的每一项都是一个对象，里面包含了所有的对于该语句的描述信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type:         描述该语句的类型  --&gt; 变量声明的语句</span><br><span class="line">kind:         变量声明的关键字  --&gt; var</span><br><span class="line">declaration:  声明内容的数组，里面每一项也是一个对象</span><br><span class="line">            type: 描述该语句的类型</span><br><span class="line">            id:   描述变量名称的对象</span><br><span class="line">                type: 定义</span><br><span class="line">                name: 变量的名字</span><br><span class="line">            init: 初始化变量值的对象</span><br><span class="line">                type:   类型</span><br><span class="line">                value:  值 &quot;is tree&quot; 不带引号</span><br><span class="line">                row:    &quot;\&quot;is tree&quot;\&quot; 带引号</span><br></pre></td></tr></table></figure><h2 id="5-2-词法分析和语法分析"><a href="#5-2-词法分析和语法分析" class="headerlink" title="5.2 词法分析和语法分析"></a>5.2 词法分析和语法分析</h2><p><code>JavaScript</code> 是解释型语言，一般通过 词法分析 -&gt; 语法分析 -&gt; 语法树，就可以开始解释执行了</p><p>词法分析：也叫<code>扫描</code>，是将字符流转换为记号流(<code>tokens</code>)，它会读取我们的代码然后按照一定的规则合成一个个的标识</p><p>比如说：<code>var a = 2</code> ，这段代码通常会被分解成 <code>var、a、=、2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#123; type: &#39;Keyword&#39;, value: &#39;var&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;Identifier&#39;, value: &#39;a&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;Punctuator&#39;, value: &#39;&#x3D;&#39; &#125;,</span><br><span class="line">  &#123; type: &#39;Numeric&#39;, value: &#39;2&#39; &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当词法分析源代码的时候，它会一个一个字符的读取代码，所以很形象地称之为扫描 - <code>scans</code>。当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。</p><p>语法分析：也称<code>解析器</code>，将词法分析出来的数组转换成树的形式，同时验证语法。语法如果有错的话，抛出语法错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  ...  &quot;type&quot;: &quot;VariableDeclarator&quot;,  &quot;id&quot;: &#123;    &quot;type&quot;: &quot;Identifier&quot;,    &quot;name&quot;: &quot;a&quot;  &#125;,  ...&#125;</span><br></pre></td></tr></table></figure><p>语法分析成 AST ，我们可以在这里在线看到效果 <a href="http://esprima.org/">http://esprima.org</a></p><h2 id="5-3-AST-能做什么"><a href="#5-3-AST-能做什么" class="headerlink" title="5.3 AST 能做什么"></a>5.3 AST 能做什么</h2><ul><li>语法检查、代码风格检查、格式化代码、语法高亮、错误提示、自动补全等</li><li>代码混淆压缩</li><li>优化变更代码，改变代码结构等</li></ul><p>比如说，有个函数 <code>function a() &#123;&#125;</code> 我想把它变成 <code>function b() &#123;&#125;</code></p><p>比如说，在 <code>webpack</code> 中代码编译完成后 <code>require(&#39;a&#39;) --&gt; __webapck__require__(&quot;*/**/a.js&quot;)</code></p><p>下面来介绍一套工具，可以把代码转成语法树然后改变节点以及重新生成代码</p><h2 id="5-4-AST-解析流程"><a href="#5-4-AST-解析流程" class="headerlink" title="5.4 AST 解析流程"></a>5.4 AST 解析流程</h2><p>准备工具：</p><ul><li>esprima：code =&gt; ast 代码转 ast</li><li>estraverse: traverse ast 转换树</li><li>escodegen: ast =&gt; code</li></ul><p>在推荐一个常用的 AST 在线转换网站：<a href="https://astexplorer.net/">https://astexplorer.net/</a></p><p>比如说一段代码 <code>function getUser() &#123;&#125;</code>，我们把函数名字更改为 <code>hello</code>，看代码流程</p><p>看以下代码，简单说明 <code>AST</code> 遍历流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const esprima &#x3D; require(&#39;esprima&#39;)</span><br><span class="line">const estraverse &#x3D; require(&#39;estraverse&#39;)</span><br><span class="line">const code &#x3D; &#96;function getUser() &#123;&#125;&#96;</span><br><span class="line">&#x2F;&#x2F; 生成 AST</span><br><span class="line">const ast &#x3D; esprima.parseScript(code)</span><br><span class="line">&#x2F;&#x2F; 转换 AST，只会遍历 type 属性</span><br><span class="line">&#x2F;&#x2F; traverse 方法中有进入和离开两个钩子函数</span><br><span class="line">estraverse.traverse(ast, &#123;</span><br><span class="line">  enter(node) &#123;</span><br><span class="line">    console.log(&#39;enter -&gt; node.type&#39;, node.type)</span><br><span class="line">  &#125;,</span><br><span class="line">  leave(node) &#123;</span><br><span class="line">    console.log(&#39;leave -&gt; node.type&#39;, node.type)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://oscimg.oschina.net/oscnet/f6ecc074-bf06-4d8a-b25b-836cdc32e2c6.jpg" alt="img"></p><p>由此可以得到 AST 遍历的流程是深度优先，遍历过程如下：</p><p><img data-src="https://oscimg.oschina.net/oscnet/c7408a95-6cfb-43c0-9f48-e49634e254df.jpg" alt="img"></p><h2 id="5-5-修改函数名字"><a href="#5-5-修改函数名字" class="headerlink" title="5.5 修改函数名字"></a>5.5 修改函数名字</h2><p>此时我们发现函数的名字在 <code>type</code> 为 <code>Identifier</code> 的时候就是该函数的名字，我们就可以直接修改它便可实现一个更改函数名字的 <code>AST</code> 工具</p><p><img data-src="https://oscimg.oschina.net/oscnet/948eebb7-a184-4ba4-a82b-d500587d39a9.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 转换树</span><br><span class="line">estraverse.traverse(ast, &#123;</span><br><span class="line">  &#x2F;&#x2F; 进入离开修改都是可以的</span><br><span class="line">  enter(node) &#123;</span><br><span class="line">    console.log(&#39;enter -&gt; node.type&#39;, node.type)</span><br><span class="line">    if (node.type &#x3D;&#x3D;&#x3D; &#39;Identifier&#39;) &#123;</span><br><span class="line">      node.name &#x3D; &#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  leave(node) &#123;</span><br><span class="line">    console.log(&#39;leave -&gt; node.type&#39;, node.type)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 生成新的代码</span><br><span class="line">const result &#x3D; escodegen.generate(ast)</span><br><span class="line">console.log(result)</span><br><span class="line">&#x2F;&#x2F; function hello() &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-babel-工作原理"><a href="#5-6-babel-工作原理" class="headerlink" title="5.6 babel 工作原理"></a>5.6 babel 工作原理</h2><p>提到 AST 我们肯定会想到 babel，自从 Es6 开始大规模使用以来，babel 就出现了，它主要解决了就是一些浏览器不兼容 Es6 新特性的问题，其实就把 Es6 代码转换为 Es5 的代码，兼容所有浏览器，babel 转换代码其实就是用了 AST，babel 与 AST 就有着很一种特别的关系。</p><p>那么我们就在 babel 的中来使用 AST，看看 babel 是如何编译代码的（不讲源码啊）</p><p>需要用到两个工具包 <code>@babel/core</code>、<code>@babel/preset-env</code></p><p>当我们配置 babel 的时候，不管是在 <code>.babelrc</code> 或者 <code>babel.config.js</code> 文件里面配置的都有 <code>presets</code> 和 <code>plugins</code> 两个配置项（还有其他配置项，这里不做介绍）</p><h3 id="5-6-1-插件和预设的区别"><a href="#5-6-1-插件和预设的区别" class="headerlink" title="5.6.1 插件和预设的区别"></a>5.6.1 插件和预设的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们配置了 <code>presets</code> 中有 <code>@babel/preset-env</code>，那么 <code>@babel/core</code> 就会去找 <code>preset-env</code> 预设的插件包，它是一套</p><p>babel 核心包并不会去转换代码，核心包只提供一些核心 API，真正的代码转换工作由插件或者预设来完成，比如要转换箭头函数，会用到这个 plugin，<code>@babel/plugin-transform-arrow-functions</code>，当需要转换的要求增加时，我们不可能去一一配置相应的 plugin，这个时候就可以用到预设了，也就是 presets。presets 是 plugins 的集合，一个 presets 内部包含了很多 plugin。</p><h3 id="5-6-2-babel-插件的使用"><a href="#5-6-2-babel-插件的使用" class="headerlink" title="5.6.2 babel 插件的使用"></a>5.6.2 babel 插件的使用</h3><p>现在我们有一个箭头函数，要想把它转成普通函数，我们就可以直接这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const babel &#x3D; require(&#39;@babel&#x2F;core&#39;)</span><br><span class="line">const code &#x3D; &#96;const fn &#x3D; (a, b) &#x3D;&gt; a + b&#96;</span><br><span class="line">&#x2F;&#x2F; babel 有 transform 方法会帮我们自动遍历，使用相应的预设或者插件转换相应的代码</span><br><span class="line">const r &#x3D; babel.transform(code, &#123;</span><br><span class="line">  presets: [&#39;@babel&#x2F;preset-env&#39;],</span><br><span class="line">&#125;)</span><br><span class="line">console.log(r.code)</span><br><span class="line">&#x2F;&#x2F; 打印结果如下</span><br><span class="line">&#x2F;&#x2F; &quot;use strict&quot;;</span><br><span class="line">&#x2F;&#x2F; var fn &#x3D; function fn() &#123; return a + b; &#125;;</span><br></pre></td></tr></table></figure><p>此时我们可以看到最终代码会被转成普通函数，但是我们，只需要箭头函数转通函数的功能，不需要用这么大一套包，只需要一个箭头函数转普通函数的包，我们其实是可以在 <code>node_modules</code> 下面找到有个叫做 <code>plugin-transform-arrow-functions</code> 的插件，这个插件是专门用来处理 箭头函数的，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const r &#x3D; babel.transform(code, &#123;</span><br><span class="line">  plugins: [&#39;@babel&#x2F;plugin-transform-arrow-functions&#39;],</span><br><span class="line">&#125;)</span><br><span class="line">console.log(r.code)</span><br><span class="line">&#x2F;&#x2F; 打印结果如下</span><br><span class="line">&#x2F;&#x2F; const fn &#x3D; function () &#123; return a + b; &#125;;</span><br></pre></td></tr></table></figure><p>我们可以从打印结果发现此时并没有转换我们变量的声明方式还是 const 声明，只是转换了箭头函数</p><h2 id="5-7-编写自己的插件"><a href="#5-7-编写自己的插件" class="headerlink" title="5.7 编写自己的插件"></a>5.7 编写自己的插件</h2><blockquote><p>此时，我们就可以自己来写一些插件，来实现代码的转换，中间处理代码的过程就是使用前面提到的 AST 的处理逻辑</p></blockquote><p>现在我们来个实战把 <code>const fn = (a, b) =&gt; a + b</code> 转换为 <code>const fn = function(a, b) &#123; return a + b &#125;</code></p><h3 id="5-7-1-分析-AST-结构"><a href="#5-7-1-分析-AST-结构" class="headerlink" title="5.7.1 分析 AST 结构"></a>5.7.1 分析 AST 结构</h3><p>首先我们在在线分析 AST 的网站上分析 <code>const fn = (a, b) =&gt; a + b</code> 和 <code>const fn = function(a, b) &#123; return a + b &#125;</code>看两者语法树的区别</p><p><img data-src="https://oscimg.oschina.net/oscnet/2730d973-5fbc-4ac2-9169-4922b3c6e4d5.jpg" alt="img"></p><p>根据我们分析可得：</p><ol><li>变成普通函数之后他就不叫箭头函数了 <code>ArrowFunctionExpression</code>，而是函数表达式了 <code>FunctionExpression</code></li><li>所以首先我们要把 <code>箭头函数表达式(ArrowFunctionExpression)</code> 转换为 <code>函数表达式(FunctionExpression)</code></li><li>要把 <code>二进制表达式(BinaryExpression)</code> 放到一个 <code>代码块中(BlockStatement)</code></li><li>其实我们要做就是把一棵树变成另外一颗树，说白了其实就是拼成另一颗树的结构，然后生成新的代码，就可以完成代码的转换</li></ol><h3 id="5-7-2-访问者模式"><a href="#5-7-2-访问者模式" class="headerlink" title="5.7.2 访问者模式"></a>5.7.2 访问者模式</h3><p>在 babel 中，我们开发 plugins 的时候要用到访问者模式，就是说在访问到某一个路径的时候进行匹配，然后在对这个节点进行修改，比如说上面的当我们访问到 <code>ArrowFunctionExpression</code> 的时候，对 <code>ArrowFunctionExpression</code> 进行修改，变成普通函数</p><p>那么我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const babel &#x3D; require(&#39;@babel&#x2F;core&#39;)</span><br><span class="line">const code &#x3D; &#96;const fn &#x3D; (a, b) &#x3D;&gt; a + b&#96; &#x2F;&#x2F; 转换后 const fn &#x3D; function(a, b) &#123; return a + b &#125;</span><br><span class="line">const arrowFnPlugin &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 访问者模式</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    &#x2F;&#x2F; 当访问到某个路径的时候进行匹配</span><br><span class="line">    ArrowFunctionExpression(path) &#123;</span><br><span class="line">      &#x2F;&#x2F; 拿到节点</span><br><span class="line">      const node &#x3D; path.node</span><br><span class="line">      console.log(&#39;ArrowFunctionExpression -&gt; node&#39;, node)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const r &#x3D; babel.transform(code, &#123;</span><br><span class="line">  plugins: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(r)</span><br></pre></td></tr></table></figure><h3 id="5-7-3-修改-AST-结构"><a href="#5-7-3-修改-AST-结构" class="headerlink" title="5.7.3 修改 AST 结构"></a>5.7.3 修改 AST 结构</h3><p>此时我们拿到的结果是这样的节点结果是 这样的，其实就是 <code>ArrowFunctionExpression</code> 的 AST，此时我们要做的是把 <code>ArrowFunctionExpression</code> 的结构替换成 <code>FunctionExpression</code>的结构，但是需要我们组装类似的结构，这么直接写很麻烦，但是 babel 为我们提供了一个工具叫做 <code>@babel/types</code></p><p><code>@babel/types</code> 有两个作用：</p><ol><li>判断这个节点是不是这个节点（ArrowFunctionExpression 下面的 path.node 是不是一个 ArrowFunctionExpression）</li><li>生成对应的表达式</li></ol><p>然后我们使用的时候，需要经常查文档，因为里面的节点类型特别多，不是做编译相关工作的是记不住怎么多节点的</p><p>那么接下来我们就开始生成一个 <code>FunctionExpression</code>，然后把之前的 <code>ArrowFunctionExpression</code> 替换掉，我们可以看 <code>types</code> 文档，找到 <code>functionExpression</code>，该方法接受相应的参数我们传递过去即可生成一个 <code>FunctionExpression</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.functionExpression(id, params, body, generator, async)</span><br></pre></td></tr></table></figure><ul><li>id: Identifier (default: null) id 可传递 null</li><li>params: Array<LVal> (required) 函数参数，可以把之前的参数拿过来</li><li>body: BlockStatement (required) 函数体，接受一个 <code>BlockStatement</code> 我们需要生成一个</li><li>generator: boolean (default: false) 是否为 generator 函数，当然不是了</li><li>async: boolean (default: false) 是否为 async 函数，肯定不是了</li></ul><p>还需要生成一个 <code>BlockStatement</code>，我们接着看文档找到 <code>BlockStatement</code> 接受的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.blockStatement(body, directives)</span><br></pre></td></tr></table></figure><p>看文档说明，blockStatement 接受一个 body，那我们把之前的 body 拿过来就可以直接用，不过这里 body 接受一个数组</p><p>我们细看 AST 结构，函数表达式中的 <code>BlockStatement</code> 中的 <code>body</code> 是一个 <code>ReturnStatement</code>，所以我们还需要生成一个 <code>ReturnStatement</code></p><p>现在我们就可以改写 AST 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const babel &#x3D; require(&#39;@babel&#x2F;core&#39;)</span><br><span class="line">const t &#x3D; require(&#39;@babel&#x2F;types&#39;)</span><br><span class="line">const code &#x3D; &#96;const fn &#x3D; (a, b) &#x3D;&gt; a + b&#96; &#x2F;&#x2F; const fn &#x3D; function(a, b) &#123; return a + b &#125;</span><br><span class="line">const arrowFnPlugin &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 访问者模式</span><br><span class="line">  visitor: &#123;</span><br><span class="line">    &#x2F;&#x2F; 当访问到某个路径的时候进行匹配</span><br><span class="line">    ArrowFunctionExpression(path) &#123;</span><br><span class="line">      &#x2F;&#x2F; 拿到节点然后替换节点</span><br><span class="line">      const node &#x3D; path.node</span><br><span class="line">      console.log(&#39;ArrowFunctionExpression -&gt; node&#39;, node)</span><br><span class="line">      &#x2F;&#x2F; 拿到函数的参数</span><br><span class="line">      const params &#x3D; node.params</span><br><span class="line">      const body &#x3D; node.body</span><br><span class="line">      const functionExpression &#x3D; t.functionExpression(null, params, t.blockStatement([body]))</span><br><span class="line">      &#x2F;&#x2F; 替换原来的函数</span><br><span class="line">      path.replaceWith(functionExpression)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">const r &#x3D; babel.transform(code, &#123;</span><br><span class="line">  plugins: [arrowFnPlugin],</span><br><span class="line">&#125;)</span><br><span class="line">console.log(r.code) &#x2F;&#x2F; const fn &#x3D; function (a, b) &#123; return a + b; &#125;;</span><br></pre></td></tr></table></figure><h3 id="5-7-4-特殊情况"><a href="#5-7-4-特殊情况" class="headerlink" title="5.7.4 特殊情况"></a>5.7.4 特殊情况</h3><p>我们知道在剪头函数中是可以省略 <code>return</code> 关键字，我们上面是处理了省略关键字的写法，但是如果用户写了 return 关键字后，我们写的这个插件就有问题了，所以我们可以在优化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fn &#x3D; (a, b) &#x3D;&gt; &#123; retrun a + b &#125;&#96; -&gt; &#96;const fn &#x3D; function(a, b) &#123; return a + b &#125;</span><br></pre></td></tr></table></figure><p>观察代码我们发现，我们就不需要把 body 转换成 blockStatement 了，直接放过去就可以了，那么我们就可以这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrowFunctionExpression(path) &#123;</span><br><span class="line">  &#x2F;&#x2F; 拿到节点然后替换节点</span><br><span class="line">  const node &#x3D; path.node</span><br><span class="line">  console.log(&quot;ArrowFunctionExpression -&gt; node&quot;, node)</span><br><span class="line">  &#x2F;&#x2F; 拿到函数的参数</span><br><span class="line">  const params &#x3D; node.params</span><br><span class="line">  let body &#x3D; node.body</span><br><span class="line">  &#x2F;&#x2F; 判断是不是 blockStatement，不是的话让他变成 blockStatement</span><br><span class="line">  if (!t.isBlockStatement(body)) &#123;</span><br><span class="line">    body &#x3D; t.blockStatement([body])</span><br><span class="line">  &#125;</span><br><span class="line">  const functionExpression &#x3D; t.functionExpression(null, params, body)</span><br><span class="line">  &#x2F;&#x2F; 替换原来的函数</span><br><span class="line">  path.replaceWith(functionExpression)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8-按需引入"><a href="#5-8-按需引入" class="headerlink" title="5.8 按需引入"></a>5.8 按需引入</h2><p>在开发中，我们引入 UI 框架，比如 vue 中用到的 <code>element-ui</code>，<code>vant</code> 或者 <code>React</code> 中的 <code>antd</code> 都支持全局引入和按需引入，默认是全局引入，如果需要按需引入就需要安装一个 <code>babel-plugin-import</code> 的插件，将全局的写法变成按需引入的写法。</p><p>就拿我最近开发移动端用的 vant 为例， <code>import &#123; Button &#125; from &#39;vant&#39;</code> 这种写法经过这个插件之后会变成 <code>import Button from &#39;vant/lib/Button&#39;</code> 这种写法，引用整个 vant 变成了我只用了 vant 下面的某一个文件，打包后的文件会比全部引入的文件大小要小很多</p><h3 id="5-8-1-分析语法树"><a href="#5-8-1-分析语法树" class="headerlink" title="5.8.1 分析语法树"></a>5.8.1 分析语法树</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Icon &#125; from &#39;vant&#39;&#96; 写法转换为 &#96;import Button from &#39;vant&#x2F;lib&#x2F;Button&#39;; import Icon from &#39;vant&#x2F;lib&#x2F;Icon&#39;</span><br></pre></td></tr></table></figure></blockquote><p>看一下两个语法树的区别</p><p><img data-src="https://oscimg.oschina.net/oscnet/822c18e6-1d5d-406f-ab28-b4dad891071f.jpg" alt="img"></p><p>根据两张图分析我们可以得到一些信息：</p><ol><li>我们发现解构方式引入的模块只有 import 声明，第二张图是两个 import 声明</li><li>解构方式引入的详细说明里面( <code>specifiers</code>)是两个 <code>ImportSpecifier</code>，第二张图里面是分开的，而且都是 <code>ImportDefaultSpecifier</code></li><li>他们引入的 <code>source</code> 也不一样</li><li>那我们要做的其实就是要把单个的 <code>ImportDeclaration</code> 变成多个 <code>ImportDeclaration</code>, 然后把单个 import 解构引入的 <code>specifiers</code> 部分 <code>ImportSpecifier</code> 转换成多个 <code>ImportDefaultSpecifier</code> 并修改对应的 <code>source</code> 即可</li></ol><h3 id="5-8-2-分析类型"><a href="#5-8-2-分析类型" class="headerlink" title="5.8.2 分析类型"></a>5.8.2 分析类型</h3><p>为了方便传递参数，这次我们写到一个函数里面，可以方便传递转换后拼接的目录</p><p>这里我们需要用到的几个类型，也需要在 types 官网上找对应的解释</p><ul><li><p>首先我们要生成多个 <code>importDeclaration</code> 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;&#125; specifiers  (required)</span><br><span class="line"> * @param &#123;StringLiteral&#125; source (required)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.importDeclaration(specifiers, source)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>importDeclaration</code> 中需要生成 <code>ImportDefaultSpecifier</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Identifier&#125; local  (required)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.importDefaultSpecifier(local)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>importDeclaration</code> 中还需要生成一个 <code>StringLiteral</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; value  (required)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.stringLiteral(value)</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-8-3-上代码"><a href="#5-8-3-上代码" class="headerlink" title="5.8.3 上代码"></a>5.8.3 上代码</h3><p>按照上面的分析，我们开始上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const babel &#x3D; require(&#39;@babel&#x2F;core&#39;)</span><br><span class="line">const t &#x3D; require(&#39;@babel&#x2F;types&#39;)</span><br><span class="line">const code &#x3D; &#96;import &#123; Button, Icon &#125; from &#39;vant&#39;&#96;</span><br><span class="line">&#x2F;&#x2F; import Button from &#39;vant&#x2F;lib&#x2F;Button&#39;</span><br><span class="line">&#x2F;&#x2F; import Icon from &#39;vant&#x2F;lib&#x2F;Icon&#39;</span><br><span class="line">function importPlugin(opt) &#123;</span><br><span class="line">  const &#123; libraryDir &#125; &#x3D; opt</span><br><span class="line">  return &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path) &#123;</span><br><span class="line">        const node &#x3D; path.node</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;ImportDeclaration -&gt; node&quot;, node)</span><br><span class="line">        &#x2F;&#x2F; 得到节点的详细说明，然后转换成多个的 import 声明</span><br><span class="line">        const specifiers &#x3D; node.specifiers</span><br><span class="line">        &#x2F;&#x2F; 要处理这个我们做一些判断，首先判断不是默认导出我们才处理，要考虑 import vant, &#123; Button, Icon &#125; from &#39;vant&#39; 写法</span><br><span class="line">        &#x2F;&#x2F; 还要考虑 specifiers 的长度，如果长度不是 1 并且不是默认导出我们才需要转换</span><br><span class="line">        if (!(specifiers.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; t.isImportDefaultSpecifier(specifiers[0]))) &#123;</span><br><span class="line">          const result &#x3D; specifiers.map((specifier) &#x3D;&gt; &#123;</span><br><span class="line">            const local &#x3D; specifier.local</span><br><span class="line">            const source &#x3D; t.stringLiteral(&#96;$&#123;node.source.value&#125;&#x2F;$&#123;libraryDir&#125;&#x2F;$&#123;specifier.local.name&#125;&#96;)</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;ImportDeclaration -&gt; specifier&quot;, specifier)</span><br><span class="line">            return t.importDeclaration([t.importDefaultSpecifier(local)],source)</span><br><span class="line">          &#125;)</span><br><span class="line">          console.log(&#39;ImportDeclaration -&gt; result&#39;, result)</span><br><span class="line">          &#x2F;&#x2F; 因为这次要替换的 AST 不是一个，而是多个的，所以需要 &#96;path.replaceWithMultiple(result)&#96; 来替换，但是一执行发现死循环了</span><br><span class="line">          path.replaceWithMultiple(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const r &#x3D; babel.transform(code, &#123;</span><br><span class="line">  plugins: [importPlugin(&#123; libraryDir: &#39;lib&#39; &#125;)],</span><br><span class="line">&#125;)</span><br><span class="line">console.log(r.code)</span><br></pre></td></tr></table></figure><p>看打印结果和转换结果似乎没什么问题，这个插件几乎就实现了</p><p><img data-src="https://oscimg.oschina.net/oscnet/1fe23797-e87f-4e81-93c2-c420c959e8a0.jpg" alt="img"></p><h3 id="5-8-4-特殊情况"><a href="#5-8-4-特殊情况" class="headerlink" title="5.8.4 特殊情况"></a>5.8.4 特殊情况</h3><p>但是我们考虑一种情况，如果用户不全部按需加载了，按需加载只是一种选择，如果用户这么写了 <code>import vant, &#123; Button, Icon &#125; from &#39;vant&#39;</code>，那么我们这个插件就出现问题了</p><p><img data-src="https://oscimg.oschina.net/oscnet/3b6def74-c525-4f94-9ebb-deafb72b7e28.jpg" alt="img"></p><p>如果遇到这种写法，那么默认导入的他的 <code>source</code> 应该是不变的，我们要把原来的 <code>source</code> 拿出来</p><p>所以还需要判断一下，每一个 <code>specifier</code> 是不是一个 <code>ImportDefaultSpecifier</code> 然后处理不同的 <code>source</code>，完整处理逻辑应该如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function importPlugin(opt) &#123;</span><br><span class="line">  const &#123; libraryDir &#125; &#x3D; opt</span><br><span class="line">  return &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path) &#123;</span><br><span class="line">        const node &#x3D; path.node</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;ImportDeclaration -&gt; node&quot;, node)</span><br><span class="line">        &#x2F;&#x2F; 得到节点的详细说明，然后转换成多个的 import 声明</span><br><span class="line">        const specifiers &#x3D; node.specifiers</span><br><span class="line">        &#x2F;&#x2F; 要处理这个我们做一些判断，首先判断不是默认导出我们才处理，要考虑 import vant, &#123; Button, Icon &#125; from &#39;vant&#39; 写法</span><br><span class="line">        &#x2F;&#x2F; 还要考虑 specifiers 的长度，如果长度不是 1 并且不是默认导出我们才需要转换</span><br><span class="line">        if (</span><br><span class="line">          !(</span><br><span class="line">            specifiers.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; t.isImportDefaultSpecifier(specifiers[0])</span><br><span class="line">          )</span><br><span class="line">        ) &#123;</span><br><span class="line">          const result &#x3D; specifiers.map((specifier) &#x3D;&gt; &#123;</span><br><span class="line">            let local &#x3D; specifier.local,</span><br><span class="line">              source</span><br><span class="line">            &#x2F;&#x2F; 判断是否存在默认导出的情况</span><br><span class="line">            if (t.isImportDefaultSpecifier(specifier)) &#123;</span><br><span class="line">              source &#x3D; t.stringLiteral(node.source.value)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              source &#x3D; t.stringLiteral(</span><br><span class="line">                &#96;$&#123;node.source.value&#125;&#x2F;$&#123;libraryDir&#125;&#x2F;$&#123;specifier.local.name&#125;&#96;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">            return t.importDeclaration(</span><br><span class="line">              [t.importDefaultSpecifier(local)],</span><br><span class="line">              source</span><br><span class="line">            )</span><br><span class="line">          &#125;)</span><br><span class="line">          path.replaceWithMultiple(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9-babylon"><a href="#5-9-babylon" class="headerlink" title="5.9 babylon"></a>5.9 babylon</h2><blockquote><p>在 babel 官网上有一句话 Babylon is a JavaScript parser used in Babel.</p></blockquote><h3 id="5-9-1-babylon-与-babel-的关系"><a href="#5-9-1-babylon-与-babel-的关系" class="headerlink" title="5.9.1 babylon 与 babel 的关系"></a>5.9.1 babylon 与 babel 的关系</h3><p><code>babel</code> 使用的引擎是 <code>babylon</code>，<code>Babylon</code> 并非 <code>babel</code> 团队自己开发的，而是 fork 的 <code>acorn</code> 项目，<code>acorn</code> 的项目本人在很早之前在兴趣部落 1.0 在构建中使用，为了是做一些代码的转换，是很不错的一款引擎，不过 <code>acorn</code> 引擎只提供基本的解析 <code>ast</code> 的能力，遍历还需要配套的 <code>acorn-travesal</code>, 替换节点需要使用 acorn-，而这些开发，在 Babel 的插件体系开发下，变得一体化了（摘自 AlloyTeam 团队的剖析 babel）</p><h3 id="5-9-2-使用-babylon"><a href="#5-9-2-使用-babylon" class="headerlink" title="5.9.2 使用 babylon"></a>5.9.2 使用 babylon</h3><p>使用 babylon 编写一个数组 rest 转 Es5 语法的插件</p><p>把 <code>const arr = [ ...arr1, ...arr2 ]</code> 转成 <code>var arr = [].concat(arr1, arr2)</code></p><p>我们使用 babylon 的话就不需要使用 <code>@babel/core</code> 了，只需要用到他里面的 <code>traverse</code> 和 <code>generator</code>，用到的包有 <code>babylon、@babel/traverse、@babel/generator、@babel/types</code></p><h3 id="5-9-3-分析语法树"><a href="#5-9-3-分析语法树" class="headerlink" title="5.9.3 分析语法树"></a>5.9.3 分析语法树</h3><p>先来看一下两棵语法树的区别</p><p><img data-src="https://oscimg.oschina.net/oscnet/03608f83-7e7d-4de8-bfe5-3265ade3edd8.jpg" alt="img"></p><p>根据上图我们分析得出：</p><ol><li>两棵树都是变量声明的方式，不同的是他们声明的关键字不一样</li><li>他们初始化变量值的时候是不一样的，一个数组表达式（ArrayExpression）另一个是调用表达式（CallExpression）</li><li>那我们要做的就很简单了，就是把 数组表达式转换为调用表达式就可以</li></ol><h3 id="5-9-4-分析类型"><a href="#5-9-4-分析类型" class="headerlink" title="5.9.4 分析类型"></a>5.9.4 分析类型</h3><p>这段代码的核心生成一个 callExpression 调用表达式，所以对应官网上的类型，我们分析需要用到的 api</p><ul><li><p>先来分析 init 里面的，首先是 callExpression</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Expression&#125; callee  (required)</span><br><span class="line"> * @param &#123;Array&lt;Expression | SpreadElement | JSXNamespacedName&gt;&#125; source (required)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.callExpression(callee, arguments)</span><br></pre></td></tr></table></figure></li><li><p>对应语法树上 callee 是一个 MemberExpression，所以要生成一个成员表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Expression&#125; object  (required)</span><br><span class="line"> * @param &#123;if computed then Expression else Identifier&#125; property (required)</span><br><span class="line"> * @param &#123;boolean&#125; computed (default: false)</span><br><span class="line"> * @param &#123;boolean&#125; optional (default: null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.memberExpression(object, property, computed, optional)</span><br></pre></td></tr></table></figure></li><li><p>在 callee 的 object 是一个 ArrayExpression 数组表达式，是一个空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;Array&lt;null | Expression | SpreadElement&gt;&#125; elements  (default: [])</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.arrayExpression(elements)</span><br></pre></td></tr></table></figure></li><li><p>对了里面的东西分析完了，我们还要生成 VariableDeclarator 和 VariableDeclaration 最终生成新的语法树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;LVal&#125; id  (required)</span><br><span class="line"> * @param &#123;Expression&#125; init (default: null)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.variableDeclarator(id, init)</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;&quot;var&quot; | &quot;let&quot; | &quot;const&quot;&#125; kind  (required)</span><br><span class="line"> * @param &#123;Array&lt;VariableDeclarator&gt;&#125; declarations (required)</span><br><span class="line"> *&#x2F;</span><br><span class="line">t.variableDeclaration(kind, declarations)</span><br></pre></td></tr></table></figure></li><li><p>其实倒着分析语法树，分析完怎么写也就清晰了，那么我们开始上代码吧</p></li></ul><h3 id="5-9-5-上代码"><a href="#5-9-5-上代码" class="headerlink" title="5.9.5 上代码"></a>5.9.5 上代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const babylon &#x3D; require(&#39;babylon&#39;)</span><br><span class="line">&#x2F;&#x2F; 使用 babel 提供的包，traverse 和 generator 都是被暴露在 default 对象上的</span><br><span class="line">const traverse &#x3D; require(&#39;@babel&#x2F;traverse&#39;).default</span><br><span class="line">const generator &#x3D; require(&#39;@babel&#x2F;generator&#39;).default</span><br><span class="line">const t &#x3D; require(&#39;@babel&#x2F;types&#39;)</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#96;const arr &#x3D; [ ...arr1, ...arr2 ]&#96; &#x2F;&#x2F; var arr &#x3D; [].concat(arr1, arr2)</span><br><span class="line"></span><br><span class="line">const ast &#x3D; babylon.parse(code, &#123;</span><br><span class="line">  sourceType: &#39;module&#39;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 转换树</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  VariableDeclaration(path) &#123;</span><br><span class="line">    const node &#x3D; path.node</span><br><span class="line">    const declarations &#x3D; node.declarations</span><br><span class="line">    console.log(&#39;VariableDeclarator -&gt; declarations&#39;, declarations)</span><br><span class="line">    const kind &#x3D; &#39;var&#39;</span><br><span class="line">    &#x2F;&#x2F; 边界判定</span><br><span class="line">    if (node.kind !&#x3D;&#x3D; kind &amp;&amp; declarations.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; t.isArrayExpression(declarations[0].init)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 取得之前的 elements</span><br><span class="line">      const args &#x3D; declarations[0].init.elements.map((item) &#x3D;&gt; item.argument)</span><br><span class="line">      const callee &#x3D; t.memberExpression(t.arrayExpression(), t.identifier(&#39;concat&#39;), false)</span><br><span class="line">      const init &#x3D; t.callExpression(callee, args)</span><br><span class="line">      const declaration &#x3D; t.variableDeclarator(declarations[0].id, init)</span><br><span class="line">      const variableDeclaration &#x3D; t.variableDeclaration(kind, [declaration])</span><br><span class="line">      path.replaceWith(variableDeclaration)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-10-具体语法树"><a href="#5-10-具体语法树" class="headerlink" title="5.10 具体语法树"></a>5.10 具体语法树</h2><p>和抽象语法树相对的是具体语法树（<code>Concrete Syntax Tree</code>）简称 <code>CST</code>（通常称作分析树）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。可参考抽象语法树和具体语法树有什么区别？</p><h2 id="5-11-补充"><a href="#5-11-补充" class="headerlink" title="5.11 补充"></a>5.11 补充</h2><p>关于 node 类型，全集大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameter) node: Identifier | SimpleLiteral | RegExpLiteral | Program | FunctionDeclaration | FunctionExpression | ArrowFunctionExpression | SwitchCase | CatchClause | VariableDeclarator | ExpressionStatement | BlockStatement | EmptyStatement | DebuggerStatement | WithStatement | ReturnStatement | LabeledStatement | BreakStatement | ContinueStatement | IfStatement | SwitchStatement | ThrowStatement | TryStatement | WhileStatement | DoWhileStatement | ForStatement | ForInStatement | ForOfStatement | VariableDeclaration | ClassDeclaration | ThisExpression | ArrayExpression | ObjectExpression | YieldExpression | UnaryExpression | UpdateExpression | BinaryExpression | AssignmentExpression | LogicalExpression | MemberExpression | ConditionalExpression | SimpleCallExpression | NewExpression | SequenceExpression | TemplateLiteral | TaggedTemplateExpression | ClassExpression | MetaProperty | AwaitExpression | Property | AssignmentProperty | Super | TemplateElement | SpreadElement | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier</span><br></pre></td></tr></table></figure><p>Babel 有文档对 AST 树的详细定义，可参考这里</p><h2 id="5-12-配套源码地址"><a href="#5-12-配套源码地址" class="headerlink" title="5.12 配套源码地址"></a>5.12 配套源码地址</h2><p>代码以存放到 GitHub，地址：<a href="https://github.com/fecym/ast-share">https://github.com/fecym/ast-share</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li>JavaScript 语法解析、AST、V8、JIT</li><li>详解 AST 抽象语法树</li><li>AST 抽象语法树 ps: 这个里面有 class 转 Es5 构造函数的过程，有兴趣可以看一下</li><li>剖析 Babel——Babel 总览 | AlloyTeam</li><li>@babel/types</li></ol><h1 id="6-webpack-流程"><a href="#6-webpack-流程" class="headerlink" title="6.webpack-流程"></a>6.webpack-流程</h1><h2 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h2><p>目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。但对于 webpack 这样一个复杂度较高的插件集合，它的整体流程及思想对我们来说还是很透明的。那么接下来我会带你了解 webpack 这样一个构建黑盒，首先来谈谈它的流程。</p><h2 id="6-2-准备工作"><a href="#6-2-准备工作" class="headerlink" title="6.2 准备工作"></a>6.2 准备工作</h2><h3 id="6-2-1-webstorm-中配置-webpack-webstorm-debugger-script"><a href="#6-2-1-webstorm-中配置-webpack-webstorm-debugger-script" class="headerlink" title="6.2.1 webstorm 中配置 webpack-webstorm-debugger-script"></a>6.2.1 webstorm 中配置 webpack-webstorm-debugger-script</h3><p>在开始了解之前，必须要能对 webpack 整个流程进行 debug ，配置过程比较简单。</p><p>先将 <a href="https://www.npmjs.com/package/webpack-webstorm-debugger-script">webpack-webstorm-debugger-script</a> 中的 <code>webstorm-debugger.js</code> 置于<code>webpack.config.js</code> 的同一目录下，搭建好你的脚手架后就可以直接 Debug 这个 webstorm-debugger.js 文件了。</p><h3 id="6-2-2-webpack-config-js-配置"><a href="#6-2-2-webpack-config-js-配置" class="headerlink" title="6.2.2 webpack.config.js 配置"></a>6.2.2 webpack.config.js 配置</h3><p>估计大家对 webpack.config.js 的配置也尝试过不少次了，这里就大致对这个配置文件进行个分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">var node_modules &#x3D; path.resolve(__dirname, &#39;node_modules&#39;);</span><br><span class="line">var pathToReact &#x3D; path.resolve(node_modules, &#39;react&#x2F;dist&#x2F;react.min.js&#39;);</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F; 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span><br><span class="line">entry: &#123;</span><br><span class="line">bundle: [</span><br><span class="line">        &#39;webpack&#x2F;hot&#x2F;dev-server&#39;,</span><br><span class="line">        &#39;webpack-dev-server&#x2F;client?http:&#x2F;&#x2F;localhost:8080&#39;,</span><br><span class="line">        path.resolve(__dirname, &#39;app&#x2F;app.js&#39;)</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 文件路径指向(可加快打包过程)。</span><br><span class="line">  resolve: &#123; </span><br><span class="line">  alias: &#123;</span><br><span class="line">  &#39;react&#39;: pathToReact</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#x2F;&#x2F; 生成文件，是模块构建的终点，包括输出文件与输出路径。</span><br><span class="line"> output: &#123;</span><br><span class="line"> path: path.resolve(__dirname, &#39;build&#39;),</span><br><span class="line"> filename: &#39;[name].js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span><br><span class="line">    module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">    &#123; </span><br><span class="line">    test: &#x2F;\.js$&#x2F;,</span><br><span class="line">    loader: &#39;babel&#39;,</span><br><span class="line">    query: &#123;</span><br><span class="line">    presets: [&#39;es2015&#39;, &#39;react&#39;]</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span><br><span class="line">    plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外再大致介绍下 webpack 的一些核心概念：</p><ul><li>loader：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。</li><li>chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。</li></ul><p>对于 module 和 chunk 的关系可以参照 webpack 官方的这张图：</p><p><img data-src="https://img.alicdn.com/tps/TB1B0DXNXXXXXXdXFXXXXXXXXXX-368-522.jpg" alt="img"></p><ul><li>plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function UglifyJsPlugin(options) &#123;</span><br><span class="line">this.options &#x3D; options;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; UglifyJsPlugin;</span><br><span class="line">UglifyJsPlugin.prototype.apply &#x3D; function(compiler) &#123;</span><br><span class="line">compiler.plugin(&quot;compilation&quot;, function(compilation) &#123;</span><br><span class="line">compilation.plugin(&quot;build-module&quot;,</span><br><span class="line">        function(module) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;);</span><br><span class="line">compilation.plugin(&quot;optimize-chunk-assets&quot;, </span><br><span class="line">function(chunks, callback) &#123;</span><br><span class="line">&#x2F;&#x2F; Uglify 逻辑</span><br><span class="line">       &#125;);</span><br><span class="line">       compilation.plugin(&quot;normal-module-loader&quot;, function(context) &#123;</span><br><span class="line">       </span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。</p><h3 id="6-2-3-流程总览"><a href="#6-2-3-流程总览" class="headerlink" title="6.2.3 流程总览"></a>6.2.3 流程总览</h3><p>在具体流程学习前，可以先通过这幅 <a href="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg">webpack 整体流程图</a> 了解一下大致流程（建议保存下来查看）。</p><p><img data-src="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" alt="img"></p><h2 id="6-3-shell-与-config-解析"><a href="#6-3-shell-与-config-解析" class="headerlink" title="6.3 shell 与 config 解析"></a>6.3 shell 与 config 解析</h2><p>每次在命令行输入 webpack 后，操作系统都会去调用 <code>./node_modules/.bin/webpack</code> 这个 shell 脚本。这个脚本会去调用 <code>./node_modules/webpack/bin/webpack.js</code> 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数)</p><p><img data-src="https://img.alicdn.com/tps/TB1kvfbNXXXXXarXpXXXXXXXXXX-500-111.jpg" alt="img"></p><p>在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。</p><h3 id="6-3-1-optimist"><a href="#6-3-1-optimist" class="headerlink" title="6.3.1 optimist"></a>6.3.1 optimist</h3><p>和 commander 一样，<a href="https://github.com/substack/node-optimist">optimist</a> 实现了 node 命令行的解析，其 API 调用非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var optimist &#x3D; require(&quot;optimist&quot;);</span><br><span class="line">optimist  .boolean(&quot;json&quot;).alias(&quot;json&quot;, &quot;j&quot;).describe(&quot;json&quot;)  .boolean(&quot;colors&quot;).alias(&quot;colors&quot;, &quot;c&quot;).describe(&quot;colors&quot;)  .boolean(&quot;watch&quot;).alias(&quot;watch&quot;, &quot;w&quot;).describe(&quot;watch&quot;)  ...</span><br></pre></td></tr></table></figure><p>获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack --hot -w&#123;  hot: true,  profile: false,  watch: true,  ...&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-2-config-合并与插件加载"><a href="#6-3-2-config-合并与插件加载" class="headerlink" title="6.3.2 config 合并与插件加载"></a>6.3.2 config 合并与插件加载</h3><p>在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到<code>./node_modules/webpack/bin/convert-argv.js</code> 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(&quot;hot&quot;, function() &#123;</span><br><span class="line">ensureArray(options, &quot;plugins&quot;);</span><br><span class="line">var HotModuleReplacementPlugin &#x3D; require(&quot;..&#x2F;lib&#x2F;HotModuleReplacementPlugin&quot;);</span><br><span class="line">options.plugins.push(new HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">return options;</span><br></pre></td></tr></table></figure><p><code>options</code> 作为最后返回结果，包含了之后构建阶段所需的重要信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">entry: &#123;&#125;,</span><br><span class="line">&#x2F;&#x2F;入口配置</span><br><span class="line">output: &#123;&#125;,</span><br><span class="line">&#x2F;&#x2F;输出配置</span><br><span class="line">plugins: [],</span><br><span class="line">&#x2F;&#x2F;插件集合(配置文件 + shell指令)</span><br><span class="line">module: &#123; loaders: [ [Object] ] &#125;,</span><br><span class="line">&#x2F;&#x2F;模块配置</span><br><span class="line">context: </span><br><span class="line">&#x2F;&#x2F;工程路径</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var webpack &#x3D; require(&quot;..&#x2F;lib&#x2F;webpack.js&quot;);var compiler &#x3D; webpack(options);</span><br></pre></td></tr></table></figure><h3 id="6-3-3-编译与构建流程"><a href="#6-3-3-编译与构建流程" class="headerlink" title="6.3.3 编译与构建流程"></a>6.3.3 编译与构建流程</h3><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 <code>lib/webpack.js</code> 中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function webpack(options) &#123;</span><br><span class="line">var compiler &#x3D; new Compiler();</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 检查options,若watch字段为true,则开启watch线程</span><br><span class="line">return compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。</p><ul><li><code>compile</code> 开始编译</li><li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li><li><code>build-module</code> 构建模块</li><li><code>after-compile</code> 完成构建</li><li><code>seal</code> 封装构建结果</li><li><code>emit</code> 把各个chunk输出到结果文件</li><li><code>after-emit</code> 完成输出</li></ul><h4 id="1-核心对象-Compilation"><a href="#1-核心对象-Compilation" class="headerlink" title="1. 核心对象 Compilation"></a>1. 核心对象 Compilation</h4><p>compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象：</p><p><img data-src="https://img.alicdn.com/tps/TB1UgS4NXXXXXXZXVXXXXXXXXXX-693-940.png" alt="compilation类图"></p><p>这个对象有两个作用，一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 <code>addEntry()</code> , <code>_addModuleChain()</code> ,<code>buildModule()</code> , <code>seal()</code> , <code>createChunkAssets()</code> (在每一个节点都会触发 webpack 事件去调用各插件)。二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</p><h4 id="2-编译与构建主流程"><a href="#2-编译与构建主流程" class="headerlink" title="2. 编译与构建主流程"></a>2. 编译与构建主流程</h4><p>在创建 module 之前，Compiler 会触发 make，并调用 <code>Compilation.addEntry</code> 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法<code>_addModuleChain</code> ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p><p>而构建模块作为最耗时的一步，又可细化为三步：</p><ul><li><p>调用各 loader 处理模块之间的依赖</p><p>webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 <code>url-loader</code> ， <code>jsx-loader</code> ， <code>css-loader</code> 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 <code>doBuild()</code> ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。</p></li><li><p>调用 <a href="https://github.com/ternjs/acorn">acorn</a> 解析经 loader 处理后的源文件生成抽象语法树 AST</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parser.prototype.parse &#x3D; function parse(source, initialState) &#123;</span><br><span class="line">    var ast;</span><br><span class="line">    if (!ast) &#123;</span><br><span class="line">        &#x2F;&#x2F; acorn以es6的语法进行解析</span><br><span class="line">        ast &#x3D; acorn.parse(source, &#123;</span><br><span class="line">            ranges: true,</span><br><span class="line">            locations: true,</span><br><span class="line">            ecmaVersion: 6,</span><br><span class="line">            sourceType: &quot;module&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>遍历 AST，构建该模块所依赖的模块</p><p>对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 <code>addDependency()</code> 添加到数组中。当前模块构建完成后，webpack 调用 <code>processModuleDependencies</code> 开始递归处理依赖的 module，接着就会重复之前的构建步骤。</p><p><code> </code></p></li></ul><h4 id="3-构建细节"><a href="#3-构建细节" class="headerlink" title="3. 构建细节"></a>3. 构建细节</h4><p>module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：<code>NormalModule</code> , <code>MultiModule</code> , <code>ContextModule</code> , <code>DelegatedModule</code> 等。但这些核心实体都是在构建中都会去调用对应方法，也就是 <code>build()</code> 。来看看其中具体做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化module信息，如context,id,chunks,dependencies等。</span><br><span class="line">NormalModule.prototype.build &#x3D; function build(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">this.buildTimestamp &#x3D; new Date().getTime();</span><br><span class="line">&#x2F;&#x2F; 构建计时</span><br><span class="line">this.built &#x3D; true;</span><br><span class="line">return this.doBuild(options, compilation, resolver, fs, function(err) &#123;</span><br><span class="line">&#x2F;&#x2F; 指定模块引用，不经acorn解析</span><br><span class="line">if (options.module &amp;&amp; options.module.noParse) &#123;</span><br><span class="line">if (Array.isArray(options.module.noParse)) &#123;</span><br><span class="line">                if (options.module.noParse.some(function(regExp) &#123;</span><br><span class="line">                return typeof regExp &#x3D;&#x3D;&#x3D; &quot;string&quot; ? this.request.indexOf(regExp) &#x3D;&#x3D;&#x3D; 0 : regExp.test(this.request);</span><br><span class="line">                &#125;, this)) &#123;</span><br><span class="line">                return callback();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; else if (typeof options.module.noParse &#x3D;&#x3D;&#x3D; &quot;string&quot; ? this.request.indexOf(options.module.noParse) &#x3D;&#x3D;&#x3D; 0 : options.module.noParse.test(this.request)) &#123;</span><br><span class="line">        return callback();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 由acorn解析生成ast</span><br><span class="line">        try &#123;</span><br><span class="line">        this.parser.parse(this._source.source(), &#123;</span><br><span class="line">        current: this,</span><br><span class="line">        module: this,</span><br><span class="line">        compilation: compilation,</span><br><span class="line">        options: options</span><br><span class="line">        &#125;);</span><br><span class="line">       &#125; catch (e) &#123;</span><br><span class="line">       var source &#x3D; this._source.source();</span><br><span class="line">       this._source &#x3D; null;</span><br><span class="line">       return callback(new ModuleParseError(this, source, e));</span><br><span class="line">      &#125;</span><br><span class="line">      return callback();</span><br><span class="line"> &#125;.bind(this));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态：</p><p><img data-src="https://img.alicdn.com/tps/TB1WOiRNXXXXXcJaXXXXXXXXXXX-445-1228.png" alt="module类图"></p><p>可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。</p><h2 id="6-4-打包输出"><a href="#6-4-打包输出" class="headerlink" title="6.4 打包输出"></a>6.4 打包输出</h2><p>在所有模块及其依赖模块 build 完成后，webpack 会监听 <code>seal</code> 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype.seal &#x3D; function seal(callback) &#123;</span><br><span class="line">this.applyPlugins(&quot;seal&quot;);</span><br><span class="line">&#x2F;&#x2F; 触发插件的seal事件</span><br><span class="line">this.preparedChunks.sort(function(a, b) &#123;</span><br><span class="line">if (a.name &lt; b.name) &#123;</span><br><span class="line">return -1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (a.name &gt; b.name) &#123;</span><br><span class="line">       return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;);</span><br><span class="line">this.preparedChunks.forEach(function(preparedChunk) &#123;</span><br><span class="line">var module &#x3D; preparedChunk.module;</span><br><span class="line">var chunk &#x3D; this.addChunk(preparedChunk.name, module);</span><br><span class="line">chunk.initial &#x3D; chunk.entry &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 整理每个Module和chunk，每个chunk对应一个输出文件。</span><br><span class="line">chunk.addModule(module);</span><br><span class="line">module.addChunk(chunk);</span><br><span class="line">&#125;, this); </span><br><span class="line">this.applyPluginsAsync(&quot;optimize-tree&quot;, this.chunks, this.modules, function(err) &#123;</span><br><span class="line">if (err) &#123;</span><br><span class="line">return callback(err);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 触发插件的事件</span><br><span class="line">this.createChunkAssets();</span><br><span class="line">&#x2F;&#x2F; 生成最终assets</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 触发插件的事件</span><br><span class="line">&#125;.bind(this));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-生成最终-assets"><a href="#1-生成最终-assets" class="headerlink" title="1. 生成最终 assets"></a>1. 生成最终 assets</h4><p>在封装过程中，webpack 会调用 Compilation 中的 <code>createChunkAssets</code> 方法进行打包后代码的生成。 createChunkAssets 流程如下：</p><p><img data-src="https://img.alicdn.com/tps/TB1cz5.NXXXXXc7XpXXXXXXXXXX-959-807.png" alt="createChunkAssets流程"></p><ul><li><p>不同的 Template</p><p>从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 <code>Template类</code> 中的<code>renderChunkModules()</code> (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(chunk.entry) &#123;</span><br><span class="line">source &#x3D; this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">source &#x3D; this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 webpack 中有四个 Template 的子类，分别是 <code>MainTemplate.js</code> ， <code>ChunkTemplate.js</code>，<code>ModuleTemplate.js</code> ， <code>HotUpdateChunkTemplate.js</code> ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。</p><ul><li><p>模块封装</p><p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用<code>module.source()</code> 来进行各操作，比如说 require() 的替换。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MainTemplate.prototype.requireFn &#x3D; &quot;__webpack_require__&quot;;</span><br><span class="line">MainTemplate.prototype.render &#x3D; function(hash, chunk, moduleTemplate, dependencyTemplates) &#123;</span><br><span class="line">var buf &#x3D; [];</span><br><span class="line">&#x2F;&#x2F; 每一个module都有一个moduleId,在最后会替换。</span><br><span class="line">buf.push(&quot;function &quot; + this.requireFn + &quot;(moduleId) &#123;&quot;);</span><br><span class="line">buf.push(this.indent(this.applyPluginsWaterfall(&quot;require&quot;, &quot;&quot;, chunk, hash)));</span><br><span class="line">buf.push(&quot;&#125;&quot;);</span><br><span class="line">buf.push(&quot;&quot;);</span><br><span class="line">... </span><br><span class="line">&#x2F;&#x2F; 其余封装操作</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>生成 assets</p><p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p></li></ul><h4 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h4><p>最后一步，webpack 调用 Compiler 中的 <code>emitAssets()</code> ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 <code>emit</code> 触发后对自定义插件进行扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack 的整体流程主要还是依赖于 <code>compilation</code> 和 <code>module</code> 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 <code>tapable</code> 控制各插件在 webpack 事件流上运行，至于具体的思想和细节，将会在后一篇文章中提到。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到。</p><h1 id="7-webpack-插件"><a href="#7-webpack-插件" class="headerlink" title="7.webpack-插件"></a>7.webpack-插件</h1><h2 id="7-1-前言"><a href="#7-1-前言" class="headerlink" title="7.1 前言"></a>7.1 前言</h2><p>webpack本身并不难，他所完成的各种复杂炫酷的功能都依赖于他的插件机制。或许我们在日常的开发需求中并不需要自己动手写一个插件，然而，了解其中的机制也是一种学习的方向，当插件出现问题时，我们也能够自己来定位。</p><h2 id="7-2-Tapable"><a href="#7-2-Tapable" class="headerlink" title="7.2 Tapable"></a>7.2 Tapable</h2><p>Webpack的插件机制依赖于一个核心的库， <strong>Tapable</strong>。<br> 在深入webpack的插件机制之前，需要对该核心库有一定的了解。</p><h3 id="7-2-1-Tapable是什么"><a href="#7-2-1-Tapable是什么" class="headerlink" title="7.2.1 Tapable是什么"></a>7.2.1 Tapable是什么</h3><p>tapable 是一个类似于nodejs 的EventEmitter 的库, 主要是控制钩子函数的发布与订阅。当然，tapable提供的hook机制比较全面，分为同步和异步两个大类(异步中又区分异步并行和异步串行)，而根据事件执行的终止条件的不同，由衍生出 Bail/Waterfall/Loop 类型。</p><h3 id="7-2-2-Tapable的使用-（该小段内容引用文章）"><a href="#7-2-2-Tapable的使用-（该小段内容引用文章）" class="headerlink" title="7.2.2 Tapable的使用 （该小段内容引用文章）"></a>7.2.2 Tapable的使用 （该小段内容引用<a href="https://juejin.im/post/6844903750729990152">文章</a>）</h3><p><strong>基本使用</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  SyncHook</span><br><span class="line">&#125; &#x3D; require(&#39;tapable&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个同步 Hook，指定参数</span><br><span class="line">const hook &#x3D; new SyncHook([&#39;arg1&#39;, &#39;arg2&#39;])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">hook.tap(&#39;a&#39;, function (arg1, arg2) &#123;</span><br><span class="line">console.log(&#39;a&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hook.tap(&#39;b&#39;, function (arg1, arg2) &#123;</span><br><span class="line">console.log(&#39;b&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hook.call(1, 2)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>钩子类型</strong>：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/12/28/167f458ac2b1e527?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/12/28/167f458d6ff8424f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p><strong>BasicHook</strong>：执行每一个，不关心函数的返回值，有SyncHook、AsyncParallelHook、AsyncSeriesHook。</p><p><strong>BailHook</strong>：顺序执行 Hook，遇到第一个结果result!==undefined则返回，不再继续执行。有：SyncBailHook、AsyncSeriseBailHook, AsyncParallelBailHook。</p><p>什么样的场景下会使用到 BailHook 呢？设想如下一个例子：假设我们有一个模块 M，如果它满足 A 或者 B 或者 C 三者任何一个条件，就将其打包为一个单独的。这里的 A、B、C 不存在先后顺序，那么就可以使用 AsyncParallelBailHook 来解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x.hooks.拆分模块的Hook.tap(&#39;A&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">   if (A 判断条件满足) &#123;</span><br><span class="line">     return true</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> x.hooks.拆分模块的Hook.tap(&#39;B&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">   if (B 判断条件满足) &#123;</span><br><span class="line">     return true</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> x.hooks.拆分模块的Hook.tap(&#39;C&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">   if (C 判断条件满足) &#123;</span><br><span class="line">     return true</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>如果 A 中返回为 true，那么就无须再去判断 B 和 C。 但是当 A、B、C 的校验，需要严格遵循先后顺序时，就需要使用有顺序的 SyncBailHook(A、B、C 是同步函数时使用) 或者 AsyncSeriseBailHook(A、B、C 是异步函数时使用)。</p><p><strong>WaterfallHook</strong>：类似于 reduce，如果前一个 Hook 函数的结果 result !== undefined，则 result 会作为后一个 Hook 函数的第一个参数。既然是顺序执行，那么就只有 Sync 和 AsyncSeries 类中提供这个Hook：SyncWaterfallHook，AsyncSeriesWaterfallHook 当一个数据，需要经过 A，B，C 三个阶段的处理得到最终结果，并且 A 中如果满足条件 a 就处理，否则不处理，B 和 C 同样，那么可以使用如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">x.hooks.tap(&#39;A&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">   if (满足 A 需要处理的条件) &#123;</span><br><span class="line">     &#x2F;&#x2F; 处理数据 data</span><br><span class="line">     return data</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">x.hooks.tap(&#39;B&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">   if (满足B需要处理的条件) &#123;</span><br><span class="line">     &#x2F;&#x2F; 处理数据 data</span><br><span class="line">     return data</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> x.hooks.tap(&#39;C&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">   if (满足 C 需要处理的条件) &#123;</span><br><span class="line">     &#x2F;&#x2F; 处理数据 data</span><br><span class="line">     return data</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p><strong>LoopHook</strong>：不停的循环执行 Hook，直到所有函数结果 result === undefined。同样的，由于对串行性有依赖，所以只有 SyncLoopHook 和 AsyncSeriseLoopHook （PS：暂时没看到具体使用 Case）</p><h3 id="7-2-3-Tapable的源码分析"><a href="#7-2-3-Tapable的源码分析" class="headerlink" title="7.2.3 Tapable的源码分析"></a>7.2.3 Tapable的源码分析</h3><p>Tapable 基本逻辑是，先通过类实例的 tap 方法注册对应 Hook 的处理函数， 这里直接分析sync同步钩子的主要流程，其他的异步钩子和拦截器等就不赘述了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hook &#x3D; new SyncHook([&#39;arg1&#39;, &#39;arg2&#39;])</span><br></pre></td></tr></table></figure><p>从该句代码， 作为源码分析的入口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SyncHook extends Hook &#123;</span><br><span class="line">    &#x2F;&#x2F; 错误处理，防止调用者调用异步钩子</span><br><span class="line">tapAsync() &#123;</span><br><span class="line">throw new Error(&quot;tapAsync is not supported on a SyncHook&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F; 错误处理，防止调用者调用promise钩子</span><br><span class="line">tapPromise() &#123;</span><br><span class="line">throw new Error(&quot;tapPromise is not supported on a SyncHook&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F; 核心实现</span><br><span class="line">compile(options) &#123;</span><br><span class="line">factory.setup(this, options);</span><br><span class="line">return factory.create(options);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类SyncHook看到， 他是继承于一个基类Hook， 他的核心实现compile等会再讲， 我们先看看基类Hook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 变量的初始化</span><br><span class="line">constructor(args) &#123;</span><br><span class="line">if (!Array.isArray(args)) args &#x3D; [];</span><br><span class="line">this._args &#x3D; args;</span><br><span class="line">this.taps &#x3D; [];</span><br><span class="line">this.interceptors &#x3D; [];</span><br><span class="line">this.call &#x3D; this._call;</span><br><span class="line">this.promise &#x3D; this._promise;</span><br><span class="line">this.callAsync &#x3D; this._callAsync;</span><br><span class="line">this._x &#x3D; undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后， 通常会注册一个事件， 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">hook.tap(&#39;a&#39;, function (arg1, arg2) &#123;</span><br><span class="line">console.log(&#39;a&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hook.tap(&#39;b&#39;, function (arg1, arg2) &#123;</span><br><span class="line">console.log(&#39;b&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显， 这两个语句都会调用基类中的tap方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tap(options, fn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 参数处理</span><br><span class="line">if (typeof options &#x3D;&#x3D;&#x3D; &quot;string&quot;) options &#x3D; &#123; name: options &#125;;</span><br><span class="line">if (typeof options !&#x3D;&#x3D; &quot;object&quot; || options &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">throw new Error(</span><br><span class="line">&quot;Invalid arguments to tap(options: Object, fn: function)&quot;</span><br><span class="line">);</span><br><span class="line">options &#x3D; Object.assign(&#123; type: &quot;sync&quot;, fn: fn &#125;, options);</span><br><span class="line">if (typeof options.name !&#x3D;&#x3D; &quot;string&quot; || options.name &#x3D;&#x3D;&#x3D; &quot;&quot;)</span><br><span class="line">throw new Error(&quot;Missing name for tap&quot;);</span><br><span class="line">&#x2F;&#x2F; 执行拦截器的register函数， 比较简单不分析</span><br><span class="line">options &#x3D; this._runRegisterInterceptors(options);</span><br><span class="line">&#x2F;&#x2F; 处理注册事件</span><br><span class="line">this._insert(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码分析， 可以看到_insert方法是注册阶段的关键函数， 直接进入该方法内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_insert(item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 重置所有的 调用 方法</span><br><span class="line">this._resetCompilation();</span><br><span class="line">&#x2F;&#x2F; 将注册事件排序后放进taps数组</span><br><span class="line">let before;</span><br><span class="line">if (typeof item.before &#x3D;&#x3D;&#x3D; &quot;string&quot;) before &#x3D; new Set([item.before]);</span><br><span class="line">else if (Array.isArray(item.before)) &#123;</span><br><span class="line">before &#x3D; new Set(item.before);</span><br><span class="line">&#125;</span><br><span class="line">let stage &#x3D; 0;</span><br><span class="line">if (typeof item.stage &#x3D;&#x3D;&#x3D; &quot;number&quot;) stage &#x3D; item.stage;</span><br><span class="line">let i &#x3D; this.taps.length;</span><br><span class="line">while (i &gt; 0) &#123;</span><br><span class="line">i--;</span><br><span class="line">const x &#x3D; this.taps[i];</span><br><span class="line">this.taps[i + 1] &#x3D; x;</span><br><span class="line">const xStage &#x3D; x.stage || 0;</span><br><span class="line">if (before) &#123;</span><br><span class="line">if (before.has(x.name)) &#123;</span><br><span class="line">before.delete(x.name);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (before.size &gt; 0) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (xStage &gt; stage) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">this.taps[i] &#x3D; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_insert主要是排序tap并放入到taps数组里面， 排序的算法并不是特别复杂，这里就不赘述了， 到了这里， 注册阶段就已经结束了， 继续看触发阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hook.call(1, 2)  &#x2F;&#x2F; 触发函数</span><br></pre></td></tr></table></figure><p>在基类hook中， 有一个初始化过程，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.call &#x3D; this._call; </span><br><span class="line"></span><br><span class="line">Object.defineProperties(Hook.prototype, &#123;</span><br><span class="line">_call: &#123;</span><br><span class="line">value: createCompileDelegate(&quot;call&quot;, &quot;sync&quot;),</span><br><span class="line">configurable: true,</span><br><span class="line">writable: true</span><br><span class="line">&#125;,</span><br><span class="line">_promise: &#123;</span><br><span class="line">value: createCompileDelegate(&quot;promise&quot;, &quot;promise&quot;),</span><br><span class="line">configurable: true,</span><br><span class="line">writable: true</span><br><span class="line">&#125;,</span><br><span class="line">_callAsync: &#123;</span><br><span class="line">value: createCompileDelegate(&quot;callAsync&quot;, &quot;async&quot;),</span><br><span class="line">configurable: true,</span><br><span class="line">writable: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以看出_call是由createCompileDelegate生成的， 往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createCompileDelegate(name, type) &#123;</span><br><span class="line">return function lazyCompileHook(...args) &#123;</span><br><span class="line">this[name] &#x3D; this._createCall(type);</span><br><span class="line">return this[name](...args);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCompileDelegate返回一个名为lazyCompileHook的函数，顾名思义，即懒编译， 直到调用call的时候， 才会编译出正在的call函数。</p><p>createCompileDelegate也是调用的_createCall， 而_createCall调用了Compier函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_createCall(type) &#123;</span><br><span class="line">return this.compile(&#123;</span><br><span class="line">taps: this.taps,</span><br><span class="line">interceptors: this.interceptors,</span><br><span class="line">args: this._args,</span><br><span class="line">type: type</span><br><span class="line">&#125;);</span><br><span class="line">&#125;  </span><br><span class="line">compile(options) &#123;</span><br><span class="line">throw new Error(&quot;Abstract: should be overriden&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到compiler必须由子类重写， 返回到syncHook的compile函数， 即我们一开始说的核心方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SyncHookCodeFactory extends HookCodeFactory &#123;</span><br><span class="line">content(&#123; onError, onResult, onDone, rethrowIfPossible &#125;) &#123;</span><br><span class="line">return this.callTapsSeries(&#123;</span><br><span class="line">onError: (i, err) &#x3D;&gt; onError(err),</span><br><span class="line">onDone,</span><br><span class="line">rethrowIfPossible</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const factory &#x3D; new SyncHookCodeFactory();</span><br><span class="line"></span><br><span class="line">class SyncHook extends Hook &#123;</span><br><span class="line">    ...</span><br><span class="line">compile(options) &#123;</span><br><span class="line">factory.setup(this, options);</span><br><span class="line">return factory.create(options);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就在于SyncHookCodeFactory和工厂类HookCodeFactory，  先看setup函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setup(instance, options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里的instance 是syncHook 实例, 其实就是把tap进来的钩子数组给到钩子的_x属性里.</span><br><span class="line">  instance._x &#x3D; options.taps.map(t &#x3D;&gt; t.fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是最关键的create函数， 可以看到最后返回的fn，其实是一个new Function动态生成的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">create(options) &#123;</span><br><span class="line">  &#x2F;&#x2F; 初始化参数,保存options到本对象this.options,保存new Hook([&quot;options&quot;]) 传入的参数到 this._args</span><br><span class="line">  this.init(options);</span><br><span class="line">  let fn;</span><br><span class="line">  &#x2F;&#x2F; 动态构建钩子,这里是抽象层,分同步, 异步, promise</span><br><span class="line">  switch (this.options.type) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先看同步</span><br><span class="line">    case &quot;sync&quot;:</span><br><span class="line">      &#x2F;&#x2F; 动态返回一个钩子函数</span><br><span class="line">      fn &#x3D; new Function(</span><br><span class="line">        &#x2F;&#x2F; 生成函数的参数,no before no after 返回参数字符串 xxx,xxx 在</span><br><span class="line">        &#x2F;&#x2F; 注意这里this.args返回的是一个字符串,</span><br><span class="line">        &#x2F;&#x2F; 在这个例子中是options</span><br><span class="line">        this.args(),</span><br><span class="line">        &#39;&quot;use strict&quot;;\n&#39; +</span><br><span class="line">          this.header() +</span><br><span class="line">          this.content(&#123;</span><br><span class="line">            onError: err &#x3D;&gt; &#96;throw $&#123;err&#125;;\n&#96;,</span><br><span class="line">            onResult: result &#x3D;&gt; &#96;return $&#123;result&#125;;\n&#96;,</span><br><span class="line">            onDone: () &#x3D;&gt; &quot;&quot;,</span><br><span class="line">            rethrowIfPossible: true</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line">      break;</span><br><span class="line">    case &quot;async&quot;:</span><br><span class="line">      fn &#x3D; new Function(</span><br><span class="line">        this.args(&#123;</span><br><span class="line">          after: &quot;_callback&quot;</span><br><span class="line">        &#125;),</span><br><span class="line">        &#39;&quot;use strict&quot;;\n&#39; +</span><br><span class="line">          this.header() +</span><br><span class="line">          &#x2F;&#x2F; 这个 content 调用的是子类类的 content 函数,</span><br><span class="line">          &#x2F;&#x2F; 参数由子类传,实际返回的是 this.callTapsSeries() 返回的类容</span><br><span class="line">          this.content(&#123;</span><br><span class="line">            onError: err &#x3D;&gt; &#96;_callback($&#123;err&#125;);\n&#96;,</span><br><span class="line">            onResult: result &#x3D;&gt; &#96;_callback(null, $&#123;result&#125;);\n&#96;,</span><br><span class="line">            onDone: () &#x3D;&gt; &quot;_callback();\n&quot;</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line">      break;</span><br><span class="line">    case &quot;promise&quot;:</span><br><span class="line">      let code &#x3D; &quot;&quot;;</span><br><span class="line">      code +&#x3D; &#39;&quot;use strict&quot;;\n&#39;;</span><br><span class="line">      code +&#x3D; &quot;return new Promise((_resolve, _reject) &#x3D;&gt; &#123;\n&quot;;</span><br><span class="line">      code +&#x3D; &quot;var _sync &#x3D; true;\n&quot;;</span><br><span class="line">      code +&#x3D; this.header();</span><br><span class="line">      code +&#x3D; this.content(&#123;</span><br><span class="line">        onError: err &#x3D;&gt; &#123;</span><br><span class="line">          let code &#x3D; &quot;&quot;;</span><br><span class="line">          code +&#x3D; &quot;if(_sync)\n&quot;;</span><br><span class="line">          code +&#x3D; &#96;_resolve(Promise.resolve().then(() &#x3D;&gt; &#123; throw $&#123;err&#125;; &#125;));\n&#96;;</span><br><span class="line">          code +&#x3D; &quot;else\n&quot;;</span><br><span class="line">          code +&#x3D; &#96;_reject($&#123;err&#125;);\n&#96;;</span><br><span class="line">          return code;</span><br><span class="line">        &#125;,</span><br><span class="line">        onResult: result &#x3D;&gt; &#96;_resolve($&#123;result&#125;);\n&#96;,</span><br><span class="line">        onDone: () &#x3D;&gt; &quot;_resolve();\n&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">      code +&#x3D; &quot;_sync &#x3D; false;\n&quot;;</span><br><span class="line">      code +&#x3D; &quot;&#125;);\n&quot;;</span><br><span class="line">      fn &#x3D; new Function(this.args(), code);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 把刚才init赋的值初始化为undefined</span><br><span class="line">  &#x2F;&#x2F; this.options &#x3D; undefined;</span><br><span class="line">  &#x2F;&#x2F; this._args &#x3D; undefined;</span><br><span class="line">  this.deinit();</span><br><span class="line"></span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成的代码大致如下， 参考<a href="https://segmentfault.com/a/1190000017421077#articleHeader9">文章</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function (options) &#123;</span><br><span class="line">  var _context;</span><br><span class="line">  var _x &#x3D; this._x;</span><br><span class="line">  var _taps &#x3D; this.taps;</span><br><span class="line">  var _interterceptors &#x3D; this.interceptors;</span><br><span class="line">&#x2F;&#x2F; 我们只有一个拦截器所以下面的只会生成一个</span><br><span class="line">  _interceptors[0].call(options);</span><br><span class="line"></span><br><span class="line">  var _tap0 &#x3D; _taps[0];</span><br><span class="line">  _interceptors[0].tap(_tap0);</span><br><span class="line">  var _fn0 &#x3D; _x[0];</span><br><span class="line">  _fn0(options);</span><br><span class="line">  var _tap1 &#x3D; _taps[1];</span><br><span class="line">  _interceptors[1].tap(_tap1);</span><br><span class="line">  var _fn1 &#x3D; _x[1];</span><br><span class="line">  _fn1(options);</span><br><span class="line">  var _tap2 &#x3D; _taps[2];</span><br><span class="line">  _interceptors[2].tap(_tap2);</span><br><span class="line">  var _fn2 &#x3D; _x[2];</span><br><span class="line">  _fn2(options);</span><br><span class="line">  var _tap3 &#x3D; _taps[3];</span><br><span class="line">  _interceptors[3].tap(_tap3);</span><br><span class="line">  var _fn3 &#x3D; _x[3];</span><br><span class="line">  _fn3(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok， 以上就是Tapabled的机制， 然而本篇的主要对象其实是基于tapable实现的compile和compilation对象。不过由于他们都是基于tapable，所以介绍的篇幅相对短一点。</p><h2 id="7-3-compile"><a href="#7-3-compile" class="headerlink" title="7.3 compile"></a>7.3 compile</h2><h3 id="7-3-1-compile是什么"><a href="#7-3-1-compile是什么" class="headerlink" title="7.3.1 compile是什么"></a>7.3.1 compile是什么</h3><blockquote><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用 compiler 来访问 webpack 的主环境。</p></blockquote><p>也就是说， compile是webpack的整体环境。</p><h3 id="7-3-2-compile的内部实现"><a href="#7-3-2-compile的内部实现" class="headerlink" title="7.3.2 compile的内部实现"></a>7.3.2 compile的内部实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Compiler extends Tapable &#123;</span><br><span class="line">  constructor(context) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.hooks &#x3D; &#123;</span><br><span class="line">      &#x2F;** @type &#123;SyncBailHook&lt;Compilation&gt;&#125; *&#x2F;</span><br><span class="line">      shouldEmit: new SyncBailHook([&quot;compilation&quot;]),</span><br><span class="line">      &#x2F;** @type &#123;AsyncSeriesHook&lt;Stats&gt;&#125; *&#x2F;</span><br><span class="line">      done: new AsyncSeriesHook([&quot;stats&quot;]),</span><br><span class="line">      &#x2F;** @type &#123;AsyncSeriesHook&lt;&gt;&#125; *&#x2F;</span><br><span class="line">      additionalPass: new AsyncSeriesHook([]),</span><br><span class="line">      &#x2F;** @type &#123;AsyncSeriesHook&lt;Compiler&gt;&#125; *&#x2F;</span><br><span class="line">      ......</span><br><span class="line">      ......</span><br><span class="line">      some code</span><br><span class="line">    &#125;;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， Compier继承了Tapable,  并且在实例上绑定了一个hook对象， 使得Compier的实例compier可以像这样使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.compile.tapAsync(</span><br><span class="line">  &#39;afterCompile&#39;,</span><br><span class="line">  (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;This is an example plugin!&#39;);</span><br><span class="line">    console.log(&#39;Here’s the &#96;compilation&#96; object which represents a single build of assets:&#39;, compilation);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 webpack 提供的 plugin API 操作构建结果</span><br><span class="line">    compilation.addModule(&#x2F;* ... *&#x2F;);</span><br><span class="line"></span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="7-4-compilation"><a href="#7-4-compilation" class="headerlink" title="7.4 compilation"></a>7.4 compilation</h2><h3 id="7-4-1-什么是compilation"><a href="#7-4-1-什么是compilation" class="headerlink" title="7.4.1 什么是compilation"></a>7.4.1 什么是compilation</h3><blockquote><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p></blockquote><h3 id="7-4-2-compilation的实现"><a href="#7-4-2-compilation的实现" class="headerlink" title="7.4.2 compilation的实现"></a>7.4.2 compilation的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Compilation extends Tapable &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of Compilation.</span><br><span class="line"> * @param &#123;Compiler&#125; compiler the compiler which created the compilation</span><br><span class="line"> *&#x2F;</span><br><span class="line">constructor(compiler) &#123;</span><br><span class="line">super();</span><br><span class="line">this.hooks &#x3D; &#123;</span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Module&gt;&#125; *&#x2F;</span><br><span class="line">buildModule: new SyncHook([&quot;module&quot;]),</span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Module&gt;&#125; *&#x2F;</span><br><span class="line">rebuildModule: new SyncHook([&quot;module&quot;]),</span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Module, Error&gt;&#125; *&#x2F;</span><br><span class="line">failedModule: new SyncHook([&quot;module&quot;, &quot;error&quot;]),</span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Module&gt;&#125; *&#x2F;</span><br><span class="line">succeedModule: new SyncHook([&quot;module&quot;]),</span><br><span class="line"></span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Dependency, string&gt;&#125; *&#x2F;</span><br><span class="line">addEntry: new SyncHook([&quot;entry&quot;, &quot;name&quot;]),</span><br><span class="line">&#x2F;** @type &#123;SyncHook&lt;Dependency, string, Error&gt;&#125; *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参考上面提到的compiler实现。</p><h2 id="7-5-编写一个插件"><a href="#7-5-编写一个插件" class="headerlink" title="7.5 编写一个插件"></a>7.5 编写一个插件</h2><p>了解到tapable\compiler\compilation之后， 再来看插件的实现就不再一头雾水了<br> 以下代码源自<a href="https://webpack.docschina.org/contribute/writing-a-plugin/">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyExampleWebpackPlugin &#123;</span><br><span class="line">  &#x2F;&#x2F; 定义 &#96;apply&#96; 方法</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    &#x2F;&#x2F; 指定要追加的事件钩子函数</span><br><span class="line">    compiler.hooks.compile.tapAsync(</span><br><span class="line">      &#39;afterCompile&#39;,</span><br><span class="line">      (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;This is an example plugin!&#39;);</span><br><span class="line">        console.log(&#39;Here’s the &#96;compilation&#96; object which represents a single build of assets:&#39;, compilation);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用 webpack 提供的 plugin API 操作构建结果</span><br><span class="line">        compilation.addModule(&#x2F;* ... *&#x2F;);</span><br><span class="line"></span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实就是在apply中传入一个Compiler实例， 然后基于该实例注册事件， compilation同理， 最后webpack会在各流程执行call方法。</p><h2 id="7-6-compiler和compilation一些比较重要的事件钩子"><a href="#7-6-compiler和compilation一些比较重要的事件钩子" class="headerlink" title="7.6 compiler和compilation一些比较重要的事件钩子"></a>7.6 compiler和compilation一些比较重要的事件钩子</h2><h3 id="7-6-1-compier"><a href="#7-6-1-compier" class="headerlink" title="7.6.1 compier"></a>7.6.1 <a href="https://webpack.docschina.org/api/compiler-hooks/#failed">compier</a></h3><table><thead><tr><th>事件钩子</th><th>触发时机</th><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>entry-option</td><td>初始化 option</td><td>-</td><td>SyncBailHook</td></tr><tr><td>run</td><td>开始编译</td><td>compiler</td><td>AsyncSeriesHook</td></tr><tr><td>compile</td><td>真正开始的编译，在创建 compilation 对象之前</td><td>compilation</td><td>SyncHook</td></tr><tr><td>compilation</td><td>生成好了 compilation 对象，可以操作这个对象啦</td><td>compilation</td><td>SyncHook</td></tr><tr><td>make</td><td>从 entry 开始递归分析依赖，准备对每个模块进行 build</td><td>compilation</td><td>AsyncParallelHook</td></tr><tr><td>after-compile</td><td>编译 build 过程结束</td><td>compilation</td><td>AsyncSeriesHook</td></tr><tr><td>emit</td><td>在将内存中 assets 内容写到磁盘文件夹之前</td><td>compilation</td><td>AsyncSeriesHook</td></tr><tr><td>after-emit</td><td>在将内存中 assets 内容写到磁盘文件夹之后</td><td>compilation</td><td>AsyncSeriesHook</td></tr><tr><td>done</td><td>完成所有的编译过程</td><td>stats</td><td>AsyncSeriesHook</td></tr><tr><td>failed</td><td>编译失败的时候</td><td>error</td><td>SyncHook</td></tr></tbody></table><h3 id="7-6-2-compilation"><a href="#7-6-2-compilation" class="headerlink" title="7.6.2 compilation"></a>7.6.2 <a href="https://webpack.docschina.org/api/compilation-hooks/">compilation</a></h3><table><thead><tr><th>事件钩子</th><th>触发时机</th><th>参数</th><th>类型</th></tr></thead><tbody><tr><td>normal-module-loader</td><td>普通模块 loader，真正（一个接一个地）加载模块图(graph)中所有模块的函数。</td><td>loaderContext module</td><td>SyncHook</td></tr><tr><td>seal</td><td>编译(compilation)停止接收新模块时触发。</td><td>-</td><td>SyncHook</td></tr><tr><td>optimize</td><td>优化阶段开始时触发。</td><td>-</td><td>SyncHook</td></tr><tr><td>optimize-modules</td><td>模块的优化</td><td>modules</td><td>SyncBailHook</td></tr><tr><td>optimize-chunks</td><td>优化 chunk</td><td>chunks</td><td>SyncBailHook</td></tr><tr><td>additional-assets</td><td>为编译(compilation)创建附加资源(asset)。</td><td>-</td><td>AsyncSeriesHook</td></tr><tr><td>optimize-chunk-assets</td><td>优化所有 chunk 资源(asset)。</td><td>chunks</td><td>AsyncSeriesHook</td></tr><tr><td>optimize-assets</td><td>优化存储在 compilation.assets 中的所有资源(asset)</td><td>assets</td><td>AsyncSeriesHook</td></tr></tbody></table><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>插件机制并不复杂，webpack也不复杂，复杂的是插件本身..<br> 另外， 本应该先写流程的， 流程只能后面补上了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://segmentfault.com/a/1190000017421077#articleHeader9">不满足于只会使用系列: tapable</a><br> <a href="https://juejin.im/post/6844903750729990152">webpack系列之二Tapable</a><br> <a href="https://webpack.docschina.org/contribute/writing-a-plugin/">编写一个插件</a><br> <a href="https://github.com/webpack/webpack/blob/master/lib/Compiler.js">Compiler</a><br> <a href="https://github.com/webpack/webpack/blob/master/lib/Compilation.js">Compilation</a><br> <a href="https://webpack.docschina.org/api/compilation-hooks/#optimizeassets">compiler和comnpilation钩子</a><br> <a href="https://zoumiaojiang.com/article/what-is-real-webpack-plugin/">看清楚真正的 Webpack 插件</a></p><h1 id="8-webpack-loader"><a href="#8-webpack-loader" class="headerlink" title="8.webpack-loader"></a>8.webpack-loader</h1><h2 id="8-1-问题"><a href="#8-1-问题" class="headerlink" title="8.1 问题"></a>8.1 问题</h2><p>以加载 less 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; example.js</span><br><span class="line">require(&#39;.&#x2F;style.less&#39;);</span><br><span class="line">&#x2F;&#x2F; style.less</span><br><span class="line">@color: #000fff;</span><br><span class="line">.content &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: @color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照官方文档，想要加载 less 文件，我们需要配置三个 loader：style-loader!css-loader!less-loader。</p><p><strong>该从什么地方着手研究呢？</strong> → 仔细观察最终生成的 <a href="https://github.com/youngwind/fake-webpack/blob/master/examples/loader/output.js">output.js </a>，如下图所示。</p><p><a href="https://cloud.githubusercontent.com/assets/8401872/23387388/18895ef0-fd97-11e6-9dd7-94628c322e8e.png"><img data-src="https://cloud.githubusercontent.com/assets/8401872/23387388/18895ef0-fd97-11e6-9dd7-94628c322e8e.png" alt="image"></a></p><p>由此我们进行以下思考：</p><ol><li><p>既然最终 css 代码会被插入到 head 标签中，那么一定是模块2在起作用。但是，项目中并不包含这部分代码，经过排查，发现源自于 node-modules/style-loader/addStyle.js ，也就是说，是由 style-loader 引入的。（后面我们再考察是如何引入的）</p></li><li><p>观察模块3，那应该是 less 代码经过 less-loader 的转换之后，再包装一层 module.exports，成为一个 JS module。</p></li><li><p>style-loader 和 less-loader 的作用已经明了，但是，css-loader 发挥什么作用呢？虽然我一直按照官方文档配置三个 loader，但我从未真正理解为什么需要 css-loader。后来我在 css-loader 的文档中找到了答案。</p><blockquote><p><a href="https://github.com/import">@import</a> and url() are interpreted like import and will be resolved by the css-loader.</p></blockquote><p>来源：<a href="https://github.com/webpack-contrib/css-loader#options">https://github.com/webpack-contrib/css-loader#options</a></p><p>既然如此，为了降低实现的难度，我们<strong>暂时不予考虑 import 和 url 的情况，也就无需实现 css-loader 了。</strong></p></li><li><p>观察模块1，<code>require(2)(require(3))</code>，很显然：”模块3的导出作为模块2的输入参数，执行模块2“，也就是说：“将模块3中的 css 代码插入到 head 标签中“。理解这个逻辑不难，难点在于：<strong>webpack 如何知道应该拼接成 <code>require(2)(require(3))</code>，而不是别的什么。也就说，如何控制拼接出 <code>require(2)(require(3))</code>？</strong></p></li></ol><h2 id="8-2-思路"><a href="#8-2-思路" class="headerlink" title="8.2 思路"></a>8.2 思路</h2><p>思路进行到这儿，似乎走不下去了。看来只分析 output.js 还不足以理清，那么，让我们更进一步，观察 depTree，如下图所示。（图片较大，请点击放大查看）<br><a href="https://cloud.githubusercontent.com/assets/8401872/23388226/ebcea460-fd9b-11e6-8cb8-cb2bb779ae62.png"><img data-src="https://cloud.githubusercontent.com/assets/8401872/23388226/ebcea460-fd9b-11e6-8cb8-cb2bb779ae62.png" alt="image"></a></p><p>问题在于：<strong>为什么凭空多出来2个模块？到底是哪里起了作用呢？→ 我在 style-loader 的源码中找到了答案。</strong></p><h2 id="8-3-style-loader-的再-require"><a href="#8-3-style-loader-的再-require" class="headerlink" title="8.3 style-loader 的再 require"></a>8.3 style-loader 的再 require</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; style-loader&#x2F;index.js</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports &#x3D; function (content) &#123;</span><br><span class="line">   &#x2F;&#x2F; content 的值为：&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js!&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;less-loader-fake&#x2F;index.js!&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;examples&#x2F;loader&#x2F;style.less</span><br><span class="line">    let loaderSign &#x3D; this.request.indexOf(&quot;!&quot;);</span><br><span class="line">    let rawCss &#x3D; this.request.substr(loaderSign);</span><br><span class="line">    &#x2F;&#x2F; rawCss 的值为：&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;less-loader-fake&#x2F;index.js!&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;examples&#x2F;loader&#x2F;style.less</span><br><span class="line">    return &quot;require(&quot; + JSON.stringify(path.join(__dirname, &#39;addStyle&#39;)) + &quot;)&quot; +</span><br><span class="line">        &quot;(require(&quot; + JSON.stringify(rawCss) + &quot;))&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察源码，我们发现：<strong>style-loader 返回的字符串里面又包含了2个 require，分别 require 了 addStyle 和 less-loader!style.less，由此，我们终于找到了突破口。→ loader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。</strong> 这就是多引入2个模块的原因。</p><h2 id="8-4-loaders-的拆解与运行"><a href="#8-4-loaders-的拆解与运行" class="headerlink" title="8.4 loaders 的拆解与运行"></a>8.4 loaders 的拆解与运行</h2><p>loaders 就像首尾相接的管道那样，<strong>从右到左</strong>地被依次运行。对应的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; buildDep.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 运算文件类型对应的 loaders，比如: less 文件对应 style-loader 和 less-loader</span><br><span class="line"> * 这些 loaders 本质上是一些处理字符串的函数,输入是一个字符串,输出是另一个字符串,从右到左串行执行。</span><br><span class="line"> * @param &#123;string&#125; request 相当于 filenamesWithLoader ,比如 &#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;fake-style-loader&#x2F;index.js!&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;fake-less-loader&#x2F;index.js!&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;examples&#x2F;loader&#x2F;style.less</span><br><span class="line"> * @param &#123;array&#125; loaders 此类型文件对应的loaders</span><br><span class="line"> * @param &#123;string&#125; content 文件内容</span><br><span class="line"> * @param &#123;object&#125; options 选项</span><br><span class="line"> * @returns &#123;Promise&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">function execLoaders(request, loaders, content, options) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 当所有 loader 都执行完了，输出最终的字符串</span><br><span class="line">        if (!loaders.length) &#123;</span><br><span class="line">            resolve(content);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let loaderFunctions &#x3D; [];</span><br><span class="line">        loaders.forEach(loaderName &#x3D;&gt; &#123;</span><br><span class="line">            let loader &#x3D; require(loaderName);</span><br><span class="line">            &#x2F;&#x2F; 每个loader 本质上是一个函数</span><br><span class="line">            loaderFunctions.push(loader);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        nextLoader(content);</span><br><span class="line"></span><br><span class="line">        &#x2F;***</span><br><span class="line">         * 调用下一个 loader</span><br><span class="line">         * @param &#123;string&#125; content 上一个loader的输出字符串</span><br><span class="line">         *&#x2F;</span><br><span class="line">        function nextLoader(content) &#123;</span><br><span class="line">            if (!loaderFunctions.length) &#123;</span><br><span class="line">                resolve(content);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 请注意: loader有同步和异步两种类型。对于异步loader,如 less-loader,</span><br><span class="line">            &#x2F;&#x2F; 需要执行 async() 和 callback(),以修改标志位和回传字符串</span><br><span class="line">            let async &#x3D; false;</span><br><span class="line">            let context &#x3D; &#123;</span><br><span class="line">                request,</span><br><span class="line">                async: () &#x3D;&gt; &#123;</span><br><span class="line">                    async &#x3D; true;</span><br><span class="line">                &#125;,</span><br><span class="line">                callback: (content) &#x3D;&gt; &#123;</span><br><span class="line">                    nextLoader(content);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 就是在这儿逐个调用 loader</span><br><span class="line">            let ret &#x3D; loaderFunctions.pop().call(context, content);</span><br><span class="line">            if(!async) &#123;</span><br><span class="line">                &#x2F;&#x2F; 递归调用下一个 loader</span><br><span class="line">                nextLoader(ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意：<strong>loader 也是分为同步和异步两种的，比如 style-loader 是同步的（看源码就知道，直接 return）；而 less-loader 却是异步的，为什么呢？</strong></p><h2 id="8-5-异步的-less-loader"><a href="#8-5-异步的-less-loader" class="headerlink" title="8.5 异步的 less-loader"></a>8.5 异步的 less-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; less-loader</span><br><span class="line">const less &#x3D; require(&#39;less&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function (source) &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明此 loader 是异步的</span><br><span class="line">    this.async();</span><br><span class="line">    let resultCb &#x3D; this.callback;</span><br><span class="line">    less.render(source, (e, output) &#x3D;&gt; &#123;</span><br><span class="line">        if (e) &#123;</span><br><span class="line">            throw &#96;less解析出现错误: $&#123;e&#125;, $&#123;e.stack&#125;&#96;;</span><br><span class="line">        &#125;</span><br><span class="line">        resultCb(&quot;module.exports &#x3D; &quot; + JSON.stringify(output.css));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码我们可以看出：<strong>less-loader 本质上只是调用了 less 本身的 render 方法，由于 less.render 是异步的，less-loader 肯定也得异步，所以需要通过回调函数来获取其解析之后的 css 代码。</strong></p><h2 id="8-6-node-modules-的逐级查找"><a href="#8-6-node-modules-的逐级查找" class="headerlink" title="8.6 node-modules 的逐级查找"></a>8.6 node-modules 的逐级查找</h2><p>还差最后一点，我们就能完成 loader 机制了。<br>试想以下情景：<strong>webpack 检测到当前为 less 文件，需要找到 style-loader 和 less-loader 运行。但是，webpack 怎么知道这两个 loader 藏在哪个目录下面呢？他们可能藏在 example.js 所在目录的任意上层文件夹的 node-modules 中。</strong> 说到底，我们还是得实现之前提到过的 <strong>node-modules 的逐级查找功能。</strong> 核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; resolve.js</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据 loaders &#x2F; 模块名,生成待查找的路径集合</span><br><span class="line"> * @param &#123;string&#125; context 入口文件所在目录</span><br><span class="line"> * @param &#123;array&#125; identifiers 可能是loader的集合,也可能是模块名</span><br><span class="line"> * @returns &#123;Array&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">function generateDirs(context, identifiers) &#123;</span><br><span class="line">    let dirs &#x3D; [];</span><br><span class="line">    for (let identifier of identifiers) &#123;</span><br><span class="line">        if (path.isAbsolute(identifier)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 绝对路径</span><br><span class="line">            if (!path.extname(identifier)) &#123;</span><br><span class="line">                identifier +&#x3D; &#39;.js&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            dirs.push(identifier);</span><br><span class="line">        &#125; else if (identifier.startsWith(&#39;.&#x2F;&#39;) || identifier.startsWith(&#39;..&#x2F;&#39;)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 相对路径</span><br><span class="line">            dirs.push(path.resolve(context, identifier));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 模块名,需要逐级生成目录</span><br><span class="line">            let ext &#x3D; path.extname(identifier);</span><br><span class="line">            if (!ext) &#123;</span><br><span class="line">                ext &#x3D; &#39;.js&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            let paths &#x3D; context.split(path.sep);</span><br><span class="line">            let tempPaths &#x3D; paths.slice();</span><br><span class="line">            for (let folder of tempPaths) &#123;</span><br><span class="line">                let newContext &#x3D; paths.join(path.sep);</span><br><span class="line">                dirs.push(path.resolve(newContext, &#39;.&#x2F;node_modules&#39;, &#96;.&#x2F;$&#123;identifier&#125;-loader-fake&#96;, &#96;index$&#123;ext&#125;&#96;));</span><br><span class="line">                paths.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dirs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，对于 style-loader 来说，生成的查找路径集合如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;examples&#x2F;loader&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">  &quot;&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;examples&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">  &quot;&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;fake-webpack&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">  &quot;&#x2F;Users&#x2F;youngwind&#x2F;www&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">  &quot;&#x2F;Users&#x2F;youngwind&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">  &quot;&#x2F;Users&#x2F;node_modules&#x2F;style-loader-fake&#x2F;index.js&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>程序按照这个顺序依次查找，直到找到为止或者最终找不到抛出错误。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>至此，我们就完成了一个非常简单的 loader 机制，可以通过 style-loader 和 less-loader 处理加载 less 文件。当然，还有很多可以完善的地方，比如：</p><ol><li>实现 css-loader，以处理 import 和 url 的情况</li><li>给 loader 传递选项参数，以控制是否压缩代码等等特性</li><li>……</li></ol><h1 id="9-微前端-前端微服务"><a href="#9-微前端-前端微服务" class="headerlink" title="9.微前端(前端微服务)"></a>9.微前端(前端微服务)</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>想跳过技术细节直接看怎么实践的同学可以直接看最后一节。</p><p>目前社区有很多关于微前端架构的介绍，但大多停留在概念介绍的阶段。而本文会就某一个具体的类型场景，着重介绍微前端架构可以<strong>带来什么价值</strong>以及<strong>具体实践过程中需要关注的技术决策</strong>，并辅以具体代码，从而能真正意义上帮助你构建一个<strong>生产可用</strong>的微前端架构系统。</p><p>两个月前 Twitter 曾爆发过关于微前端的“热烈”讨论，参与大佬众多(Dan、Larkin 等)，对“事件”本身我们今天不做过多评论(后面可能会写篇文章来回顾一下)，有兴趣的同学可以通过这篇文章（<a href="https://zendev.com/2019/06/17/microfrontends-good-bad-ugly.html%EF%BC%89%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%8C%E3%80%82">https://zendev.com/2019/06/17/microfrontends-good-bad-ugly.html）了解一二。</a></p><h2 id="9-1-微前端的价值"><a href="#9-1-微前端的价值" class="headerlink" title="9.1 微前端的价值"></a>9.1 微前端的价值</h2><p>微前端架构具备以下几个核心价值：</p><p><strong>技术栈无关</strong>：主框架不限制接入应用的技术栈，子应用具备完全自主权</p><p><strong>独立开发、独立部署</strong>：子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p><p><strong>独立运行时</strong>：每个子应用之间状态隔离，运行时状态不共享</p><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用( Frontend Monolith )后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p><h2 id="9-2-针对中后台应用的解决方案"><a href="#9-2-针对中后台应用的解决方案" class="headerlink" title="9.2 针对中后台应用的解决方案"></a>9.2 针对中后台应用的解决方案</h2><p><strong>中后台应用由于其应用生命周期长(动辄 3+ 年)等特点，最后演变成一个巨石应用的概率往往高于其他类型的 web 应用。而从技术实现角度，微前端架构解决方案大概分为两类场景：</strong></p><p><strong>单实例</strong>：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。</p><p><strong>多实例</strong>：同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用。</p><p>本文将着重介绍<strong>单实例场景</strong>下的微前端架构实践方案（基于 single-spa），因为这个场景更贴近大部分中后台应用。</p><h2 id="9-3-行业现状"><a href="#9-3-行业现状" class="headerlink" title="9.3 行业现状"></a>9.3 行业现状</h2><p>传统的云控制台应用，几乎都会面临业务快速发展之后，单体应用进化成巨石应用的问题。为了解决产品研发之间各种耦合的问题，大部分企业也都会有自己的解决方案。笔者于17年底，针对国内外几个著名的云产品控制台，做过这样一个技术调研：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/1c4ee3d5-d535-4bb4-a511-2d0e1274519d.png" alt="img"></p><p>MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。</p><p>SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。</p><p>那我们有没有可能将 MPA 和SPA 两者的优势结合起来，构建出一个相对完善的微前端架构方案呢？</p><p>jsconf china 2016 大会上，ucloud 的同学分享了他们的基于 angularjs 的方案（单页应用“联邦制”实践），里面提到的 “联邦制” 概念很贴切，可以认为是早期的基于耦合技术栈的微前端架构实践。</p><h2 id="9-4-微前端架构实践中的问题"><a href="#9-4-微前端架构实践中的问题" class="headerlink" title="9.4 微前端架构实践中的问题"></a>9.4 微前端架构实践中的问题</h2><p>可以发现，微前端架构的优势，正是 MPA 与 SPA 架构优势的合集。即保证应用具备独立开发权的同时，又有将它们整合到一起保证产品完整的流程体验的能力。</p><p>这样一套模式下，应用的架构就会变成：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/00e4ae14-6a48-4118-a9d3-bdcbf2debadd.png" alt="img"></p><p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<strong>导航路由 + 资源加载框架。</strong></p><p>而具体要实现这样一套架构，我们需要解决以下几个技术问题：</p><p><strong>路由系统及 FutureStat</strong></p><p>我们在一个实现了微前端内核的产品中，正常访问一个子应用的页面时，可能会有这样一个链路：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/86e06958-dc1b-404a-9aaa-7b7a33c7bab8.png" alt="img"></p><p>由于我们的子应用都是 lazy load 的，当浏览器重新刷新时，主框架的资源会被重新加载，同时异步 load 子应用的静态资源，由于此时主应用的路由系统已经激活，但子应用的资源可能还没有完全加载完毕，从而导致路由注册表里发现没有能匹配子应用 /subApp/123/detail 的规则，这时候就会导致跳 NotFound 页或者直接路由报错。</p><p>这个问题在所有 lazy load 方式加载子应用的方案中都会碰到，早些年前 angularjs 社区把这个问题统一称之为 Future State。</p><p>解决的思路也很简单，我们需要设计这样一套路由机制：</p><p>主框架配置子应用的路由为subApp: { url: ‘/subApp/**’, entry:’./subApp.js’ }，则当浏览器的地址为 /subApp/abc 时，框架需要先加载 entry 资源，待 entry 资源加载完毕，确保子应用的路由系统注册进主框架之后后，再去由子应用的路由系统接管 url change 事件。同时在子应用路由切出时，主框架需要触发相应的destroy 事件，子应用在监听到该事件时，调用自己的卸载方法卸载应用，如 React 场景下 destroy = () =&gt; ReactDOM.unmountAtNode(container) 。</p><p>要实现这样一套机制，我们可以自己去劫持 url change 事件从而实现自己的路由系统，也可以基于社区已有的 ui router library，尤其是 react-router 在 v4 之后实现了 Dynamic Routing 能力，我们只需要复写一部分路由发现的逻辑即可。这里我们推荐直接选择社区比较完善的相关实践single-spa。</p><p><strong>App Entry</strong></p><p>解决了路由问题后，主框架与子应用集成的方式，也会成为一个需要重点关注的技术决策。</p><p><strong>1. 构建时组合 VS 运行时组合</strong></p><p>微前端架构模式下，子应用打包的方式，基本分为两种：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/ce38b308-f0c6-402d-a9fa-30cdb5424706.png" alt="img"></p><p>两者的优缺点也很明显：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/faaf3ace-15a2-4db9-875e-92b41035d6c8.png" alt="img"></p><p>很显然，要实现真正的技术栈无关跟独立部署两个核心目标，大部分场景下我们需要使用运行时加载子应用这种方案。</p><p><strong>2. JS Entry vs HTMLEntry</strong></p><p>在确定了运行时载入的方案后，另一个需要决策的点是，我们需要子应用提供什么形式的资源作为渲染入口？</p><p>JS Entry 的方式通常是子应用将资源打成一个entry script，比如 single-spa 的 example 中的方式。但这个方案的限制也颇多，如要求子应用的所有资源打包到一个 js bundle 里，包括 css、图片等资源。除了打出来的包可能体积庞大之外的问题之外，资源的并行加载等特性也无法利用上。</p><p>HTML Entry 则更加灵活，直接将子应用打出来 HTML作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。这样不仅可以极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整，而且可以天然的解决子应用之间样式隔离的问题(后面提到)。想象一下这样一个场景：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/da63a733-edca-4e57-a1cd-f9e4358c5609.png" alt="img"></p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/73cc3732-55af-4d60-b70a-9f2d0b206726.png" alt="img"></p><p>如果是 JS Entry 方案，主框架需要在子应用加载之前构建好相应的容器节点(比如这里的 “#root” 节点)，不然子应用加载时会因为找不到 container 报错。但问题在于，主应用并不能保证子应用使用的容器节点为某一特定标记元素。而 HTML Entry 的方案则天然能解决这一问题，保留子应用完整的环境上下文，从而确保子应用有良好的开发体验。</p><p>HTML Entry 方案下，主框架注册子应用的方式则变成：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/c6c206b5-bf52-4494-ad0b-b443f9abb467.png" alt="img"></p><p>本质上这里 HTML 充当的是应用静态资源表的角色，在某些场景下，我们也可以将 HTML Entry 的方案优化成 Config Entry，从而减少一次请求，如：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/74436fb6-dad1-4af6-9318-db5e217622a3.png" alt="img"></p><p>总结一下：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/ce4bd74e-eb49-4538-bfc0-8b639d294c24.png" alt="img"></p><p><strong>3. 模块导入</strong></p><p>微前端架构下，我们需要获取到子应用暴露出的一些钩子引用，如 bootstrap、mount、unmout 等(参考 single-spa)，从而能对接入应用有一个完整的生命周期控制。而由于子应用通常又有集成部署、独立部署两种模式同时支持的需求，使得我们只能选择 umd 这种兼容性的模块格式打包我们的子应用。如何在浏览器运行时获取远程脚本中导出的模块引用也是一个需要解决的问题。</p><p>通常我们第一反应的解法，也是最简单的解法就是与子应用与主框架之间约定好一个全局变量，把导出的钩子引用挂载到这个全局变量上，然后主应用从这里面取生命周期函数。</p><p>这个方案很好用，但是最大的问题是，主应用与子应用之间存在一种强约定的打包协议。那我们是否能找出一种松耦合的解决方案呢？</p><p>很简单，我们只需要走 umd 包格式中的 global export 方式获取子应用的导出即可，大体的思路是通过给 window变量打标记，记住每次最后添加的全局变量，这个变量一般就是应用 export 后挂载到 global 上的变量。实现方式可以参考 systemjs global import，这里不再赘述。</p><p><strong>应用隔离</strong></p><p>微前端架构方案中有两个非常关键的问题，有没有解决这两个问题将直接标志你的方案是否真的生产可用。比较遗憾的是此前社区在这个问题上的处理都会不约而同选择”绕道“的方式，比如通过主子应用之间的一些默认约定去规避冲突。而今天我们会尝试从纯技术角度，更智能的解决应用之间可能冲突的问题。</p><p><strong>1. 样式隔离</strong></p><p>由于微前端场景下，不同技术栈的子应用会被集成到同一个运行时中，所以我们必须在框架层确保各个子应用之间不会出现样式互相干扰的问题。</p><p><strong>Shadow DOM？</strong></p><p>针对 “Isolated Styles” 这个问题，如果不考虑浏览器兼容性，通常第一个浮现到我们脑海里的方案会是 Web Components。基于 Web Components 的 Shadow DOM 能力，我们可以将每个子应用包裹到一个 Shadow DOM 中，保证其运行时的样式的绝对隔离。</p><p>但 Shadow DOM 方案在工程实践中会碰到一个常见问题，比如我们这样去构建了一个在 Shadow DOM 里渲染的子应用：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/24ba6c51-5e32-4f65-b700-1e527ed44dc3.png" alt="img"></p><p>由于子应用的样式作用域仅在 shadow 元素下，那么一旦子应用中出现运行时越界跑到外面构建 DOM 的场景，必定会导致构建出来的 DOM 无法应用子应用的样式的情况。</p><p>比如 sub-app 里调用了antd modal 组件，由于 modal 是动态挂载到document.body 的，而由于 Shadow DOM 的特性 antd 的样式只会在 shadow 这个作用域下生效，结果就是弹出框无法应用到 antd 的样式。解决的办法是把 antd 样式上浮一层，丢到主文档里，但这么做意味着子应用的样式直接泄露到主文档了。gg…</p><p><strong>CSS Module? BEM?</strong></p><p>社区通常的实践是通过约定 css 前缀的方式来避免样式冲突，即各个子应用使用特定的前缀来命名 class，或者直接基于 css module 方案写样式。对于一个全新的项目，这样当然是可行，但是通常微前端架构更多的目标是解决存量/遗产 应用的接入问题。很显然遗产应用通常是很难有动力做大幅改造的。</p><p>最主要的是，约定的方式有一个无法解决的问题，假如子应用中使用了三方的组件库，三方库在写入了大量的全局样式的同时又不支持定制化前缀？比如 a 应用引入了 antd 2.x，而b 应用引入了 antd 3.x，两个版本的 antd 都写入了全局的 .menu class ，但又彼此不兼容怎么办？</p><p><strong>Dynamic Stylesheet !</strong></p><p>解决方案其实很简单，我们只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的。这样即能保证，在一个时间点里，只有一个应用的样式表是生效的。</p><p>上文提到的 HTML Entry 方案则天生具备样式隔离的特性，因为应用卸载后会直接移除去 HTML 结构，从而自动移除了其样式表。</p><p>比如 HTML Entry 模式下，子应用加载完成的后的 DOM 结构可能长这样：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/cf7eb534-e522-4da7-84e5-6c314f9d52a3.png" alt="img"></p><p>当子应用被替换或卸载时，subApp节点的innerHTML 也会被复写，//alipay.com/subapp.css 也就自然被移除样式也随之卸载了。</p><p><strong>2. JS 隔离</strong></p><p>解决了样式隔离的问题后，有一个更关键的问题我们还没有解决：如何确保各个子应用之间的全局变量不会互相干扰，从而保证每个子应用之间的软隔离？</p><p>这个问题比样式隔离的问题更棘手，社区的普遍玩法是给一些全局副作用加各种前缀从而避免冲突。但其实我们都明白，这种通过团队间的“口头”约定的方式往往低效且易碎，所有依赖人为约束的方案都很难避免由于人的疏忽导致的线上 bug。那么我们是否有可能打造出一个好用的且完全无约束的 JS 隔离方案呢？</p><p>针对 JS 隔离的问题，我们独创了一个运行时的 JS 沙箱。简单画了个架构图：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/f9b794e2-24cc-40c8-bd57-7254c93d5908.png" alt="img"></p><p>即在应用的 bootstrap 及 mount 两个生命周期开始之前分别给全局状态打下快照，然后当应用切出/卸载时，将状态回滚至 bootstrap 开始之前的阶段，确保应用对全局状态的污染全部清零。而当应用二次进入时则再恢复至 mount 前的状态的，从而确保应用在 remount 时拥有跟第一次 mount 时一致的全局上下文。</p><p>当然沙箱里做的事情还远不止这些，其他的还包括一些对全局事件监听的劫持等，以确保应用在切出之后，对全局事件的监听能得到完整的卸载，同时也会在 remount 时重新监听这些全局事件，从而模拟出与应用独立运行时一致的沙箱环境。</p><h2 id="9-5-蚂蚁金服微前端落地实践"><a href="#9-5-蚂蚁金服微前端落地实践" class="headerlink" title="9.5 蚂蚁金服微前端落地实践"></a>9.5 蚂蚁金服微前端落地实践</h2><p>自去年年底伊始，我们便尝试基于微前端架构模式，构建出一套全链路的面向中后台场景的产品接入平台，目的是解决不同产品之间集成困难、流程割裂的问题，希望接入平台后的应用，不论使用哪种技术栈，在运行时都可以通过自定义配置，实现不同应用之间页面级别的自由组合，从而生成一个千人千面的个性化控制台。</p><p>目前这套平台已在蚂蚁生产环境运行半年多，同时接入了多个产品线的 40+ 应用、4+ 不同类型的技术栈。过程中针对大量微前端实践中的问题，我们总结出了一套完整的解决方案：</p><p><img data-src="https://antcloud-cnhz02-athomeweb-01.oss-cn-hzfinance.aliyuncs.com/image/2019-08-26/f44b35de-1d21-45dd-9998-e65cc52c0266.png" alt="img"></p><p>在内部得到充分的技术验证和线上考验之后，我们决定将这套解决方案开源出来！</p><p>qiankun - 一套完整的微前端解决方案</p><p><a href="https://github.com/umijs/qiankun">https://github.com/umijs/qiankun</a></p><p>取名 qiankun，意为统一。我们希望通过 qiankun 这种技术手段，让你能很方便的将一个巨石应用改造成一个基于微前端架构的系统，并且不再需要去关注各种过程中的技术细节，做到真正的开箱即用和生产可用。</p><p>对于umi用户我们也提供了配套的qiankun插件，以便于 umi 应用能几乎零成本的接入 qiankun：</p><p>@umijs/plugin-qiankun</p><p><a href="https://github.com/umijs/umi-plugin-qiankun/">https://github.com/umijs/umi-plugin-qiankun/</a></p><p>最后欢迎大家点赞使用提出宝贵的意见。</p><p>Maybe the most complete micro-frontends solution youever met.</p><p>可能是你见过的最完善的微前端架构解决方案。</p><h1 id="10-Nodejs模块机制"><a href="#10-Nodejs模块机制" class="headerlink" title="10.Nodejs模块机制"></a>10.Nodejs模块机制</h1><p>我们都知道Nodejs遵循的是<code>CommonJS</code>规范，当我们<code>require(&#39;moduleA&#39;)</code>时，模块是怎么通过名字或者路径获取到模块的呢？首先要聊一下模块引用、模块定义、模块标识三个概念。</p><h2 id="10-1-CommonJS规范"><a href="#10-1-CommonJS规范" class="headerlink" title="10.1 CommonJS规范"></a>10.1 CommonJS规范</h2><h3 id="10-1-1-模块引用"><a href="#10-1-1-模块引用" class="headerlink" title="10.1.1 模块引用"></a>10.1.1 模块引用</h3><p>模块上下文提供<code>require()</code>方法来引入外部模块，看似简单的require函数， 其实内部做了大量工作。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; test.js</span><br><span class="line">&#x2F;&#x2F; 引入一个模块到当前上下文中</span><br><span class="line">const math &#x3D; require(&#39;math&#39;);</span><br><span class="line">math.add(1, 2);</span><br></pre></td></tr></table></figure><h3 id="10-1-2-模块定义"><a href="#10-1-2-模块定义" class="headerlink" title="10.1.2 模块定义"></a>10.1.2 模块定义</h3><p>模块上下文提供了<code>exports</code>对象用于导入导出当前模块的方法或者变量，并且它是唯一的导出出口。模块中存在一个<code>module</code>对象，它代表模块自身，<code>exports</code>是module的属性。<strong>一个文件就是一个模块</strong>，将方法作为属性挂载在exports上就可以定义导出的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;math.js</span><br><span class="line">exports.add &#x3D; function () &#123;</span><br><span class="line">    let sum &#x3D; 0, i &#x3D; 0, args &#x3D; arguments, l &#x3D; args.length;</span><br><span class="line">    while(i &lt; l) &#123;</span><br><span class="line">        sum +&#x3D; args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可像<code>test.js</code>里那样在require()之后调用模块的属性或者方法了。</p><h3 id="10-1-3-模块标识"><a href="#10-1-3-模块标识" class="headerlink" title="10.1.3 模块标识"></a>10.1.3 模块标识</h3><p>模块标识就是传递<code>给require()</code>方法的参数，它必须是符合小驼峰命名的字符串，或者以<code>.</code>、<code>..</code>开头的相对路径或者绝对路径，可以没有文件后缀名<code>.js</code>.</p><h2 id="10-2-Node的模块实现"><a href="#10-2-Node的模块实现" class="headerlink" title="10.2 Node的模块实现"></a>10.2 Node的模块实现</h2><p>在Node中引入模块，需要经历如下四个步骤:</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li><li>加入内存</li></ul><h3 id="10-2-1-路径分析"><a href="#10-2-1-路径分析" class="headerlink" title="10.2.1 路径分析"></a>10.2.1 路径分析</h3><p>Node.js中模块可以通过文件路径或名字获取模块的引用。<strong>模块的引用会映射到一个js文件路径</strong>。 在Node中模块分为两类：</p><ul><li>一是Node提供的模块，称为<strong>核心模块</strong>（内置模块），内置模块公开了一些常用的API给开发者，并且它们在Node进程开始的时候就预加载了。</li><li>另一类是用户编写的模块，称为<strong>文件模块</strong>。如通过NPM安装的第三方模块（third-party modules）或本地模块（local modules），每个模块都会暴露一个公开的API。以便开发者可以导入。如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mod &#x3D; require(&#39;module_name&#39;)</span><br><span class="line">const &#123; methodA &#125; &#x3D; require(&#39;module_name&#39;)</span><br></pre></td></tr></table></figure><p>执行后，Node内部会载入内置模块或通过NPM安装的模块。require函数会返回一个对象，该对象公开的API可能是函数、对象或者属性如函数、数组甚至任意类型的JS对象。</p><p>核心模块是Node源码在编译过程中编译进了二进制执行文件。在Node启动时这些模块就被加载进内存中，所以核心模块引入时省去了文件定位和编译执行两个步骤，并且在路径分析中优先判断，因此核心模块的加载速度是最快的。文件模块则是在运行时动态加载，速度比核心模块慢。</p><p>这里列下node模块的载入及缓存机制：</p><p>1、载入内置模块（A Core Module）</p><p>2、载入文件模块（A File Module）</p><p>3、载入文件目录模块（A Folder Module）</p><p>4、载入node_modules里的模块</p><p>5、自动缓存已载入模块</p><p><strong>1、载入内置模块</strong></p><p>Node的内置模块被编译为二进制形式，引用时直接使用名字而非文件路径。当第三方的模块和内置模块同名时，内置模块将覆盖第三方同名模块。因此命名时需要注意不要和内置模块同名。如获取一个http模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;)</span><br></pre></td></tr></table></figure><p>返回的http即是实现了HTTP功能Node的内置模块。</p><p><strong>2、载入文件模块</strong></p><p>绝对路径的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myMod &#x3D; require(&#39;&#x2F;home&#x2F;base&#x2F;my_mod&#39;)</span><br></pre></td></tr></table></figure><p>或相对路径的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myMod &#x3D; require(&#39;.&#x2F;my_mod&#39;)</span><br></pre></td></tr></table></figure><p>注意，这里忽略了扩展名<code>.js</code>，以下是对等的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myMod &#x3D; require(&#39;.&#x2F;my_mod&#39;)</span><br><span class="line">const myMod &#x3D; require(&#39;.&#x2F;my_mod.js&#39;)</span><br></pre></td></tr></table></figure><p><strong>3、载入文件目录模块</strong></p><p>可以直接require一个目录，假设有一个目录名为folder，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myMod &#x3D; require(&#39;.&#x2F;folder&#39;)</span><br></pre></td></tr></table></figure><p>此时，Node将搜索整个folder目录，Node会假设folder为一个包并试图找到包定义文件package.json。如果folder目录里没有包含<code>package.json</code>文件，Node会假设默认主文件为<code>index.js</code>，即会加载<code>index.js</code>。如果<code>index.js</code>也不存在， 那么加载将失败。</p><p><strong>4、载入node_modules里的模块</strong></p><p>如果模块名不是路径，也不是内置模块，Node将试图去当前目录的<code>node_modules</code>文件夹里搜索。如果当前目录的<code>node_modules</code>里没有找到，Node会从父目录的<code>node_modules</code>里搜索，这样递归下去直到根目录。</p><p><strong>5、自动缓存已载入模块</strong></p><p>对于已加载的模块Node会缓存下来，而不必每次都重新搜索。下面是一个示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modA.js</span><br><span class="line">console.log(&#39;模块modA开始加载...&#39;)</span><br><span class="line">exports &#x3D; function() &#123;</span><br><span class="line">    console.log(&#39;Hi&#39;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;模块modA加载完毕&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; init.js</span><br><span class="line">var mod1 &#x3D; require(&#39;.&#x2F;modA&#39;)</span><br><span class="line">var mod2 &#x3D; require(&#39;.&#x2F;modA&#39;)</span><br><span class="line">console.log(mod1 &#x3D;&#x3D;&#x3D; mod2)</span><br></pre></td></tr></table></figure><p>命令行<code>node init.js</code>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块modA开始加载...</span><br><span class="line">模块modA加载完毕</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>可以看到虽然require了两次，但modA.js仍然只执行了一次。mod1和mod2是相同的，即两个引用都指向了同一个模块对象。</p><p><strong>优先从缓存加载</strong></p><p>和浏览器会缓存静态js文件一样，Node也会对引入的模块进行缓存，不同的是，浏览器仅仅缓存文件，而nodejs缓存的是编译和执行后的对象（<strong>缓存内存</strong>） <code>require()</code>对相同模块的二次加载一律采用缓存优先的方式，这是第一优先级的，核心模块缓存检查先于文件模块的缓存检查。</p><p>基于这点：我们可以编写一个模块，用来记录长期存在的变量。例如：我可以编写一个记录接口访问数的模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let count &#x3D; &#123;&#125;; &#x2F;&#x2F; 因模块是封闭的，这里实际上借用了js闭包的概念</span><br><span class="line">exports.count &#x3D; function(name)&#123;</span><br><span class="line">    if(count[name])&#123;</span><br><span class="line">    count[name]++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    count[name] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(name + &#39;被访问了&#39; + count[name] + &#39;次。&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在路由的 <code>action</code> 或 <code>controller</code>里这样引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let count &#x3D; require(&#39;count&#39;);</span><br><span class="line"></span><br><span class="line">export.index &#x3D; function(req, res)&#123;</span><br><span class="line">    count(&#39;index&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上便完成了对接口调用数的统计，但这只是个demo，因为数据存储在内存，服务器重启后便会清空。真正的计数器一定是要结合持久化存储器的。</p><p>在进入路径查找之前有必要描述一下<code>module path</code>这个Node.js中的概念。对于每一个被加载的文件模块，创建这个模块对象的时候，这个模块便会有一个paths属性，其值根据当前文件的路径 计算得到。我们创建<code>modulepath.js</code>这样一个文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modulepath.js</span><br><span class="line">console.log(module.paths);</span><br></pre></td></tr></table></figure><p>我们将其放到任意一个目录中执行node modulepath.js命令，将得到以下的输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;&#x2F;home&#x2F;ikeepstudying&#x2F;research&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;home&#x2F;ikeepstudying&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;home&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;node_modules&#39; ]</span><br></pre></td></tr></table></figure><h3 id="10-2-2-文件定位"><a href="#10-2-2-文件定位" class="headerlink" title="10.2.2 文件定位"></a>10.2.2 文件定位</h3><p><strong>1.文件扩展名分析</strong></p><p>调用<code>require()</code>方法时若参数没有文件扩展名，Node会按<code>.js</code>、<code>.json</code>、<code>.node</code>的顺寻补足扩展名，依次尝试。</p><p>在尝试过程中，需要调用<strong>fs模块阻塞式</strong>地判断文件是否存在。因为Node的执行是单线程的，这是一个会引起性能问题的地方。如果是<code>.node</code>或者·.json·文件可以加上扩展名加快一点速度。另一个诀窍是：同步配合缓存。</p><p><strong>2.目录分析和包</strong></p><p><code>require()</code>分析文件扩展名后，可能没有查到对应文件，而是找到了一个目录，此时Node会将目录当作一个包来处理。</p><p>首先， Node在挡墙目录下查找<code>package.json</code>，通过<code>JSON.parse()</code>解析出包描述对象，从中取出main属性指定的文件名进行定位。若main属性指定文件名错误，或者没有<code>pachage.json</code>文件，Node会将index当作默认文件名。</p><p>简而言之，如果<code>require</code>绝对路径的文件，查找时不会去遍历每一个<code>node_modules</code>目录，其速度最快。其余流程如下：</p><p>1.从<code>module path</code>数组中取出第一个目录作为查找基准。</p><p>2.直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。</p><p>3.尝试添加<code>.js</code>、<code>.json</code>、<code>.node</code>后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</p><p>4.尝试将<code>require</code>的参数作为一个包来进行查找，读取目录下的<code>package.json</code>文件，取得<code>main</code>参数指定的文件。</p><p>5.尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。</p><p>6.如果继续失败，则取出<code>module path</code>数组中的下一个目录作为基准查找，循环第1至5个步骤。</p><p>7.如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。</p><p>8.如果仍然失败，则抛出异常。</p><p>整个查找过程十分类似原型链的查找和作用域的查找。所幸Node.js对路径查找实现了缓存机制，否则由于每次判断路径都是同步阻塞式进行，会导致严重的性能消耗。</p><p>一旦加载成功就以模块的路径进行缓存</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/25/16f38d1d79c552e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="10-2-3-模块编译"><a href="#10-2-3-模块编译" class="headerlink" title="10.2.3 模块编译"></a>10.2.3 模块编译</h3><p>每个模块文件模块都是一个对象，它的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.exports &#x3D; &#123;&#125;;</span><br><span class="line">    this.parent &#x3D; parent;</span><br><span class="line">    if(parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        parent.children.push(this);</span><br><span class="line">    &#125;</span><br><span class="line">    this.filename &#x3D; null;</span><br><span class="line">    this.loaded &#x3D; false;</span><br><span class="line">    this.children &#x3D; [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同扩展名，其载入方法也有所不同：</p><ul><li><code>.js</code>通过fs模块同步读取文件后编译执行。</li><li><code>.node</code>这是C/C++编写的扩展文件，通过<code>dlopen()</code>方法加载最后编译生成的文件</li><li><code>.json</code>同过fs模块同步读取文件后，用<code>JSON.pares()</code>解析返回结果</li></ul><p>其他当作<code>.js</code></p><p>每一个编译成功的模块都会将其文件路径作为索引缓存在<code>Module._cache</code>对象上。</p><p><strong><code>json</code> 文件的编译</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.json&#96;文件调用的方法如下:其实就是调用&#96;JSON.parse</span><br><span class="line">&#x2F;&#x2F; Native extension for .json</span><br><span class="line">Module._extensions[&#39;.json&#39;] &#x3D; function(module, filename) &#123;</span><br><span class="line">    var content &#x3D; NativeModule.require(&#39;fs&#39;).readFileSync(filename, &#39;utf-8&#39;);</span><br><span class="line">    try &#123;</span><br><span class="line">        module.exports &#x3D; JSON.parse(stripBOM(content));</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        err.message &#x3D; filename + &#39;：&#39; + err.message;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Module._extensions</code>会被赋值给<code>require()</code>的<code>extensions</code>属性，所以可以用:<code>console.log(require.extensions)</code>;输出系统中已有的扩展加载方式。 当然也可以自己增加一些特殊的加载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require.extensions[&#39;.txt&#39;] &#x3D; function()&#123;</span><br><span class="line">&#x2F;&#x2F; code</span><br><span class="line">&#125;;。</span><br></pre></td></tr></table></figure><p>但是官方不鼓励通过这种方式自定义扩展名加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样的好处在于不讲烦琐的编译加载等过程引入Node的执行过程。</p><p><strong><code>js</code>模块的编译</strong> 在编译的过程中，Node对获取的javascript文件内容进行了头尾包装，将文件内容包装在一个function中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    var math &#x3D; require(‘math‘);</span><br><span class="line">    exports.area &#x3D; function(radius) &#123;</span><br><span class="line">       return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>包装之后的代码会通过vm原生模块的<code>runInThisContext()</code>方法执行（具有明确上下文，不污染全局），返回一个具体的function对象，最后传参执行，执行后返回<code>module.exports</code>.</p><p><strong>核心模块编译</strong></p><p>核心模块分为<code>C/C++</code>编写和JavaScript编写的两个部分，其中<code>C/C++</code>文件放在Node项目的src目录下，JavaScript文件放在lib目录下。</p><p>1.转存为C/C++代码</p><p>Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码转换成C++里的数组，生成node_natives.h头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">namespace node &#123;</span><br><span class="line">    const char node_native[] &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    const char dgram_native[] &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    const char console_native &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    const char buffer_native &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    const char querystring_native &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    const char punycode_native &#x3D; &#123; 47, 47, ..&#125;;</span><br><span class="line">    ...</span><br><span class="line">    struct _native &#123;</span><br><span class="line">        const char* name;</span><br><span class="line">        const char* source;</span><br><span class="line">        size_t source_len;</span><br><span class="line">    &#125;</span><br><span class="line">    static const struct _native natives[] &#x3D; &#123;</span><br><span class="line">      &#123; &quot;node&quot;, node_native, sizeof(node_native)-1&#125;,</span><br><span class="line">      &#123; &quot;dgram&quot;, dgram_native, sizeof(dgram_native)-1&#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，<strong>JavaScript代码以字符串形式存储在node命名空间中,是不可直接执行的</strong>。在启动Node进程时，js代码直接加载到内存中。在加载的过程中，js核心模块经历标识符分析后直接定位到内存中。</p><p>2.编译js核心模块</p><p>lib目录下的模块文件也在引入过程中经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块的区别在于：获取源代码的方式（核心模块从内存加载）和缓存执行结果的位置。</p><p>js核心模块源文件通过<code>process.binding(&#39;natives&#39;)</code>取出，编译成功的模块缓存到<code>NativeModule._cache</code>上。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function NativeModule() &#123;</span><br><span class="line">    this.filename &#x3D; id + &#39;.js&#39;;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.exports &#x3D; &#123;&#125;;</span><br><span class="line">    this.loaded &#x3D; fales;</span><br><span class="line">&#125;</span><br><span class="line">NativeModule._source &#x3D; process.binding(&#39;natives&#39;);</span><br><span class="line">NativeModule._cache &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-import和require"><a href="#10-3-import和require" class="headerlink" title="10.3 import和require"></a>10.3 <code>import</code>和<code>require</code></h2><p>简单的说一下<code>import</code>和<code>require</code>的本质区别</p><p><code>import</code>是ES6的模块规范，<code>require</code>是commonjs的模块规范，详细的用法我不介绍，我只想说一下他们最基本的区别，<strong>import是静态加载模块，require是动态加载</strong>，那么静态加载和动态加载的区别是什么呢？</p><p>静态加载时代码在编译的时候已经执行了，动态加载是编译后在代码运行的时候再执行，那么具体点是什么呢？ 先说说import，如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; name &#125; from &#39;name.js&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; name.js文件</span><br><span class="line">export let name &#x3D; &#39;jinux&#39;</span><br><span class="line">export let age &#x3D; 20</span><br></pre></td></tr></table></figure><p>上面的代码表示<code>main.js</code>文件里引入了<code>name.js</code>文件导出的变量，在代码编译阶段执行后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; &#39;jinux&#39;</span><br></pre></td></tr></table></figure><p>这个是我自己理解的，其实就是直接把<code>name.js</code>里的代码放到了<code>main.js</code>文件里，好比是在<code>main.js</code>文件中声明一样。 再来看看require</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; require(&#39;obj.js&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj.js文件</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &#39;jinux&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">module.export obj;</span><br></pre></td></tr></table></figure><p>require是在运行阶段，需要把obj对象整个加载进内存，之后用到哪个变量就用哪个，这里再对比一下<code>import</code>，<code>import</code>是静态加载，如果只引入了name，age是不会引入的，所以是按需引入，性能更好一点。</p><h2 id="10-4-nodejs清除require缓存"><a href="#10-4-nodejs清除require缓存" class="headerlink" title="10.4 nodejs清除require缓存"></a>10.4 nodejs清除require缓存</h2><p>开发nodejs应用时会面临一个麻烦的事情，就是修改了配置数据之后，必须重启服务器才能看到修改后的结果。</p><p>于是问题来了，挖掘机哪家强？噢，no! no! no!怎么做到修改文件之后，自动重启服务器。</p><p><code>server.js</code>中的片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const port &#x3D; process.env.port || 1337;</span><br><span class="line">app.listen(port);</span><br><span class="line">console.log(&quot;server start in &quot; + port);</span><br><span class="line">exports.app &#x3D; app;</span><br></pre></td></tr></table></figure><p>假定我们现在是这样的, app.js的片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const app &#x3D; require(&#39;.&#x2F;server.js&#39;);</span><br></pre></td></tr></table></figure><p>如果我们在server.js中启动了服务器，我们停止服务器可以在app.js中调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.app.close()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是当我们重新引入server.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app &#x3D;  require(&#39;.&#x2F;server.js&#39;)</span><br></pre></td></tr></table></figure><p>的时候会发现并不是用的最新的server.js文件，原因是require的缓存机制，在第一次调用<code>require(&#39;./server.js&#39;)</code>的时候缓存下来了。</p><p>这个时候怎么办？</p><p>下面的代码解决了这个问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete require.cache[require.resolve(&#39;.&#x2F;server.js&#39;)];</span><br><span class="line">app &#x3D; require(&#39;.&#x2F;server.js&#39;);</span><br></pre></td></tr></table></figure><h1 id="11-require原理"><a href="#11-require原理" class="headerlink" title="11.require原理"></a>11.require原理</h1><p>2009年，<a href="http://nodejs.org/">Node.js</a> 项目诞生，所有模块一律为 <a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a> 格式。</p><p>时至今日，Node.js 的模块仓库 <a href="https://www.npmjs.com/">npmjs.com</a> ，已经存放了15万个模块，其中绝大部分都是 CommonJS 格式。</p><p>这种格式的核心就是 require 语句，模块通过它加载。学习 Node.js ，必学如何使用 require 语句。本文通过源码分析，详细介绍 require 语句的内部运行机制，帮你理解 Node.js 的模块机制。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015052001.png" alt="img"></p><h2 id="11-1-require-的基本用法"><a href="#11-1-require-的基本用法" class="headerlink" title="11.1 require() 的基本用法"></a>11.1 require() 的基本用法</h2><p>分析源码之前，先介绍 require 语句的内部逻辑。如果你只想了解 require 的用法，只看这一段就够了。</p><p>下面的内容翻译自<a href="https://nodejs.org/api/modules.html#modules_all_together">《Node使用手册》</a>。</p><blockquote><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p><p>（1）如果 X 是内置模块（比如 require(‘http’）)<br>　　a. 返回该模块。<br>　　b. 不再继续执行。</p><p>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p><blockquote><ul><li>X</li><li>X.js</li><li>X.json</li><li>X.node</li></ul></blockquote><p>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p><blockquote><ul><li>X/package.json（main字段）</li><li>X/index.js</li><li>X/index.json</li><li>X/index.node</li></ul></blockquote><p>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p><p>（4） 抛出 “not found”</p></blockquote><p>请看一个例子。</p><p>当前脚本文件 /home/ry/projects/foo.js 执行了 require(‘bar’) ，这属于上面的第三种情况。Node 内部运行过程如下。</p><p>首先，确定 x 的绝对路径可能是下面这些位置，依次搜索每一个目录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/ry/projects/node_modules/bar</span><br><span class="line">/home/ry/node_modules/bar</span><br><span class="line">/home/node_modules/bar</span><br><span class="line">/node_modules/bar</span><br></pre></td></tr></table></figure></blockquote><p>搜索时，Node 先将 bar 当成文件名，依次尝试加载下面这些文件，只要有一个成功就返回。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">bar.js</span><br><span class="line">bar.json</span><br><span class="line">bar.node</span><br></pre></td></tr></table></figure></blockquote><p>如果都不成功，说明 bar 可能是目录名，于是依次尝试加载下面这些文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar/package.json（main字段）</span><br><span class="line">bar/index.js</span><br><span class="line">bar/index.json</span><br><span class="line">bar/index.node</span><br></pre></td></tr></table></figure></blockquote><p>如果在所有目录中，都无法找到 bar 对应的文件或目录，就抛出一个错误。</p><h2 id="11-2-Module-构造函数"><a href="#11-2-Module-构造函数" class="headerlink" title="11.2 Module 构造函数"></a>11.2 Module 构造函数</h2><p>了解内部逻辑以后，下面就来看源码。</p><p>require 的源码在 Node 的 <a href="https://github.com/joyent/node/blob/master/lib/module.js">lib/module.js</a> 文件。为了便于理解，本文引用的源码是简化过的，并且删除了原作者的注释。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.parent = parent;</span><br><span class="line">  <span class="built_in">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.children = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Module;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。</p><p>每个实例都有自己的属性。下面通过一个例子，看看这些属性的值是什么。新建一个脚本文件 a.js 。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.id: &#x27;</span>, <span class="built_in">module</span>.id);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.exports: &#x27;</span>, <span class="built_in">module</span>.exports);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.parent: &#x27;</span>, <span class="built_in">module</span>.parent);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.filename: &#x27;</span>, <span class="built_in">module</span>.filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.loaded: &#x27;</span>, <span class="built_in">module</span>.loaded);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.children: &#x27;</span>, <span class="built_in">module</span>.children);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module.paths: &#x27;</span>, <span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure></blockquote><p>运行这个脚本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node a.js</span><br><span class="line"></span><br><span class="line">module.id:  .</span><br><span class="line">module.exports:  &#123;&#125;</span><br><span class="line">module.parent:  null</span><br><span class="line">module.filename:  /home/ruanyf/tmp/a.js</span><br><span class="line">module.loaded:  <span class="literal">false</span></span><br><span class="line">module.children:  []</span><br><span class="line">module.paths:  [ <span class="string">&#x27;/home/ruanyf/tmp/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/ruanyf/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/node_modules&#x27;</span> ]</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，如果没有父模块，直接调用当前模块，parent 属性就是 null，id 属性就是一个点。filename 属性是模块的绝对路径，path 属性是一个数组，包含了模块可能的位置。另外，输出这些内容时，模块还没有全部加载，所以 loaded 属性为 false 。</p><p>新建另一个脚本文件 b.js，让其调用 a.js 。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><p>运行 b.js 。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node b.js</span><br><span class="line"></span><br><span class="line">module.id:  /home/ruanyf/tmp/a.js</span><br><span class="line">module.exports:  &#123;&#125;</span><br><span class="line">module.parent:  &#123; object &#125;</span><br><span class="line">module.filename:  /home/ruanyf/tmp/a.js</span><br><span class="line">module.loaded:  <span class="literal">false</span></span><br><span class="line">module.children:  []</span><br><span class="line">module.paths:  [ <span class="string">&#x27;/home/ruanyf/tmp/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/ruanyf/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/node_modules&#x27;</span> ]</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，由于 a.js 被 b.js 调用，所以 parent 属性指向 b.js 模块，id 属性和 filename 属性一致，都是模块的绝对路径。</p><h2 id="11-3-模块实例的-require-方法"><a href="#11-3-模块实例的-require-方法" class="headerlink" title="11.3 模块实例的 require 方法"></a>11.3 模块实例的 require 方法</h2><p>每个模块实例都有一个 require 方法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>由此可知，require 并不是全局性命令，而是每个模块提供的一个内部方法，也就是说，只有在模块内部才能使用 require 命令（唯一的例外是 REPL 环境）。另外，require 其实内部调用 Module._load 方法。</p><p>下面来看 Module._load 的源码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  计算绝对路径</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  第一步：如果有缓存，取出缓存</span></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：是否为内置模块</span></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.exists(filename)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步：生成模块实例，存入缓存</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四步：加载模块</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.load(filename);</span><br><span class="line">    hadException = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hadException) &#123;</span><br><span class="line">      <span class="keyword">delete</span> Module._cache[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第五步：输出模块的exports属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，首先解析出模块的绝对路径（filename），以它作为模块的识别符。然后，如果模块已经在缓存中，就从缓存取出；如果不在缓存中，就加载模块。</p><p>因此，Module._load 的关键步骤是两个。</p><blockquote><ul><li>Module._resolveFilename() ：确定模块的绝对路径</li><li>module.load()：加载模块</li></ul></blockquote><h2 id="11-4-模块的绝对路径"><a href="#11-4-模块的绝对路径" class="headerlink" title="11.4 模块的绝对路径"></a>11.4 模块的绝对路径</h2><p>下面是 Module._resolveFilename 方法的源码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步：如果是内置模块，不含路径返回</span></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.exists(request)) &#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：确定所有可能的路径</span></span><br><span class="line">  <span class="keyword">var</span> resolvedModule = Module._resolveLookupPaths(request, parent);</span><br><span class="line">  <span class="keyword">var</span> id = resolvedModule[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> paths = resolvedModule[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三步：确定哪一个路径为真</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._findPath(request, paths);</span><br><span class="line">  <span class="keyword">if</span> (!filename) &#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Cannot find module &#x27;&quot;</span> + request + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    err.code = <span class="string">&#x27;MODULE_NOT_FOUND&#x27;</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filename;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，在 Module.*resolveFilename 方法内部，又调用了两个方法 Module.*resolveLookupPaths() 和 Module._findPath() ，前者用来列出可能的路径，后者用来确认哪一个路径为真。</p><p>为了简洁起见，这里只给出 Module._resolveLookupPaths() 的运行结果。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[   <span class="string">&#x27;/home/ruanyf/tmp/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/home/ruanyf/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/home/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span> </span><br><span class="line">    <span class="string">&#x27;/home/ruanyf/.node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/home/ruanyf/.node_libraries&#x27;</span>，</span><br><span class="line">     <span class="string">&#x27;$Prefix/lib/node&#x27;</span> ]</span><br></pre></td></tr></table></figure></blockquote><p>上面的数组，就是模块所有可能的路径。基本上是，从当前路径开始一级级向上寻找 node_modules 子目录。最后那三个路径，主要是为了历史原因保持兼容，实际上已经很少用了。</p><p>有了可能的路径以后，下面就是 Module._findPath() 的源码，用来确定到底哪一个是正确路径。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Module._findPath = <span class="function"><span class="keyword">function</span>(<span class="params">request, paths</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 列出所有可能的后缀名：.js，.json, .node</span></span><br><span class="line">  <span class="keyword">var</span> exts = <span class="built_in">Object</span>.keys(Module._extensions);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是绝对路径，就不再搜索</span></span><br><span class="line">  <span class="keyword">if</span> (request.charAt(<span class="number">0</span>) === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    paths = [<span class="string">&#x27;&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否有后缀的目录斜杠</span></span><br><span class="line">  <span class="keyword">var</span> trailingSlash = (request.slice(-<span class="number">1</span>) === <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一步：如果当前路径已在缓存中，就直接返回缓存</span></span><br><span class="line">  <span class="keyword">var</span> cacheKey = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">request</span>: request, <span class="attr">paths</span>: paths&#125;);</span><br><span class="line">  <span class="keyword">if</span> (Module._pathCache[cacheKey]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Module._pathCache[cacheKey];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步：依次遍历所有路径</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, PL = paths.length; i &lt; PL; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> basePath = path.resolve(paths[i], request);</span><br><span class="line">    <span class="keyword">var</span> filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!trailingSlash) &#123;</span><br><span class="line">      <span class="comment">// 第三步：是否存在该模块文件</span></span><br><span class="line">      filename = tryFile(basePath);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!filename &amp;&amp; !trailingSlash) &#123;</span><br><span class="line">        <span class="comment">// 第四步：该模块文件加上后缀名，是否存在</span></span><br><span class="line">        filename = tryExtensions(basePath, exts);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步：目录中是否存在 package.json </span></span><br><span class="line">    <span class="keyword">if</span> (!filename) &#123;</span><br><span class="line">      filename = tryPackage(basePath, exts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filename) &#123;</span><br><span class="line">      <span class="comment">// 第六步：是否存在目录名 + index + 后缀名 </span></span><br><span class="line">      filename = tryExtensions(path.resolve(basePath, <span class="string">&#x27;index&#x27;</span>), exts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第七步：将找到的文件路径存入返回缓存，然后返回</span></span><br><span class="line">    <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">      Module._pathCache[cacheKey] = filename;</span><br><span class="line">      <span class="keyword">return</span> filename;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第八步：没有找到文件，返回false </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>经过上面代码，就可以找到模块的绝对路径了。</p><p>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Module._resolveFilename(request, self);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">&#x27;a.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 返回 /home/ruanyf/tmp/a.js</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="11-5-加载模块"><a href="#11-5-加载模块" class="headerlink" title="11.5 加载模块"></a>11.5 加载模块</h2><p>有了模块的绝对路径，就可以加载该模块了。下面是 module.load 方法的源码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">&#x27;.js&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">&#x27;.js&#x27;</span>;</span><br><span class="line">  Module._extensions[extension](<span class="built_in">this</span>, filename);</span><br><span class="line">  <span class="built_in">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，首先确定模块的后缀名，不同的后缀名对应不同的加载方法。下面是 .js 和 .json 后缀名对应的处理方法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[<span class="string">&#x27;.js&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="built_in">module</span>._compile(stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Module._extensions[<span class="string">&#x27;.json&#x27;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">&#x27;: &#x27;</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>这里只讨论 js 文件的加载。首先，将模块文件读取成字符串，然后剥离 utf8 编码特有的BOM文件头，最后编译该模块。</p><p>module._compile 方法用于模块的编译。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [self.exports, <span class="built_in">require</span>, self, filename, dirname];</span><br><span class="line">  <span class="keyword">return</span> compiledWrapper.apply(self.exports, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码基本等同于下面的形式。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模块源码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><p>也就是说，模块的加载实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出。</p><h1 id="12-Node-js-事件循环"><a href="#12-Node-js-事件循环" class="headerlink" title="12.Node.js 事件循环"></a>12.Node.js 事件循环</h1><h2 id="前言-Node-事件循环"><a href="#前言-Node-事件循环" class="headerlink" title="前言 Node 事件循环"></a>前言 Node 事件循环</h2><p>翻译完了之后，才发现有官方翻译 ; 但是本文更加全面。本文是从官方文档和多篇文章整合而来。</p><p>看完本文之后，你会发现这里内容与《NodeJs 深入浅出》第三章第四节 3.4 非I/O异步API 中的内容不吻合。因为书上是有些内容是错误的。<br>还有一点的是，NodeJS 的事件循环与 Javascript 的略有不同。因此需要把两者区分开。</p><h2 id="12-1-什么是事件循环-What-is-the-Event-Loop"><a href="#12-1-什么是事件循环-What-is-the-Event-Loop" class="headerlink" title="12.1 什么是事件循环 (What is the Event Loop)?"></a>12.1 什么是事件循环 (What is the Event Loop)?</h2><p>事件循环使 Node.js 可以通过将操作转移到系统内核中来执行非阻塞 I/O 操作（尽管 JavaScript 是单线程的）。</p><p>由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。 当这些操作之一完成时，内核会告诉 Node.js，以便可以将适当的回调添加到轮询队列中以最终执行。 我们将在本文的后面对此进行详细说明。</p><h2 id="12-2-这就是事件循环-Event-Loop-Explained"><a href="#12-2-这就是事件循环-Event-Loop-Explained" class="headerlink" title="12.2 这就是事件循环 (Event Loop Explained)"></a>12.2 这就是事件循环 (Event Loop Explained)</h2><p>Node.js 启动时，它将初始化事件循环，处理提供的输入脚本（或放入 REPL，本文档未涵盖），这些脚本可能会进行异步 API 调用，调度计时器或调用 process.nextTick， 然后开始处理事件循环。</p><p>下图显示了事件循环操作顺序的简化概述。</p><p>   ┌───────────────────────────┐<br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │     pending callbacks     │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤  connections, │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │           check           │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br>每个阶段都有一个要执行的回调 FIFO 队列。 尽管每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行回调的最大数量为止。 当队列已为空或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p><p>由于这些操作中的任何一个都可能调度更多操作，并且在 poll阶段处理由内核排队的新事件 (比如 I/O 事件)，因此可以在处理 poll 事件时将 poll 事件排队。 最终导致的结果是，长时间运行的回调可使 poll 阶段运行的时间比 timer 的阈值长得多。 有关更多详细信息，请参见计时器 (timer) 和轮询 (poll) 部分。</p><p>注意：Windows 和 Unix / Linux 实现之间存在细微差异，但这对于本演示并不重要。 最重要的部分在这里。 实际上有七个或八个阶段，但是我们关心的那些（Node.js 实际使用的那些）是上面的阶段。</p><h2 id="12-3-各阶段概览-Phases-Overview"><a href="#12-3-各阶段概览-Phases-Overview" class="headerlink" title="12.3 各阶段概览 Phases Overview"></a>12.3 各阶段概览 Phases Overview</h2><ul><li>timers：此阶段执行由 setTimeout 和 setInterval 设置的回调。</li><li>pending callbacks：执行推迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare, ：仅在内部使用。</li><li>poll：取出新完成的 I/O 事件；执行与 I/O 相关的回调（除了关闭回调，计时器调度的回调和 setImmediate 之外，几乎所有这些回调） 适当时，node 将在此处阻塞。</li><li>check：在这里调用 setImmediate 回调。</li><li>close callbacks：一些关闭回调，例如 socket.on(‘close’, …)。<br>在每次事件循环运行之间，Node.js 会检查它是否正在等待任何异步 I/O 或 timers，如果没有，则将其干净地关闭。</li></ul><h2 id="12-4-各阶段详细解释-Phases-in-Detail"><a href="#12-4-各阶段详细解释-Phases-in-Detail" class="headerlink" title="12.4 各阶段详细解释 Phases in Detail"></a>12.4 各阶段详细解释 Phases in Detail</h2><h3 id="12-4-1-timers-计时器阶段"><a href="#12-4-1-timers-计时器阶段" class="headerlink" title="12.4.1 timers 计时器阶段"></a>12.4.1 timers 计时器阶段</h3><p>计时器可以在回调后面指定时间阈值，但这不是我们希望其执行的确切时间。 计时器回调将在经过指定的时间后尽早运行。 但是，操作系统调度或其他回调的运行可能会延迟它们。– 执行的实际时间不确定</p><p>注意：从技术上讲，轮询 (poll) 阶段控制计时器的执行时间。</p><p>例如，假设你计划在 100 毫秒后执行回调，然后脚本开始异步读取耗时 95 毫秒的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">function someAsyncOperation(callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; Assume this takes 95ms to complete</span><br><span class="line">  fs.readFile(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const timeoutScheduled &#x3D; Date.now();</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  const delay &#x3D; Date.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;$&#123;delay&#125;ms have passed since I was scheduled&#96;);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; do someAsyncOperation which takes 95 ms to complete</span><br><span class="line">someAsyncOperation(() &#x3D;&gt; &#123;</span><br><span class="line">  const startCallback &#x3D; Date.now();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; do something that will take 10ms...</span><br><span class="line">  while (Date.now() - startCallback &lt; 10) &#123;</span><br><span class="line">    &#x2F;&#x2F; do nothing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当事件循环进入 poll 阶段时，它有一个空队列（fs.readFile 尚未完成），因此它将等待直到达到最快的计时器 timer 阈值为止。 等待 95 ms 过去时，fs.readFile 完成读取文件，并将需要 10ms 完成的其回调添加到轮询 (poll) 队列并执行。 回调完成后，队列中不再有回调，此时事件循环已达到最早计时器 (timer) 的阈值 (100ms)，然后返回到计时器 (timer) 阶段以执行计时器的回调。 在此示例中，您将看到计划的计时器与执行的回调之间的总延迟为 105ms。</p><p>Note: To prevent the poll phase from starving the event loop, libuv (the C library that implements the Node.js event loop and all of the asynchronous behaviors of the platform) also has a hard maximum (system dependent) before it stops polling for more events.</p><p>注意：为防止轮询 poll 阶段使事件循环陷入饥饿状态 (一直等待 poll 事件)，libuv 还具有一个硬最大值限制来停止轮询。</p><h3 id="12-4-2-pending-callbacks-阶段"><a href="#12-4-2-pending-callbacks-阶段" class="headerlink" title="12.4.2 pending callbacks 阶段"></a>12.4.2 pending callbacks 阶段</h3><p>此阶段执行某些系统操作的回调，例如 TCP 错误。 举个例子，如果 TCP 套接字在尝试连接时收到 ECONNREFUSED，则某些 * nix 系统希望等待报告错误。 这将会在 pending callbacks 阶段排队执行。</p><h3 id="12-4-3-轮询-poll-阶段"><a href="#12-4-3-轮询-poll-阶段" class="headerlink" title="12.4.3 轮询 poll 阶段"></a>12.4.3 轮询 poll 阶段</h3><p>轮询阶段具有两个主要功能：</p><ul><li><p>计算应该阻塞并 I/O 轮询的时间</p></li><li><p>处理轮询队列 (poll queue) 中的事件<br>当事件循环进入轮询 (poll) 阶段并且没有任何计时器调度 (timers scheduled) 时，将发生以下两种情况之一：</p></li><li><p>如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，直到队列用尽或达到与系统相关的硬限制为止 (到底是哪些硬限制？)。</p></li><li><p>如果轮询队列为空，则会发生以下两种情况之一：<br>如果已通过 setImmediate 调度了脚本，则事件循环将结束轮询 poll 阶段，并继续执行 check 阶段以执行那些调度的脚本。<br>如果脚本并没有 setImmediate 设置回调，则事件循环将等待 poll 队列中的回调，然后立即执行它们。<br>一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 timer 已经到时间。 如果一个或多个计时器 timer 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调。</p></li></ul><h3 id="12-4-4-检查阶段-check"><a href="#12-4-4-检查阶段-check" class="headerlink" title="12.4.4 检查阶段 check"></a>12.4.4 检查阶段 check</h3><p>此阶段允许在轮询 poll 阶段完成后立即执行回调。 如果轮询 poll 阶段处于空闲，并且脚本已使用 setImmediate 进入 check 队列，则事件循环可能会进入 check 阶段，而不是在 poll 阶段等待。</p><p>setImmediate 实际上是一个特殊的计时器，它在事件循环的单独阶段运行。 它使用 libuv API，该 API 计划在轮询阶段完成后执行回调。</p><p>通常，在执行代码时，事件循环最终将到达轮询 poll 阶段，在该阶段它将等待传入的连接，请求等。但是，如果已使用 setImmediate 设置回调并且轮询阶段变为空闲，则它将将结束并进入 check 阶段，而不是等待轮询事件。</p><h3 id="12-4-5-close-callbacks-阶段"><a href="#12-4-5-close-callbacks-阶段" class="headerlink" title="12.4.5 close callbacks 阶段"></a>12.4.5 close callbacks 阶段</h3><p>如果套接字或句柄突然关闭（例如 socket.destroy），则在此阶段将发出 ‘close’ 事件。 否则它将通过 process.nextTick 发出。</p><h2 id="12-5-setImmediate-vs-setTimeout"><a href="#12-5-setImmediate-vs-setTimeout" class="headerlink" title="12.5 setImmediate vs setTimeout"></a>12.5 setImmediate vs setTimeout</h2><p>setImmediate 和 setTimeout 相似，但是根据调用时间的不同，它们的行为也不同。</p><ul><li>setImmediate 设计为在当前轮询 poll 阶段完成后执行脚本。</li><li>setTimeout 计划在以毫秒为单位的最小阈值过去之后运行脚本。<br>计时器的执行顺序将根据调用它们的上下文而有所不同。 如果两者都是主模块 (main module) 中调用的，则时序将受到进程性能的限制（这可能会受到计算机上运行的其他应用程序的影响）。有点难懂，举个例子：</li></ul><p>例如，如果我们运行以下不在 I/O 回调（即主模块）内的脚本，则两个计时器的执行顺序是不确定的，因为它受进程性能的约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; timeout_vs_immediate.js</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;timeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;immediate&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ node timeout_vs_immediate.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>但是，如果这两个调用在一个 I/O 回调中，那么 immediate 总是执行第一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; timeout_vs_immediate.js</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;timeout&#39;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;immediate&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>与 setTimeout 相比，使用 setImmediate 的主要优点是，如果在 I/O 周期内 setImmediate 总是比任何 timers 快。这个可以在下方彩色图中找到答案：poll 阶段用 setImmediate 设置下阶段 check 的回调，等到了 check 就开始执行；timers 阶段只能等到下次循环执行！</p><p>问题：那为什么在外部 (比如主代码部分 mainline) 这两者的执行顺序不确定呢？</p><p>解答：在 mainline 部分执行 setTimeout 设置定时器 (没有写入队列呦)，与 setImmediate 写入 check 队列。mainline 执行完开始事件循环，第一阶段是 timers，这时候 timers 队列可能为空，也可能有回调；如果没有那么执行 check 队列的回调，下一轮循环在检查并执行 timers 队列的回调；如果有就先执行 timers 的回调，再执行 check 阶段的回调。因此这是 timers 的不确定性导致的。</p><p>举一反三：timers 阶段写入 check 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;timeout&#39;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;immediate&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总是会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const ITERATIONS_MAX &#x3D; 2;</span><br><span class="line">let iteration &#x3D; 0;</span><br><span class="line"></span><br><span class="line">const timeout &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;TIME PHASE START:&#39; + iteration);</span><br><span class="line">    if (iteration &gt;&#x3D; ITERATIONS_MAX) &#123;</span><br><span class="line">        clearInterval(timeout);</span><br><span class="line">        console.log(&#39;TIME PHASE exceeded!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&#39;TIME PHASE END:&#39; + iteration);</span><br><span class="line"></span><br><span class="line">    ++iteration;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;TIME PHASE0&#39;);</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;TIME PHASE1&#39;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;TIME PHASE2&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TIME PHASE START:0</span><br><span class="line">TIME PHASE END:0</span><br><span class="line">TIME PHASE0</span><br><span class="line">TIME PHASE START:1</span><br><span class="line">TIME PHASE END:1</span><br><span class="line">TIME PHASE1</span><br><span class="line">TIME PHASE START:2</span><br><span class="line">TIME PHASE exceeded!</span><br><span class="line">TIME PHASE END:2</span><br><span class="line">TIME PHASE2</span><br></pre></td></tr></table></figure><p>这表明，可以理解 setInterval 是 setTimeout 的嵌套调用的语法糖。setInterval(() =&gt; {}, 0) 是在每一次事件循环中添加回调到 timers 队列。因此不会阻止事件循环的继续运行，在浏览器上也不会感到卡顿。</p><h2 id="12-6process-nextTick"><a href="#12-6process-nextTick" class="headerlink" title="12.6process.nextTick"></a>12.6process.nextTick</h2><h3 id="12-6-1-理解-process-nextTick"><a href="#12-6-1-理解-process-nextTick" class="headerlink" title="12.6.1 理解 process.nextTick"></a>12.6.1 理解 process.nextTick</h3><p>你可能已经注意到 process.nextTick 并未显示在图中，即使它是异步 API 的一部分也是如此。 这是因为 process.nextTick 从技术上讲不是事件循环的一部分。 相反，无论事件循环的当前阶段如何，都将在当前操作完成之后处理 nextTickQueue。 在此，将操作定义为在 C/C ++ 处理程序基础下过渡并处理需要执行的 JavaScript。</p><p>回顾一下我们的图，在给定阶段里可以在任意时间调用 process.nextTick，传递给 process.nextTick 的所有回调都将在事件循环继续之前得到解决。 这可能会导致一些不良情况，因为它允许您通过进行递归 process.nextTick 调用来让 I/O 处于 “饥饿” 状态，从而防止事件循环进入轮询 poll 阶段。</p><p>注意：Microtask callbacks 微服务</p><h3 id="12-6-2-为什么允许这样操作？-Why-would-that-be-allowed"><a href="#12-6-2-为什么允许这样操作？-Why-would-that-be-allowed" class="headerlink" title="12.6.2 为什么允许这样操作？ Why would that be allowed?"></a>12.6.2 为什么允许这样操作？ Why would that be allowed?</h3><p>为什么这样的东西会包含在 Node.js 中？ 它的一部分是一种设计理念，即使不是必须的情况下，API 也应始终是异步的。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function apiCall(arg, callback) &#123;</span><br><span class="line">  if (typeof arg !&#x3D;&#x3D; &#39;string&#39;)</span><br><span class="line">    return process.nextTick(callback,</span><br><span class="line">                            new TypeError(&#39;argument should be string&#39;));</span><br><span class="line">&#125;</span><br><span class="line">apiCall(1, e &#x3D;&gt; console.log(e));</span><br><span class="line">console.log(2);</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>该代码段会进行参数检查，如果不正确，则会将错误传递给回调。 该 API 最近进行了更新，以允许将参数传递给 process.nextTick，从而可以将回调后传递的所有参数都传播为回调的参数，因此您不必嵌套函数。</p><p>我们正在做的是将错误传递回用户，但只有在我们允许其余用户的代码执行之后。 通过使用 process.nextTick，我们保证 apiCall 始终在用户的其余代码之后以及事件循环继续下阶段之前运行其回调。 为此，允许 JS 调用堆栈展开，然后立即执行所提供的回调，该回调可以对 process.nextTick 进行递归调用，而不会达到 RangeError：v8 超出最大调用堆栈大小。</p><p>这种理念可能会导致某些潜在的问题情况。 以下代码段为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; this has an asynchronous signature, but calls callback synchronously</span><br><span class="line">function someAsyncApiCall(callback) &#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; the callback is called before &#96;someAsyncApiCall&#96; completes.</span><br><span class="line">someAsyncApiCall(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; since someAsyncApiCall has completed, bar hasn&#39;t been assigned any value</span><br><span class="line">  console.log(&#39;bar&#39;, bar); &#x2F;&#x2F; undefined</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar &#x3D; 1;</span><br></pre></td></tr></table></figure><p>用户将 someAsyncApiCall 定义为具有异步签名，但实际上它是同步运行的。 调用它时，提供给 someAsyncApiCall 的回调在事件循环的同一阶段被调用，因为 someAsyncApiCall 实际上并不异步执行任何操作。 结果，即使脚本可能尚未在范围内，该回调也会尝试引用 bar，因为该脚本无法运行完毕。</p><p>通过将回调放置在 process.nextTick 中，脚本仍具有运行完成的能力，允许在调用回调之前初始化所有变量，函数等。 它还具有不允许事件循环继续下个阶段的优点。 在允许事件循环继续之前，向用户发出错误提示可能很有用。 这是使用 process.nextTick 的先前示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let bar;</span><br><span class="line"></span><br><span class="line">function someAsyncApiCall(callback) &#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;bar&#39;, bar); &#x2F;&#x2F; 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar &#x3D; 1;</span><br></pre></td></tr></table></figure><p>这是另一个真实的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; net.createServer(() &#x3D;&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&#39;listening&#39;, () &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>仅通过端口时，该端口将立即绑定。 因此，可以立即调用 “监听” 回调。 问题在于那时尚未设置.on(‘listening’) 回调。</p><p>为了解决这个问题，”listening” 事件在 nextTick() 中排队，以允许脚本运行完成。 这允许用户设置他们想要的任何事件处理程序。</p><h3 id="12-6-3-process-nextTick-vs-setImmediate"><a href="#12-6-3-process-nextTick-vs-setImmediate" class="headerlink" title="12.6.3 process.nextTick vs setImmediate"></a>12.6.3 process.nextTick vs setImmediate</h3><p>他们的调用方式很相似，但是名称让人困惑。</p><ul><li>process.nextTick 在同一阶段立即触发</li><li>setImmediate fires on the following iteration or ‘tick’ of the event loop (在事件循环接下来的阶段迭代中执行 - check 阶段)。</li></ul><p>本质上，名称应互换。 process.nextTick 比 setImmediate 触发得更快，但由于历史原因，不太可能改变。 进行此切换将破坏 npm 上很大一部分软件包。 每天都会添加更多的新模块，这意味着我们每天都在等待，更多潜在的损坏发生。 尽管它们令人困惑，但名称本身不会改变。</p><p>我们建议开发人员在所有情况下都使用 setImmediate，因为这样更容易推理（并且代码与各种环境兼容，例如浏览器 JS。）- 但是如果理解底层原理，就不一样。</p><h3 id="12-6-4-为什么还用-process-nextTick？"><a href="#12-6-4-为什么还用-process-nextTick？" class="headerlink" title="12.6.4 为什么还用 process.nextTick？"></a>12.6.4 为什么还用 process.nextTick？</h3><ul><li>这里举出两个原因：</li><li>在事件循环继续之前下个阶段允许开发者处理错误，清理所有不必要的资源，或者重新尝试请求。<br>有时需要让回调在事件循环继续下个阶段之前运行 (At times it’s necessary to allow a callback to run after the call stack has unwound but before the event loop continues.)。</li></ul><p>简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; net.createServer();</span><br><span class="line">server.on(&#39;connection&#39;, (conn) &#x3D;&gt; &#123; &#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8080);</span><br><span class="line">server.on(&#39;listening&#39;, () &#x3D;&gt; &#123; &#125;); &#x2F;&#x2F; 设置监听回调</span><br></pre></td></tr></table></figure><p>假设 listen 在事件循环的开始处运行，但是侦听回调被放置在 setImmediate 中 (实际上 listen 使用 process.nextTick,.on 在本阶段完成)。 除非传递主机名，否则将立即绑定到端口。 为了使事件循环继续进行，它必须进入轮询 poll 阶段，这意味着存在已经接收到连接可能性，从而导致在侦听事件之前触发连接事件 (漏掉一些 poll 事件)。</p><p>另一个示例正在运行一个要从 EventEmitter 继承的函数构造函数，它想在构造函数中调用一个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line">  EventEmitter.call(this);</span><br><span class="line">  this.emit(&#39;event&#39;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;an event occurred!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你无法立即从构造函数中发出事件，因为脚本还没运行到开发者为该事件分配回调的那里 (指 myEmitter.on)。 因此，在构造函数本身内，你可以使用 process.nextTick 设置构造函数完成后发出事件的回调，从而提供预期的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">function MyEmitter() &#123;</span><br><span class="line">  EventEmitter.call(this);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; use nextTick to emit the event once a handler is assigned</span><br><span class="line">  process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    this.emit(&#39;event&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;an event occurred!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="12-6-5-process-nextTick-在事件循环的位置："><a href="#12-6-5-process-nextTick-在事件循环的位置：" class="headerlink" title="12.6.5 process.nextTick 在事件循环的位置："></a>12.6.5 process.nextTick 在事件循环的位置：</h3><p>来子一位外国小哥之手。链接在本文下面。</p><pre><code>       ┌───────────────────────────┐    ┌─&gt;│           timers          │    │  └─────────────┬─────────────┘    │           nextTickQueue    │  ┌─────────────┴─────────────┐    │  │     pending callbacks     │    │  └─────────────┬─────────────┘    │           nextTickQueue    │  ┌─────────────┴─────────────┐    |  |     idle, prepare         │    |  └─────────────┬─────────────┘</code></pre><p>  nextTickQueue     nextTickQueue<br>        |  ┌─────────────┴─────────────┐<br>        |  │           poll            │<br>        │  └─────────────┬─────────────┘<br>        │           nextTickQueue<br>        │  ┌─────────────┴─────────────┐<br>        │  │           check           │<br>        │  └─────────────┬─────────────┘<br>        │           nextTickQueue<br>        │  ┌─────────────┴─────────────┐<br>        └──┤       close callbacks     │<br>           └───────────────────────────┘<br>下图补充了官方并没有提及的 Microtasks 微任务:</p><p><img data-src="https://cdn.learnku.com/uploads/images/201912/27/20604/NclgxSvw3g.png!large" alt="img"></p><h2 id="12-7-Microtasks-微任务"><a href="#12-7-Microtasks-微任务" class="headerlink" title="12.7 Microtasks 微任务"></a>12.7 Microtasks 微任务</h2><p>微任务会在主线之后和事件循环的每个阶段之后立即执行。</p><p>如果您熟悉 JavaScript 事件循环，那么应该对微任务不陌生，这些微任务在 Node 中的工作方式相同。 如果你想重新了解事件循环和微任务队列，请查看此链接（这东西非常底层，慎点）。</p><p>在 Node 领域，微任务是来自以下对象的回调：</p><ul><li>process.nextTick()</li><li>then() handlers for resolved or rejected Promises</li></ul><p>在主线结束后以及事件循环的每个阶段之后，立即运行微任务回调。</p><p>resolved 的 promise.then 回调像微处理一样执行，就像 process.nextTick 一样。 虽然，如果两者都在同一个微任务队列中，则将首先执行 process.nextTick 的回调。</p><p>优先级 process.nextTick &gt; promise.then = queueMicrotask</p><p>下面例子完整演示了事件循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const logger &#x3D; require(&#39;..&#x2F;common&#x2F;logger&#39;);</span><br><span class="line">const ITERATIONS_MAX &#x3D; 2;</span><br><span class="line">let iteration &#x3D; 0;</span><br><span class="line">const start &#x3D; Date.now();</span><br><span class="line">const msleep &#x3D; (i) &#x3D;&gt; &#123;</span><br><span class="line">    for (let index &#x3D; 0; Date.now() - start &lt; i; index++) &#123;</span><br><span class="line">        &#x2F;&#x2F; do nonthing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Microtask callback runs AFTER mainline, even though the code is here</span><br><span class="line">    logger.info(&#39;Promise.resolve.then&#39;, &#39;MAINLINE MICROTASK&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">logger.info(&#39;START&#39;, &#39;MAINLINE&#39;);</span><br><span class="line">const timeout &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    logger.info(&#39;START iteration &#39; + iteration + &#39;: setInterval&#39;, &#39;TIMERS PHASE&#39;);</span><br><span class="line">    if (iteration &lt; ITERATIONS_MAX) &#123;</span><br><span class="line">        setTimeout((iteration) &#x3D;&gt; &#123;</span><br><span class="line">            logger.info(&#39;TIMER EXPIRED (from iteration &#39; + iteration + &#39;): setInterval.setTimeout&#39;, &#39;TIMERS PHASE&#39;);</span><br><span class="line">            Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">                logger.info(&#39;setInterval.setTimeout.Promise.resolve.then&#39;, &#39;TIMERS PHASE MICROTASK&#39;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, 0, iteration);</span><br><span class="line">        fs.readdir(__dirname, (err, files) &#x3D;&gt; &#123;</span><br><span class="line">            if (err) throw err;</span><br><span class="line">            logger.info(&#39;fs.readdir() callback: Directory contains: &#39; + files.length + &#39; files&#39;, &#39;POLL PHASE&#39;);</span><br><span class="line">            queueMicrotask(() &#x3D;&gt; logger.info(&#39;setInterval.fs.readdir.queueMicrotask&#39;, &#39;POLL PHASE MICROTASK&#39;));</span><br><span class="line">            Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">                logger.info(&#39;setInterval.fs.readdir.Promise.resolve.then&#39;, &#39;POLL PHASE MICROTASK&#39;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">            logger.info(&#39;setInterval.setImmediate&#39;, &#39;CHECK PHASE&#39;);</span><br><span class="line">            Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">                logger.info(&#39;setInterval.setTimeout.Promise.resolve.then&#39;, &#39;CHECK PHASE MICROTASK&#39;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; msleep(1000); &#x2F;&#x2F; 等待 I&#x2F;O 完成</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.info(&#39;Max interval count exceeded. Goodbye.&#39;, &#39;TIMERS PHASE&#39;);</span><br><span class="line">        clearInterval(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(&#39;END iteration &#39; + iteration + &#39;: setInterval&#39;, &#39;TIMERS PHASE&#39;);</span><br><span class="line">    iteration++;</span><br><span class="line">&#125;, 0);</span><br><span class="line">logger.info(&#39;END&#39;, &#39;MAINLINE&#39;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1577168519233:INFO: MAINLINE: START</span><br><span class="line">1577168519242:INFO: MAINLINE: END</span><br><span class="line">1577168519243:INFO: MAINLINE MICROTASK: Promise.resolve.then</span><br><span class="line"></span><br><span class="line"># 第一次</span><br><span class="line"></span><br><span class="line">1577168519243:INFO: TIMERS PHASE: START iteration 0: setInterval</span><br><span class="line">1577168519244:INFO: TIMERS PHASE: END iteration 0: setInterval</span><br><span class="line"></span><br><span class="line">## 到这里循环已经结束了</span><br><span class="line"></span><br><span class="line">## 这时候 timers 阶段为空, poll 阶段有新事件完成</span><br><span class="line"></span><br><span class="line">1577168519245:INFO: POLL PHASE: fs.readdir() callback: Directory contains: 2 files</span><br><span class="line">1577168519245:INFO: POLL PHASE MICROTASK: setInterval.fs.readdir.queueMicrotask</span><br><span class="line">1577168519245:INFO: POLL PHASE MICROTASK: setInterval.fs.readdir.Promise.resolve.then</span><br><span class="line"></span><br><span class="line">## 在 poll 阶段结束后马上处理微任务</span><br><span class="line"></span><br><span class="line">## poll 转 check 阶段执行 setImmediate 设置的回调</span><br><span class="line"></span><br><span class="line">1577168519245:INFO: CHECK PHASE: setInterval.setImmediate</span><br><span class="line">1577168519245:INFO: CHECK PHASE MICROTASK: setInterval.setTimeout.Promise.resolve.then</span><br><span class="line"></span><br><span class="line">## 开始新的循环, timers 队列不为空</span><br><span class="line"></span><br><span class="line">1577168519246:INFO: TIMERS PHASE: TIMER EXPIRED (from iteration 0): setInterval.setTimeout</span><br><span class="line">1577168519246:INFO: TIMERS PHASE MICROTASK: setInterval.setTimeout.Promise.resolve.then</span><br><span class="line"></span><br><span class="line"># 第二次</span><br><span class="line"></span><br><span class="line">1577168519246:INFO: TIMERS PHASE: START iteration 1: setInterval</span><br><span class="line">1577168519246:INFO: TIMERS PHASE: END iteration 1: setInterval</span><br><span class="line"></span><br><span class="line">1577168519246:INFO: CHECK PHASE: setInterval.setImmediate</span><br><span class="line">1577168519246:INFO: CHECK PHASE MICROTASK: setInterval.setTimeout.Promise.resolve.then</span><br><span class="line"></span><br><span class="line">1577168519246:INFO: POLL PHASE: fs.readdir() callback: Directory contains: 2 files</span><br><span class="line">1577168519253:INFO: POLL PHASE MICROTASK: setInterval.fs.readdir.queueMicrotask</span><br><span class="line">1577168519253:INFO: POLL PHASE MICROTASK: setInterval.fs.readdir.Promise.resolve.then</span><br><span class="line"></span><br><span class="line">1577168519253:INFO: TIMERS PHASE: TIMER EXPIRED (from iteration 1): setInterval.setTimeout</span><br><span class="line">1577168519253:INFO: TIMERS PHASE MICROTASK: setInterval.setTimeout.Promise.resolve.then</span><br><span class="line"></span><br><span class="line"># 第三次退出</span><br><span class="line"></span><br><span class="line">1577168519253:INFO: TIMERS PHASE: START iteration 2: setInterval</span><br><span class="line">1577168519253:INFO: TIMERS PHASE: Max interval count exceeded. Goodbye.</span><br><span class="line">1577168519253:INFO: TIMERS PHASE: END iteration 2: setInterval</span><br></pre></td></tr></table></figure><p>运行结果的顺序不固定，因为 fs.readdir 需要 I/O 系统调用，需要等待系统的调度，因此等待事件并不固定。</p><p>但是顺序仍然是有规律的：</p><ul><li>因为 setTimeout 和 setImmediate 在 timers 阶段 (不是 mainline 就行) 被调用，因此 setImmediate 总是比 setTimeout 快 (前面第 5 节已说明)</li><li>因为 poll 阶段等待系统调用的时间不确定。因此它会在上面两者之间插空，就是 3 种排序<br>poll check timers 这种可能比较少，取决于 I/O 调用速度与进程在当前 timers 阶段的处理时间 —— 也就是 I/O 的事件循环进入 poll 阶段前就已经完成，也就是 poll 队列不为空。把上面的 msleep 注释打开即可测试。<br>check poll timers 这种情况比较多出现。<br>check timers poll 这种情况也多。</li></ul><p>因此存在 3 种顺序。</p><p>本文下方链接包含更多例子</p><p>timers 阶段和 poll 阶段，因为依赖系统的调度，所以具体在哪一次事件循环执行？这是不确定的，有可能是下次循环就可以，也许需要等待。在上面彩色图的事件循环中黄色标记的阶段中，只剩下 check 阶段是确定的 —— 必然是在本次 (还没到本次循环的 check 阶段的话) 或者下次循环调用。还有的是，微服务是能够保证，必然在本阶段结束后下阶段前执行。</p><p>timers 不确定，poll 不确定，check 确定，Microtasks 确定。</p><h2 id="12-8题外话：Events"><a href="#12-8题外话：Events" class="headerlink" title="12.8题外话：Events"></a>12.8题外话：Events</h2><p>事件是应用程序中发生的重要事件。 诸如 Node 之类的事件驱动的运行时在某些地方发出事件，并在其他地方响应事件。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The Node EventEmitter</span><br><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">&#x2F;&#x2F; Create an instance of EventEmitter</span><br><span class="line">const eventEmitter &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The common logger</span><br><span class="line">const logger &#x3D; require(&#39;..&#x2F;common&#x2F;logger&#39;);</span><br><span class="line"></span><br><span class="line">logger.info(&#39;START&#39;, &#39;MAINLINE&#39;);</span><br><span class="line"></span><br><span class="line">logger.info(&#39;Registering simpleEvent handler&#39;, &#39;MAINLINE&#39;);</span><br><span class="line">eventEmitter.on(&#39;simpleEvent&#39;, (eventName, message, source, timestamp) &#x3D;&gt; &#123;</span><br><span class="line">logger.info(&#39;Received event: &#39; + timestamp + &#39;: &#39; + source + &#39;:[&#39; + eventName + &#39;]: &#39; + message, &#39;EventEmitter.on()&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Get the current time</span><br><span class="line">let hrtime &#x3D; process.hrtime();</span><br><span class="line">eventEmitter.emit(&#39;simpleEvent&#39;, &#39;simpleEvent&#39;, &#39;Custom event says what?&#39;, &#39;MAINLINE&#39;, (hrtime[0] * 1e9 + hrtime[1] ) &#x2F; 1e6);</span><br><span class="line"></span><br><span class="line">logger.info(&#39;END&#39;, &#39;MAINLINE&#39;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node example7</span><br><span class="line">1530379926998:INFO: MAINLINE: START</span><br><span class="line">1530379927000:INFO: MAINLINE: Registering simpleEvent handler</span><br><span class="line">1530379927000:INFO: EventEmitter.on(): Received event: 553491474.966337: MAINLINE:[simpleEvent]: Custom event says what?</span><br><span class="line">1530379927000:INFO: MAINLINE: END</span><br></pre></td></tr></table></figure><p>上面结果看出，Event 是同步，什么时候 emit 就什么时候执行回调。</p><h1 id="13-cluster原理"><a href="#13-cluster原理" class="headerlink" title="13.cluster原理"></a>13.<a href="https://www.cnblogs.com/dashnowords/p/10958457.html">cluster原理</a></h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><p><code>cluster</code>模块是<code>node.js</code>中用于实现和管理多进程的模块。常规的<code>node.js</code>应用程序是单线程单进程的，这也意味着它很难充分利用服务器多核CPU的性能，而<code>cluster</code>模块就是为了解决这个 问题的，它使得<code>node.js</code>程序可以以多个实例并存的方式运行在不同的进程中，以求更大地榨取服务器的性能。<code>node.js</code>在官方示例代码中使用<code>worker</code>实例来表示主进程fork出的子进程，使得前端开发者在学习过程中非常容易和浏览器环境中的<code>worker</code>实现的多线程混淆。为了容易区分，我们和<code>node</code>官方文档使用一致的名称，用集群中的<code>master</code>和<code>worker</code>来区分主进程和工作进程，用<code>worker_threads</code>来描述工作线程。</p><p><code>node.js</code>的主从模型中，<code>master</code>主进程相当于一个包工头，主管监听端口，而<code>slave</code>进程被用于实际的任务执行，当任务请求到达后，它会根据某种方式将连接循环分发给<code>worker</code>进程来处理。理论上，如果根据当前各个<code>worker</code>进程的负载状况或者相关信息来挑选工作进程，效率应该比直接循环发放要更高，但<code>node.js</code>文档中声明这种方式由于受到操作系统调度机制的影响，会使得分发变得不稳定，所以会将**”循环法”**作为默认的分发策略。</p><p>关于<code>cluster</code>模块的用法和<strong>API</strong>细节，可以直接参考官方文档<a href="http://nodejs.cn/api/cluster.html">《Node.js中文网V10.15.3/cluster》</a>。</p><h2 id="13-2-线程与进程"><a href="#13-2-线程与进程" class="headerlink" title="13.2 线程与进程"></a>13.2 线程与进程</h2><p>想要尽可能利用服务器性能，首先需要了解“线程”（thread）和“进程”（process）这两个概念。</p><p>计算机是由CPU来执行计算任务的，如果你只有一个CPU，那么这台机器上所有的任务都将由它来执行。它既可以按照串联执行的原则一个接一个执行任务，也可以依据并联原则同步执行多个任务，多个任务同步执行时，CPU会快速在多个线程之间进行切换，切换线程的同时要切换对应任务的上下文，这就会造成额外的CPU资源消耗，所以当线程数量非常多时，线程切换本身就会浪费大量的CPU资源。如果在执行一个任务的同时，CPU和内存都还有充足的剩余，就可以通过某种方式让它们去执行其他任务。</p><blockquote><p>你可以将“线程”看作是一种轻量级的“进程”。</p></blockquote><p>如果你在操作系统中打开任务管理器，在<code>进程</code>标签下就可以看到如下图的示例：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090434633-1515670765.png" alt="img"></p><p>我们可以看到每一个程序<strong>至少</strong>开辟一个新的进程（你可能瞬间就明白了chrome效率高的原因，我什么都没说），它是一种粒度更大的资源隔离单元，进程之间使用不同的内存区域，无法直接共享数据，只能通过跨进程通讯机制来通讯，而且由于要使用新的内存区域，它的创建销毁和切换相对而言都更耗时，它的好处就是进程之间是互相隔离的，互不影响，所以你可以一边听音乐一边玩游戏，而不会因为音乐软件里突然放了一首轻音乐，结果你游戏里的角色攻击力减半了。</p><p>再来看一下<code>性能</code>这个标签：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090447906-116651620.png" alt="img"></p><p>可以看到线程数是远大于进程数的。“线程”通常用来在单个“进程”中提高CPU的利用率，它是一种粒度更细的资源调度单位，它更容易创建和销毁，在同一个进程内的线程共享分配给这个进程的内存，所以也就实现了共享数据，多线程的编程要更加复杂，由于共享数据，如果线程之间传递指针然后操作同一数据源，就必须考虑“原子操作”和“锁”的问题，否则很容易就乱套了，如果传递数据的拷贝，又会造成内存浪费，另外线程异常不会被隔离，而会导致整个进程异常。</p><p>线程和进程的相关知识涉及到底层操作系统的内容，笔者涉猎有限，先分享这么多（会的都告诉你了，还要我怎样）。</p><h2 id="13-3-cluster模块源码解析"><a href="#13-3-cluster模块源码解析" class="headerlink" title="13.3 cluster模块源码解析"></a>13.3 cluster模块源码解析</h2><h3 id="13-3-1-起步"><a href="#13-3-1-起步" class="headerlink" title="13.3.1 起步"></a>13.3.1 起步</h3><p><code>cluster</code>模块的用法看起来并不复杂，官方给出的示例是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`主进程 <span class="subst">$&#123;process.pid&#125;</span> 正在运行`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 衍生工作进程。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`工作进程 <span class="subst">$&#123;worker.process.pid&#125;</span> 已退出`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 工作进程可以共享任何 TCP 连接。</span></span><br><span class="line">  <span class="comment">// 在本例子中，共享的是 HTTP 服务器。</span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">&#x27;你好世界\n&#x27;</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`工作进程 <span class="subst">$&#123;process.pid&#125;</span> 已启动`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3-2-入口"><a href="#13-3-2-入口" class="headerlink" title="13.3.2 入口"></a>13.3.2 入口</h3><p><code>cluster</code>模块的入口在<code>/lib/cluster.js</code>，这里的代码很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> childOrMaster = <span class="string">&#x27;NODE_UNIQUE_ID&#x27;</span> <span class="keyword">in</span> process.env ? <span class="string">&#x27;child&#x27;</span> : <span class="string">&#x27;master&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">`internal/cluster/<span class="subst">$&#123;childOrMaster&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>可以看到，如果进程对象的环境变量中有<code>NODE_UNIQUE_ID</code>这个变量，就透传<code>internal/cluster/child.js</code>模块的输出，否则就透传<code>internal/cluster/master.js</code>模块的输出。这是<code>node</code>的主进程在进行子进程管理时的标识，后面的代码中可以看到当调用<code>cluster.fork( )</code>生成一个子进程时会以一个自增ID的形式生成这个环境变量。</p><h3 id="13-3-3-主进程模块master-js"><a href="#13-3-3-主进程模块master-js" class="headerlink" title="13.3.3 主进程模块master.js"></a>13.3.3 主进程模块master.js</h3><p>首先运行<code>node</code>程序的肯定是主线程，那么我们从<code>master.js</code>这个模块开始，先用工具折叠一下代码浏览一下：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090509233-278998873.png" alt="img"></p><p>可以看到除了模块属性外，cluster模块对外暴露的方法只有下面3个，其他的都是用来完成内部功能的：</p><ul><li><code>setupMaster(options )</code>-修改<code>fork</code>时默认设置</li><li><code>fork( )</code>-生成子进程</li><li><code>disconnect( )</code>- 断开和所有子进程的连接</li></ul><p>我们按照官方示例的逻辑路线来阅读代码<code>cluster.fork( )</code>方法定义在161-217行，一样是用折叠工具来看全貌：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090521479-130930914.png" alt="img"></p><p>可以看到<code>cluster.fork( )</code>执行时做了如下几件事情：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>设置主线程参数</span><br><span class="line"><span class="number">2.</span>传入一个自增参数id(就是前文提到的NODE_UNIQUE_ID)和环境信息env来生成一个worker线程的process对象</span><br><span class="line"><span class="number">3.</span>将id和新的process对象传入Worker构造器生成新的worker进程实例</span><br><span class="line"><span class="number">4.</span>在子进程的process对象上添加了一些事件监听</span><br><span class="line"><span class="number">5.</span>在cluster.workers中以id为键添加对子进程的引用</span><br><span class="line"><span class="number">6.</span>返回子进程worker实例</span><br></pre></td></tr></table></figure><p>接着看第一步<code>setupMaster( )</code>，在源码中50-95行，着重看81-95行：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090532829-2120517530.png" alt="img"></p><p>留意一下主线程在进程层面监听的<code>internalMessage</code>事件非常关键，主进程监听到这个事件后，首先判断消息对象的cmd属性是否为<code>NODE_DEBUGE_ENABLED</code>，并以此为条件判断后续语句是否执行，后续的逻辑是遍历每一个<code>worker</code>进程实例，如果子进程的状态是<code>online</code>或<code>listening</code>就将子进程<strong>pid</strong>作为参数调用主进程的<code>_debugProcess( )</code>方法，否则改为在<code>worker</code>进程实例首次上线时调用。</p><p><code>process._debugProcess</code>的定义在<code>src/node_process_methods.cc</code>里，看名字推测大致的意思就是为了启用对子进程的调试功能。这是一个重载方法，在<strong>windows</strong>和<strong>linux</strong>下有不同的实现。<code>linux</code>下的代码较短，基本可以看懂（不秀一下怎么对得住自己看1周的C++）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __POSIX__</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DebugProcess</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的常量参数是通过地址引用的worker.process.pid</span></span><br><span class="line">  Environment* env = Environment::GetCurrent(args); </span><br><span class="line">    <span class="comment">//用pid做参数获取当前激活的环境变量，这一步应该是在获取上下文</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (args.Length() != <span class="number">1</span>) &#123;<span class="comment">//不合法调用时报错，没什么可说的</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;ThrowError(<span class="string">&quot;Invalid number of arguments.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  CHECK(args[<span class="number">0</span>]-&gt;IsNumber());<span class="comment">//检测参数</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = args[<span class="number">0</span>].As&lt;Integer&gt;()-&gt;Value();</span><br><span class="line">  <span class="keyword">int</span> r = kill(pid, SIGUSR1);<span class="comment">//发送SIGUSR1信号，终止了这个子进程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;<span class="comment">//exit code为0时是正常退出，子进程未能正常中止时报错</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;ThrowErrnoException(errno, <span class="string">&quot;kill&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>win32平台中对应的代码比较长，看不懂。总结一下这里就是，在没有收到<code>cmd</code>属性等于<code>NODE_DEBUG_ENABLED</code>的内部消息之前，什么都不做，如果收到这个消息，就<strong>终止所有的子进程，或者通过事件在子进程第一次处于online状态就终止它</strong>。</p><p>按照执行顺序接下来是101-140行的<code>createWorkerProcess(id,env)</code>方法，看名字就知道是生成子进程process对象的，前半部分合并和处理环境参数，然后判断运行参数中是否包含启用<code>--inspect</code>功能的参数并进行一些处理，最后传入一堆参数调用了<code>fork</code>方法，这个方法就是<code>child_process.fork( )</code>，它就是用来生成子进程的，返回值就是子进程实例，你可以先简单浏览一下API<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options">【官方文档child_process.fork功能】</a>，或者知道这里生成了子进程就好。</p><p>回到<code>cluster.fork</code>方法继续执行，下一步使用新生成的子进程process对象和唯一id作为参数传入Worker构造函数，生成<code>worker</code>实例,<code>Worker</code>的定义就在当前文件夹的<code>worker.js</code>中，它首先继承了<code>EventEmitter</code>的消息的发布订阅能力，然后把子进程的process对象挂在在自己的process属性上，接着为子进程添加<code>error</code>和 <code>message</code>事件的监听，最后暴露了一些更语义化的针对进程实例的管理方法（更详细的分析可以参考本系列前一篇博文）。生成了<code>worker</code>进程实例后，添加了对于<code>message</code>事件的响应，并在子进程<code>process</code>对象上监听进程的<code>exit</code>,<code>disconnect</code>,<code>internalMessage</code>事件，最后将worker实例和自己的id以键值对的形式添加到<code>cluster.workers</code>中记录，并通过<code>return</code>返回给外界，至此<code>master</code>模块的初始化流程就告一段落，先mark一下，后面还会讲这里。</p><h3 id="13-3-4-子进程模块child-js"><a href="#13-3-4-子进程模块child-js" class="headerlink" title="13.3.4 子进程模块child.js"></a>13.3.4 子进程模块child.js</h3><p>子进程模块是从<code>master.js</code>调用<code>child_process</code>时启动的，它和主进程是并行执行的。老规矩，代码折叠看一下：</p><p><img data-src="https://img2018.cnblogs.com/blog/1354575/201906/1354575-20190601090551857-551223998.png" alt="img"></p><p>看出什么了吗？<code>child.js</code>的代码里只有引用和定义，<code>_setupWorker</code>是在<code>nodejs</code>工作进程初始化时执行的，它在自己的独立进程中初始化了一个进程管理实例，并执行了下述逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实例化进程管理对象worker</span><br><span class="line"><span class="number">2.</span>全局添加<span class="string">`disconnect`</span>事件响应</span><br><span class="line"><span class="number">3.</span>全局添加<span class="string">`internalMessage`</span>事件响应，主要是分发<span class="string">`act:newconn`</span>和<span class="string">`act:disconnect`</span>事件</span><br><span class="line"><span class="number">4.</span>用send方法发送<span class="string">`online`</span>事件，通知主线程自己已上线。</span><br></pre></td></tr></table></figure><p>注意，这个<code>process</code>对象就是IPC(Inter Process Communication,也称为跨进程通讯)能够实现的关键，很明显它继承了<code>EventEmitter</code>的消息收发能力，在子进程内部进行消息收发不存在任何问题，还记得<code>master.js</code>中<code>fork</code>方法吗？这个process就是调用<code>child_process</code>启动子进程时返回给主进程的那个process对象，当你在主进程中获取它后，就可以共享worker进程的消息能力，从而在资源隔离的条件下实现<code>master</code>和<code>worker</code>进程的跨进程通讯。<code>_getServer( )</code>方法是在建立server实例时调用的，等到驱动事件信息到达<code>child.js</code>时再看，可以留意一下最后两个添加在<code>Worker</code>原型方法上的方法，它们只在子进程中有效。</p><h2 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结"></a>13.4 小结</h2><p>至此，你已经看到node是如何通过cluster模块实现多实例并初始化跨进程通讯了。但是跨进程通讯的底层实现以及服务器的建立，以及如何在进程间协调网络请求的处理，还依赖于<code>net</code>和<code>http</code>的一些内容，只好等研究完了再继续，硬刚反正我是吃不消的。</p><h1 id="14-流机制"><a href="#14-流机制" class="headerlink" title="14.流机制"></a>14.流机制</h1><p>相信很多人对 Node 的 Stream 已经不陌生了，不论是请求流、响应流、文件流还是 socket 流，这些流的底层都是使用 <code>stream</code> 模块封装的，甚至我们平时用的最多的 <code>console.log</code> 打印日志也使用了它，不信你打开 Node runtime 的源码，看看 <a href="https://github.com/nodejs/node/blob/master/lib/console.js#L82-L109"><code>lib/console.js</code></a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function write(ignoreErrors, stream, string, errorhandler) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  stream.once(&#39;error&#39;, noop);</span><br><span class="line">  stream.write(string, errorhandler);</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.prototype.log &#x3D; function log(...args) &#123;</span><br><span class="line">  write(this._ignoreErrors,</span><br><span class="line">        this._stdout,</span><br><span class="line">        &#96;$&#123;util.format.apply(null, args)&#125;\n&#96;,</span><br><span class="line">        this._stdoutErrorHandler);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Stream 模块做了很多事情，了解了 Stream，那么 Node 中其他很多模块理解起来就顺畅多了。</p><blockquote><p>本文代码和图片可以在这里取用：<a href="https://github.com/barretlee/dive-into-node-stream%E3%80%82">https://github.com/barretlee/dive-into-node-stream。</a></p></blockquote><h2 id="14-1-stream-模块"><a href="#14-1-stream-模块" class="headerlink" title="14.1 stream 模块"></a>14.1 stream 模块</h2><p>如果你了解 <a href="https://zh.wikipedia.org/zh-hans/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">生产者和消费者问题</a> 的解法，那理解 stream 就基本没有压力了，它不仅仅是资料的起点和落点，还包含了一系列状态控制，可以说一个 stream 就是一个状态管理单元。了解内部机制的最佳方式除了看 <a href="https://nodejs.org/api/stream.html">Node 官方文档</a>，还可以去看看 Node 的 <a href="https://github.com/nodejs/node/blob/master/lib/">源码</a>：</p><ul><li><code>lib/module.js</code></li><li><code>lib/_stream_readable.js</code></li><li><code>lib/_stream_writable.js</code></li><li><code>lib/_stream_tranform.js</code></li><li><code>lib/_stream_duplex.js</code></li></ul><p>把 <code>Readable</code> 和 <code>Writable</code> 看明白，Tranform 和 Duplex 就不难理解了。</p><h2 id="14-2-Readable-Stream"><a href="#14-2-Readable-Stream" class="headerlink" title="14.2 Readable Stream"></a>14.2 Readable Stream</h2><p>Readable Stream 存在两种模式，一种是叫做 <code>Flowing Mode</code>，流动模式，在 Stream 上绑定 ondata 方法就会自动触发这个模式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const readable &#x3D; getReadableStreamSomehow();</span><br><span class="line">readable.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Received $&#123;chunk.length&#125; bytes of data.&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个模式的流程图如下：</p><p><img data-src="http://www.barretlee.com/blogimgs/2017/06/06/node-stream-readable-flowing.png" alt="Flowing"></p><p>资源的数据流并不是直接流向消费者，而是先 push 到缓存池，缓存池有一个水位标记 <code>highWatermark</code>，超过这个标记阈值，push 的时候会返回 <code>false</code>，什么场景下会出现这种情况呢？</p><ul><li>消费者主动执行了 <code>.pause()</code></li><li>消费速度比数据 push 到缓存池的生产速度慢</li></ul><p>有个专有名词来形成这种情况，叫做「背压」，Writable Stream 也存在类似的情况。</p><p>流动模式，这个名词还是很形象的，缓存池就像一个水桶，消费者通过管口接水，同时，资源池就像一个水泵，不断地往水桶中泵水，而 highWaterMark 是水桶的浮标，达到阈值就停止蓄水。下面是一个简单的 Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const Readable &#x3D; require(&#39;stream&#39;).Readable;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Stream 实现</span><br><span class="line">class MyReadable extends Readable &#123;</span><br><span class="line">  constructor(dataSource, options) &#123;</span><br><span class="line">    super(options);</span><br><span class="line">    this.dataSource &#x3D; dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 继承了 Readable 的类必须实现这个函数</span><br><span class="line">  &#x2F;&#x2F; 触发系统底层对流的读取</span><br><span class="line">  _read() &#123;</span><br><span class="line">    const data &#x3D; this.dataSource.makeData();</span><br><span class="line">    this.push(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟资源池</span><br><span class="line">const dataSource &#x3D; &#123;</span><br><span class="line">  data: new Array(10).fill(&#39;-&#39;),</span><br><span class="line">  &#x2F;&#x2F; 每次读取时 pop 一个数据</span><br><span class="line">  makeData() &#123;</span><br><span class="line">    if (!dataSource.data.length) return null;</span><br><span class="line">    return dataSource.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const myReadable &#x3D; new MyReadable(dataSource);</span><br><span class="line">myReadable.setEncoding(&#39;utf8&#39;);</span><br><span class="line">myReadable.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外一种模式是 <code>Non-Flowing Mode</code>，没流动，也就是暂停模式，这是 Stream 的预设模式，Stream 实例的 <code>_readableState.flow</code> 有三个状态，分别是：</p><ul><li><code>_readableState.flow = null</code>，暂时没有消费者过来</li><li><code>_readableState.flow = false</code>，主动触发了 <code>.pause()</code></li><li><code>_readableState.flow = true</code>，流动模式</li></ul><p>当我们监听了 onreadable 事件后，会进入这种模式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myReadable &#x3D; new MyReadable(dataSource);</span><br><span class="line">myReadable.setEncoding(&#39;utf8&#39;);</span><br><span class="line">myReadable.on(&#39;readable&#39;, () &#x3D;&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>监听 <code>readable</code> 的回调函数第一个参数不会传递内容，需要我们通过 <code>myReadable.read()</code> 主动读取，为啥呢，可以看看下面这张图：</p><p><img data-src="http://www.barretlee.com/blogimgs/2017/06/06/node-stream-non-flowing.png" alt="node-stream-non-flowing"></p><p>资源池会不断地往缓存池输送数据，直到 highWaterMark 阈值，消费者监听了 readable 事件并不会消费数据，需要主动调用 <code>.read([size])</code> 函数才会从缓存池取出，并且可以带上 size 参数，用多少就取多少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myReadable &#x3D; new MyReadable(dataSource);</span><br><span class="line">myReadable.setEncoding(&#39;utf8&#39;);</span><br><span class="line">myReadable.on(&#39;readable&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  let chunk;</span><br><span class="line">  while (null !&#x3D;&#x3D; (chunk &#x3D; myReadable.read())) &#123;</span><br><span class="line">    console.log(&#96;Received $&#123;chunk.length&#125; bytes of data.&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里需要注意一点，只要数据达到缓存池都会触发一次 readable 事件，有可能出现「消费者正在消费数据的时候，又触发了一次 readable 事件，那么下次回调中 read 到的数据可能为空」的情况。我们可以通过 <code>_readableState.buffer</code> 来查看缓存池到底缓存了多少资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let once &#x3D; false;</span><br><span class="line">myReadable.on(&#39;readable&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(myReadable._readableState.buffer.length);</span><br><span class="line">  if (once) return;</span><br><span class="line">  once &#x3D; true;</span><br><span class="line">  console.log(myReadable.read());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码我们只消费一次缓存池的数据，那么在消费后，缓存池又收到了一次资源池的 push 操作，此时还会触发一次 readable 事件，我们可以看看这次存了多大的 buffer。</p><p>需要注意的是，buffer 大小也是有上限的，默认设置为 16kb，也就是 16384 个字节长度，它最大可设置为 8Mb，没记错的话，这个值好像是 Node 的 new space memory 的大小。</p><p>上面介绍了 Readable Stream 大概的机制，还有很多细节部分没有提到，比如 <code>Flowing Mode</code> 在不同 Node 版本中的 Stream 实现不太一样，实际上，它有三个版本，上面提到的是第 2 和 第 3 个版本的实现；再比如 <code>Mixins Mode</code> 模式，一般我们只推荐（允许）使用 ondata 和 onreadable 的一种来处理 Readable Stream，但是如果要求在 <code>Non-Flowing Mode</code> 的情况下使用 ondata 如何实现呢？那么就可以考虑 <code>Mixins Mode</code> 了。</p><h2 id="14-3-Writable-Stream"><a href="#14-3-Writable-Stream" class="headerlink" title="14.3 Writable Stream"></a>14.3 Writable Stream</h2><p>原理与 Readable Stream 是比较相似的，数据流过来的时候，会直接写入到资源池，当写入速度比较缓慢或者写入暂停时，数据流会进入队列池缓存起来，如下图所示：</p><p><img data-src="http://www.barretlee.com/blogimgs/2017/06/06/node-stream-writable.png" alt="node-stream-writable"></p><p>当生产者写入速度过快，把队列池装满了之后，就会出现「背压」，这个时候是需要告诉生产者暂停生产的，当队列释放之后，Writable Stream 会给生产者发送一个 <code>drain</code> 消息，让它恢复生产。下面是一个写入一百万条数据的 Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function writeOneMillionTimes(writer, data, encoding, callback) &#123;</span><br><span class="line">  let i &#x3D; 10000;</span><br><span class="line">  write();</span><br><span class="line">  function write() &#123;</span><br><span class="line">    let ok &#x3D; true;</span><br><span class="line">    while(i-- &gt; 0 &amp;&amp; ok) &#123;</span><br><span class="line">      &#x2F;&#x2F; 写入结束时回调</span><br><span class="line">      ok &#x3D; writer.write(data, encoding, i &#x3D;&#x3D;&#x3D; 0 ? callback : null);</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里提前停下了，&#39;drain&#39; 事件触发后才可以继续写入  </span><br><span class="line">      console.log(&#39;drain&#39;, i);</span><br><span class="line">      writer.once(&#39;drain&#39;, write);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造一个 Writable Stream，在写入到资源池的时候，我们稍作处理，让它效率低一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Writable &#x3D; require(&#39;stream&#39;).Writable;</span><br><span class="line">const writer &#x3D; new Writable(&#123;</span><br><span class="line">  write(chunk, encoding, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 比 process.nextTick() 稍慢</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      callback &amp;&amp; callback();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writeOneMillionTimes(writer, &#39;simple&#39;, &#39;utf8&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;end&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后执行的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drain 7268</span><br><span class="line">drain 4536</span><br><span class="line">drain 1804</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>说明程序遇到了三次「背压」，如果我们没有在上面绑定 <code>writer.once(&#39;drain&#39;)</code>，那么最后的结果就是 Stream 将第一次获取的数据消耗完变结束了程序。</p><h2 id="14-4-pipe"><a href="#14-4-pipe" class="headerlink" title="14.4 pipe"></a>14.4 pipe</h2><p>了解了 Readable 和 Writable，pipe 这个常用的函数应该就很好理解了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readable.pipe(writable);</span><br></pre></td></tr></table></figure><p>这句代码的语意性很强，readable 通过 pipe（管道）传输给 writable，pipe 的实现大致如下（伪代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe &#x3D; function(writable, options) &#123;</span><br><span class="line">  this.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">    let ok &#x3D; writable.write(chunk);</span><br><span class="line">true&#x2F;&#x2F; 背压，暂停</span><br><span class="line">    !ok &amp;&amp; this.pause();</span><br><span class="line">  &#125;);</span><br><span class="line">  writable.on(&#39;drain&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 恢复</span><br><span class="line">    this.resume();</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F; 告诉 writable 有流要导入</span><br><span class="line">  writable.emit(&#39;pipe&#39;, this);</span><br><span class="line">  &#x2F;&#x2F; 支持链式调用</span><br><span class="line">  return writable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面做了五件事情：</p><ul><li><code>emit(pipe)</code>，通知写入</li><li><code>.write()</code>，新数据过来，写入</li><li><code>.pause()</code>，消费者消费速度慢，暂停写入</li><li><code>.resume()</code>，消费者完成消费，继续写入</li><li><code>return writable</code>，支持链式调用</li></ul><p>当然，上面只是最简单的逻辑，还有很多异常和临界判断没有加入，具体可以去看看 Node 的代码（ <a href="https://github.com/nodejs/node/blob/master/lib/_stream_readable.js#L541-L684">/lib/_stream_readable.js</a>）。</p><h2 id="14-5-Duplex-Stream"><a href="#14-5-Duplex-Stream" class="headerlink" title="14.5 Duplex Stream"></a>14.5 Duplex Stream</h2><p>Duplex，双工的意思，它的输入和输出可以没有任何关系，</p><p><img data-src="http://www.barretlee.com/blogimgs/2017/06/06/node-stream-duplex.png" alt="Node-Stream-Duplex"></p><p>Duplex Stream 实现特别简单，不到一百行代码，它继承了 Readable Stream，并拥有 Writable Stream 的方法（<a href="https://github.com/nodejs/node/blob/master/lib/_stream_duplex.js#L31-L42">源码地址</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const Readable &#x3D; require(&#39;_stream_readable&#39;);</span><br><span class="line">const Writable &#x3D; require(&#39;_stream_writable&#39;);</span><br><span class="line"></span><br><span class="line">util.inherits(Duplex, Readable);</span><br><span class="line"></span><br><span class="line">var keys &#x3D; Object.keys(Writable.prototype);</span><br><span class="line">for (var v &#x3D; 0; v &lt; keys.length; v++) &#123;</span><br><span class="line">  var method &#x3D; keys[v];</span><br><span class="line">  if (!Duplex.prototype[method])</span><br><span class="line">    Duplex.prototype[method] &#x3D; Writable.prototype[method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 options 参数来配置它为只可读、只可写或者半工模式，一个简单的 Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Duplex &#x3D; require(&#39;stream&#39;).Duplex</span><br><span class="line"></span><br><span class="line">const duplex &#x3D; Duplex();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; readable</span><br><span class="line">let i &#x3D; 2;</span><br><span class="line">duplex._read &#x3D; function () &#123;</span><br><span class="line">  this.push(i-- ? &#39;read &#39; + i : null);</span><br><span class="line">&#125;;</span><br><span class="line">duplex.on(&#39;data&#39;, data &#x3D;&gt; console.log(data.toString()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; writable</span><br><span class="line">duplex._write &#x3D; function (chunk, encoding, callback) &#123;</span><br><span class="line">  console.log(chunk.toString());</span><br><span class="line">  callback();</span><br><span class="line">&#125;;</span><br><span class="line">duplex.write(&#39;write&#39;);</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write</span><br><span class="line">read 1</span><br><span class="line">read 0</span><br></pre></td></tr></table></figure><p>可以看出，两个管道是相互之间不干扰的。</p><h2 id="14-6-Transform-Stream"><a href="#14-6-Transform-Stream" class="headerlink" title="14.6 Transform Stream"></a>14.6 Transform Stream</h2><p>Transform Stream 集成了 Duplex Stream，它同样具备 Readable 和 Writable 的能力，只不过它的输入和输出是存在相互关联的，中间做了一次转换处理。常见的处理有 Gzip 压缩、解压等。</p><p><img data-src="http://www.barretlee.com/blogimgs/2017/06/06/node-stream-transform.png" alt="node-stream-transform"></p><p>Transform 的处理就是通过 <code>_transform</code> 函数将 Duplex 的 Readable 连接到 Writable，由于 Readable 的生产效率与 Writable 的消费效率是一样的，所以这里 Transform 内部不存在「背压」问题，背压问题的源头是外部的生产者和消费者速度差造成的。</p><p>关于 Transfrom Stream，我写了一个简单的 Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Transform &#x3D; require(&#39;stream&#39;).Transform;</span><br><span class="line">const MAP &#x3D; &#123;</span><br><span class="line">  &#39;Barret&#39;: &#39;靖&#39;,</span><br><span class="line">  &#39;Lee&#39;: &#39;李&#39;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">class Translate extends Transform &#123;</span><br><span class="line">  constructor(dataSource, options) &#123;</span><br><span class="line">    super(options);</span><br><span class="line">  &#125;</span><br><span class="line">  _transform(buf, enc, next) &#123;</span><br><span class="line">    const key &#x3D; buf.toString();</span><br><span class="line">    const data &#x3D; MAP[key];</span><br><span class="line">    this.push(data);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var transform &#x3D; new Translate();</span><br><span class="line">transform.on(&#39;data&#39;, data &#x3D;&gt; console.log(data.toString()));</span><br><span class="line">transform.write(&#39;Lee&#39;);</span><br><span class="line">transform.write(&#39;Barret&#39;);</span><br><span class="line">transform.end();</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要参考和查阅 Node 官网的文档和源码，细节问题都是从源码中找到的答案，如有理解不准确之处，还请斧正。关于 Stream，这篇文章只是讲述了基础的原理，还有很多细节之处没有讲到，要真正理解它，还是需要多读读文档，写写代码。</p><p>了解了这些 Stream 的内部机制，对我们后续深入理解上层代码有很大的促进作用，特别希望初学 Node 的同学花点时间进来看看。</p><p>另外，本文代码和图片可以在这里取用：<a href="https://github.com/barretlee/dive-into-node-stream%E3%80%82">https://github.com/barretlee/dive-into-node-stream。</a></p><h1 id="15-pipe原理"><a href="#15-pipe原理" class="headerlink" title="15.pipe原理"></a>15.pipe原理</h1><p>通过流我们可以将一大块数据拆分为一小部分一点一点的流动起来，而无需一次性全部读入，在 Linux 下我们可以通过 | 符号实现，类似的在 Nodejs 的 Stream 模块中同样也为我们提供了 pipe() 方法来实现。</p><h2 id="15-1-Nodejs-Stream-pipe-基本示例"><a href="#15-1-Nodejs-Stream-pipe-基本示例" class="headerlink" title="15.1 Nodejs Stream pipe 基本示例"></a><strong>15.1 Nodejs Stream pipe 基本示例</strong></h2><p>选择 Koa 来实现这个简单的 Demo，因为之前有人在 “Nodejs技术栈” 交流群问过一个问题，怎么在 Koa 中返回一个 Stream，顺便在下文借此机会提下。</p><h3 id="15-1-1-未使用-Stream-pipe-情况"><a href="#15-1-1-未使用-Stream-pipe-情况" class="headerlink" title="15.1.1 未使用 Stream pipe 情况"></a><strong>15.1.1 未使用 Stream pipe 情况</strong></h3><p>在 Nodejs 中 I/O 操作都是异步的，先用 util 模块的 promisify 方法将 fs.readFile 的 callback 形式转为 Promise 形式，这块代码看似没问题，但是它的体验不是很好，因为它是将数据一次性读入内存再进行的返回，当数据文件很大的时候也是对内存的一种消耗，因此不推荐它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ctx.body = <span class="keyword">await</span> readFile(resolve(__dirname, <span class="string">&#x27;test.json&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123; ctx.body = err &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h3 id="15-1-2-使用-Stream-pipe-情况"><a href="#15-1-2-使用-Stream-pipe-情况" class="headerlink" title="15.1.2 使用 Stream pipe 情况"></a><strong>15.1.2 使用 Stream pipe 情况</strong></h3><p>下面，再看看怎么通过 Stream 的方式在 Koa 框架中响应数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> readable = fs.createReadStream(resolve(__dirname, <span class="string">&#x27;test.json&#x27;</span>));</span><br><span class="line">    ctx.body = readable;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123; ctx.body = err &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上在 Koa 中直接创建一个可读流赋值给 ctx.body 就可以了，你可能疑惑了为什么没有 pipe 方法，因为框架给你封装好了，不要被表象所迷惑了，看下相关源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/koajs/koa/blob/master/lib/application.js#L256</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有神奇之处，框架在返回的时候做了层判断，因为 res 是一个可写流对象，如果 body 也是一个 Stream 对象（此时的 Body 是一个可读流），则使用 body.pipe(res) 以流的方式进行响应。</p><h3 id="15-1-3-使用-Stream-VS-不使用-Stream"><a href="#15-1-3-使用-Stream-VS-不使用-Stream" class="headerlink" title="15.1.3 使用 Stream VS 不使用 Stream"></a><strong>15.1.3 使用 Stream VS 不使用 Stream</strong></h3><p>使用流：</p><p><img data-src="https://images2015.cnblogs.com/blog/561179/201701/561179-20170126172845566-1089400487.gif" alt="img"></p><p>不适用流：</p><p><img data-src="https://images2015.cnblogs.com/blog/561179/201701/561179-20170126170225816-1851442511.gif" alt="img"></p><h2 id="15-2-pipe-的调用过程与实现原理分析"><a href="#15-2-pipe-的调用过程与实现原理分析" class="headerlink" title="15.2 pipe 的调用过程与实现原理分析"></a><strong>15.2 pipe 的调用过程与实现原理分析</strong></h2><p>以上最后以流的方式响应数据最核心的实现就是使用 pipe 方法来实现的输入、输出，本节的重点也是研究 pipe 的实现，最好的打开方式通过阅读源码实现吧。</p><h3 id="15-2-1-顺藤摸瓜"><a href="#15-2-1-顺藤摸瓜" class="headerlink" title="15.2.1 顺藤摸瓜"></a><strong>15.2.1 顺藤摸瓜</strong></h3><p>在应用层我们调用了 fs.createReadStream() 这个方法，顺藤摸瓜找到这个方法创建的可读流对象的 pipe 方法实现，以下仅列举核心代码实现，基于 Nodejs v12.x 源码。</p><h4 id="15-2-1-1-lib-fs-js"><a href="#15-2-1-1-lib-fs-js" class="headerlink" title="15.2.1.1 /lib/fs.js"></a><strong>15.2.1.1 /lib/fs.js</strong></h4><p>导出一个 createReadStream 方法，在这个方法里面创建了一个 ReadStream 可读流对象，且 ReadStream 来自 internal/fs/streams 文件，继续向下找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/v12.x/lib/fs.js</span></span><br><span class="line"><span class="comment">// 懒加载，主要在用到的时候用来实例化 ReadStream、WriteStream ... 等对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadStreams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReadStream) &#123;</span><br><span class="line">    (&#123; ReadStream, WriteStream &#125; = <span class="built_in">require</span>(<span class="string">&#x27;internal/fs/streams&#x27;</span>));</span><br><span class="line">    [ FileReadStream, FileWriteStream ] = [ ReadStream, WriteStream ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReadStream</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  lazyLoadStreams();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path, options); <span class="comment">// 创建一个可读流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs = &#123;</span><br><span class="line">  createReadStream, <span class="comment">// 导出 createReadStream 方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-1-2-lib-internal-fs-streams-js"><a href="#15-2-1-2-lib-internal-fs-streams-js" class="headerlink" title="15.2.1.2 /lib/internal/fs/streams.js"></a><strong>15.2.1.2 /lib/internal/fs/streams.js</strong></h4><p>这个方法里定义了构造函数 ReadStream，且在原型上定义了 open、_read、_destroy 等方法，并没有我们要找的 pipe 方法。</p><p>但是呢<strong>通过 ObjectSetPrototypeOf 方法实现了继承，ReadStream 继承了 Readable 在原型中定义的函数，接下来继续查找 Readable 的实现</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/v12.x/lib/internal/fs/streams.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; Readable, Writable &#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> ReadStream))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path, options);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  Readable.call(<span class="built_in">this</span>, options);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(ReadStream.prototype, Readable.prototype);</span><br><span class="line">ObjectSetPrototypeOf(ReadStream, Readable);</span><br><span class="line"></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">ReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123; ... &#125;;;</span><br><span class="line"></span><br><span class="line">ReadStream.prototype._destroy = <span class="function"><span class="keyword">function</span>(<span class="params">err, cb</span>) </span>&#123; ... &#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ReadStream,</span><br><span class="line">  WriteStream</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="15-2-1-3-lib-stream-js"><a href="#15-2-1-3-lib-stream-js" class="headerlink" title="15.2.1.3 /lib/stream.js"></a><strong>15.2.1.3 /lib/stream.js</strong></h4><p>在 stream.js 的实现中，有条注释：**在 Readable/Writable/Duplex/… 之前导入 Stream，原因是为了避免 cross-reference(require)**，为什么会这样？</p><p>第一步 stream.js 这里将 require(‘internal/streams/legacy’) 导出复制给了 Stream。</p><p>在之后的 _stream_readable、Writable、Duplex … 模块也会反过来引用 stream.js 文件，具体实现下面会看到。</p><p>Stream 导入了 internal/streams/legacy</p><p><strong>上面 /lib/internal/fs/streams.js 文件从 stream 模块获取了一个 Readable 对象，就是下面的 Stream.Readable 的定义。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/v12.x/lib/stream.js</span></span><br><span class="line"><span class="comment">// Note: export Stream before Readable/Writable/Duplex/...</span></span><br><span class="line"><span class="comment">// to avoid a cross-reference(require) issues</span></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">&#x27;internal/streams/legacy&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Stream.Readable = <span class="built_in">require</span>(<span class="string">&#x27;_stream_readable&#x27;</span>);</span><br><span class="line">Stream.Writable = <span class="built_in">require</span>(<span class="string">&#x27;_stream_writable&#x27;</span>);</span><br><span class="line">Stream.Duplex = <span class="built_in">require</span>(<span class="string">&#x27;_stream_duplex&#x27;</span>);</span><br><span class="line">Stream.Transform = <span class="built_in">require</span>(<span class="string">&#x27;_stream_transform&#x27;</span>);</span><br><span class="line">Stream.PassThrough = <span class="built_in">require</span>(<span class="string">&#x27;_stream_passthrough&#x27;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="15-2-1-4-lib-internal-streams-legacy-js"><a href="#15-2-1-4-lib-internal-streams-legacy-js" class="headerlink" title="15.2.1.4 /lib/internal/streams/legacy.js"></a><strong>15.2.1.4 /lib/internal/streams/legacy.js</strong></h4><p>上面的 Stream 等于 internal/streams/legacy，首先继承了 Events 模块，之后呢在原型上定义了 pipe 方法，刚开始看到这里的时候以为实现是在这里了，但后来看 _stream_readable 的实现之后，发现 _stream_readable 继承了 Stream 之后自己又重新实现了 pipe 方法，那么疑问来了这个模块的 pipe 方法是干嘛的？什么时候会被用？翻译文件名 “legacy=遗留”？有点没太理解，难道是遗留了？有清楚的大佬可以指点下，也欢迎在公众号 “Nodejs技术栈” 后台加我微信一块讨论下！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/nodejs/node/blob/v12.x/lib/internal/streams/legacy.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  ObjectSetPrototypeOf,</span><br><span class="line">&#125; = primordials;</span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  EE.call(<span class="built_in">this</span>, opts);</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype, EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream, EE);</span><br><span class="line"></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Stream;</span><br></pre></td></tr></table></figure><h4 id="15-2-1-5-lib-stream-readable-js"><a href="#15-2-1-5-lib-stream-readable-js" class="headerlink" title="15.2.1.5 /lib/_stream_readable.js"></a><strong>15.2.1.5 /lib/_stream_readable.js</strong></h4><p>在 _stream_readable.js 的实现里面定义了 Readable 构造函数，且继承于 Stream，这个 Stream 正是我们上面提到的 /lib/stream.js 文件，而在 /lib/stream.js 文件里加载了 internal/streams/legacy 文件且重写了里面定义的 pipe 方法。</p><p>经过上面一系列的分析，终于找到可读流的 pipe 在哪里，同时也更进一步的认识到了在创建一个可读流时的执行调用过程，下面将重点来看这个方法的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = Readable;</span><br><span class="line">Readable.ReadableState = ReadableState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Readable, Stream);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Readable</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Readable))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Readable(options);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  Stream.call(<span class="built_in">this</span>, options); <span class="comment">// 继承自 Stream 构造函数的定义</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="15-2-2-stream-readable-实现分析"><a href="#15-2-2-stream-readable-实现分析" class="headerlink" title="15.2.2 _stream_readable 实现分析"></a><strong>15.2.2 _stream_readable 实现分析</strong></h3><h4 id="15-2-2-1-声明构造函数-Readable"><a href="#15-2-2-1-声明构造函数-Readable" class="headerlink" title="15.2.2.1 声明构造函数 Readable"></a><strong>15.2.2.1 声明构造函数 Readable</strong></h4><p>声明构造函数 Readable 继承 Stream 的构造函数和原型。</p><p>Stream 是 /lib/stream.js 文件，上面分析了，这个文件继承了 events 事件，此时也就拥有了 events 在原型中定义的属性，例如 on、emit 等方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line">ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Readable, Stream);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Readable</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Readable))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Readable(options);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Stream.call(<span class="built_in">this</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-2-声明-pipe-方法，订阅-data-事件"><a href="#15-2-2-2-声明-pipe-方法，订阅-data-事件" class="headerlink" title="15.2.2.2 声明 pipe 方法，订阅 data 事件"></a><strong>15.2.2.2 声明 pipe 方法，订阅 data 事件</strong></h4><p>在 Stream 的原型上声明 pipe 方法，订阅 data 事件，src 为可读流对象，dest 为可写流对象。</p><p>我们在使用 pipe 方法的时候也是监听的 data 事件，一边读取数据一边写入数据。</p><p>看下 ondata() 方法里的几个核心实现：</p><ul><li><strong>dest.write(chunk)**：接收 chunk 写入数据，如果内部的缓冲小于创建流时配置的 highWaterMark，则返回 true，否则</strong>返回 false 时应该停止向流写入数据，直到 ‘drain’ 事件被触发**。</li><li>**src.pause()**：可读流会停止 data 事件，意味着此时暂停数据写入了。</li></ul><p>之所以<strong>调用 src.pause() 是为了防止读入数据过快来不及写入</strong>，什么时候知道来不及写入呢，要看 dest.write(chunk) 什么时候返回 false，是根据创建流时传的 highWaterMark 属性，默认为 16384 (16kb)，对象模式的流默认为 16。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> src = <span class="built_in">this</span>;</span><br><span class="line">  src.on(<span class="string">&#x27;data&#x27;</span>, ondata);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">    <span class="keyword">if</span> (ret === <span class="literal">false</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      src.pause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-3-订阅-drain-事件，继续流动数据"><a href="#15-2-2-3-订阅-drain-事件，继续流动数据" class="headerlink" title="15.2.2.3 订阅 drain 事件，继续流动数据"></a><strong>15.2.2.3 订阅 drain 事件，继续流动数据</strong></h4><p>上面提到在 data 事件里，如果调用 dest.write(chunk) 返回 false，就会调用 src.pause() 停止数据流动，什么时候再次开启呢？</p><p>如果说可以继续写入事件到流时会触发 drain 事件，也是在 dest.write(chunk) 等于 false 时，如果 ondrain 不存在则注册 drain 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> src = <span class="built_in">this</span>;</span><br><span class="line">  src.on(<span class="string">&#x27;data&#x27;</span>, ondata);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">    <span class="keyword">if</span> (ret === <span class="literal">false</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (!ondrain) &#123;</span><br><span class="line">        <span class="comment">// When the dest drains, it reduces the awaitDrain counter</span></span><br><span class="line">        <span class="comment">// on the source.  This would be more elegant with a .once()</span></span><br><span class="line">        <span class="comment">// handler in flow(), but adding and removing repeatedly is</span></span><br><span class="line">        <span class="comment">// too slow.</span></span><br><span class="line">        ondrain = pipeOnDrain(src);</span><br><span class="line">        dest.on(<span class="string">&#x27;drain&#x27;</span>, ondrain);</span><br><span class="line">      &#125;</span><br><span class="line">      src.pause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当可写入流 dest 耗尽时，它将会在可读流对象 source 上减少 awaitDrain 计数器</span></span><br><span class="line"><span class="comment">// 为了确保所有需要缓冲的写入都完成，即 state.awaitDrain === 0 和 src 可读流上的 data 事件存在，切换流到流动模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrainFunctionResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> state = src._readableState;</span><br><span class="line">    debug(<span class="string">&#x27;pipeOnDrain&#x27;</span>, state.awaitDrain);</span><br><span class="line">    <span class="keyword">if</span> (state.awaitDrain)</span><br><span class="line">      state.awaitDrain--;</span><br><span class="line">    <span class="keyword">if</span> (state.awaitDrain === <span class="number">0</span> &amp;&amp; EE.listenerCount(src, <span class="string">&#x27;data&#x27;</span>)) &#123;</span><br><span class="line">      state.flowing = <span class="literal">true</span>;</span><br><span class="line">      flow(src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stream.read() 从内部缓冲拉取并返回数据。如果没有可读的数据，则返回 null。在可读流上 src 还有一个 readable 属性，如果可以安全地调用 readable.read()，则为 true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = stream._readableState;</span><br><span class="line">  debug(<span class="string">&#x27;flow&#x27;</span>, state.flowing);</span><br><span class="line">  <span class="keyword">while</span> (state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-4-触发-data-事件"><a href="#15-2-2-4-触发-data-事件" class="headerlink" title="15.2.2.4 触发 data 事件"></a><strong>15.2.2.4 触发 data 事件</strong></h4><p>调用 readable 的 resume() 方法，触发可读流的 ‘data’ 事件，进入流动模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> src = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// Start the flow if it hasn&#x27;t been started already.</span></span><br><span class="line">  <span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">&#x27;pipe resume&#x27;</span>);</span><br><span class="line">    src.resume();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>然后实例上的 resume（Readable 原型上定义的）会在调用 resume() 方法，在该方法内部又调用了 resume_()，最终执行了 stream.read(0) 读取了一次空数据（size 设置的为 0），将会触发实例上的 _read() 方法，之后会在触发 data 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params">stream, state</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  process.nextTick(resume_, stream, state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_</span>(<span class="params">stream, state</span>) </span>&#123;</span><br><span class="line">  debug(<span class="string">&#x27;resume&#x27;</span>, state.reading);</span><br><span class="line">  <span class="keyword">if</span> (!state.reading) &#123;</span><br><span class="line">    stream.read(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-5-订阅-end-事件"><a href="#15-2-2-5-订阅-end-事件" class="headerlink" title="15.2.2.5 订阅 end 事件"></a><strong>15.2.2.5 订阅 end 事件</strong></h4><p>end 事件：当可读流中没有数据可供消费时触发，调用 onend 函数，执行 dest.end() 方法，表明已没有数据要被写入可写流，进行关闭（关闭可写流的 fd），之后再调用 stream.write() 会导致错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp;</span><br><span class="line">              dest !== process.stdout &amp;&amp;</span><br><span class="line">              dest !== process.stderr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> endFn = doEnd ? onend : unpipe;</span><br><span class="line">  <span class="keyword">if</span> (state.endEmitted)</span><br><span class="line">    process.nextTick(endFn);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    src.once(<span class="string">&#x27;end&#x27;</span>, endFn);</span><br><span class="line"></span><br><span class="line">  dest.on(<span class="string">&#x27;unpipe&#x27;</span>, onunpipe);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    debug(<span class="string">&#x27;onend&#x27;</span>);</span><br><span class="line">    dest.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-2-2-6-触发-pipe-事件"><a href="#15-2-2-6-触发-pipe-事件" class="headerlink" title="15.2.2.6 触发 pipe 事件"></a><strong>15.2.2.6 触发 pipe 事件</strong></h4><p>在 pipe 方法里面最后还会触发一个 pipe 事件，传入可读流对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> source = <span class="built_in">this</span>;</span><br><span class="line">  dest.emit(<span class="string">&#x27;pipe&#x27;</span>, src);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在应用层使用的时候可以在可写流上订阅 pipe 事件，做一些判断，具体可参考官网给的这个示例 stream_event_pipe</p><h4 id="15-2-2-7-支持链式调用"><a href="#15-2-2-7-支持链式调用" class="headerlink" title="15.2.2.7 支持链式调用"></a><strong>15.2.2.7 支持链式调用</strong></h4><p>最后返回 dest，支持类似 unix 的用法：A.pipe(B).pipe(C)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-3-总结"><a href="#15-3-总结" class="headerlink" title="15.3 总结"></a><strong>15.3 总结</strong></h2><p>本文总体分为两部分：</p><ul><li>第一部分相对较基础，讲解了 Nodejs Stream 的 pipe 方法在 Koa2 中是怎么去应用的。</li><li>第二部分仍以 Nodejs Stream pipe 方法为题，查找它的实现，以及对源码的一个简单分析，其实 pipe 方法核心还是要去监听 data 事件，向可写流写入数据，如果内部缓冲大于创建流时配置的 highWaterMark，则要停止数据流动，直到 drain 事件触发或者结束，当然还要监听 end、error 等事件做一些处理。</li></ul><h2 id="15-4-Reference"><a href="#15-4-Reference" class="headerlink" title="15.4 Reference"></a><strong>15.4 Reference</strong></h2><ul><li>nodejs.cn/api/stream.html</li><li>cnodejs.org/topic/56ba030271204e03637a3870</li><li>github.com/nodejs/node/blob/master/lib/_stream_readable.js</li></ul><h1 id="16-守护进程"><a href="#16-守护进程" class="headerlink" title="16.守护进程"></a>16.守护进程</h1><h2 id="16-1-Nodejs编写守护进程"><a href="#16-1-Nodejs编写守护进程" class="headerlink" title="16.1 Nodejs编写守护进程"></a><strong>16.1 Nodejs编写守护进程</strong></h2><p>目前Nodejs编写一个守护进程非常简单，在6.3.1版本中已经存在非常方便的API，这些API可以帮助我们更方便的创建一个守护进程。本文仅在描述守护进程的创建方式，而不会对守护进程所要执行的任务做任何描述。</p><h2 id="16-2-守护进程的启动方式"><a href="#16-2-守护进程的启动方式" class="headerlink" title="16.2 守护进程的启动方式"></a>16.2 守护进程的启动方式</h2><p>如果不在Nodejs环境中，我们如何创建守护进程？过程如下：</p><ol><li>创建一个进程A。</li><li>在进程A中创建进程B，我们可以使用fork方式，或者其他方法。</li><li>对进程B执行 <code>setsid</code> 方法。</li><li>进程A退出，进程B由init进程接管。此时进程B为守护进程。</li></ol><h2 id="16-3-setsid详解"><a href="#16-3-setsid详解" class="headerlink" title="16.3 setsid详解"></a>16.3 setsid详解</h2><p><code>setsid</code> 主要完成三件事：</p><ol><li>该进程变成一个新会话的会话领导。</li><li>该进程变成一个新进程组的组长。</li><li>该进程没有控制终端。</li></ol><p>然而，Nodejs中并没有对 <code>setsid</code> 方法的直接封装，翻阅文档发现有一个地方是可以调用该方法的。</p><h2 id="16-4-Nodejs中启动子进程方法"><a href="#16-4-Nodejs中启动子进程方法" class="headerlink" title="16.4 Nodejs中启动子进程方法"></a>16.4 Nodejs中启动子进程方法</h2><p>借助 <code>clild_process</code> 中的 <code>spawn</code> 即可创建子进程，方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar spawn &#x3D; require(&#39;child_process&#39;).spawn;</span><br><span class="line">var process &#x3D; require(&#39;process&#39;);</span><br><span class="line"></span><br><span class="line">var p &#x3D; spawn(&#39;node&#39;,[&#39;b.js&#39;]);</span><br><span class="line">console.log(process.pid, p.pid);</span><br></pre></td></tr></table></figure><p>注意，这里只打印当前进程的PID和子进程的PID，同时为了观察效果，我并没有将父进程退出。</p><p><code>b.js</code> 中代码很简单，打开一个资源，并不停的写入数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var process &#x3D; require(&#39;process&#39;);</span><br><span class="line"></span><br><span class="line">fs.open(&quot;&#x2F;Users&#x2F;mebius&#x2F;Desktop&#x2F;log.txt&quot;,&#39;w&#39;,function(err, fd)&#123;</span><br><span class="line">console.log(fd);</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">fs.write(fd,process.pid+&quot;\n&quot;,function()&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行后的效果如图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2016/11/29/7a21cc1b1975ad2128ed094f5e8effc6.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们来看以下 <code>top</code> 命令下的进程情况。</p><p><img data-src="https://user-gold-cdn.xitu.io/2016/11/29/52bf06943ce2b7f2acfc9095bb202ece.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>看一看到，此时父进程PID为17055，子进程的PPID为17055，PID为17056.</p><h2 id="16-5-Nodejs中setsid的调用"><a href="#16-5-Nodejs中setsid的调用" class="headerlink" title="16.5 Nodejs中setsid的调用"></a>16.5 Nodejs中setsid的调用</h2><p>到此为止，守护进程已经完成一半，下面要调用setsid方法，并且退出父进程。</p><p>代码修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var spawn &#x3D; require(&#39;child_process&#39;).spawn;</span><br><span class="line">var process &#x3D; require(&#39;process&#39;);</span><br><span class="line"></span><br><span class="line">var p &#x3D; spawn(&#39;node&#39;,[&#39;b.js&#39;],&#123;</span><br><span class="line">        detached : true</span><br><span class="line">    &#125;);</span><br><span class="line">console.log(process.pid, p.pid);</span><br><span class="line">process.exit(0);</span><br></pre></td></tr></table></figure><p>在 <code>spawn</code> 的第三个参数中，可以设置 <code>detached</code> 属性，如果该属性为true，则会调用 <code>setsid</code> 方法。这样就满足我们对守护进程的要求。</p><p>在此运行命令。</p><p><img data-src="https://user-gold-cdn.xitu.io/2016/11/29/04ffe72d6460092a8b5796f6f6099734.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>查看 <code>top</code> 命令</p><p><img data-src="https://user-gold-cdn.xitu.io/2016/11/29/c05d3cae380bb9f107f09793c8c67923.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>可以看到，当前仅存在一个PID为17062的进程，这个进程就是我们要的守护进程。</p><blockquote><p>由于每次运行PID都不同，所以此次子进程的PID于第一次不同。</p></blockquote><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>守护进程最重要的是稳定，如果守护进程挂掉，那么其管理的子进程都将变为孤儿进程，同时被init进程接管，这是我们不愿意看到的。于此同时，守护进程对于子进程的管理也是有非常多的发挥余地的，例如PM2中，将一个进程同时启动4次，达到CPU多核使用的目的（很有可能你的进程在同一核中运行），进程挂掉后自动重启等等，这些事情等着我们去造轮子。</p><p>总体来说，Nodejs启动守护进程方式比较简单，默认所暴露的API也屏蔽了很多系统级别API，使得大家使用上更加方便，但没有接触过Linux的人在理解上有一些复杂。推荐大家学习Nodejs的同时，多学习Linux系统调用的和系统内核的一些东西。</p><h1 id="17-Nodejs进程间通信"><a href="#17-Nodejs进程间通信" class="headerlink" title="17.Nodejs进程间通信"></a>17.Nodejs进程间通信</h1><h2 id="17-1-场景"><a href="#17-1-场景" class="headerlink" title="17.1 场景"></a>17.1 场景</h2><p>Node运行在单线程下，但这并不意味着无法利用多核/多机下多进程的优势</p><p>事实上，Node最初从设计上就考虑了分布式网络场景：</p><blockquote><p>Node is a single-threaded, single-process system which enforces shared-nothing design with OS process boundaries. It has rather good libraries for networking. I believe this to be a basis for designing very large distributed programs. The “nodes” need to be organized: given a communication protocol, told how to connect to each other. In the next couple months we are working on libraries for Node that allow these networks.</p></blockquote><p>P.S.关于Node之所以叫Node，见<a href="https://stackoverflow.com/questions/5621812/why-is-node-js-named-node-js">Why is Node.js named Node.js?</a></p><h2 id="17-2-创建进程"><a href="#17-2-创建进程" class="headerlink" title="17.2 创建进程"></a>17.2 创建进程</h2><p>通信方式与进程产生方式有关，而Node有4种创建进程的方式：<code>spawn()</code>，<code>exec()</code>，<code>execFile()</code>和<code>fork()</code></p><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; spawn(&#39;pwd&#39;);</span><br><span class="line">&#x2F;&#x2F; 带参数的形式</span><br><span class="line">&#x2F;&#x2F; const child &#x3D; spawn(&#39;find&#39;, [&#39;.&#39;, &#39;-type&#39;, &#39;f&#39;]);</span><br></pre></td></tr></table></figure><p><code>spawn()</code>返回<code>ChildProcess</code>实例，<code>ChildProcess</code>同样基于事件机制（EventEmitter API），提供了一些事件：</p><ul><li><code>exit</code>：子进程退出时触发，可以得知进程退出状态（<code>code</code>和<code>signal</code>）</li><li><code>disconnect</code>：父进程调用<code>child.disconnect()</code>时触发</li><li><code>error</code>：子进程创建失败，或被<code>kill</code>时触发</li><li><code>close</code>：子进程的<code>stdio</code>流（标准输入输出流）关闭时触发</li><li><code>message</code>：子进程通过<code>process.send()</code>发送消息时触发，父子进程之间可以通过这种<em>内置的消息机制通信</em></li></ul><p>可以通过<code>child.stdin</code>，<code>child.stdout</code>和<code>child.stderr</code>访问子进程的<code>stdio</code>流，这些流被关闭的时，子进程会触发<code>close</code>事件</p><p>P.S.<code>close</code>与<code>exit</code>的区别主要体现在多进程共享同一<code>stdio</code>流的场景，某个进程退出了并不意味着<code>stdio</code>流被关闭了</p><p>在子进程中，<code>stdout/stderr</code>具有Readable特性，而<code>stdin</code>具有Writable特性，<em>与主进程的情况正好相反</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">child.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;child stdout:\n$&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#96;child stderr:\n$&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>利用进程<code>stdio</code>流的管道特性，就可以完成更复杂的事情，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">const find &#x3D; spawn(&#39;find&#39;, [&#39;.&#39;, &#39;-type&#39;, &#39;f&#39;]);</span><br><span class="line">const wc &#x3D; spawn(&#39;wc&#39;, [&#39;-l&#39;]);</span><br><span class="line"></span><br><span class="line">find.stdout.pipe(wc.stdin);</span><br><span class="line"></span><br><span class="line">wc.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Number of files $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>作用等价于<code>find . -type f | wc -l</code>，递归统计当前目录文件数量</p><h4 id="IPC选项"><a href="#IPC选项" class="headerlink" title="IPC选项"></a>IPC选项</h4><p>另外，通过<code>spawn()</code>方法的<code>stdio</code>选项可以建立IPC机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">const child &#x3D; spawn(&#39;node&#39;, [&#39;.&#x2F;ipc-child.js&#39;], &#123; stdio: [null, null, null, &#39;ipc&#39;] &#125;);</span><br><span class="line">child.on(&#39;message&#39;, (m) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(m);</span><br><span class="line">&#125;);</span><br><span class="line">child.send(&#39;Here Here&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .&#x2F;ipc-child.js</span><br><span class="line">process.on(&#39;message&#39;, (m) &#x3D;&gt; &#123;</span><br><span class="line">  process.send(&#96;&lt; $&#123;m&#125;&#96;);</span><br><span class="line">  process.send(&#39;&gt; 不要回答x3&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于<code>spawn()</code>的IPC选项的详细信息，请查看<a href="https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html#child_process_options_stdio">options.stdio</a></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>spawn()</code>方法默认不会创建shell去执行传入的命令（所以<em>性能上稍微好一点</em>），而<code>exec()</code>方法会创建一个shell。另外，<code>exec()</code>不是基于stream的，而是把传入命令的执行结果暂存到buffer中，再整个传递给回调函数</p><p><code>exec()</code>方法的特点是<em>完全支持shell语法</em>，可以直接传入任意shell脚本，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">exec(&#39;find . -type f | wc -l&#39;, (err, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(&#96;exec error: $&#123;err&#125;&#96;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;Number of files $&#123;stdout&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但<code>exec()</code>方法也因此存在<a href="https://blog.liftsecurity.io/2014/08/19/Avoid-Command-Injection-Node.js/">命令注入</a>的安全风险，在含有用户输入等动态内容的场景要特别注意。所以，<code>exec()</code>方法的适用场景是：希望直接使用shell语法，并且预期输出数据量不大（不存在内存压力）</p><p>那么，有没有既支持shell语法，还具有stream IO优势的方式？</p><p>有。<em>两全其美的方式</em>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; spawn(&#39;find . -type f | wc -l&#39;, &#123;</span><br><span class="line">  shell: true</span><br><span class="line">&#125;);</span><br><span class="line">child.stdout.pipe(process.stdout);</span><br></pre></td></tr></table></figure><p>开启<code>spawn()</code>的<code>shell</code>选项，并通过<code>pipe()</code>方法把子进程的标准输出简单地接到当前进程的标准输入上，以便看到命令执行结果。实际上还有更容易的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">process.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">const child &#x3D; spawn(&#39;find . -type f | wc -l&#39;, &#123;</span><br><span class="line">  shell: true,</span><br><span class="line">  stdio: &#39;inherit&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>stdio: &#39;inherit&#39;</code>允许子进程继承当前进程的标准输入输出（共享<code>stdin</code>，<code>stdout</code>和<code>stderr</code>），所以上例能够通过监听当前进程<code>process.stdout</code>的<code>data</code>事件拿到子进程的输出结果</p><p>另外，除了<code>stdio</code>和<code>shell</code>选项，<code>spawn()</code>还支持一些其它选项，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const child &#x3D; spawn(&#39;find . -type f | wc -l&#39;, &#123;</span><br><span class="line">  stdio: &#39;inherit&#39;,</span><br><span class="line">  shell: true,</span><br><span class="line">  &#x2F;&#x2F; 修改环境变量，默认process.env</span><br><span class="line">  env: &#123; HOME: &#39;&#x2F;tmp&#x2F;xxx&#39; &#125;,</span><br><span class="line">  &#x2F;&#x2F; 改变当前工作目录</span><br><span class="line">  cwd: &#39;&#x2F;tmp&#39;,</span><br><span class="line">  &#x2F;&#x2F; 作为独立进程存在</span><br><span class="line">  detached: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><em>注意</em>，<code>env</code>选项除了以环境变量形式向子进程传递数据外，还可以用来实现沙箱式的环境变量隔离，默认把<code>process.env</code>作为子进程的环境变量集，子进程与当前进程一样能够访问所有环境变量，如果像上例中指定自定义对象作为子进程的环境变量集，子进程就无法访问其它环境变量</p><p>所以，想要增/删环境变量的话，需要这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var spawn_env &#x3D; JSON.parse(JSON.stringify(process.env));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; remove those env vars</span><br><span class="line">delete spawn_env.ATOM_SHELL_INTERNAL_RUN_AS_NODE;</span><br><span class="line">delete spawn_env.ELECTRON_RUN_AS_NODE;</span><br><span class="line"></span><br><span class="line">var sp &#x3D; spawn(command, [&#39;.&#39;], &#123;cwd: cwd, env: spawn_env&#125;);</span><br></pre></td></tr></table></figure><p><code>detached</code>选项更有意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">const child &#x3D; spawn(&#39;node&#39;, [&#39;stuff.js&#39;], &#123;</span><br><span class="line">  detached: true,</span><br><span class="line">  stdio: &#39;ignore&#39;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.unref();</span><br></pre></td></tr></table></figure><p>以这种方式创建的独立进程行为取决于操作系统，Windows上detached子进程将拥有自己的console窗口，而Linux上该进程会<em>创建新的process group</em>（这个特性可以用来管理子进程族，实现类似于<a href="http://www.ayqy.net/blog/nodejs%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/npmjs.com/package/tree-kill">tree-kill</a>的特性）</p><p><code>unref()</code>方法用来断绝关系，这样“父”进程可以独立退出（不会导致子进程跟着退出），但要注意这时子进程的<code>stdio</code>也应该独立于“父”进程，否则“父”进程退出后子进程仍会受到影响</p><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; execFile &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>与<code>exec()</code>方法类似，但不通过shell来执行（所以性能稍好一点），所以要求传入<em>可执行文件</em>。Windows下某些文件无法直接执行，比如<code>.bat</code>和<code>.cmd</code>，这些文件就不能用<code>execFile()</code>来执行，只能借助<code>exec()</code>或开启了<code>shell</code>选项的<code>spawn()</code></p><p>P.S.与<code>exec()</code>一样也<em>不是基于stream的</em>，同样存在输出数据量风险</p><h4 id="xxxSync"><a href="#xxxSync" class="headerlink" title="xxxSync"></a>xxxSync</h4><p><code>spawn</code>，<code>exec</code>和<code>execFile</code>都有对应的同步阻塞版本，一直等到子进程退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; </span><br><span class="line">  spawnSync, </span><br><span class="line">  execSync, </span><br><span class="line">  execFileSync,</span><br><span class="line">&#125; &#x3D; require(&#39;child_process&#39;);</span><br></pre></td></tr></table></figure><p>同步方法用来简化脚本任务，比如启动流程，其它时候应该避免使用这些方法</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><code>fork()</code>是<code>spawn()</code>的变体，用来创建Node进程，最大的特点是父子进程自带通信机制（IPC管道）：</p><blockquote><p>The child_process.fork() method is a special case of child_process.spawn() used specifically to spawn new Node.js processes. Like child_process.spawn(), a ChildProcess object is returned. The returned ChildProcess will have an additional communication channel built-in that allows messages to be passed back and forth between the parent and child. See subprocess.send() for details.</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; child_process.fork(&#39;.&#x2F;child.js&#39;);</span><br><span class="line">n.on(&#39;message&#39;, function(m) &#123;</span><br><span class="line">  console.log(&#39;PARENT got message:&#39;, m);</span><br><span class="line">&#125;);</span><br><span class="line">n.send(&#123; hello: &#39;world&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; .&#x2F;child.js</span><br><span class="line">process.on(&#39;message&#39;, function(m) &#123;</span><br><span class="line">  console.log(&#39;CHILD got message:&#39;, m);</span><br><span class="line">&#125;);</span><br><span class="line">process.send(&#123; foo: &#39;bar&#39; &#125;);</span><br></pre></td></tr></table></figure><p>因为<code>fork()</code>自带通信机制的优势，尤其适合用来拆分耗时逻辑，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const longComputation &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  let sum &#x3D; 0;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; 1e9; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;;</span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;compute&#39;) &#123;</span><br><span class="line">    const sum &#x3D; longComputation();</span><br><span class="line">    return res.end(&#96;Sum is $&#123;sum&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.end(&#39;Ok&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure><p>这样做的致命问题是一旦有人访问<code>/compute</code>，后续请求都无法及时处理，因为事件循环还被<code>longComputation</code>阻塞着，直到耗时计算结束才能恢复服务能力</p><p>为了避免耗时操作阻塞主进程的事件循环，可以把<code>longComputation()</code>拆分到子进程中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; compute.js</span><br><span class="line">const longComputation &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  let sum &#x3D; 0;</span><br><span class="line">  for (let i &#x3D; 0; i &lt; 1e9; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开关，收到消息才开始做</span><br><span class="line">process.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">  const sum &#x3D; longComputation();</span><br><span class="line">  process.send(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>主进程开启子进程执行<code>longComputation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const &#123; fork &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;compute&#39;) &#123;</span><br><span class="line">    const compute &#x3D; fork(&#39;compute.js&#39;);</span><br><span class="line">    compute.send(&#39;start&#39;);</span><br><span class="line">    compute.on(&#39;message&#39;, sum &#x3D;&gt; &#123;</span><br><span class="line">      res.end(&#96;Sum is $&#123;sum&#125;&#96;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.end(&#39;Ok&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure><p>主进程的事件循环不会再被耗时计算阻塞，但进程数量还需要进一步限制，否则资源被进程消耗殆尽时服务能力仍会受到影响</p><p>P.S.实际上，<code>cluster</code>模块就是对多进程服务能力的封装，<em>思路与这个简单示例类似</em></p><h2 id="17-3-通信方式"><a href="#17-3-通信方式" class="headerlink" title="17.3 通信方式"></a>17.3 通信方式</h2><h3 id="17-3-1-通过stdin-stdout传递json"><a href="#17-3-1-通过stdin-stdout传递json" class="headerlink" title="17.3.1 通过stdin/stdout传递json"></a>17.3.1 通过stdin/stdout传递json</h3><blockquote><p>stdin/stdout and a JSON payload</p></blockquote><p>最直接的通信方式，拿到子进程的handle后，可以访问其<code>stdio</code>流，然后约定一种<code>message</code>格式开始愉快地通信：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line"></span><br><span class="line">child &#x3D; spawn(&#39;node&#39;, [&#39;.&#x2F;stdio-child.js&#39;]);</span><br><span class="line">child.stdout.setEncoding(&#39;utf8&#39;);</span><br><span class="line">&#x2F;&#x2F; 父进程-发</span><br><span class="line">child.stdin.write(JSON.stringify(&#123;</span><br><span class="line">  type: &#39;handshake&#39;,</span><br><span class="line">  payload: &#39;你好吖&#39;</span><br><span class="line">&#125;));</span><br><span class="line">&#x2F;&#x2F; 父进程-收</span><br><span class="line">child.stdout.on(&#39;data&#39;, function (chunk) &#123;</span><br><span class="line">  let data &#x3D; chunk.toString();</span><br><span class="line">  let message &#x3D; JSON.parse(data);</span><br><span class="line">  console.log(&#96;$&#123;message.type&#125; $&#123;message.payload&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子进程与之类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .&#x2F;stdio-child.js</span><br><span class="line">&#x2F;&#x2F; 子进程-收</span><br><span class="line">process.stdin.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">  let data &#x3D; chunk.toString();</span><br><span class="line">  let message &#x3D; JSON.parse(data);</span><br><span class="line">  switch (message.type) &#123;</span><br><span class="line">    case &#39;handshake&#39;:</span><br><span class="line">      &#x2F;&#x2F; 子进程-发</span><br><span class="line">      process.stdout.write(JSON.stringify(&#123;</span><br><span class="line">        type: &#39;message&#39;,</span><br><span class="line">        payload: message.payload + &#39; : hoho&#39;</span><br><span class="line">      &#125;));</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>P.S.VS Code进程间通信就采用了这种方式，具体见<a href="https://github.com/Microsoft/vscode/issues/3011#issuecomment-196305696">access electron API from vscode extension</a></p><p>明显的<em>限制</em>是需要拿到“子”进程的handle，两个完全独立的进程之间无法通过这种方式来通信（比如跨应用，甚至跨机器的场景）</p><p>P.S.关于stream及pipe的详细信息，请查看<a href="http://www.ayqy.net/blog/node-stream/">Node中的流</a></p><h3 id="17-3-2-原生IPC支持"><a href="#17-3-2-原生IPC支持" class="headerlink" title="17.3.2 原生IPC支持"></a>17.3.2 原生IPC支持</h3><p>如<code>spawn()</code>及<code>fork()</code>的例子，进程之间可以借助内置的IPC机制通信</p><p>父进程：</p><ul><li><code>process.on(&#39;message&#39;)</code>收</li><li><code>child.send()</code>发</li></ul><p>子进程：</p><ul><li><code>process.on(&#39;message&#39;)</code>收</li><li><code>process.send()</code>发</li></ul><p>限制同上，同样要有一方能够拿到另一方的handle才行</p><h3 id="17-3-3-sockets"><a href="#17-3-3-sockets" class="headerlink" title="17.3.3 sockets"></a>17.3.3 sockets</h3><p>借助网络来完成进程间通信，<em>不仅能跨进程，还能跨机器</em></p><p><a href="https://www.npmjs.com/package/node-ipc">node-ipc</a>就采用这种方案，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; server</span><br><span class="line">const ipc&#x3D;require(&#39;..&#x2F;..&#x2F;..&#x2F;node-ipc&#39;);</span><br><span class="line"></span><br><span class="line">ipc.config.id &#x3D; &#39;world&#39;;</span><br><span class="line">ipc.config.retry&#x3D; 1500;</span><br><span class="line">ipc.config.maxConnections&#x3D;1;</span><br><span class="line"></span><br><span class="line">ipc.serveNet(</span><br><span class="line">    function()&#123;</span><br><span class="line">        ipc.server.on(</span><br><span class="line">            &#39;message&#39;,</span><br><span class="line">            function(data,socket)&#123;</span><br><span class="line">                ipc.log(&#39;got a message : &#39;, data);</span><br><span class="line">                ipc.server.emit(</span><br><span class="line">                    socket,</span><br><span class="line">                    &#39;message&#39;,</span><br><span class="line">                    data+&#39; world!&#39;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ipc.server.on(</span><br><span class="line">            &#39;socket.disconnected&#39;,</span><br><span class="line">            function(data,socket)&#123;</span><br><span class="line">                console.log(&#39;DISCONNECTED\n\n&#39;,arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">ipc.server.on(</span><br><span class="line">    &#39;error&#39;,</span><br><span class="line">    function(err)&#123;</span><br><span class="line">        ipc.log(&#39;Got an ERROR!&#39;,err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">ipc.server.start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; client</span><br><span class="line">const ipc&#x3D;require(&#39;node-ipc&#39;);</span><br><span class="line"></span><br><span class="line">ipc.config.id &#x3D; &#39;hello&#39;;</span><br><span class="line">ipc.config.retry&#x3D; 1500;</span><br><span class="line"></span><br><span class="line">ipc.connectToNet(</span><br><span class="line">    &#39;world&#39;,</span><br><span class="line">    function()&#123;</span><br><span class="line">        ipc.of.world.on(</span><br><span class="line">            &#39;connect&#39;,</span><br><span class="line">            function()&#123;</span><br><span class="line">                ipc.log(&#39;## connected to world ##&#39;, ipc.config.delay);</span><br><span class="line">                ipc.of.world.emit(</span><br><span class="line">                    &#39;message&#39;,</span><br><span class="line">                    &#39;hello&#39;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        ipc.of.world.on(</span><br><span class="line">            &#39;disconnect&#39;,</span><br><span class="line">            function()&#123;</span><br><span class="line">                ipc.log(&#39;disconnected from world&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        ipc.of.world.on(</span><br><span class="line">            &#39;message&#39;,</span><br><span class="line">            function(data)&#123;</span><br><span class="line">                ipc.log(&#39;got a message from world : &#39;, data);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>P.S.更多示例见<a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example">RIAEvangelist/node-ipc</a></p><p>当然，单机场景下通过网络来完成进程间通信有些浪费性能，但网络通信的<em>优势</em>在于跨环境的兼容性与更进一步的RPC场景</p><h3 id="17-3-4-message-queue"><a href="#17-3-4-message-queue" class="headerlink" title="17.3.4 message queue"></a>17.3.4 message queue</h3><p>父子进程都通过外部消息机制来通信，跨进程的能力取决于MQ支持</p><p>即进程间不直接通信，而是通过中间层（MQ），<em>加一个控制层</em>就能获得更多灵活性和优势：</p><ul><li>稳定性：消息机制提供了强大的稳定性保证，比如确认送达（消息回执ACK），失败重发/防止多发等等</li><li>优先级控制：允许调整消息响应次序</li><li>离线能力：消息可以被缓存</li><li>事务性消息处理：把关联消息组合成事务，保证其送达顺序及完整性</li></ul><p>P.S.不好实现？包一层能解决吗，不行就包两层……</p><p>比较受欢迎的有<a href="https://github.com/smrchy/rsmq">smrchy/rsmq</a>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; init</span><br><span class="line">RedisSMQ &#x3D; require(&quot;rsmq&quot;);</span><br><span class="line">rsmq &#x3D; new RedisSMQ( &#123;host: &quot;127.0.0.1&quot;, port: 6379, ns: &quot;rsmq&quot;&#125; );</span><br><span class="line">&#x2F;&#x2F; create queue</span><br><span class="line">rsmq.createQueue(&#123;qname:&quot;myqueue&quot;&#125;, function (err, resp) &#123;</span><br><span class="line">    if (resp&#x3D;&#x3D;&#x3D;1) &#123;</span><br><span class="line">      console.log(&quot;queue created&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; send message</span><br><span class="line">rsmq.sendMessage(&#123;qname:&quot;myqueue&quot;, message:&quot;Hello World&quot;&#125;, function (err, resp) &#123;</span><br><span class="line">  if (resp) &#123;</span><br><span class="line">    console.log(&quot;Message sent. ID:&quot;, resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; receive message</span><br><span class="line">rsmq.receiveMessage(&#123;qname:&quot;myqueue&quot;&#125;, function (err, resp) &#123;</span><br><span class="line">  if (resp.id) &#123;</span><br><span class="line">    console.log(&quot;Message received.&quot;, resp)  </span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    console.log(&quot;No messages for me...&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>会起一个Redis server，基本原理如下：</p><blockquote><p>Using a shared Redis server multiple Node.js processes can send / receive messages.</p></blockquote><p>消息的收/发/缓存/持久化依靠Redis提供的能力，在此基础上实现完整的队列机制</p><h3 id="17-3-5-Redis"><a href="#17-3-5-Redis" class="headerlink" title="17.3.5 Redis"></a>17.3.5 Redis</h3><p>基本思路与message queue类似：</p><blockquote><p>Use Redis as a message bus/broker.</p></blockquote><p>Redis自带<a href="https://redis.io/topics/pubsub">Pub/Sub机制</a>（即发布-订阅模式），适用于简单的通信场景，比如一对一或一对多并且<em>不关注消息可靠性</em>的场景</p><p>另外，Redis有list结构，可以用作消息队列，以此提高消息可靠性。一般做法是生产者<a href="https://redis.io/commands/lpush">LPUSH</a>消息，消费者<a href="https://redis.io/commands/brpop">BRPOP</a>消息。适用于要求消息可靠性的简单通信场景，但缺点是消息不具状态，且没有ACK机制，无法满足复杂的通信需求</p><p>P.S.Redis的Pub/Sub示例见<a href="https://stackoverflow.com/questions/6463945/whats-the-most-efficient-node-js-inter-process-communication-library-method">What’s the most efficient node.js inter-process communication library/method?</a></p><h2 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4 总结"></a>17.4 总结</h2><p>Node进程间通信有4种方式：</p><ul><li>通过stdin/stdout传递json：最直接的方式，适用于能够拿到“子”进程handle的场景，适用于关联进程之间通信，无法跨机器</li><li>Node原生IPC支持：最native（地道？）的方式，比上一种“正规”一些，具有同样的局限性</li><li>通过sockets：最通用的方式，有良好的跨环境能力，但存在网络的性能损耗</li><li>借助message queue：最强大的方式，既然要通信，场景还复杂，不妨扩展出一层消息中间件，漂亮地解决各种通信问题</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://medium.freecodecamp.org/node-js-child-processes-everything-you-need-to-know-e69498fe970a">Node.js Child Processes: Everything you need to know</a></li></ul><h1 id="18-Node-js-捕获异常"><a href="#18-Node-js-捕获异常" class="headerlink" title="18.Node.js 捕获异常"></a>18.Node.js 捕获异常</h1><p>采用事件轮训、异步 IO 等机制使得 Node.js 能够从容应对无阻塞高并发场景，令工程师很困扰的几个理解 Node.js 的地方除了它的事件（回调）机制，还有一个同样头痛的是异常代码的捕获。</p><h2 id="18-1-try-catch-之痛"><a href="#18-1-try-catch-之痛" class="headerlink" title="18.1 try/catch 之痛"></a>18.1 try/catch 之痛</h2><p>一般情况下，我们会将有可能出错的代码放到 <code>try/catch</code> 块里。但是到了 Node.js，由于 <code>try/catch</code> 无法捕捉异步回调里的异常，Node.js 原生提供 <code>uncaughtException</code> 事件挂到 <code>process</code> 对象上，用于捕获所有未处理的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;uncaughtException&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught in uncaughtException event:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">try &#123;</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        fs.readFile(&#39;non_existent.js&#39;, function(err, str) &#123;</span><br><span class="line">            if(err) throw err;</span><br><span class="line">            else console.log(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">    console.error(&#39;Error caught by catch block:&#39;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果是代码进到了 uncaughtException 的回调里而不是 catch 块。 uncaughtException 虽然能够捕获异常，但是此时错误的上下文已经丢失，即使看到错误也不知道哪儿报的错，定位问题非常的不利。而且一旦 uncaughtException 事件触发，整个 node 进程将 crash 掉，如果不做一些善后处理的话会导致整个服务挂掉，这对于线上的服务来说将是非常不好的。</p><h2 id="18-2-使用-domain-模块捕捉异常"><a href="#18-2-使用-domain-模块捕捉异常" class="headerlink" title="18.2 使用 domain 模块捕捉异常"></a>18.2 使用 domain 模块捕捉异常</h2><p>随 Node.js v0.8 版本发布了一个 <a href="http://nodejs.org/api/domain.html">domain</a>（域）模块，专门用于处理异步回调的异常，使用 <code>domain</code> 我们将很轻松的捕获异步异常：</p><p>运行上面的代码，我们会看到错误被 domain 捕获到，并且 uncaughtException 回调并不会执行，事情似乎变得稍微容易些了。</p><p>但是如果研究 domain 模块的 API 很快我们会发现，domain 提供了好几个方法，理解起来似乎不是那么直观（其实为啥这个模块叫 “域 (domain)” 呢，总感觉些许别扭），这里简单解释下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;uncaughtException&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught in uncaughtException event:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line"> </span><br><span class="line">d.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught by domain:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">d.run(function() &#123;</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        fs.readFile(&#39;non_existent.js&#39;, function(err, str) &#123;</span><br><span class="line">            if(err) throw err;</span><br><span class="line">            else console.log(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 首先，关于 domain 模块，我们看到它的稳定性是 2，也就是不稳定，API 可能会变更。</p><p>默认情况下，domain 模块是不被引入的，当 <code>domain.create()</code>创建一个 domain 之后，调用 <code>enter()</code>方法即可 “激活” 这个 domain，具体表现为全局的进程（<code>process</code>）对象上会有一个 domain 属性指向之前创建的这个的 domain 实例，同时，domain 模块上有个 <code>active</code> 属性也指向这个的 domain 实例。、</p><p>结合 <a href="https://github.com/visionmedia/should.js">should</a> 断言库测试下上面说的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; domain was not exists by default</span><br><span class="line">should.not.exist(process.domain);</span><br><span class="line"> </span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line"> </span><br><span class="line">d.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">d.enter(); &#x2F;&#x2F; makes d the current domain</span><br><span class="line"> </span><br><span class="line">process.domain.should.be.an.Object;</span><br><span class="line">process.domain.should.equal(domain.active);</span><br><span class="line"> </span><br><span class="line">d.exit(); &#x2F;&#x2F; makes d inactive</span><br><span class="line"> </span><br><span class="line">should.not.exist(process.domain);</span><br></pre></td></tr></table></figure><p> 执行之后发现几个断言都能 pass。<code>exit()</code>方法的意思是退出当前 “域”，将会影响到后续异步异常的捕获，后面会提到。</p><p><code>enter</code> 和 <code>exit</code> 组合调用这样会使代码有些混乱，尤其是当多个 domain 混合、嵌套使用时比较难理解。</p><p>这时候可以使用 <code>run()</code>方法，<code>run()</code>其实就是对 <code>enter</code> 和 <code>exit</code> 以及回调的简单封装，即：run() – callback() – exit() 这样，就像上面例子中的 <code>run()</code>一样。</p><p>还有两个方法，<code>bind()</code>和 <code>intercept()</code>：</p><p>bind:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;non_existent.js&#39;, d.bind(function(err, buf) &#123;</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    else res.end(buf.toString());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>intercept：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#39;non_existent.js&#39;, d.intercept(function(buf) &#123;</span><br><span class="line">    console.log(buf);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p> 用法差不多，只是 intercept 拦截了异步回调，如果抛出异常就自己处理掉了。</p><h3 id="18-2-1-domain-的隐式绑定"><a href="#18-2-1-domain-的隐式绑定" class="headerlink" title="18.2.1 domain 的隐式绑定"></a>18.2.1 domain 的隐式绑定</h3><p>domain 主要会影响 <code>timers</code> 模块（包括 <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>）, 事件循环 <code>process.nextTick</code>，还有就是 event。</p><p>实现的思路都差不多，都是通过注入 domain 代码到 timer、nextTick、event 模块中，在创建的时候检查当前有没有激活（active）的 domain，有则记录下，如果是 timer 和 nextTick，当在事件循环中执行回调的时候，把 process.domain 设置为之前记录的 domain 并把错误交给它处理。如果是 event，多一步判断，先会把异常交给 event 自己定义的 error 事件处理。</p><p>这里要注意，如果这个 domain 没有绑定 <code>error</code> 事件的话，node 会直接抛出错误，即使 uncaughtException 绑定了也没有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;uncaughtException&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught in uncaughtException event:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line"> </span><br><span class="line">d.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught by domain:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">d.run(function() &#123;</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        fs.readFile(&#39;non_existent.js&#39;, function(err, str) &#123;</span><br><span class="line">            if(err) throw err;</span><br><span class="line">            else console.log(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 在这个例子里面，使用了 domain 捕获异常但是没有监听 domain 的 error 事件，监听了 uncaughtException，但是还是抛出了异常，个人觉得觉得这里是个 bug，domain 没有 errorHandle 应该把异常交给全局的 uncaughtException，后面有例子验证这一点。</p><p>还有一个小问题，同时监听了 uncaughtException 和 domain 的 error 事件，在 node v0.8 里有个 bug，uncaughtException 和 domain 都能捕获异常，0.10+已经修复。</p><h3 id="18-2-2-domain-的显式绑定"><a href="#18-2-2-domain-的显式绑定" class="headerlink" title="18.2.2 domain 的显式绑定"></a>18.2.2 domain 的显式绑定</h3><p>上面没有提到的两个 API 是 <code>add()</code>和 <code>remove()</code>，add 作用是把 domain 创建之前创建的（EventEmitter 实例）对象添加到这个 domain 里边，然后这个对象即可使用 domain 捕捉异常了，remove 则相反。domain 对象上有个 numbers 队列专门用于管理 add 后的对象。</p><p>这里可参考<a href="http://nodejs.org/api/domain.html#domain_explicit_binding">官方示例</a>。</p><h3 id="18-2-3-domain-如何抛出异常"><a href="#18-2-3-domain-如何抛出异常" class="headerlink" title="18.2.3 domain 如何抛出异常"></a>18.2.3 domain 如何抛出异常</h3><p>我们看 <a href="https://github.com/joyent/node/blob/v0.10.4/src/node.js#L43">node 源码</a>有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; do this good and early, since it handles errors.</span><br><span class="line">startup.processFatal();</span><br></pre></td></tr></table></figure><p> <code>processFatal</code> 里边调用 <code>process._fatalException()</code>，先判断是否存在 process.domain，尝试把错误交给 process.domain 处理，如果不存在才交给 uncaughtException 处理，所以 domain 捕获异常的关键代码在 <a href="https://github.com/joyent/node/blob/v0.10.4/src/node.js#L219">node.js#L219</a>。</p><p>这里尝试修改下上面的例子，在抛出异常前把 process.domain 设为 null：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d.run(function() &#123;</span><br><span class="line">    process.domain &#x3D; null;</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        fs.readFile(&#39;non_existent.js&#39;, function(err, str) &#123;</span><br><span class="line">            if(err) throw err;</span><br><span class="line">            else console.log(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这下 uncaughtException 将捕获异常！</p><p>当上面提到的异常都没被捕获，进程将直接退出 <a href="https://github.com/joyent/node/blob/v0.10.4/src/node.js#L280">node.js#L280</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; if someone handled it, then great.  otherwise, die in C++ land</span><br><span class="line">&#x2F;&#x2F; since that means that we&#39;ll exit the process, emit the &#39;exit&#39; event</span><br><span class="line">...</span><br><span class="line">process.emit(&#39;exit&#39;, 1);</span><br></pre></td></tr></table></figure><p>另外关于 domain 如何在多个不同的事件循环中传递，可以参考下<a href="http://deadhorse.me/nodejs/2013/04/13/exception_and_domain.html">这篇</a>文章。</p><p>值得关注的是，并不是所有在 domain 域下创建的事件分发器（EventEmitter）上面的异步异常都能捕获：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; domain.create();</span><br><span class="line">var msg;</span><br><span class="line">var Msg &#x3D; function() &#123;</span><br><span class="line">    events.EventEmitter.call(this);</span><br><span class="line"> </span><br><span class="line">    this.on(&#39;msg&#39;, function(msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    this.send &#x3D; function(msg) &#123;</span><br><span class="line">        this.emit(&#39;msg&#39;, msg);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.read &#x3D; function(file) &#123;</span><br><span class="line">        var root &#x3D; this;</span><br><span class="line">        fs.readFile(file, function(err, buf) &#123;</span><br><span class="line">            if(err) throw err;</span><br><span class="line">            else root.send(buf.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">require(&#39;util&#39;).inherits(Msg, events.EventEmitter);</span><br><span class="line"> </span><br><span class="line">d.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught by domain:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">d.run(function() &#123;</span><br><span class="line">    msg &#x3D; new Msg();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">msg.read(&#39;non_existent.js&#39;);</span><br></pre></td></tr></table></figure><p> 这个例子中，msg 对象虽然是在 domain 中实例化，但是 msg.send 里边 fs.readFile 在执行回调的时候，process.domain 是 <code>undefined</code>。</p><p>我们稍微改造下，把 readFile 的回调绑定到 domain 上，或者把 msg.send() 的调用放到 d.run() 包裹，结果可预知，能正常捕获抛出的异常。为了验证，尝试改造下 readFile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(file, function(err, buf) &#123;</span><br><span class="line">    process.domain &#x3D; d;</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    else root.send(buf.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 这样亦可捕获异常，不过实际中不要这样写，还是要采用 domain 提供的方法。</p><h4 id="更好的使用-domain"><a href="#更好的使用-domain" class="headerlink" title="更好的使用 domain"></a>更好的使用 domain</h4><p>其实上，更推荐的做法是，如果在活动 domain 里面创建了事件分发器（EventEmitter）实例，我们应该尽可能的给它注册 error 事件，把错误都抛给这个 EventEmitter 实例处理，就像上面的例子，我们改造下，绑定 error 事件并把 readFile 的错误交给 Msg 实例处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    throw err;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">this.read &#x3D; function(file) &#123;</span><br><span class="line">    var root &#x3D; this;</span><br><span class="line">    fs.readFile(file, function(err, buf) &#123;</span><br><span class="line">        if(err) root.emit(&#39;error&#39;, err);</span><br><span class="line">        else root.send(buf.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在书写 Node.js 代码的时候，对于事件分发器，应该养成先绑定（<code>on()</code>或 <code>addEventListener()</code>）后触发（<code>emit()</code>）的习惯。在执行事件回调的时候，<strong>对于有可能抛异常的情况，应该把 emit 放到 domain 里去</strong>： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; domain.create();</span><br><span class="line">var e &#x3D; new events.EventEmitter();</span><br><span class="line"> </span><br><span class="line">d.on(&#39;error&#39;, function(err) &#123;</span><br><span class="line">    console.error(&#39;Error caught by domain:&#39;, err);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">e.on(&#39;data&#39;, function(err) &#123;</span><br><span class="line">    if(err) throw err;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">if(Math.random() &gt; 0.5) &#123;</span><br><span class="line">    d.run(function() &#123;</span><br><span class="line">        e.emit(&#39;data&#39;, new Error(&#39;Error in domain runtime.&#39;));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    e.emit(&#39;data&#39;, new Error(&#39;Error without domain.&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <a href="https://github.com/joyent/node/blob/v0.10.4/lib/domain.js#L187">domain#L187</a> 可知，run 会把传进去的函数包装成另一个函数返回，并在这个返回的函数上设置 domain：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.domain &#x3D; this;</span><br></pre></td></tr></table></figure><p> events 模块 <a href="https://github.com/joyent/node/blob/v0.10.4/lib/events.js#L85">events.js#L85</a> 有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>当调用 e.emit() 的时候，如果回调函数上挂有 domain，则将这个 domain 激活，进而可以捕获异常。</p><h4 id="domain-的缺陷"><a href="#domain-的缺陷" class="headerlink" title="domain 的缺陷"></a>domain 的缺陷</h4><p>有了 domain，似乎异步异常捕捉已经不再是难事。Node.js 允许创建多个 domain 实例，并允许使用 add 添加多个事件分发器给 domain 管理，，而且 domain 之间可以相互嵌套，而创建 domain，是有一定的性能耗损的，这样带来了一个棘手的问题是：多个 domain 如何合理的创建与销毁，domain 的运行期应该如何维护？</p><p>还有一点，domain 并不能捕捉所有的异常，看<a href="https://github.com/domenic/domains-tragedy">这里</a>。</p><h4 id="domain-实践"><a href="#domain-实践" class="headerlink" title="domain 实践"></a>domain 实践</h4><p>关于使用 domain 到集群环境，推荐都看看官方的说明：<a href="http://nodejs.org/docs/latest/api/domain.html#domain_warning_don_t_ignore_errors">Warning: Don’t Ignore Errors!</a>。把每一个网络请求都包在一个 domain 里边，捕获到异常时，不要立即退出进程，应该保证进程中其他连接正常退出之后再 exit，官方推荐的是设一个定时器，过 3min 后退出进程，接下去做善后处理，然后应该返回应该有的错误（如 500）给客户端。</p><p>对于 connect 或者 express 创建的 web 服务，有一个 <a href="https://github.com/fengmk2/domain-middleware">domain-middleware</a> 中间件可以直接用，它会把 next 包装到一个已经定制好的 domain 里边。</p><p>在具体应用场景，应该 uncaughtException 事件配合 domain 来用。</p><p>本篇完，欢迎补充指正，所有用到的例子都在<a href="https://github.com/chemdemo/chemdemo.github.io/blob/master/demos/domain_demo.js">这里</a>。</p><p>参考资料：</p><ul><li><a href="http://nodejs.org/docs/latest/api/domain.html">http://nodejs.org/docs/latest/api/domain.html</a></li><li><a href="https://github.com/joyent/node">https://github.com/joyent/node</a></li><li><a href="http://www.slideshare.net/domenicdenicola/domains-20010482">http://www.slideshare.net/domenicdenicola/domains-20010482</a></li><li><a href="http://deadhorse.me/nodejs/2013/04/13/exception_and_domain.html">http://deadhorse.me/nodejs/2013/04/13/exception_and_domain.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍Node相关知识，很遗憾没有做过一个完整的Node项目，掌握度不足，但Vue实战中的打包过程用了很多相关知识，赶紧补起来，这一块实战中由于脚手架的出现，已经相对遗忘了，要自己写一个配置，就需要好好掌握了&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Node" scheme="https://hxy1997.xyz/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://hxy1997.xyz/2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://hxy1997.xyz/2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-14T12:35:39.000Z</published>
    <updated>2021-03-15T12:53:26.920Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络的相关内容，这部分上过专业课的，只是电院的专业课讲得不是太深，还是需要自己买书重学，这也是前端必备的计算机基础了，这一块内容要背的有点多</p><span id="more"></span><h1 id="1-OSI-7层模型和TCP-IP-4层模型"><a href="#1-OSI-7层模型和TCP-IP-4层模型" class="headerlink" title="1.OSI 7层模型和TCP/IP 4层模型"></a>1.OSI 7层模型和TCP/IP 4层模型</h1><ul><li>OSI: open system interconnection 开放式系统互联参考模型</li><li>OSI 和TCP/IP 的对应关系和协议</li></ul><p><img data-src="https://pic1.zhimg.com/80/v2-2d62ba265be486cb94ab531912aa3b9c_720w.jpg" alt="img"></p><p>OSI模型各层的基本作用</p><p><img data-src="https://pic2.zhimg.com/80/v2-436927a69a3574532059a78623d3095d_720w.jpg" alt="img"></p><ul><li>OSI模型的详解（但是对会话层、表示层、应用层合并为TCP/IP的应用层）</li><li>大纲</li></ul><p><img data-src="https://pic4.zhimg.com/80/v2-5ce0438c1e2c59840286b124fc70dd67_720w.jpg" alt="img"></p><ul><li>物理层</li></ul><p><img data-src="https://pic1.zhimg.com/80/v2-343093645638ea0839b71db5eba1f7c0_720w.jpg" alt="img"></p><ul><li>数据链路层</li></ul><p><img data-src="https://pic1.zhimg.com/80/v2-fb8534d86e40986e43449de6c35ebd14_720w.jpg" alt="img"></p><ul><li>网络层</li></ul><p><img data-src="https://pic4.zhimg.com/80/v2-991572825990575d273f653a78bcc5e7_720w.jpg" alt="img"></p><ul><li>传输层</li></ul><p><img data-src="https://pic2.zhimg.com/80/v2-31bff54e0720487afe37e5f3f282d231_720w.jpg" alt="img"></p><ul><li>应用层</li></ul><p><img data-src="https://pic2.zhimg.com/80/v2-741e4cd7f95897d6a61bd219e208f1c1_720w.jpg" alt="img"></p><ul><li>以下为补充内容，可以帮助理解</li></ul><ul><li>pc连网的设置详解</li></ul><p><img data-src="https://pic4.zhimg.com/80/v2-b09a3718e0501f053b6ed418b087211b_720w.jpg" alt="img"></p><ul><li>数据链路层数据包（以太网数据包）格式，除了应用层没有头部，其他都有</li></ul><p><img data-src="https://pic2.zhimg.com/80/v2-3c8ab7e3f330238821adedea31b9c321_720w.jpg" alt="img"></p><ul><li>由于以太网数据包的数据部分，最大长度为1500字节，当IP包过大时，会分割下来，但是每个分割包的头部都一样</li></ul><p><img data-src="https://pic1.zhimg.com/80/v2-5ce2810c5f0ed99ad92d7d3a43cc652c_720w.jpg" alt="img"></p><p>数据包在传送时的封装和解封装如下所示</p><p><img data-src="https://pic3.zhimg.com/80/v2-80430dbb37a1e42315a77e30448b34b2_720w.jpg" alt="img"></p><ul><li><p>参考文献：</p></li><li><ul><li><a href="https://link.zhihu.com/?target=http://www.jianshu.com/p/c793a279f698">计算机网络漫谈：OSI七层模型与TCP/IP四层（参考）模型</a></li><li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/Robin-YB/p/6668762.html">OSI七层协议模型、TCP/IP四层模型学习笔记</a></li></ul></li></ul><h1 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2.HTTP"></a>2.HTTP</h1><p>HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 <a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a> v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始<a href="https://tools.ietf.org/html/rfc2068">RFC 2068</a> 在1997年发布， 然后在1999年被 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 取代，再在2014年被 <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> /<a href="https://tools.ietf.org/html/rfc7231">7231</a>/<a href="https://tools.ietf.org/html/rfc7232">7232</a>/<a href="https://tools.ietf.org/html/rfc7233">7233</a>/<a href="https://tools.ietf.org/html/rfc7234">7234</a>/<a href="https://tools.ietf.org/html/rfc7235">7235</a>取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。</p><h2 id="HTTP-0-9-1-0"><a href="#HTTP-0-9-1-0" class="headerlink" title="HTTP 0.9 / 1.0"></a>HTTP 0.9 / 1.0</h2><p>0.9和1.0这两个版本，就是最传统的 request – response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 <code>GET</code> 方法，HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：</p><ul><li>在请求中加入了HTTP版本号，如：<code>GET /coolshell/index.html HTTP/1.0</code></li><li>HTTP 开始有 header了，不管是request还是response 都有header了。</li><li>增加了HTTP Status Code 标识相关的状态码。</li><li>还有 <code>Content-Type</code> 可以传输其它的文件了。</li></ul><p>我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：</p><ul><li>一个协议有没有版本管理，是一个工程化的象征。</li><li>header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。</li><li>Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。</li></ul><p>（注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）</p><p>但是，HTTP1.0性能上有一个很大的问题，那就是每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西：</p><ul><li>可以设置 <code>keepalive</code> 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“<strong>HTTP 长链接</strong>” 或是 “<strong>请求响应式的HTTP 持久链接</strong>”。英文叫 HTTP Persistent connection.</li><li>然后支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）</li><li>支持 Chunked Responses ，也就是说，在Response的时候，不必说明 <code>Content-Length</code> 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “<strong>服务端Push模型</strong>”，或是 “<strong>服务端Push式的HTTP 持久链接</strong>”</li><li>还增加了 cache control 机制。</li><li>协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。</li><li>还正式加入了一个很重要的头—— <code>HOST</code>这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。</li><li>正式加入了 <code>OPTIONS</code> 方法，其主要用于 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS – Cross Origin Resource Sharing</a> 应用。</li></ul><p>HTTP/1.1应该分成两个时代，一个是2014年前，一个是2014年后，因为2014年HTTP/1.1有了一组RFC（<a href="https://tools.ietf.org/html/rfc7230">7230</a> /<a href="https://tools.ietf.org/html/rfc7231">7231</a>/<a href="https://tools.ietf.org/html/rfc7232">7232</a>/<a href="https://tools.ietf.org/html/rfc7233">7233</a>/<a href="https://tools.ietf.org/html/rfc7234">7234</a>/<a href="https://tools.ietf.org/html/rfc7235">7235</a>），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：</p><ul><li>一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。</li><li>另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：<ul><li>传统的短链接。</li><li>可重用TCP的的长链接模型。</li><li>服务端push的模型。</li><li>WebSocket模型。</li></ul></li></ul><p>自从2005年以来，整个世界的应用API越来多，这些都造就了整个世界在推动HTTP的前进，我们可以看到，<strong>自2014的HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向HTTP看齐了，也许2014年前，还有一些专用的RPC协议，但是2014年以后，HTTP协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。</strong></p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然HTTP/1.1 可以重用TCP链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个HTTP请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。</p><p>另外，HTTP/1.1传输数据时，是以文本的方式，借助耗CPU的zip压缩的方式减少网络带宽，但是耗了前端和后端的CPU。这也是为什么很多RPC协议诟病HTTP的一个原因，就是数据传输的成本比较大。</p><p>其实，在2010年时，Google 就在搞一个实验型的协议，这个协议叫<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>，这个协议成为了HTTP/2的基础（也可以说成HTTP/2就是SPDY的复刻）。HTTP/2基本上解决了之前的这些性能问题，其和HTTP/1.1最主要的不同是：</p><ul><li>HTTP/2是一个二进制协议，增加了数据传输的效率。</li><li>HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。</li><li>HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看<a href="https://tools.ietf.org/html/rfc7541">RFC 7541</a> 附录A）</li><li>HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。</li></ul><p>对于这些性能上的改善，在Medium上有篇文章你可看一下相关的细节说明和测试“<a href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>”</p><p>当然，还需要注意到的是HTTP/2的协议复杂度比之前所有的HTTP协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2还是很快地被世界所采用。</p><p>HTTP/2 是2015年推出的，其发布后，Google 宣布移除对SPDY的支持，拥抱标准的 HTTP/2。过了一年后，就有8.7%的网站开启了HTTP/2，根据 <a href="https://w3techs.com/technologies/details/ce-http2/all/all">这份报告</a> ，截止至本文发布时（2019年10月1日 ）， 在全世界范围内已经有41%的网站开启了HTTP/2。</p><p>HTTP/2的官方组织在 Github 上维护了一份<a href="https://github.com/http2/http2-spec/wiki/Implementations">各种语言对HTTP/2的实现列表</a>，大家可以去看看。</p><p>我们可以看到，HTTP/2 在性能上对HTTP有质的提高，所以，HTTP/2 被采用的也很快，所以，<strong>如果你在你的公司内负责架构的话，HTTP/2是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。</strong></p><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h2><p>然而，这个世界没有完美的解决方案，HTTP/2也不例外，其主要的问题是：若干个HTTP的请求在复用一个TCP的连接，底层的TCP协议是不知道上层有多少个HTTP的请求的，所以，一旦发生丢包，造成的问题就是所有的HTTP请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个HTTP请求的。因为TCP底层是没有这个知识了。</p><p>这个问题又叫<a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-Line Blocking</a>问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自Wikipedia。</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2019/10/HOL_blocking.png" alt="img"></p><p>图中，左边的是输入队列，其中的1，2，3，4表示四个队列，四个队列中的1，2，3，4要去的右边的output的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的3号或1号端口是空闲的，而队列中的要去1和3号端号的数据，被第四号端口给block住了。这就是所谓的HOL blocking问题。</p><p>HTTP/1.1中的pipeline中如果有一个请求block了，那么队列后请求也统统被block住了；HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会block住所有的HTTP请求。这样的问题很讨厌。好像基本无解了。</p><p>是的TCP是无解了，但是UDP是有解的 ！<strong>于是HTTP/3破天荒地把HTTP底层的TCP协议改成了UDP！</strong></p><p>然后又是Google 家的协议进入了标准 – QUIC （Quick UDP Internet Connections）。接下来是QUIC协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《<a href="https://book.douban.com/subject/1088054/">TCP/IP详解</a>》一书（在我写blog的这15年里，这本书推荐了无数次了），或是看一下本站的《<a href="https://coolshell.cn/articles/11564.html">TCP的那些事</a>》。）：</p><ul><li>首先是上面的Head-of-Line blocking问题，在UDP的世界中，这个就没了。这个应该比较好理解，因为UDP不管顺序，不管丢包（当然，QUIC的一个任务是要像TCP的一个稳定，所以QUIC有自己的丢包重传的机制）</li><li>TCP是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在TCP连接建立时，这个慢启动也在，所以导致TCP性能迸发地比较慢。QUIC基于UDP，使用更为激进的方式。同时，QUIC有一套自己的丢包重传和拥塞控制的协，一开始QUIC是重新实现一TCP 的 CUBIC算法，但是随着BBR算法的成熟（BBR也在借鉴CUBIC算法的数学模型），QUIC也可以使用BBR算法。这里，多说几句，<strong>从模型来说，以前的TCP的拥塞控制算法玩的是数学模型，而新型的TCP拥塞控制算法是以BBR为代表的测量模型</strong>，理论上来说，后者会更好，但QUIC的团队在一开始觉得BBR不如CUBIC的算法好，所以没有用。现在的BBR 2.x借鉴了CUBIC数学模型让拥塞控制更公平。这里有文章大家可以一读“<a href="https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437">TCP BBR : Magic dust for network performance.</a>”</li><li>接下来，现在要建立一个HTTPS的连接，先是TCP的三次握手，然后是TLS的三次握手，要整出六次网络交互，一个链接才建好，虽说HTTP/1.1和HTTP/2的连接复用解决这个问题，但是基于UDP后，UDP也得要实现这个事。于是QUIC直接把TCP的和TLS的合并成了三次握手（对此，在HTTP/2的时候，是否默认开启TLS业内是有争议的，反对派说，TLS在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS的那些开销，什么也不算了）。</li></ul><table><thead><tr><th><img data-src="https://coolshell.cn/wp-content/uploads/2019/10/http-request-over-tcp-tls@2x-292x300.png" alt="img"></th><th><img data-src="https://coolshell.cn/wp-content/uploads/2019/10/http-request-over-quic@2x-300x215.png" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>所以，QUIC是一个在UDP之上的伪TCP +TLS +HTTP/2的多路复用的协议。</p><p>但是对于UDP还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么QUIC，他们看QUIC就只能看到的就是UDP，所以，在一些情况下，UDP就是有问题的，</p><ul><li><p>比如在NAT的环境下，如果是TCP的话，NAT路由或是代理服务器，可以通过记录TCP的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在UDP的情况下不行了。于是，QUIC引入了个叫connection id的不透明的ID来标识一个链接，用这种业务ID很爽的一个事是，如果你从你的3G/4G的网络切到WiFi网络（或是反过来），你的链接不会断，因为我们用的是connection id，而不是四元组。</p></li><li><p>然而就算引用了connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做hash把你的请求的IP转到后端的实际的服务器上，然而，他们不懂connection id，只懂四元组，这么导致属于同一个connection id但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的 <a href="https://github.com/facebookincubator/katran">Katran</a> 开源项目 ）</p></li></ul><p>好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2的头压缩算法 HPACK，HPACK需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK的这个数据结构需要在encoder和decoder端同步这个东西。在TCP上，这种同步是透明的，然而在UDP上这个事不好干了。所以，这个事也必需要重新设计了，基于QUIC的QPACK就出来了，利用两个附加的QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来ack对方发过来的update。</p><p>目前看下来，HTTP/3目前看上去没有太多的协议业务逻辑上的东西，更多是HTTP/2 + QUIC协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2要慢的多的多。但是，可以看到QUIC协议的强大，细思及恐，QUIC这个协议真对TCP是个威胁，如果QUIC成熟了，TCP是不是会有可能成为历史呢？</p><p>未来十年，让我们看看UDP是否能够逆袭TCP……</p><h1 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3.HTTPS"></a>3.HTTPS</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>HTTP是不安全的，只需要设定相应的DNS，做一个中间人攻击，再将修改后的数据返回，可能泄露用户隐私数据。然而，当我们切换HTTPS时候，服务端认证不通过，浏览器不会展示相应的页面数据；运营商实施搞的这一套东东也就不能在用户不知情的情况下搞起来了，解决办法是去除相应的受污染的DNS。</p><h3 id="安全的HTTP的需求"><a href="#安全的HTTP的需求" class="headerlink" title="安全的HTTP的需求"></a>安全的HTTP的需求</h3><p>对HTTP的安全需求：</p><ul><li>加密（客户端和服务器的对话是私密的，无须担心被窃听）</li><li>服务端认证（客户端知道它们是在与真正的而不是伪造的服务器通信）</li><li>客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通信）</li><li>完整性（客户端和服务器的数据不会被修改）</li><li>效率（一个运行足够快的算法，一遍低端的客户端和服务器使用）</li><li>普适性（基本上所有的客户端和服务器都支持这些协议）</li><li>管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）</li><li>适应性（能够支持当前最知名的安全方法）</li><li>在社会上的可行性（满足社会的政治文化需要），要有公众受信能力</li></ul><p>在这里面最重要的是前面几条</p><ul><li>数据加密 传输内容进行混淆</li><li>身份验证 通信双方验证对方的身份真实性</li><li>数据完整性保护 检测传输的内容是否被篡改或伪造</li></ul><h3 id="安全HTTP的实现"><a href="#安全HTTP的实现" class="headerlink" title="安全HTTP的实现"></a>安全HTTP的实现</h3><h4 id="加密方式的选择"><a href="#加密方式的选择" class="headerlink" title="加密方式的选择"></a>加密方式的选择</h4><p>共享密钥加密 对称密钥加密</p><p>共享密钥加密方式使用相同的密钥进行加密解密，通信双方都需要接收对方的加密密钥进行数据解密，这种方式在通信过程中必须交互共享的密钥，同样无法避免被网络监听泄漏密钥的问题；同时对于众多客户端的服务器来说还需要分配和管理密钥，对于客户端来说也需要管理密钥，增加设计和实现的复杂度，同时也降低了通信的效率；不用看都不靠谱。</p><p>公开密钥加密</p><p>公开密钥加密方式使用一对非对称的密钥对（私钥和公钥），不公开的作为私钥，随意分发的作为公钥；公钥和私钥都能进行数据加密和解密，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据；这样只需要一套密钥就能处理服务端和众多客户端直接的通信被网络监听泄漏密钥的问题，同时没有额外的管理成本；看起来挺合适。</p><p>没那么简单</p><p>公开密钥加密安全性高，伴随着加密方式复杂，处理速度慢的问题。如果我们的通信都是用公开密钥的方式加密，那么通信效率会很低。</p><p>HTTPS采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。</p><h4 id="认证方式实现"><a href="#认证方式实现" class="headerlink" title="认证方式实现"></a>认证方式实现</h4><p>数字证书</p><p>数字签名是附加在报文上的特殊加密校验码，可以证明是作者编写了这条报文，前提是作者才会有私钥，才能算出这些校验码。如果传输的报文被篡改，则校验码不会匹配，因为校验码只有作者保存的私钥才能产生，所以前面可以保证报文的完整性。</p><p>数字证书认证机构（Certificate Authority CA）是客户端和服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向数字证书认证机构提出证书认证申请，数字证书认证机构在判明申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书（也叫数字证书或证书）后绑定在一起。服务器将这份有数字认证机构颁发的公钥证书发总给客户端，以进行公开密钥加密方式通信。</p><p>EV SSL（Extended Validation SSL Certificate）证书是基于国际标准的认证指导方针办法的证书，通过认证的Web网站能获得更高的认可度。持有EV SSL证书的Web网站的浏览器地址栏的背景色是绿色的，同时在地址栏的左侧显示了SSL证书中记录的组织名称及办法证书的认证机构的名称。</p><p>使用OpenSSL，每个人都可以构建一套认证机构文件，同时可以用来给自己的证书请求进行签名，这种方式产生的证书称为自签名证书，这种证书通常是CA自己的证书，用户开发测试的正式，也可以像12306这样的，信不信由你。</p><p>证书信任的方式</p><ul><li><p>操作系统和浏览器内置</p><p>每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此，你也会信任操作系统及浏览器提供商提供和维护的可信任机构。</p><p>受信认证机构（也有不受信的，比如赛门铁克，沃通，或者像2011年被入侵的DigiNotar等）的证书一般会被操作系统或者浏览器在发行或者发布时内置。</p></li><li><p>证书颁发机构</p><p>CA（ Certificate Authority，证书颁发机构）是被证书接受者（拥有者）和依赖证书的一方共同信任的第三方。</p></li><li><p>手动指定证书</p><p>所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。</p></li></ul><p>PKI（Public Key Infrastructure），即公开密钥基础设施，是国际上解决开放式互联网络信息安全需求的一套体系。PKI支持身份认证，信息传输，存储的完整性，消息传输，存储的机密性以及操作的不可否认性。</p><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>数字签名是只有信息发送者才能产生的别人无法伪造的一段文本，这段文本是对信息发送者发送信息真实性的一个有效证明，具有不可抵赖性。</p><p>报文的发送方从报文文本生成一个128位的散列值（或称为报文摘要活哈希值），发送方使用自己的私钥对这个摘要值进行加密来形成发送方的数字签名。然后这个数字签名将作为报文的附件一起发送给报文的接收方。报文的接收方首先从接收到的原始报文中计算出128位的散列值，再用发送方的公钥来对报文附加的数字签名进行解密。如果两次得到的结果是一致的那么接收方可以确认该数字签名是发送方的，同时确认信息是真实的 。</p><h3 id="HTTPS数据交互过程"><a href="#HTTPS数据交互过程" class="headerlink" title="HTTPS数据交互过程"></a>HTTPS数据交互过程</h3><p>HTTP中没有加密机制，可以通过SSL（Secure Socket Layer 安全套接层）或TLS（Transport Layer Security 安全层传输协议）的组合使用，加密HTTP的通信内容。</p><p>HTTPS是 HTTP Secure 或 HTTP over SSL。</p><p>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但目前主流的还是SSL3.0和TSL1.0。</p><p>SSL工作在OSI七层模型中的表示层，TCP/IP 四层模型的应用层。</p><p>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。</p><p>SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p><h4 id="SSL记录协议操作"><a href="#SSL记录协议操作" class="headerlink" title="SSL记录协议操作"></a>SSL记录协议操作</h4><ul><li>分段 将每个上层消息分解成不大于2^14（16384）位，然后有选择的进行压缩</li><li>添加MAC 在压缩数据的基础上计算MAC</li><li>加密 消息加上MAC用对称加密方法加密</li><li>添加SSL记录头 内容类型（8位），主版本（8位），副版本（8位），压缩长度（16位）</li></ul><h4 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h4><ul><li>第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数</li><li>第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号</li><li>第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息</li><li>第四阶段 变更密码构件和结束握手协议</li></ul><p>SSL协议两个重要概念，SSL会话，SSL连接；SSL连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello:HandShake       --------&gt;</span><br><span class="line">                                                ServerHello:Handshake</span><br><span class="line">                                               Certificate*:Handshake</span><br><span class="line">                                         ServerKeyExchange*:Handshake</span><br><span class="line">                                        CertificateRequest*:Handshake</span><br><span class="line">                             &lt;--------      ServerHelloDone:Handshake</span><br><span class="line">Certificate*:Handshake</span><br><span class="line">ClientKeyExchange:Handshake</span><br><span class="line">CertificateVerify*:Handshake</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished:Handshake           --------&gt;</span><br><span class="line">                                                   [ChangeCipherSpec]</span><br><span class="line">                             &lt;--------             Finished:Handshake</span><br><span class="line">Application Data             &lt;-------&gt;               Application Data</span><br></pre></td></tr></table></figure><h3 id="客户端服务器数据交互实战"><a href="#客户端服务器数据交互实战" class="headerlink" title="客户端服务器数据交互实战"></a>客户端服务器数据交互实战</h3><h4 id="使用openssl命令"><a href="#使用openssl命令" class="headerlink" title="使用openssl命令"></a>使用openssl命令</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -state -connect q.qunarzz.com:443</span><br></pre></td></tr></table></figure><p>该命令可以显示SSL握手过程，SSL证书链，公钥证书以及其他相关的状态和属性信息。</p><h4 id="使用Wireshark抓取数据包"><a href="#使用Wireshark抓取数据包" class="headerlink" title="使用Wireshark抓取数据包"></a>使用Wireshark抓取数据包</h4><p>相关配置</p><ul><li><p>配置环境变量，同时保证文件路径存在</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSLKEYLOG=/path/to/sslkeylog.log</span><br></pre></td></tr></table></figure></li><li><p>配置Wireshark</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wireshark-&gt;Preference-&gt;Protocols-&gt;SSL-&gt;(Pre)-Master-Secret log filename=&gt;选择上面的路径</span><br></pre></td></tr></table></figure></li></ul><p>抓包操作</p><ul><li><p>在命令行中打开Chrome或者Firefox，确保环境变量被读取;如果不行就用Chrome或者Firefox的开发版。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open /Applications/Firefox.app</span><br><span class="line">open /Applications/Google\ Chrome.app</span><br></pre></td></tr></table></figure></li><li><p>确保$SSLKEYLOGFILE里面有内容了，再往下进行。</p></li><li><p>选择对应网卡，抓包配置为host <a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>，开始抓包</p></li><li><p>使用刚刚打开的浏览器访问一个对应host <a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>下的某个资源，在抓包界面使用ssl过滤数据</p></li><li><p>在抓包界面可以看到对应的SSL握手信息，同时还能看到解密后的应用数据。</p></li></ul><h4 id="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"><a href="#内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）" class="headerlink" title="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"></a>内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）</h4><p>客户端⇒服务器</p><ul><li>Client Hello<ul><li>最高支持的协议版本 如TLS 1.0</li><li>支持的加密算法列表(Cipher Suites)</li><li>支持的压缩算法列表(Compression Methods)</li><li>客户端生成的随机数，稍后用于生成会话密钥</li></ul></li></ul><p>服务器⇒客户端</p><ul><li>Server Hello<ul><li>选定的协议版本</li><li>选定的加密算法</li><li>选定的压缩方法</li><li>服务端生成的随机数，稍后用于生成会话密钥</li></ul></li><li>Certificate 证书内容</li><li>Server Key Exchange, Server Hello Done<ul><li>公钥</li><li>数字签名</li><li>Server Hello Done</li></ul></li></ul><p>客户端⇒服务器</p><ul><li>Client Key Exchange, Change Cipher Spec, Finished<ul><li>公钥</li><li>Change Cipher Spec</li><li>Finished</li></ul></li></ul><p>客户端⇒服务器</p><ul><li>HTTP GET</li></ul><p>服务端⇒客户端</p><ul><li><strong>内容的数据片段信息</strong></li><li>HTTP HTTP/1.1 200 OK</li></ul><p>服务端⇒客户端</p><ul><li>Encrypted Alert</li><li>Alert (Level Warning, Description: Close Notify)</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>《Web性能权威指南》</li><li>《RFC 2246》</li><li>《图解HTTP》</li><li>《HTTP权威指南》</li><li>《HTTPS权威指南 在服务器和Web应用上部署SSL/TLS和PKI》</li><li>《计算机网络系统方法》</li><li>《计算机网络自上而下方法》</li><li>《计算机安全原理与实践》</li><li>《网络安全基础-应用与标准》</li><li>《PKI/CA与数字证书技术大全》</li><li>《SSL与TLS》</li><li>《OpenSSL官方命令文档》</li><li>《OpenSSL与网络信息安全-基础、结构和指令》</li><li>《OpenSSL攻略》</li><li><a href="https://link.zhihu.com/?target=http://SSL%20-%20The%20Wireshark%20Wiki">Wireshark Doc SSL</a></li></ol><h1 id="4-http2-0"><a href="#4-http2-0" class="headerlink" title="4.http2.0"></a>4.http2.0</h1><p><strong>导读</strong></p><p>http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0协议也在被越来越多的网站支持。据统计，截止至2018年8月，已经有27.9%的网站支持http2.0。</p><p>本文将从<strong>概述、原理、实战及检测</strong>等方面来详细介绍http2.0，希望能够加深你的理解。</p><h2 id="什么是http2-0协议？"><a href="#什么是http2-0协议？" class="headerlink" title="什么是http2.0协议？"></a><strong>什么是http2.0协议？</strong></h2><p>在http2.0官网①的描述是：</p><p>http/2 is a replacement for how http is expressed “on the wire.” It is not a ground-up rewrite of the protocol; http methods, status codes and semantics are the same, and it should be possible to use the same APIs as http/1.x (possibly                        with some small additions) to represent the protocol.</p><p>The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a Web site.</p><p>The basis of the work was SPDY, but http/2 has evolved to take the community’s input into account, incorporating several improvements in the process.</p><p>中文总结一下就是：</p><h3 id="●对1-x协议语意的完全兼容"><a href="#●对1-x协议语意的完全兼容" class="headerlink" title="●对1.x协议语意的完全兼容"></a><strong>●对1.x协议语意的完全兼容</strong></h3><p>2.0协议是在1.x基础上的升级而不是重写，1.x协议的方法，状态及api在2.0协议里是一样的。</p><h3 id="●性能的大幅提升"><a href="#●性能的大幅提升" class="headerlink" title="●性能的大幅提升"></a><strong>●性能的大幅提升</strong></h3><p>2.0协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能的优化。</p><h2 id="http2-0优化内容"><a href="#http2-0优化内容" class="headerlink" title="http2.0优化内容"></a><strong>http2.0优化内容</strong></h2><h3 id="01-二进制分帧（Binary-Format）-http2-0的基石"><a href="#01-二进制分帧（Binary-Format）-http2-0的基石" class="headerlink" title="01.二进制分帧（Binary Format）- http2.0的基石"></a><strong>01</strong>.二进制分帧（Binary Format）- http2.0的基石</h3><p>http2.0之所以能够突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p><p>在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee1d0caab8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="02-多路复用-Multiplexing-连接共享"><a href="#02-多路复用-Multiplexing-连接共享" class="headerlink" title="02.多路复用 (Multiplexing) / 连接共享"></a><strong>02</strong>.多路复用 (Multiplexing) / 连接共享</h3><p>在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee1cebfa44?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图展示了一个连接上的多个传输数据流：客户端向服务端传输数据帧stream5，同时服务端向客户端乱序发送stream1和stream3。这次连接上有三个响应请求乱序并行交换。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee1e5c87aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图就是http1.X和http2.0在传输数据时的区别。以货物运输为例再现http1.1与http2.0的场景：</p><p>http1.1过程：货轮1从A地到B地去取货物，取到货物后，从B地返回，然后货轮2在A返回并卸下货物后才开始再从A地出发取货返回，如此有序往返。</p><p>http2.0过程：货轮1、2、3、4、5从A地无序全部出发，取货后返回，然后根据货轮号牌卸载对应货物。</p><p>显然，第二种方式运输货物多，河道的利用率高。</p><h3 id="03-头部压缩（Header-Compression）"><a href="#03-头部压缩（Header-Compression）" class="headerlink" title="03.头部压缩（Header Compression）"></a><strong>03.头部压缩（Header Compression）</strong></h3><p>http1.x的头带有大量信息，而且每次都要重复发送。http/2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p><p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><p>需要注意的是，http 2.0关注的是首部压缩，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p><p>http/2使用的是专门为首部压缩而设计的HPACK②算法。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee3331569a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>从上图可以看到http1.X不支持首部压缩，而http2.0的压缩算法效果最好，发送和接受的数据量都是最少的。</p><h3 id="04-压缩原理"><a href="#04-压缩原理" class="headerlink" title="04.压缩原理"></a><strong>04.压缩原理</strong></h3><p>用header字段表里的索引代替实际的header。</p><p>http/2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p><p>例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee3d18e3b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>完整的列表参考：HPACK Static Table③ 。</p><p>只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1GET &#x2F;index.html</span><br></pre></td></tr></table></figure><p>为什么是 0x8285，而不是 0x0205？这是因为高位设置为 1 表示这个字节是一个完全索引值（key 和 value 都在索引中）。</p><p>类似的，通过高位的标志位可以区分出这个字节是属于一个完全索引值，还是仅索引了 key，还是 key和value 都没有索引(参见：HTTP/2首部压缩的OkHttp3实现④)。</p><p>因为索引表的大小的是有限的，它仅保存了一些常用的 http Header，同时每次请求还可以在表的末尾动态追加新的 http Header 缓存，动态部分称之为 Dynamic Table。Static Table 和 Dynamic Table 在一起组合成了索引表：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee45d07de6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小。</p><p>以常用的 User-Agent 为例，它在静态表中的索引值是 58，它的值是不存在表中的，因为它的值是多变的。第一次请求的时候它的 key 用 58 表示，表示这是一个 User-Agent ，它的值部分会进行霍夫曼编码（如果编码后的字符串变更长了，则不采用霍夫曼编码）。</p><p>服务端收到请求后，会将这个 User-Agent 添加到 Dynamic Table 缓存起来，分配一个新的索引值。客户端下一次请求时，假设上次请求User-Agent的在表中的索引位置是 62， 此时只需要发送 0xBE（同样的，高位置 1），便可以代表：User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36。</p><p>其过程如下图所示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee50805e63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>最终，相同的 Header 只需要发送索引值，新的 Header 会重新加入 Dynamic Table。</p><h3 id="05-请求优先级（Request-Priorities）"><a href="#05-请求优先级（Request-Priorities）" class="headerlink" title="05.请求优先级（Request Priorities）"></a><strong>05.请求优先级（Request Priorities）</strong></h3><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><p>●优先级最高：主要的html</p><p>●优先级高：CSS文件</p><p>●优先级中：js文件</p><p>●优先级低：图片</p><h3 id="06-服务端推送（Server-Push）"><a href="#06-服务端推送（Server-Push）" class="headerlink" title="06.服务端推送（Server Push）"></a><strong>06.服务端推送（Server Push）</strong></h3><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。</p><p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 http1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p><p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee5cbb8b0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>注意两点：</p><p>1、推送遵循同源策略；</p><p>2、这种服务端的推送是基于客户端的请求响应来确定的。</p><p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p><h2 id="http2-0性能瓶颈"><a href="#http2-0性能瓶颈" class="headerlink" title="http2.0性能瓶颈"></a><strong>http2.0性能瓶颈</strong></h2><p>启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。</p><h3 id="01-如何升级http2-0协议"><a href="#01-如何升级http2-0协议" class="headerlink" title="01.如何升级http2.0协议"></a><strong>01.如何升级http2.0协议</strong></h3><p>nginx服务器升级http2.0协议需要满足如下条件：</p><p>1、nginx版本高于1.9.5；</p><p>2、–with-http_ssl_module 跟 –with-http_v2_module</p><p>–with-http_ssl_module模块是因为http2.0协议是一种https协议。</p><h3 id="02-查看你的nginx配置"><a href="#02-查看你的nginx配置" class="headerlink" title="02.查看你的nginx配置"></a><strong>02.查看你的nginx配置</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V </span><br></pre></td></tr></table></figure><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee711d4128?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这个是已经添加了对应模块。没有这两个模块的需要手动编译安装。</p><h3 id="03-找到nginx文件目录"><a href="#03-找到nginx文件目录" class="headerlink" title="03.找到nginx文件目录"></a><strong>03.找到nginx文件目录</strong></h3><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee773a838f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="04-编译安装nginx文件"><a href="#04-编译安装nginx文件" class="headerlink" title="04.编译安装nginx文件"></a><strong>04.编译安装nginx文件</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-http_stub_status_module  --with-http_ssl_module  --with-http_v2_module</span><br></pre></td></tr></table></figure><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee7fbed777?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>然后执行如下命令，进行编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1make2make install</span><br></pre></td></tr></table></figure><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee8673d2af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208ee9fd8cf0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="05-更改nginx配置"><a href="#05-更改nginx配置" class="headerlink" title="05.更改nginx配置"></a><strong>05.更改nginx配置</strong></h3><p>安装结束后将nginx.config文件中443端口添加http2；</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/10/31/16e208eea00bbd84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="06-启动nginx"><a href="#06-启动nginx" class="headerlink" title="06.启动nginx"></a><strong>06.启动nginx</strong></h3><p>最后一步，重启nginx nginx restart（注意不要直接 nginx -s reload ）。这时候你的站点就升级为了http2.0协议了。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a><strong>检测</strong></h4><p>升级完成后，怎么确定自己的站点是http2.0协议呢？一般有如下几种方法：</p><h4 id="●chrome-devtool"><a href="#●chrome-devtool" class="headerlink" title="●chrome devtool"></a><strong>●chrome devtool</strong></h4><p>打开chrome调试工具，在network勾选protocol项，h2代表的是http2.0协议；</p><h4 id="●网站"><a href="#●网站" class="headerlink" title="●网站"></a><strong>●网站</strong></h4><p>SSL lab⑤ 一个SSL服务器检测的网站，对网站进行安全评级，并将检测结果自动生成一个详细的评价报告；</p><h4 id="●插件"><a href="#●插件" class="headerlink" title="●插件"></a><strong>●插件</strong></h4><p>http/2 and SPDY indicator 这是一款检测http2.0和SPDY协议（Google开发的基于TCP的会话层协议）的插件。</p><p>参考资料：</p><p>[1].<a href="https://http2.github.io/">https://http2.github.io/</a></p><p>[2].<a href="http://http2.github.io/http2-spec/compression.html">http://http2.github.io/http2-spec/compression.html</a></p><p>[3].<a href="http://http2.github.io/http2-spec/compression.html#rfc.section.A">http://http2.github.io/http2-spec/compression.html#rfc.section.A</a></p><p>[4].<a href="https://neyoufan.github.io/2017/01/06/android/OkHttp3%E4%B8%AD%E7%9A%84HTTP2%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9/">https://neyoufan.github.io/2017/01/06/android/OkHttp3中的HTTP2首部压缩/</a></p><p>[5].<a href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a></p><h1 id="5-HTTP3-0"><a href="#5-HTTP3-0" class="headerlink" title="5.HTTP3.0"></a>5.HTTP3.0</h1><p>写在前面</p><p>如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。<br>如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复用的强大。<br>如果你刚刚才听说 HTTP2 是下一代互联网协议，如果你刚刚才关注到 TLS1.3 是一个革命性具有里程碑意义的协议，但是这两个协议却一直在被另一个更新兴的协议所影响和挑战。</p><h2 id="1-HTTP2-0和HTTP3-0"><a href="#1-HTTP2-0和HTTP3-0" class="headerlink" title="1. HTTP2.0和HTTP3.0"></a>1. HTTP2.0和HTTP3.0</h2><p>科技永不止步</p><p>我们都知道互联网中业务是不断迭代前进的，像HTTP这种重要的网络协议也是如此，新版本是对旧版本的扬弃。</p><h4 id="1-1-HTTP2-0和TCP的爱恨纠葛"><a href="#1-1-HTTP2-0和TCP的爱恨纠葛" class="headerlink" title="1.1 HTTP2.0和TCP的爱恨纠葛"></a>1.1 HTTP2.0和TCP的爱恨纠葛</h4><p> HTTP2.0是2015年推出的，还是比较年轻的，其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等重要优化使HTTP协议真正上了一个新台阶。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>像谷歌这种重要的公司并没有满足于此，而且想继续提升HTTP的性能，花最少的时间和资源获取极致体验。<br>那么肯定要问HTTP2.0虽然性能已经不错了，还有什么不足吗？ 建立连接时间长(本质上是TCP的问题) ,队头阻塞问题<br>移动互联网领域表现不佳(弱网环境) …<br>熟悉HTTP2.0协议的同学应该知道，这些缺点基本都是由于TCP协议引起的，水能载舟亦能覆舟，其实TCP也很无辜呀！</p><p><img data-src="https://img-blog.csdnimg.cn/20200922123253603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在我们眼里，TCP是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于TCP来实现的。<br>网络环境的改变速度很快，但是TCP协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-基于UDP来开发新一代HTTP协议。</p><h3 id="1-2-谷歌为什么选择UDP"><a href="#1-2-谷歌为什么选择UDP" class="headerlink" title="1.2 谷歌为什么选择UDP"></a>1.2 谷歌为什么选择UDP</h3><p>上面提到，谷歌选择UDP是看似出乎意料的，仔细想一想其实很有道理。</p><p> 我们单纯地看看TCP协议的不足和UDP的一些优点：<br>基于TCP开发的设备和协议非常多，兼容困难<br>TCP协议栈是Linux内部的重要部分，修改和升级成本很大<br>UDP本身是无连接的、没有建链和拆链成本<br>UDP的数据包无队头阻塞问题<br>UDP改造成本小<br>从上面的对比可以知道，谷歌要想从TCP上进行改造升级绝非易事，但是UDP虽然没有TCP为了保证可靠连接而引发的问题，但是UDP本身不可靠，又不能直接用</p><p><img data-src="https://img-blog.csdnimg.cn/20200922123855517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>综合而知，谷歌决定在UDP基础上改造一个具备TCP协议优点的新协议也就顺理成章了，这个新协议就是QUIC协议。</p><h3 id="1-3-QUIC协议和HTTP3-0"><a href="#1-3-QUIC协议和HTTP3-0" class="headerlink" title="1.3 QUIC协议和HTTP3.0"></a>1.3 QUIC协议和HTTP3.0</h3><p>QUIC其实是Quick UDP Internet Connections的缩写，直译为快速UDP互联网连接。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124004308.png#pic_center" alt="在这里插入图片描述"></p><p>我们来看看维基百科对于QUIC协议的一些介绍：<br>QUIC协议最初由Google的Jim Roskind设计，实施并于2012年部署，在2013年随着实验的扩大而公开宣布，并向IETF进行了描述。<br>QUIC提高了当前正在使用TCP的面向连接的Web应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。<br>QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。<br>HTTP3.0又称为HTTP Over QUIC，其弃用TCP协议，改为使用基于UDP协议的QUIC协议来实现。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124129106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-QUIC详解"><a href="#2-QUIC详解" class="headerlink" title="2.QUIC详解"></a>2.QUIC详解</h2><p>择其善者而从之，其不善者而改之。</p><p>HTTP3.0既然选择了QUIC协议，也就意味着HTTP3.0基本继承了HTTP2.0的强大功能，并且进一步解决了HTTP2.0存在的一些问题，同时必然引入了新的问题</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124303607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>QUIC协议必须要实现HTTP2.0在TCP协议上的重要功能，同时解决遗留问题，我们来看看QUIC是如何实现的。</p><h3 id="2-1-队头阻塞问题"><a href="#2-1-队头阻塞问题" class="headerlink" title="2.1 队头阻塞问题"></a>2.1 队头阻塞问题</h3><p> 队头阻塞 Head-of-line blocking（缩写为HOL blocking）是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包，它不来大家都走不了。</p><p>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124452630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。</p><p>TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。</p><p>多路复用是 HTTP2 最强大的特性 ，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞 ，如下图示：</p><p><img data-src="https://img-blog.csdnimg.cn/20200922135620387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。</p><p>但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。</p><p>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞</p><p><img data-src="https://img-blog.csdnimg.cn/20200922135807354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p> QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。</p><p>QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。</p><p>这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p><p>QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题</p><p>2.2 0RTT 建链<br> 衡量网络建链的常用指标是RTT Round-Trip Time，也就是数据包一来一回的时间消耗。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124623833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124649743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>一般来说HTTPS协议要建立完整链接包括:TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少1个RTT才可以完成握手。</p><p>然而，QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件的。</p><p> 0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</p><p>传输层 0RTT 就能建立连接</p><p>加密层 0RTT 就能建立加密连接</p><p><img data-src="https://img-blog.csdnimg.cn/20200922132748609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption，也需要至少 2 个 RTT。<br>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密 的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket 要高很多。<br> 简单来说，基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据。</p><p>但是QUIC则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922124817379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>QUIC的0RTT也是需要条件的，对于第一次交互的客户端和服务端0RTT也是做不到的，毕竟双方完全陌生。<br>因此，QUIC协议可以分为首次连接和非首次连接，两种情况进行讨论。</p><h3 id="2-2-1-首次连接和非首次连接"><a href="#2-2-1-首次连接和非首次连接" class="headerlink" title="2.2.1 首次连接和非首次连接"></a>2.2.1 首次连接和非首次连接</h3><p> 使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。</p><h3 id="2-2-2-首次连接"><a href="#2-2-2-首次连接" class="headerlink" title="2.2.2 首次连接"></a>2.2.2 首次连接</h3><p> 简单来说一下，首次连接时客户端和服务端的密钥协商和数据传输过程，其中涉及了DH算法的基本过程：</p><p><img data-src="https://img-blog.csdnimg.cn/20200922125205577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img data-src="https://img-blog.csdnimg.cn/20200922125320566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-3-非首次连接"><a href="#2-2-3-非首次连接" class="headerlink" title="2.2.3 非首次连接"></a>2.2.3 非首次连接</h3><p> 前面提到客户端和服务端首次连接时服务端传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互。<br> 客户端保存config是有时间期限的，在config失效之后仍然需要进行首次连接时的密钥交换。</p><h2 id="2-3-前向安全问题"><a href="#2-3-前向安全问题" class="headerlink" title="2.3 前向安全问题"></a>2.3 前向安全问题</h2><p>前向安全是密码学领域的专业术语，看下百度上的解释：</p><p>前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。<br>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此<br>通俗来说，前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922125953787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-4-前向纠错"><a href="#2-4-前向纠错" class="headerlink" title="2.4 前向纠错"></a>2.4 前向纠错</h2><p> 前向纠错是通信领域的术语，看下百科的解释：<br>前向纠错也叫前向纠错码Forward Error Correction 简称FEC;是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输。<br>FEC是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。<br> 听这段描述就是做校验的，看看QUIC协议是如何实现的：<br>QUIC每发送一组数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错。</p><h2 id="2-5-连接迁移"><a href="#2-5-连接迁移" class="headerlink" title="2.5 连接迁移"></a>2.5 连接迁移</h2><p>网络切换几乎无时无刻不在发生。</p><p> TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据。<br> QUIC协议基于UDP实现摒弃了五元组的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。<br> 基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922130333415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-6-改进的拥塞控制"><a href="#2-6-改进的拥塞控制" class="headerlink" title="2.6 改进的拥塞控制"></a>2.6 改进的拥塞控制</h2><p> TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复</p><p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法 ，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</p><p>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</p><h3 id="2-6-1-可插拔"><a href="#2-6-1-可插拔" class="headerlink" title="2.6.1 可插拔"></a>2.6.1 可插拔</h3><p> 什么叫可插拔呢？就是能够非常灵活地生效，变更和停止,体现在如下方面：<br>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。<br>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。<br>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</p><h3 id="2-6-2单调递增的-Packet-Number"><a href="#2-6-2单调递增的-Packet-Number" class="headerlink" title="2.6.2单调递增的 Packet Number"></a>2.6.2单调递增的 Packet Number</h3><p> TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。<br> QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。<br> 而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题</p><p><img data-src="https://img-blog.csdnimg.cn/20200922133727910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。</p><p>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。</p><p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922133916874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p><p> 但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922134146426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。<br>Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset<br>来保证应用数据的顺序。<br>如图所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的Offset 分别是 x 和 x+y。<br>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。</p><h3 id="2-6-3-不允许-Reneging"><a href="#2-6-3-不允许-Reneging" class="headerlink" title="2.6.3 不允许 Reneging"></a>2.6.3 不允许 Reneging</h3><p> 什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容 。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。</p><p> Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。</p><p> QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。</p><h3 id="2-6-4-更多的-Ack-块"><a href="#2-6-4-更多的-Ack-块" class="headerlink" title="2.6.4 更多的 Ack 块"></a>2.6.4 更多的 Ack 块</h3><p> TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</p><p> 由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 ，所以留给 Sack 选项的只有 30 个字节。</p><p> 每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。</p><p> 但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。</p><h3 id="2-6-5-Ack-Delay-时间"><a href="#2-6-5-Ack-Delay-时间" class="headerlink" title="2.6.5 Ack Delay 时间"></a>2.6.5 Ack Delay 时间</h3><p> Tcp 的 Timestamp 选项存在一个问题 ，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。</p><p>这样就会导致 RTT 计算误差。如下图：</p><p><img data-src="https://img-blog.csdnimg.cn/20200922134723577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>可以认为 TCP 的 RTT 计算：<img data-src="https://img-blog.csdnimg.cn/20200922134807851.png#pic_center" alt="在这里插入图片描述"></p><p>而 Quic 计算如下：<img data-src="https://img-blog.csdnimg.cn/20200922134824234.png#pic_center" alt="在这里插入图片描述"></p><p>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式:<img data-src="https://img-blog.csdnimg.cn/20200922134848538.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-6-6-基于-stream-和-connecton-级别的流量控制"><a href="#2-6-6-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="2.6.6 基于 stream 和 connecton 级别的流量控制"></a>2.6.6 基于 stream 和 connecton 级别的流量控制</h3><p> QUIC 的流量控制 类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</p><p>Stream 可以认为就是一条 HTTP 请求。</p><p>Connection 可以类比一条 TCP 连接。</p><p>多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</p><p>QUIC 实现流量控制的原理比较简单：</p><p>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。<br>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。<br>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。<br>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</p><p><img data-src="https://img-blog.csdnimg.cn/20200922135106709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>针对 Stream：<img data-src="https://img-blog.csdnimg.cn/20200922135129300.png#pic_center" alt="在这里插入图片描述"></p><p>针对 Connection：<img data-src="https://img-blog.csdnimg.cn/20200922135146282.png#pic_center" alt="在这里插入图片描述"></p><p>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。<br>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>QUIC协议 存在的意义在于解决 TCP 协议的一些无法解决的痛点</p><ul><li>多次握手：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点</li><li>队头阻塞：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。</li><li>无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制</li><li>无法进行连接迁移：一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。<br>现在我们给出一个 QUIC 协议的 Overview</li><li>更好的连接建立方式</li><li>更好的拥塞控制</li><li>没有队头阻塞的多路复用</li><li>前向纠错</li><li>连接迁移</li></ul><h1 id="6-websocket协议"><a href="#6-websocket协议" class="headerlink" title="6.websocket协议"></a>6.websocket协议</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于HTTP协议，HTTP协议有一个的缺陷为：通信只能由客户端发起。在一些场景下，这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><h2 id="websocket-协议概述"><a href="#websocket-协议概述" class="headerlink" title="websocket 协议概述"></a>websocket 协议概述</h2><p>Webscoket是Web浏览器和服务器之间的一种全双工通信协议，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。<br>WS（WebSocket）与HTTP协议相比，</p><p>相同点主要有：</p><ul><li><p>都是基于TCP的应用层协议；</p></li><li><p>都使用Request/Response模型进行连接的建立；</p></li><li><p>在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码；</p></li><li><p>都可以在网络中传输数据。</p></li></ul><p>不同之处在于：</p><ul><li>WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用；</li><li>WS的连接不能通过中间人来转发，它必须是一个直接连接；</li><li>WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据；</li><li>WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息；</li><li>WS的数据帧有序。</li><li>websocket 通信过程及对应报文分析<br>WS整个通信过程如下图所示：</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200527233222508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img data-src="https://img-blog.csdnimg.cn/20200527233246458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70" alt="img"></p><p>websocket是基于TCP的一个应用协议，与HTTP协议的关联之处在于websocket的握手数据被HTTP服务器当作HTTP包来处理，主要通过Update request HTTP包建立起连接，之后的通信全部使用websocket自己的协议。</p><p><strong>请求：</strong>TCP连接建立后，客户端发送websocket的握手请求，请求报文头部如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;uin&#x3D;xxxxxxxx&amp;app&#x3D;xxxxxxxxx&amp;token&#x3D;XXXXXXXXXXXX HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.cn:443</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;81.0.4044.138 Safari&#x2F;537.36</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Cookie: user_id&#x3D;XXXXX</span><br><span class="line">Sec-WebSocket-Key: 1&#x2F;2hTi&#x2F;+eNURiekpNI4k5Q&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Protocol: binary, base64</span><br></pre></td></tr></table></figure><ul><li>第一行为为请求的方法，类型必须为GET，协议版本号必须大于1.1</li><li>Upgrade字段必须包含，值为websocket</li><li>Connection字段必须包含，值为Upgrade</li><li>Sec-WebSocket-Key字段必须包含 ，记录着握手过程中必不可少的键值。</li><li>Sec-WebSocket-Protocol字段必须包含 ，记录着使用的子协议</li><li>Origin（请求头）：Origin用来指明请求的来源，Origin头部主要用于保护Websocket服务器免受非授权的跨域脚本调用Websocket API的请求。也就是不想没被授权的跨域访问与服务器建立连接，服务器可以通过这个字段来判断来源的域并有选择的拒绝。</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200527233303721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70" alt="img"></p><p>第一行为为请求的方法，类型必须为GET，协议版本号必须大于1.1<br>Upgrade字段必须包含，值为websocket<br>Connection字段必须包含，值为Upgrade<br>Sec-WebSocket-Key字段必须包含 ，记录着握手过程中必不可少的键值。<br>Sec-WebSocket-Protocol字段必须包含 ，记录着使用的子协议<br>Origin（请求头）：Origin用来指明请求的来源，Origin头部主要用于保护Websocket服务器免受非授权的跨域脚本调用Websocket API的请求。也就是不想没被授权的跨域访问与服务器建立连接，服务器可以通过这个字段来判断来源的域并有选择的拒绝。</p><p><strong>响应：</strong>服务器接收到请求后，返回状态码为101 Switching Protocols 的响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Server: WebSockify Python&#x2F;2.6.6</span><br><span class="line">Date: Wed, 27 May 2020 03:03:21 GMT</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: hXXXXXXXXXXXXXXxGmM&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: binary</span><br></pre></td></tr></table></figure><p>Sec-WebSocket-Accept字段是由握手请求中的Sec-WebSocket-Key字段生层的。</p><p>握手成功后，通信不再使用HTTP协议，而采用WebSocket独立的数据帧。如下图所示，为协议帧格式：</p><p><img data-src="https://img-blog.csdnimg.cn/20200527233345809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FIN，指明Frame是否是一个Message里最后Frame（之前说过一个Message可能又多个Frame组成）；1bit，是否为信息的最后一帧</span><br><span class="line">RSV1-3，默认是0 (必须是0)，除非有扩展定义了非零值的意义。</span><br><span class="line">Opcode，这个比较重要，有如下取值是被协议定义的</span><br><span class="line">0x00 denotes a continuation frame</span><br><span class="line">0x01 表示一个text frame</span><br><span class="line">0x02 表示一个binary frame</span><br><span class="line">0x03 ~~ 0x07 are reserved for further non-control frames,为将来的非控制消息片段保留测操作码</span><br><span class="line">0x08 表示连接关闭</span><br><span class="line">0x09 表示 ping (心跳检测相关)</span><br><span class="line">0x0a 表示 pong (心跳检测相关)</span><br><span class="line">0x0b ~~ 0x0f are reserved for further control frames,为将来的控制消息片段保留的操作码</span><br><span class="line">Mask，这个是指明“payload data”是否被计算掩码。这个和后面的Masking-key有关，如果设置为1,掩码键必须放在masking-key区域，客户端发送给服务端的所有消息，此位的值都是1；</span><br><span class="line">Payload len，数据的长度，</span><br><span class="line">Masking-key，0或者4bit，只有当MASK设置为1时才有效。，给一个Websocket中掩码的意义</span><br><span class="line">Payload data，帧真正要发送的数据，可以是任意长度，但尽管理论上帧的大小没有限制，但发送的数据不能太大，否则会导致无法高效利用网络带宽，正如上面所说Websocket提供分片。</span><br><span class="line">Extension data：扩展数据，如果客户端和服务端没有特殊的约定，那么扩展数据长度始终为0</span><br><span class="line">Application data：应用数据，</span><br></pre></td></tr></table></figure><p>websocket 报文细节，这里由于client 和 server 端的 ip 都是127.0.0.1 ：</p><p><img data-src="https://img-blog.csdnimg.cn/20200527233405188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="nginx-支持websocket-配置"><a href="#nginx-支持websocket-配置" class="headerlink" title="nginx 支持websocket 配置"></a>nginx 支持websocket 配置</h2><p>由于http 请求 涉及 反向代理 所以就涉及 nginx 配置需要支持 websocket 需要做一些特殊的配置；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 配置Nginx支持webSocket开始</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200527233424850.png" alt="img"></p><p>其他通过代码模拟websocket 的代码可以查阅其他博客内容，这里就不赘述；</p><p><a href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p><h1 id="7-TCP"><a href="#7-TCP" class="headerlink" title="7.TCP"></a>7.TCP</h1><p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看<a href="http://www.kohala.com/start/">W.Richard Stevens</a>的《<a href="http://book.douban.com/subject/1088054/">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下<a href="http://tools.ietf.org/html/rfc793">RFC793</a>以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p><p>之所以想写这篇文章，目的有三个，</p><ul><li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li><li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li><li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li></ul><p>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层（传输层），IP在第三层——Network层（网络层），ARP在第二层——Data Link层（数据链路层），在第二层上的数据，我们叫Frame（帧），在第三层上的数据叫Packet（数据包），第四层的数据叫Segment（片段）。</p><p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p><p><a href="https://coolshell.cn/articles/11564.html#TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F">TCP头格式</a><a href="https://coolshell.cn/articles/11564.html#TCP%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA">TCP的状态机</a><a href="https://coolshell.cn/articles/11564.html#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84Sequence_Number">数据传输中的Sequence Number</a><a href="https://coolshell.cn/articles/11564.html#TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">TCP重传机制</a><a href="https://coolshell.cn/articles/11564.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a><a href="https://coolshell.cn/articles/11564.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">快速重传机制</a><a href="https://coolshell.cn/articles/11564.html#SACK_%E6%96%B9%E6%B3%95">SACK 方法</a><a href="https://coolshell.cn/articles/11564.html#Duplicate_SACK_%E2%80%93_%E9%87%8D%E5%A4%8D%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98">Duplicate SACK – 重复收到数据的问题</a></p><h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p>接下来，我们来看一下TCP头的格式</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/TCP-Header-01.jpg" alt="img">TCP头格式（<a href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）</p><p>你需要注意这么几点：</p><ul><li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li><li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window又叫Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong> ，也就是包的类型，<strong>主要是用于操控TCP的状态机的</strong>。</li></ul></li></ul><p>关于其它的东西，可以参看下面的图示</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/TCP-Header-02.jpg" alt="img"></p><p>（<a href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）</p><h2 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h2><p>其实，<strong>网络上的传输是没有连接的，包括TCP也是一样的</strong>。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p><p>下面是：“<strong>TCP协议的状态机</strong>”（<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">图片来源</a>） 和 “<strong>TCP建链接</strong>”、“<strong>TCP断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcpfsm.png" alt="img"> <img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_open_close.jpg" alt="img"></p><p>很多人会问，为什么建立链接要3次握手，断链接需要4次挥手？</p><ul><li><p><strong>对于建链接的3次握手，</strong>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p></li><li><p><strong>对于4次挥手，</strong>其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</p></li></ul><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcpclosesimul.png" alt="img"><br>两端同时断连接（<a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">图片来源</a>）</p><p>另外，有几个事情需要注意一下：</p><ul><li><p><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p></li><li><p><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫<strong>tcp_syncookies</strong>的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，<strong>请先千万别用tcp_syncookies来处理正常的大负载的连接的情况</strong>。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</p></li><li><p><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p></li><li><p><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（<a href="http://tools.ietf.org/html/rfc793">RFC793</a>定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</p></li><li><p><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫<strong>tcp_tw_reuse</strong>，另一个叫<strong>tcp_tw_recycle</strong>的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">官方文档</a>上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。</p></li><li><ul><li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li></ul></li><li><ul><li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码<a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process"> tcp_timewait_state_process</a>）。</li></ul></li><li><ul><li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li></ul></li></ul><p><strong>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122">RFC 1122</a>）</strong> </p><p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p><h2 id="数据传输中的Sequence-Number"><a href="#数据传输中的Sequence-Number" class="headerlink" title="数据传输中的Sequence Number"></a>数据传输中的Sequence Number</h2><p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_data_seq_num.jpg" alt="img"></p><p>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p><p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p><h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p><p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p><p>对此有两种选择：</p><ul><li>一种是仅重传timeout的包。也就是第3份数据。</li><li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li></ul><p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p><h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>于是，TCP引入了一种叫<strong>Fast Retransmit</strong> 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p><p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/FASTIncast021.png" alt="img"></p><p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p><h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>另外一种更好的方式叫：**Selective Acknowledgment (SACK)**（参看<a href="http://tools.ietf.org/html/rfc2018">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_sack_example-1024x577.jpg" alt="img"></p><p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过<strong>tcp_sack</strong>参数打开这个功能（Linux 2.4后默认打开）。</p><p>这里还需要注意一个问题——<strong>接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</strong></p><p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/">TCP SACK的性能权衡</a>》</p><h3 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h3><p>Duplicate SACK又称D-SACK，<strong>其主要使用了SACK来告诉发送方有哪些数据被重复接收了</strong>。<a href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883 </a>里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>）</p><p>D-SACK使用了SACK的第一个段来做标志，</p><ul><li><p>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</p></li><li><p>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</p></li></ul><h4 id="示例一：ACK丢包"><a href="#示例一：ACK丢包" class="headerlink" title="示例一：ACK丢包"></a><strong>示例一：ACK丢包</strong></h4><p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p><p>  Transmitted  Received    ACK Sent</p><p>  Segment      Segment     (Including SACK Blocks)</p><p>  3000-3499    3000-3499   3500 (ACK dropped)</p><p>  3500-3999    3500-3999   4000 (ACK dropped)</p><p>  3000-3499    3000-3499   4000, SACK=3000-3500</p><p>​                                        -——–</p><h4 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a><strong>示例二，网络延误</strong></h4><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p><p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p><p>​    Transmitted    Received    ACK Sent</p><p>​    Segment        Segment     (Including SACK Blocks)</p><p>​    500-999        500-999     1000</p><p>​    1000-1499      (delayed)</p><p>​    1500-1999      1500-1999   1000, SACK=1500-2000</p><p>​    2000-2499      2000-2499   1000, SACK=1500-2500</p><p>​    2500-2999      2500-2999   1000, SACK=1500-3000</p><p>​    1000-1499      1000-1499   3000</p><p>​                   1000-1499   3000, SACK=1000-1500</p><p>​                                          -——–</p><p>可见，引入了D-SACK，有这么几个好处：</p><p>1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p><p>2）是不是自己的timeout太小了，导致重传。</p><p>3）网络上出现了先发的包后到的情况（又称reordering）</p><p>4）网络上是不是把我的数据包给复制了。</p><p> <strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控</strong>。</p><p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p><h2 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h2><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p><ul><li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><p><a href="http://tools.ietf.org/html/rfc793">RFC793</a> 中定义的经典算法是这样的：</p><p>1）首先，先采样RTT，记下最近好几次的RTT值。</p><p>2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p><p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p><p>3）开始计算RTO。公式如下：</p><p><strong>RTO = min [ UBOUND,  max [ LBOUND,  (β * SRTT) ]  ]</strong></p><p>其中：</p><ul><li>UBOUND是最大的timeout时间，上限值</li><li>LBOUND是最小的timeout时间，下限值</li><li>β 值一般在1.3到2.0之间。</li></ul><h4 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h4><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p><p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p><ul><li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li><li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li></ul><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/Karn-Partridge-Algorithm.jpg" alt="img"></p><p>所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn's_Algorithm">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p><p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p><h4 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h4><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p><p><strong>SRTT= SRTT + α(RTT – SRTT)</strong>  —— 计算平滑RTT</p><p><strong>DevRTT = (1-β)<em>DevRTT + β</em>(|RTT-SRTT|)</strong> ——计算平滑RTT和真实的差距（加权移动平均）</p><p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p><p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/sliding_window.jpg" alt="img"></p><p>上图中，我们可以看到：</p><ul><li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p></li><li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p></li></ul><p>于是：</p><ul><li><p>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</p></li><li><p>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</p></li></ul><p>下面我们来看一下发送方的滑动窗口示意图：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcpswwindows.png" alt="img"></p><p>（<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">图片来源</a>）</p><p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p><ul><li>#1已收到ack确认的数据。</li><li>#2发还没收到ack的。</li><li>#3在窗口中还没有发出的（接收方还有空间）。</li><li>#4窗口以外的数据（接收方没空间）</li></ul><p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcpswslide.png" alt="img"></p><p>下面我们来看一个接受端控制发送端的图示：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcpswflow.png" alt="img"></p><p>（<a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">图片来源</a>）</p><h4 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h4><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p><p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p><p><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress">Wikipedia的SockStress词条</a>）</p><p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p><h4 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h4><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 <a href="http://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p><p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p><p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p><ul><li><p>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</p></li><li><p>如果这个问题是由Sender端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</p></li></ul><p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p><p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<strong>char</strong> *)&amp;value,sizeof(<strong>int</strong>));</p><p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p><h2 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h2><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p><p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</strong>这是一个灾难。</p><p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p><p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)</p><p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p><ul><li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li><li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li></ul><h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h3><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p><p>慢启动的算法如下(cwnd全称Congestion Window)：</p><p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p><p>2）每当收到一个ACK，cwnd++; 呈线性上升</p><p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p><p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p><p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp.slow_.start_.jpg" alt="img"></p><p>这里，我需要提一下的是一篇Google的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p><h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h3><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p><p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p><p>2）当每过一个RTT时，cwnd = cwnd + 1</p><p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p><h3 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h3><p>前面我们说过，当丢包的时候，会有两种情况：</p><p>1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p><ul><li><ul><li>sshthresh =  cwnd /2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ul></li></ul><p>2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p><ul><li><ul><li>TCP Tahoe的实现和RTO超时一样。</li></ul></li><li><ul><li>TCP Reno的实现是：<ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li><li>进入快速恢复算法——Fast Recovery</li></ul></li></ul></li></ul><p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p><h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h3><p><strong>TCP Reno</strong></p><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li></ul><p>然后，真正的Fast Recovery算法如下：</p><ul><li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li><li>重传Duplicated ACKs指定的数据包</li><li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li><li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li></ul><p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p><p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p><p><strong>TCP New Reno</strong></p><p>于是，1995年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p><ul><li><p>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</p></li><li><p>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</p></li></ul><p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p><h5 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h5><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp.fr_-1024x359.jpg" alt="img"></p><h5 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h5><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p><ul><li><p>这个算法会把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</p></li><li><p>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</p></li><li><p>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd是传出去的数据 + 重传的数据。</p></li><li><p>然后触发Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</p></li></ul><p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p><h3 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h3><h4 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h4><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了Vegas和 New Reno的对比：</p><p><img data-src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_vegas_newreno-1024x555.jpg" alt="img"></p><p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c">/net/ipv4/tcp_vegas.c</a></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h4><p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p><ul><li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li><li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li></ul><p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c">/net/ipv4/tcp_highspeed.c</a></p><h4 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h4><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr:lang_1zh-CN%7Clang_1zh-TW&q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c">/net/ipv4/tcp_bic.c</a></p><h4 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h4><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。  关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c">/net/ipv4/tcp_westwood.c</a></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p><p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p><h1 id="8-UDP"><a href="#8-UDP" class="headerlink" title="8.UDP"></a>8.UDP</h1><p>UDP数据报</p><h2 id="一、UDP的概述（User-Datagram-Protocol，用户数据报协议）"><a href="#一、UDP的概述（User-Datagram-Protocol，用户数据报协议）" class="headerlink" title="一、UDP的概述（User Datagram Protocol，用户数据报协议）"></a><strong>一、UDP的概述（User Datagram Protocol，用户数据报协议）</strong></h2><p>UDP是<strong>传输层</strong>的协议，功能即为在IP的数据报服务之上增加了最基本的服务：<strong>复用</strong>和<strong>分用</strong>以及<strong>差错检测</strong>。<br>UDP提供<strong>不可靠</strong>服务，具有TCP所没有的<strong>优势</strong>：</p><ul><li>UDP<strong>无连接</strong>，时间上<strong>不存在建立连接需要的时延</strong>。空间上，TCP需要在端系统中<strong>维护连接</strong>状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。<br>举个例子：<br>DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。<br>HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，<strong>可靠性</strong>很重要。<br>同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。</li><li>分组首部开销小**，TCP首部20字节，UDP首部8字节。</li><li><strong>UDP没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，<strong>能容 忍一些数据的丢失，但是不能允许有较大的时延</strong>（比如实时视频，直播等）</li><li>UDP<strong>提供尽最大努力的交付</strong>，不保证可靠交付。所有维护传输可靠性的工作需要用户在<strong>应用层</strong>来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息</li><li>UDP是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。<br>正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</li><li>UDP<strong>常用一次性传输比较少量数据的网络应用</strong>，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的</li></ul><h2 id="二、UDP的首部格式"><a href="#二、UDP的首部格式" class="headerlink" title="二、UDP的首部格式"></a><strong>二、UDP的首部格式</strong></h2><p>UDP数据报分为<strong>首部</strong>和<strong>用户数据部分</strong>，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示：</p><p><img data-src="https://pic4.zhimg.com/80/v2-5802c1b70343ab580e72a6005f5a6207_720w.jpg" alt="img"></p><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置0.<br>2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。<br>3.<strong>长度</strong>：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）<br>4.<strong>校验和</strong>：检测UDP数据报在传输中是否有错，有错则丢弃。<br>该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.<br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。<br>如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。<br>UDP校验<br>在计算校验和的时候，需要在UDP数据报之前增加<strong>12字节的伪首部</strong>，伪首部并不是UDP真正的首部。只是在计算校验和，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而<strong>仅仅是为了计算校验和</strong>。这样的校验和，既<strong>检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。</strong></p><p><img data-src="https://pic1.zhimg.com/80/v2-2e61d2cf1a9cb712b4c92a1e17984e74_720w.jpg" alt="img"></p><p>UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP数据报的校验和之检验IP数据报和首部，但UDP的校验和是把首部和数据部分一起校验。<br>发送方，首先是把<strong>全零放入校验和字段</strong>并且添加<strong>伪首部</strong>，然后把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得UDP数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些16位字的和。<strong>当无差错时其结果全为1</strong>,。否则就表明有差错出现，接收方应该丢弃这个UDP数据报。</p><p><img data-src="https://pic3.zhimg.com/80/v2-74d21374dcc643813758af9e6ae333de_720w.jpg" alt="img"></p><p>注意：<br>1.校验时，若UDP数据报部分的长度不是偶数个字节，则需要填入一个全0字节，但是次字节和伪首部一样，是不发送的。<br>2.如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。<br>3.通过伪首部，不仅可以检查源端口号，目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。<br>这种差错检验的检错能力不强，但是简单，速度快<a href="https://link.zhihu.com/?target=https://blog.csdn.net/blogdevteam/article/details/90369522">https://link.zhihu.com/?target=https%3A//blog.csdn.net/blogdevteam/article/details/90369522</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络的相关内容，这部分上过专业课的，只是电院的专业课讲得不是太深，还是需要自己买书重学，这也是前端必备的计算机基础了，这一块内容要背的有点多&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="计算机网络" scheme="https://hxy1997.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="计算机基础" scheme="https://hxy1997.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目部署到Gitee Pages和GitHub Pages</title>
    <link href="https://hxy1997.xyz/2021/03/11/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Gitee%20Pages%E5%92%8CGitHub%20Pages/"/>
    <id>https://hxy1997.xyz/2021/03/11/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0Gitee%20Pages%E5%92%8CGitHub%20Pages/</id>
    <published>2021-03-11T04:02:39.000Z</published>
    <updated>2021-03-13T06:09:54.572Z</updated>
    
    <content type="html"><![CDATA[<p>使用Gitee Pages实现静态页面（<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器(Gitee Pages)</a> 和<a href="https://hxy1997.xyz/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器(GitHub Pages)</a>）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Pages，实现项目的正式上线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目(Gitee Pages)</a>和<a href="https://hxy1997.xyz/vue_shops/">Vue电商项目(GitHub Pages)</a></p><span id="more"></span><h1 id="一、简单的音乐播放器静态页面"><a href="#一、简单的音乐播放器静态页面" class="headerlink" title="一、简单的音乐播放器静态页面"></a>一、简单的音乐播放器静态页面</h1><h2 id="1-1-将项目提交至gitee"><a href="#1-1-将项目提交至gitee" class="headerlink" title="1.1 将项目提交至gitee"></a>1.1 将项目提交至gitee</h2><p>到Gitee上新建仓库，写仓库名称 选择是否开源 </p><p>使用git remote add origin <a href="https://gitee.com/%E7%A0%81%E4%BA%91%E7%94%A8%E6%88%B7%E5%90%8D/%E9%A1%B9%E7%9B%AE%E5%90%8D">https://gitee.com/码云用户名/项目名</a> / 添加远程仓库。</p><p>git pull origin master 命令，将码云上的仓库pull到先前创建的文件夹中，期间需要输入gitee上面的账号和密码，输入完成密码之后点击 OK。<br>可能会出现以下提示问题：</p><p>这是因为没有配置提交时的用户名和邮箱的原因，你可以直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure><p>完毕之后再把将要上传的文件，全部添加到之前在桌面创建的文件夹中并使用git add .（. 表示所有的）或者 git add 文件名 // 将文件保存到缓存区<br>然后使用git commit -m ‘这里写新推送的文件描述’ //添加文件描述<br>使用git push origin master ，将本地仓库推送到远程仓库，之后去刷新gitee就能看到推送上去的项目了。</p><h2 id="1-2-配置Gitee-Page"><a href="#1-2-配置Gitee-Page" class="headerlink" title="1.2 配置Gitee Page"></a>1.2 配置Gitee Page</h2><p><img data-src="https://www.pianshen.com/images/787/f15acfa42d77a529ca3163842b954a93.png" alt="在这里插入图片描述"></p><p>点击项目导航栏中的<code>服务 --&gt; Gitee Pages</code></p><h2 id="1-3-访问网站"><a href="#1-3-访问网站" class="headerlink" title="1.3 访问网站"></a>1.3 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，我的项目入口文件不是，所以需要，打开<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器</a> 可以享用音乐了</p><h2 id="1-4-将码云库同步到Github库"><a href="#1-4-将码云库同步到Github库" class="headerlink" title="1.4 将码云库同步到Github库"></a>1.4 将码云库同步到Github库</h2><h4 id="步骤一：在github中新建一个项目"><a href="#步骤一：在github中新建一个项目" class="headerlink" title="步骤一：在github中新建一个项目"></a>步骤一：在github中新建一个项目</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-3e82df4fbe5fa3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/776/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤二：在码云中复制要导入github中的git地址"><a href="#步骤二：在码云中复制要导入github中的git地址" class="headerlink" title="步骤二：在码云中复制要导入github中的git地址"></a>步骤二：在码云中复制要导入github中的git地址</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-a04729ae3833d460.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤三：在github平台进入步骤一创建的项目，点击“Import-code”进入导入页面"><a href="#步骤三：在github平台进入步骤一创建的项目，点击“Import-code”进入导入页面" class="headerlink" title="步骤三：在github平台进入步骤一创建的项目，点击“Import code”进入导入页面"></a>步骤三：在github平台进入步骤一创建的项目，点击“Import code”进入导入页面</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-c05082be38fdd50d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1031/format/webp" alt="img"></p><p>image.png</p><h4 id="步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin-import”"><a href="#步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin-import”" class="headerlink" title="步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin import”"></a>步骤四：在导入页面，将步骤二复制出来的码云中项目的git地址，粘贴到“url”中，并点击“Begin import”</h4><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-b2c3d0bbb6f5b7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp" alt="img"></p><p>image.png</p><blockquote><p>注意：有时候步骤四在导入时，会出现一个500异常界面。这时，我们不需要管它，只需要重新进入我们新建的项目，再次从步骤三开始操作即可， 这时候便会看见项目正在导入，稍等一段时间，便会提示你导入成功，最后我们再次访问该项目，便会发现码云中的项目已经导入到github中来了。（导入成功GitHub会发邮件提醒）</p></blockquote><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-80137b7b12df8633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>500异常界面</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15384200-bf599039eac9003d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p><p>再次进入时的导入界面</p><h4 id="步骤五：开启GitHub-Pages"><a href="#步骤五：开启GitHub-Pages" class="headerlink" title="步骤五：开启GitHub Pages"></a>步骤五：开启GitHub Pages</h4><p>点击右上角的 Settings</p><p><img data-src="https://cdn.sspai.com/20190506142601.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p><p>找到 GitHub Pages 选项，设置好后，<a href="https://github用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6">https://Github用户名.github.io/项目名/入口文件</a></p><h1 id="二、使用vue-cli脚手架创建的页面提交至Gitee-Pages"><a href="#二、使用vue-cli脚手架创建的页面提交至Gitee-Pages" class="headerlink" title="二、使用vue-cli脚手架创建的页面提交至Gitee Pages"></a>二、使用vue-cli脚手架创建的页面提交至Gitee Pages</h1><h2 id="2-1-调整本地项目"><a href="#2-1-调整本地项目" class="headerlink" title="2.1 调整本地项目"></a>2.1 调整本地项目</h2><h3 id="在根目录下增加-spa文件"><a href="#在根目录下增加-spa文件" class="headerlink" title="在根目录下增加.spa文件"></a>在根目录下增加.spa文件</h3><p>首先，根据<a href="https://gitee.com/help/articles/4237">官方指示</a></p><p><img data-src="https://www.pianshen.com/images/763/d160e86218b36d31956264b83badf383.png" alt="在这里插入图片描述"></p><p>在项目路径中添加<code>.spa</code>文件</p><p><img data-src="https://www.pianshen.com/images/47/56f6b7fcdf231191cb0eee073e26c65f.png" alt="在这里插入图片描述"></p><p>原理，我不是很清楚，应该是给Nginx做一个<code>标识</code>作用吧。</p><h3 id="配置production版本路径名称"><a href="#配置production版本路径名称" class="headerlink" title="配置production版本路径名称"></a>配置production版本路径名称</h3><p>根目录下的vue.config.js文件，如下图箭头那个要改为项目文件名称</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003141513-937920345.png" alt="img"></p><p>在本地运行<code>npm run build</code>，得到/dist</p><p><img data-src="https://www.pianshen.com/images/168/5518c17f01e39d7a0984962b7276a2e0.png" alt="在这里插入图片描述">`</p><h3 id="配置-gitignore文件"><a href="#配置-gitignore文件" class="headerlink" title="配置.gitignore文件"></a>配置.gitignore文件</h3><p>首先要在.gitignore文件去掉/dist，这个文件默认是不上传的，但是执行打包bulid的时候会生成dist文件，而线上访问的是打包之后的dist文件；</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208002522081-1246305362.png" alt="img"></p><h2 id="2-2-将项目提交至gitee"><a href="#2-2-将项目提交至gitee" class="headerlink" title="2.2 将项目提交至gitee"></a>2.2 将项目提交至gitee</h2><p>参考1.2节的做法，此步不再赘述</p><h2 id="2-3-配置Gitee-Page"><a href="#2-3-配置Gitee-Page" class="headerlink" title="2.3 配置Gitee Page"></a>2.3 配置Gitee Page</h2><p>用上次同样的方法点进Gitee Pages</p><p><img data-src="https://img2018.cnblogs.com/i-beta/475401/202002/475401-20200208002750052-1156032907.png" alt="img"></p><p>这一次部署目录要填写dist</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003016869-817429112.png" alt="img"></p><h2 id="2-4-访问网站"><a href="#2-4-访问网站" class="headerlink" title="2.4 访问网站"></a>2.4 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，这次vue-cli创建的项目不需要，打开线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目</a> 就可以体验电商项目了</p><h1 id="三、使用vue-cli脚手架创建的页面提交至GitHub-Pages"><a href="#三、使用vue-cli脚手架创建的页面提交至GitHub-Pages" class="headerlink" title="三、使用vue-cli脚手架创建的页面提交至GitHub Pages"></a>三、使用vue-cli脚手架创建的页面提交至GitHub Pages</h1><h2 id="3-1-GitHub-Pages服务说明与注意事项"><a href="#3-1-GitHub-Pages服务说明与注意事项" class="headerlink" title="3.1 GitHub Pages服务说明与注意事项"></a>3.1 GitHub Pages服务说明与注意事项</h2><p>在你的github项目设置的GitHub Pages项，有这么一句话：</p><blockquote><p><a href="https://pages.github.com/">GitHub Pages</a> is designed to host your personal, organization, or project pages from a GitHub repository.<br>译：GitHub Pages旨在从GitHub存储库中托管您的个人、组织或项目页面。</p></blockquote><p>这句话主要是介绍GitHub Pages的宗旨，<a href="https://pages.github.com/">Github Pages</a> 官网上有其他的一些介绍，由于都是英文，我们看着费劲，不如直接看Gitee Pages 服务的说明，两者都差不多。<br><a href="https://img-blog.csdnimg.cn/20191224113012803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70"><img data-src="https://img-blog.csdnimg.cn/20191224113012803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70" alt="Gitee Pages 服务说明"></a><br>注意事项大家了解一下切勿违反就行，这里重点给大家说的是红框圈出的内容，Pages服务只支持静态项目，若你的项目需要服务器支持，就不适合部署到这上面了。</p><h2 id="3-2-项目配置注意事项"><a href="#3-2-项目配置注意事项" class="headerlink" title="3.2 项目配置注意事项"></a>3.2 项目配置注意事项</h2><h4 id="1、vue-router-不要开启-history-模式"><a href="#1、vue-router-不要开启-history-模式" class="headerlink" title="1、vue-router 不要开启 history 模式"></a>1、vue-router 不要开启 history 模式</h4><p>正常项目中我们会因为网站路径中带有“#”而将vue-router开启history模式，以去掉#号。但开启history模式需要服务器的支持，因此在github pages中不支持这一模式，所以我们不能开启history模式。</p><h4 id="2、在-vue-config-js-中设置正确的-publicPath"><a href="#2、在-vue-config-js-中设置正确的-publicPath" class="headerlink" title="2、在 vue.config.js 中设置正确的 publicPath"></a>2、在 vue.config.js 中设置正确的 publicPath</h4><p>要将项目部署到 https://<USERNAME>.github.io/<REPO>/ 上 (即仓库地址为 <a href="https://github.com/">https://github.com/</a><USERNAME>/<REPO>)，可将 publicPath 设为 “/<REPO>/“。<br>举个例子，我的仓库名字为“vue-admin-web”，那么 vue.config.js 的内容应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; vue.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">    ? &#39;&#x2F;vue-admin-web&#x2F;&#39;</span><br><span class="line">    : &#39;&#x2F;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、部署github项目"><a href="#三、部署github项目" class="headerlink" title="三、部署github项目"></a>三、部署github项目</h2><p>做好上述的配置后，就可以把项目推送到github上了，首先在Github上新建仓库</p><p>在本地上.git中的config中[remote “origin”]下增加一行</p><p>  url = <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:<USERNAME>/<REPO>.git</p><p>gitpush成功把项目推送到了该仓库下。接下来把项目部署到github pages上。【参考 <a href="https://cli.vuejs.org/zh/guide/deployment.html#github-pages">vue-cli</a> 官方说明】<br>1、在项目目录下，创建内容如下的 deploy.sh 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env sh</span><br><span class="line"></span><br><span class="line"># 当发生错误时中止脚本</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># 构建</span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"># cd 到构建输出的目录下 </span><br><span class="line">cd dist</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &#39;deploy&#39;</span><br><span class="line"></span><br><span class="line"># 部署到 https:&#x2F;&#x2F;&lt;USERNAME&gt;.github.io&#x2F;&lt;REPO&gt;</span><br><span class="line">git push -f git@github.com:&lt;USERNAME&gt;&#x2F;&lt;REPO&gt;.git master:gh-pages</span><br><span class="line"></span><br><span class="line">cd -</span><br></pre></td></tr></table></figure><p>2、运行该文件<br>在项目目录下打开cmd命令窗口（快捷方法：在项目目录下，按住Shift键，然后鼠标右键，选择“在此处打开命令窗口”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Linux环境下</span><br><span class="line">bash deploy.sh</span><br><span class="line">&#x2F;&#x2F; Windows环境下</span><br><span class="line">deploy.sh</span><br></pre></td></tr></table></figure><p>运行后，git就会执行该文件里的命令。大致就是，构建打包项目代码，然后将打包后的代码上传到仓库中的 gh-pages 分支。（注意：新建的仓库默认只有master分支，没有gh-pages分支，但不需要你手动新建该分支，运行该文件后，会自动帮你生成gh-pages分支）<br>这样，你的项目就已经部署到github pages 了。在你的github项目的 Settings - Options 下的 GitHub Pages项里，可以看到你的项目线上网站地址。<br>示例：<a href="https://marco-hui.github.io/vue-admin-web/">https://marco-hui.github.io/vue-admin-web/</a><br><a href="https://img-blog.csdnimg.cn/20200104151551478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70"><img data-src="https://img-blog.csdnimg.cn/20200104151551478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmNvX2h1aQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Gitee Pages实现静态页面（&lt;a href=&quot;https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF&quot;&gt;悦听播放器(Gitee Pages)&lt;/a&gt; 和&lt;a href=&quot;https://hxy1997.xyz/music_player/%E6%A8%A1%E6%9D%BF&quot;&gt;悦听播放器(GitHub Pages)&lt;/a&gt;）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Pages，实现项目的正式上线 &lt;a href=&quot;https://hxy1997.gitee.io/vue_shops/&quot;&gt;Vue电商项目(Gitee Pages)&lt;/a&gt;和&lt;a href=&quot;https://hxy1997.xyz/vue_shops/&quot;&gt;Vue电商项目(GitHub Pages)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://hxy1997.xyz/tags/Vue/"/>
    
    <category term="Gitee Pages" scheme="https://hxy1997.xyz/tags/Gitee-Pages/"/>
    
    <category term="GitHub Pages" scheme="https://hxy1997.xyz/tags/GitHub-Pages/"/>
    
    <category term="实战" scheme="https://hxy1997.xyz/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>HTML和浏览器</title>
    <link href="https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2021-03-09T12:42:39.000Z</published>
    <updated>2021-03-29T07:32:57.265Z</updated>
    
    <content type="html"><![CDATA[<p>HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。</p><span id="more"></span><h1 id="1-行内元素和块级元素"><a href="#1-行内元素和块级元素" class="headerlink" title="1.行内元素和块级元素"></a>1.行内元素和块级元素</h1><h3 id="初窥门径："><a href="#初窥门径：" class="headerlink" title="初窥门径："></a>初窥门径：</h3><p>什么叫行内元素？</p><p>常见的span、a、lable、strong、b等html标签都是行内元素</p><p>什么叫块级元素？</p><p>常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素</p><h3 id="略知一二："><a href="#略知一二：" class="headerlink" title="略知一二："></a>略知一二：</h3><p>行内元素有：<br>a, span, label, strong, em, br, img, input, select, textarea, cite,<br>块级元素：<br>div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset</p><h3 id="粗通皮毛："><a href="#粗通皮毛：" class="headerlink" title="粗通皮毛："></a>粗通皮毛：</h3><h4 id="（行内元素）内联元素-inline-element"><a href="#（行内元素）内联元素-inline-element" class="headerlink" title="（行内元素）内联元素(inline element)"></a>（行内元素）内联元素(inline element)</h4><ul><li>a - 锚点</li><li>abbr - 缩写</li><li>acronym - 首字</li><li>b - 粗体(不推荐)</li><li>bdo - bidi override</li><li>big - 大字体</li><li>br - 换行</li><li>cite - 引用</li><li>code - 计算机代码(在引用源码的时候需要)</li><li>dfn - 定义字段</li><li>em - 强调</li><li>font - 字体设定(不推荐)</li><li>i - 斜体</li><li>img - 图片</li><li>input - 输入框</li><li>kbd - 定义键盘文本</li><li>label - 表格标签</li><li>q - 短引用</li><li>s - 中划线(不推荐)</li><li>samp - 定义范例计算机代码</li><li>select - 项目选择</li><li>small - 小字体文本</li><li>span - 常用内联容器，定义文本内区块</li><li>strike - 中划线</li><li>strong - 粗体强调</li><li>sub - 下标</li><li>sup - 上标</li><li>textarea - 多行文本输入框</li><li>tt - 电传文本</li><li>u - 下划线</li><li>var - 定义变量</li></ul><h4 id="块元素-block-element"><a href="#块元素-block-element" class="headerlink" title="块元素(block element)"></a>块元素(block element)</h4><ul><li>address - 地址</li><li>blockquote - 块引用</li><li>center - 举中对齐块</li><li>dir - 目录列表</li><li>div - 常用块级容易，也是css layout的主要标签</li><li>dl - 定义列表</li><li>fieldset - form控制组</li><li>form - 交互表单</li><li>h1 - 大标题</li><li>h2 - 副标题</li><li>h3 - 3级标题</li><li>h4 - 4级标题</li><li>h5 - 5级标题</li><li>h6 - 6级标题</li><li>hr - 水平分隔线</li><li>isindex - input prompt</li><li>menu - 菜单列表</li><li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容</li><li>noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）</li><li>ol - 排序表单</li><li>p - 段落</li><li>pre - 格式化文本</li><li>table - 表格</li><li>ul - 非排序列表</li></ul><h4 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h4><p>可变元素为根据上下文语境决定该元素为块元素或者行内元素。</p><ul><li>applet - java applet</li><li>button - 按钮</li><li>del - 删除文本</li><li>iframe - inline frame</li><li>ins - 插入的文本</li><li>map - 图片区块(map)</li><li>object - object对象</li><li>script - 客户端脚本</li></ul><h3 id="驾轻就熟："><a href="#驾轻就熟：" class="headerlink" title="驾轻就熟："></a>驾轻就熟：</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>块级元素会独占一行，其宽度自动填满其父元素宽度<br>行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化</li><li>块级元素可以设置 width, height属性，【注意：块级元素即使设置了宽度，仍然是独占一行的】<br>行内元素设置width, height无效;</li><li>块级元素可以设置margin 和 padding.<br>行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）</li></ol><h3 id="青出于蓝"><a href="#青出于蓝" class="headerlink" title="青出于蓝:"></a>青出于蓝:</h3><ul><li>行内元素与块级元素直观上的区别<br>行内元素会在一条直线上排列，都是同一行的，水平方向排列<br>块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</li><li>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上<br>行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display：inline 行内元素&#x2F;内联元素</span><br><span class="line">display: block 块级元素</span><br><span class="line">display:inline-block 设置成行内块级元素。</span><br></pre></td></tr></table></figure><blockquote><p>行内块级元素:和其他元素同一行（行内元素特点），可以设置元素的宽高等（块级元素特点）；这样的元素有img input；它们为行内元素，但可以改变宽和高；<br>但我在我印象中，貌似没有默认样式是inline-block的元素。</p></blockquote><h3 id="融会贯通："><a href="#融会贯通：" class="headerlink" title="融会贯通："></a>融会贯通：</h3><ul><li>行内元素属性<ol><li>行内元素属性标签它和其它标签处在同一行内</li><li>行内元素属性标签无法设置宽度，高度 行高 距顶部距离 距底部距离</li><li>行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的</li><li>行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接）</li></ol></li><li>块级元素属性<ol><li>每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）</li><li>块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离</li><li>块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的100%</li><li>块级元素属性标签是可以直接嵌套的</li><li>p标签中不能嵌套div标签</li></ol></li></ul><h3 id="出类拔萃："><a href="#出类拔萃：" class="headerlink" title="出类拔萃："></a>出类拔萃：</h3><ul><li><p>CSS设置行内元素的</p><ul><li><p>水平居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;text-align:center&#125; &#x2F;*DIV内的行内元素均会水平居中*&#x2F; </span><br></pre></td></tr></table></figure></li><li><p>垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;height:30px; line-height:30px&#125; &#x2F;*DIV内的行内元素均会垂直居中*&#x2F; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>CSS设置块级元素的<br>- 水平居中<br><code>div p&#123;margin:0 auto; width:500px&#125; /*块级元素p一定要设置宽度， 才能相当于DIV父容器水平居中*/</code><br>- 垂直居中<br><code>div&#123;width:500px&#125; /*DIV父容器设置宽度*/ div p&#123;margin:0 aut0; height:30px; line-height:30px&#125; /*块级元素p也可以加个宽度， 以达到相对于DIV父容器的水平居中效果*/</code></p></li></ul><blockquote><p>在以后的实际项目中，块级元素的垂直居中布局方式可能会碰到比这个更复杂, 会尝试用inline-block去解决问题，希望后续多多关注；另外推荐各位一本书肖志华《CSS核心技术详解》</p></blockquote><h3 id="返璞归真："><a href="#返璞归真：" class="headerlink" title="返璞归真："></a>返璞归真：</h3><p>在标准文档流里面，块级元素具有以下特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 总是在新行上开始，占据一整行；</span><br><span class="line">② 高度，行高以及外边距和内边距都可控制；</span><br><span class="line">③ 宽带始终是与浏览器宽度一样，与内容无关；</span><br><span class="line">④ 它可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure><p>行内元素的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 和其他元素都在一行上；</span><br><span class="line">② 高，行高及外边距和内边距部分可改变；</span><br><span class="line">③ 宽度只与内容有关；</span><br><span class="line">④ 行内元素只能容纳文本或者其他行内元素。</span><br><span class="line">不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用</span><br></pre></td></tr></table></figure><h1 id="2-跨页面通信"><a href="#2-跨页面通信" class="headerlink" title="2.跨页面通信"></a>2.跨页面通信</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。</p><p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?imageslim" alt="跨页面通信实例"></p><p>这就是我们所说的前端跨页面通信。</p><p>你知道哪些跨页面通信的方式呢？如果不清楚，下面我就带大家来看看七种跨页面通信的方式。</p><hr><h2 id="一、同源页面间的跨页面通信"><a href="#一、同源页面间的跨页面通信" class="headerlink" title="一、同源页面间的跨页面通信"></a>一、同源页面间的跨页面通信</h2><blockquote><p>以下各种方式的 <a href="https://alienzhou.github.io/cross-tab-communication/">在线 Demo 可以戳这里 &gt;&gt;</a></p></blockquote><p>浏览器的<a href="https://en.wikipedia.org/wiki/Same-origin_policy">同源策略</a>在下述的一些跨页面通信方法中依然存在限制。因此，我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p><h3 id="1-BroadCast-Channel"><a href="#1-BroadCast-Channel" class="headerlink" title="1. BroadCast Channel"></a>1. BroadCast Channel</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadCast Channel</a> 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的API和用法都非常简单。</p><p>下面的方式就可以创建一个标识为<code>AlienZHOU</code>的频道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br></pre></td></tr></table></figure><p>各个页面可以通过<code>onmessage</code>来监听被广播的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[BroadcastChannel] receive message:&#39;, text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要发送消息时只需要调用实例上的<code>postMessage</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(mydata);</span><br></pre></td></tr></table></figure><blockquote><p>Broadcast Channel 的具体的使用方式可以看这篇<a href="https://juejin.im/post/6844903811228663815">《【3分钟速览】前端广播式通信：Broadcast Channel》</a>。</p></blockquote><h3 id="2-Service-Worker"><a href="#2-Service-Worker" class="headerlink" title="2. Service Worker"></a>2. Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a> 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p><blockquote><p>Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章<a href="https://juejin.im/post/6844903588691443725">【PWA学习与实践】(3) 让你的WebApp离线可用</a>。</p></blockquote><p>首先，需要在页面注册 Service Worker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.register(&#39;..&#x2F;util.sw.js&#39;).then(function () &#123;</span><br><span class="line">    console.log(&#39;Service Worker 注册成功&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>../util.sw.js</code>是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.sw.js Service Worker 逻辑 *&#x2F;</span><br><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    console.log(&#39;service worker receive message&#39;, e.data);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(function (clients) &#123;</span><br><span class="line">            if (!clients || clients.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            clients.forEach(function (client) &#123;</span><br><span class="line">                client.postMessage(e.data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在 Service Worker 中监听了<code>message</code>事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过<code>self.clients.matchAll()</code>获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的<code>postMessage</code>方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。</p><p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Service Worker] receive message:&#39;, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，当需要同步消息时，可以调用 Service Worker 的<code>postMessage</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.controller.postMessage(mydata);</span><br></pre></td></tr></table></figure><h3 id="3-LocalStorage"><a href="#3-LocalStorage" class="headerlink" title="3. LocalStorage"></a>3. LocalStorage</h3><p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但<a href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent"><code>StorageEvent</code></a>这个与它相关的事件有些同学可能会比较陌生。</p><p>当 LocalStorage 变化时，会触发<code>storage</code>事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听<code>storage</code>事件即可收到通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, function (e) &#123;</span><br><span class="line">    if (e.key &#x3D;&#x3D;&#x3D; &#39;ctc-msg&#39;) &#123;</span><br><span class="line">        const data &#x3D; JSON.parse(e.newValue);</span><br><span class="line">        const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">        console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的<code>setItem</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata.st &#x3D; +(new Date);</span><br><span class="line">window.localStorage.setItem(&#39;ctc-msg&#39;, JSON.stringify(mydata));</span><br></pre></td></tr></table></figure><p>注意，这里有一个细节：我们在mydata上添加了一个取当前毫秒时间戳的<code>.st</code>属性。这是因为，<code>storage</code>事件只有在值真正改变时才会触发。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br></pre></td></tr></table></figure><p>由于第二次的值<code>&#39;123&#39;</code>与第一次的值相同，所以以上的代码只会在第一次<code>setItem</code>时触发<code>storage</code>事件。因此我们通过设置<code>st</code>来保证每次调用时一定会触发<code>storage</code>事件。</p><h3 id="小憩一下"><a href="#小憩一下" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是些 tricky 的<code>storage</code>事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。</p><blockquote><p>在上面的例子中，这个“中央站”可以是一个 BroadCast Channel 实例、一个 Service Worker 或是 LocalStorage。</p></blockquote><p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p><hr><h3 id="4-Shared-Worker"><a href="#4-Shared-Worker" class="headerlink" title="4. Shared Worker"></a>4. Shared Worker</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared Worker</a> 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p><p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：</p><p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过<code>postMessage</code>传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p><p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span><br><span class="line">const sharedWorker &#x3D; new SharedWorker(&#39;..&#x2F;util.shared.js&#39;, &#39;ctc&#39;);</span><br></pre></td></tr></table></figure><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.shared.js: Shared Worker 代码 *&#x2F;</span><br><span class="line">let data &#x3D; null;</span><br><span class="line">self.addEventListener(&#39;connect&#39;, function (e) &#123;</span><br><span class="line">    const port &#x3D; e.ports[0];</span><br><span class="line">    port.addEventListener(&#39;message&#39;, function (event) &#123;</span><br><span class="line">        &#x2F;&#x2F; get 指令则返回存储的消息数据</span><br><span class="line">        if (event.data.get) &#123;</span><br><span class="line">            data &amp;&amp; port.postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非 get 指令则存储该消息数据</span><br><span class="line">        else &#123;</span><br><span class="line">            data &#x3D; event.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时轮询，发送 get 指令的消息</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line">    sharedWorker.port.postMessage(&#123;get: true&#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 get 消息的返回数据</span><br><span class="line">sharedWorker.port.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Shared Worker] receive message:&#39;, text);</span><br><span class="line">&#125;, false);</span><br><span class="line">sharedWorker.port.start();</span><br></pre></td></tr></table></figure><p>最后，当要跨页面通信时，只需给 Shared Worker <code>postMessage</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.port.postMessage(mydata);</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果使用<code>addEventListener</code>来添加 Shared Worker 的消息监听，需要显式调用<code>MessagePort.start</code>方法，即上文中的<code>sharedWorker.port.start()</code>；如果使用<code>onmessage</code>绑定监听则不需要。</p></blockquote><h3 id="5-IndexedDB"><a href="#5-IndexedDB" class="headerlink" title="5. IndexedDB"></a>5. IndexedDB</h3><p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> 或 cookie。</p><blockquote><p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p></blockquote><p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p><ul><li><p>打开数据库连接：</p><p>function openStore() { const storeName = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { if (!(‘indexedDB’ in window)) { return reject(‘don’t support indexedDB’); } const request = indexedDB.open(‘CTC_DB’, 1); request.onerror = reject; request.onsuccess =  e =&gt; resolve(e.target.result); request.onupgradeneeded = function (e) { const db = e.srcElement.result; if (e.oldVersion === 0 &amp;&amp; !db.objectStoreNames.contains(storeName)) { const store = db.createObjectStore(storeName, {keyPath: ‘tag’}); store.createIndex(storeName + ‘Index’, ‘tag’, {unique: false}); } } }); }</p></li><li><p>存储数据</p><p>function saveData(db, data) { return new Promise(function (resolve, reject) { const STORE_NAME = ‘ctc_aleinzhou’; const tx = db.transaction(STORE_NAME, ‘readwrite’); const store = tx.objectStore(STORE_NAME); const request = store.put({tag: ‘ctc_data’, data}); request.onsuccess = () =&gt; resolve(db); request.onerror = reject; }); }</p></li><li><p>查询/读取数据</p><p>function query(db) { const STORE_NAME = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { try { const tx = db.transaction(STORE_NAME, ‘readonly’); const store = tx.objectStore(STORE_NAME); const dbRequest = store.get(‘ctc_data’); dbRequest.onsuccess = e =&gt; resolve(e.target.result); dbRequest.onerror = reject; } catch (err) { reject(err); } }); }</p></li></ul><p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null))</span><br></pre></td></tr></table></figure><p>对于消息读取，可以在连接与初始化后轮询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        query(db).then(function (res) &#123;</span><br><span class="line">            if (!res || !res.data) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const data &#x3D; res.data;</span><br><span class="line">            const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">            console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… 省略上面的轮询代码</span><br><span class="line">    &#x2F;&#x2F; 触发 saveData 的方法可以放在用户操作的事件监听内</span><br><span class="line">    saveData(db, mydata);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="小憩一下-1"><a href="#小憩一下-1" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p><p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听<code>visibilitychange</code>这样的事件，来做一次信息同步即可。</p><p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p><hr><h3 id="6-window-open-window-opener"><a href="#6-window-open-window-opener" class="headerlink" title="6. window.open + window.opener"></a>6. window.open + window.opener</h3><p>当我们使用<code>window.open</code>打开页面时，方法会返回一个被打开页面<code>window</code>的引用。而在未显示指定<code>noopener</code>时，被打开的页面可以通过<code>window.opener</code>获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p><p>首先，我们把<code>window.open</code>打开的页面的<code>window</code>对象收集起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let childWins &#x3D; [];</span><br><span class="line">document.getElementById(&#39;btn&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    const win &#x3D; window.open(&#39;.&#x2F;some&#x2F;sample&#39;);</span><br><span class="line">    childWins.push(win);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">if (childWins.length &gt; 0) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; false;</span><br><span class="line">    childWins.forEach(w &#x3D;&gt; w.postMessage(mydata));</span><br><span class="line">&#125;</span><br><span class="line">if (window.opener &amp;&amp; !window.opener.closed) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; true;</span><br><span class="line">    window.opener.postMessage(mydata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我这里先用<code>.closed</code>属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p><p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p><blockquote><p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Cross-document Messaging] receive message:&#39;, text);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (window.opener &amp;&amp; !window.opener.closed &amp;&amp; data.fromOpenner) &#123;</span><br><span class="line">        window.opener.postMessage(data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">    childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (childWins &amp;&amp; !data.fromOpenner) &#123;</span><br><span class="line">        childWins.forEach(w &#x3D;&gt; w.postMessage(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p><h3 id="小憩一下-2"><a href="#小憩一下-2" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的<code>window.open</code>打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p><p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。</p><p>关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇<a href="https://juejin.im/post/6844903618043183111">《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》</a></p><p>此外，我还针对以上各种方式写了一个 <a href="https://alienzhou.github.io/cross-tab-communication/">在线演示的 Demo &gt;&gt;</a></p><p>![Demo页面](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="567"></svg>)</p><h2 id="二、非同源页面之间的通信"><a href="#二、非同源页面之间的通信" class="headerlink" title="二、非同源页面之间的通信"></a>二、非同源页面之间的通信</h2><p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p><p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定<code>origin</code>来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<code>http://sample.com/bridge.html</code>），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.frames[0].window.postMessage(mydata, &#39;*&#39;);</span><br></pre></td></tr></table></figure><p>其中为了简便此处将<code>postMessage</code>的第二个参数设为了<code>&#39;*&#39;</code>，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br><span class="line">&#x2F;&#x2F; 收到来自页面的消息后，在 iframe 间进行广播</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    bc.postMessage(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 对于收到的（iframe）广播消息，通知给所属的业务页面</span><br><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    window.parent.postMessage(e.data, &#39;*&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/31/169d468988a6ba8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天和大家分享了一下跨页面通信的各种方式。</p><p>对于同源页面，常见的方式包括：</p><ul><li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li><li>共享存储模式：Shared Worker / IndexedDB / cookie</li><li>口口相传模式：window.open + window.opener</li><li>基于服务端：Websocket / Comet / SSE 等</li></ul><p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p><h1 id="3-前端路由的两种模式：hash模式和-history模式"><a href="#3-前端路由的两种模式：hash模式和-history模式" class="headerlink" title="3.前端路由的两种模式：hash模式和 history模式"></a>3.前端路由的两种模式：hash模式和 history模式</h1><h2 id="为什么要使用路由"><a href="#为什么要使用路由" class="headerlink" title="为什么要使用路由"></a>为什么要使用路由</h2><p>现在的网络应用程序越来越多的使用AJAX异步请求完成页面的无缝刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而提高了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。</p><p>单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。</p><h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能：</p><ol><li>当浏览器地址变化时，切换页面；</li><li>点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</li><li>刷新浏览器，网页加载当前路由对应内容；</li></ol><p>在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：</p><ul><li>hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；</li><li>history模式：利用history API实现url地址改变，网页内容改变；</li></ul><p>它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。</p><h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：</p><ol><li>hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如<a href="http://localhost/index.html#abc%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84#abc%E5%B0%B1%E6%98%AFhash%EF%BC%9B">http://localhost/index.html#abc，这里的#abc就是hash；</a></li><li>散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；</li><li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；</li><li>location.hash值的变化会直接反应到浏览器地址栏；</li></ol><h2 id="触发hashchange事件的几种情况："><a href="#触发hashchange事件的几种情况：" class="headerlink" title="触发hashchange事件的几种情况："></a>触发hashchange事件的几种情况：</h2><ul><li>浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；</li><li>当浏览器地址栏中URL包含哈希如 <a href="http://www.baidu.com/#home%EF%BC%8C%E8%BF%99%E6%97%B6%E6%8C%89%E4%B8%8B%E8%BE%93%E5%85%A5%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81http://www.baidu.com/%E8%AF%B7%E6%B1%82%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%E8%AE%BE%E7%BD%AE%E6%95%A3%E5%88%97%E5%80%BC%E4%B8%BA#home%EF%BC%8C%E8%BF%9B%E8%80%8C%E8%A7%A6%E5%8F%91onhashchange%E4%BA%8B%E4%BB%B6%EF%BC%9B">http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；</a></li><li>当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；</li><li>html中<a>标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置 url 的 hash，会在当前url后加上&#39;#abc&#39;</span><br><span class="line">window.location.hash&#x3D;&#39;abc&#39;;</span><br><span class="line">let hash &#x3D; window.location.hash &#x2F;&#x2F;&#39;#abc&#39;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;hashchange&#39;,function()&#123;</span><br><span class="line">&#x2F;&#x2F;监听hash变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>概述<br>window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。<br>History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。<br>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。<br>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。<br>属性<br>History 对象主要有两个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">History.length：当前窗口访问过的网址数量（包括当前网页）</span><br><span class="line">History.state：History 堆栈最上层的状态值（详见下文）</span><br><span class="line">&#x2F;&#x2F; 当前窗口访问过多少个网页</span><br><span class="line">history.length &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; History 对象的当前状态</span><br><span class="line">&#x2F;&#x2F; 通常是 undefined，即未设置</span><br><span class="line">history.state &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p><p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p><p>History.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。<br>History.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。<br>History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(1);&#x2F;&#x2F;相当于history.forward()</span><br><span class="line">history.go(-1);&#x2F;&#x2F;相当于history.back()</span><br><span class="line">history.go(0); &#x2F;&#x2F; 刷新当前页面</span><br></pre></td></tr></table></figure><p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p><p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p><p>History.pushState()<br>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。</p><p>语法：history.pushState(object, title, url)</p><p>该方法接受三个参数，依次为：</p><p>object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。<br>title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。<br>url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(data, &#39;&#39;, &#39;2.html&#39;);</span><br><span class="line">console.log(history.state) &#x2F;&#x2F; &#123;foo: &quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure><p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p><p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p><p>如果 pushState() 方法设置了一个跨域网址，则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">&#x2F;&#x2F; 当前网址为 http:&#x2F;&#x2F;example.com</span><br><span class="line">history.pushState(null, &#39;&#39;, &#39;https:&#x2F;&#x2F;twitter.com&#x2F;hello&#39;);</span><br></pre></td></tr></table></figure><p>上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p><p>History.replaceState()<br>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。</p><p>假定当前网页是 example.com/example.html。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;page: 1&#125;, &#39;&#39;, &#39;?page&#x3D;1&#39;)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;page: 2&#125;, &#39;&#39;, &#39;?page&#x3D;2&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;2</span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &#39;&#39;, &#39;?page&#x3D;3&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html</span><br><span class="line"></span><br><span class="line">history.go(2)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br></pre></td></tr></table></figure><p>popstate 事件<br>每当 history 对象出现变化时，就会触发 popstate 事件。</p><p>注意：</p><p>仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;<br>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。<br>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。<br>页面第一次加载的时候，浏览器不会触发popstate事件。<br>使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;popstate&#39;, function(e) &#123;</span><br><span class="line">&#x2F;&#x2F;e.state 相当于 history.state</span><br><span class="line">console.log(&#39;state: &#39; + JSON.stringify(e.state));</span><br><span class="line">console.log(history.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击查看 通过history.pushState 实现页面 tab 切换的功能。</p><p>history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。</p><h1 id="4-DOM树：JavaScript是如何影响DOM树构建的"><a href="#4-DOM树：JavaScript是如何影响DOM树构建的" class="headerlink" title="4.DOM树：JavaScript是如何影响DOM树构建的"></a>4.DOM树：JavaScript是如何影响DOM树构建的</h1><p>续沿着网络数据流路径来介绍 DOM 树是怎么生成的。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p><h2 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h2><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用</p><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p><h2 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h2><p>在渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p><p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p><p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p><p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p><p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/57.png" alt="img"></p><p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p><p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong></p><p>前面《14 | 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/58.png" alt="img"></p><p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如</p><p>就是 StartTag ，就是EndTag，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。</p><p><strong>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中</strong>。</p><blockquote><p>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p></blockquote><ul><li>如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p><p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p><p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/59.png" alt="img"></p><p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/60.png" alt="img"></p><p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/61.png" alt="img"></p><p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/62.png" alt="img"></p><p>按照同样的规则，一路解析，最终结果如下图所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/63.png" alt="img"></p><p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p><h2 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h2><p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。script标签之前，所有的解析流程还是和之前介绍的一样，但是解析到script标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p><p><img data-src="http://blog.poetries.top/img-repo/2019/11/64.png" alt="img"></p><p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p><p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p><p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">            div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM</span><br><span class="line">            div1.style.color = &#x27;red&#x27;  // 需要 CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p><p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p><p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p><p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p><p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了</p><h1 id="5-事件模型"><a href="#5-事件模型" class="headerlink" title="5.事件模型"></a>5.事件模型</h1><p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章介绍 DOM 的事件编程。</p><h2 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h2><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p><p>该接口主要提供三个实例方法。</p><ul><li><code>addEventListener</code>：绑定事件的监听函数</li><li><code>removeEventListener</code>：移除事件的监听函数</li><li><code>dispatchEvent</code>：触发事件</li></ul><h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure><p>该方法接受三个参数。</p><ul><li><code>type</code>：事件名称，大小写敏感。</li><li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li><li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li></ul><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var button &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">button.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p><p>关于参数，有两个地方需要注意。</p><p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(&#39;click&#39;, &#123;</span><br><span class="line">  handleEvent: function (event) &#123;</span><br><span class="line">    console.log(&#39;click&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p><p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p><blockquote><ul><li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li><li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li><li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li></ul></blockquote><p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure><p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p><p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function print(x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var el &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">el.addEventListener(&#39;click&#39;, function () &#123; print(&#39;Hello&#39;); &#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p><p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">var para &#x3D; document.getElementById(&#39;para&#39;);</span><br><span class="line">para.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(this.nodeName); &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p><h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, listener, false);</span><br></pre></td></tr></table></figure><p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p><p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;mousedown&#39;, handleMouseDown, true);</span><br><span class="line">element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p><h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure><p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p>上面代码在当前节点触发了<code>click</code>事件。</p><p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p><p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canceled &#x3D; !cb.dispatchEvent(event);</span><br><span class="line">if (canceled) &#123;</span><br><span class="line">  console.log(&#39;事件取消&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;事件未取消&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h2><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p><p>JavaScript 有三种方法，可以为事件绑定监听函数。</p><h3 id="HTML-的-on-属性"><a href="#HTML-的-on-属性" class="headerlink" title="HTML 的 on- 属性"></a>HTML 的 on- 属性</h3><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line">&lt;div onclick&#x3D;&quot;console.log(&#39;触发事件&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p><p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p><p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure><p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p><p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&quot;console.log(2)&quot;&gt;</span><br><span class="line">  &lt;button onClick&#x3D;&quot;console.log(1)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p><p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(&#39;onclick&#39;, &#39;doSomething()&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; &lt;Element onclick&#x3D;&quot;doSomething()&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h3><p>元素节点对象的事件属性，同样可以指定监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p><p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p><h3 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, doSomething, false);</span><br></pre></td></tr></table></figure><p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p><p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p><p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p><ul><li>同一个事件可以添加多个监听函数。</li><li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li><li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li></ul><h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;btn&quot; onclick&#x3D;&quot;console.log(this.id)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>执行上面代码，点击后会输出<code>btn</code>。</p><p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">btn.onclick &#x3D; function () &#123;</span><br><span class="line">  console.log(this.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">btn.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p><h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p><ul><li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li><li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li><li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li></ul><p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;点击&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p><p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var phases &#x3D; &#123;</span><br><span class="line">  1: &#39;capture&#39;,</span><br><span class="line">  2: &#39;target&#39;,</span><br><span class="line">  3: &#39;bubble&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  var phase &#x3D; phases[event.eventPhase];</span><br><span class="line">  console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击以后的结果</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;capture&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;bubble&#39;</span><br></pre></td></tr></table></figure><p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p><ol><li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li><li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li><li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li></ol><p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p><p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p><p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p><h2 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; some code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 事件传播到 p 元素后，就不再向下传播了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件冒泡到 p 元素后，就不再向上冒泡了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p><p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 会触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件向其他元素传播。因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p><p>如果想要彻底阻止这个事件的传播，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底阻止这个事件传播，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p><h2 id="Event-对象概述"><a href="#Event-对象概述" class="headerlink" title="Event 对象概述"></a>Event 对象概述</h2><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p><p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event &#x3D; new Event(type, options);</span><br></pre></td></tr></table></figure><p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p><ul><li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li><li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; new Event(</span><br><span class="line">  &#39;look&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#39;bubbles&#39;: true,</span><br><span class="line">    &#39;cancelable&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">document.dispatchEvent(ev);</span><br></pre></td></tr></table></figure><p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p><p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  console.log(&#39;Tag: &#39; + tag); &#x2F;&#x2F; 没有任何输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">var click &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p><p>另一方面，如果这个事件在<code>div</code>元素上触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure><p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p><h2 id="Event-对象的实例属性"><a href="#Event-对象的实例属性" class="headerlink" title="Event 对象的实例属性"></a>Event 对象的实例属性</h2><h3 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h3><p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p><p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var phase &#x3D; event.eventPhase;</span><br></pre></td></tr></table></figure><p><code>Event.eventPhase</code>的返回值有四种可能。</p><ul><li>0.事件目前没有发生。</li><li>1.事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li><li>2.事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li><li>3.事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li></ul><h3 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h3><p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p><p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.cancelable  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p><p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function preventEvent(event) &#123;</span><br><span class="line">  if (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.warn(&#39;This event couldn\&#39;t be canceled.&#39;);</span><br><span class="line">    console.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p><p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (event.defaultPrevented) &#123;</span><br><span class="line">  console.log(&#39;该事件已经取消了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h3><p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p><p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">function hide(e) &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.currentTarget);  &#x2F;&#x2F; 总是 true</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.target);  &#x2F;&#x2F; 有可能不是 true</span><br><span class="line">  e.target.style.visibility &#x3D; &#39;hidden&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">para.addEventListener(&#39;click&#39;, hide, false);</span><br></pre></td></tr></table></figure><p>上面代码中，如果在<code>para</code>节点的<code>&lt;em&gt;</code>子节点上面点击，则<code>e.target</code>指向<code>&lt;em&gt;</code>子节点，导致<code>&lt;em&gt;</code>子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个<code>para</code>都将不可见。</p><h3 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h3><p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.type &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure><h3 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h3><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.timeStamp &#x2F;&#x2F; 3683.6999999995896</span><br></pre></td></tr></table></figure><p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p><p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var previousX;</span><br><span class="line">var previousY;</span><br><span class="line">var previousT;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;mousemove&#39;, function(event) &#123;</span><br><span class="line">  if (</span><br><span class="line">    previousX !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousY !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousT !&#x3D;&#x3D; undefined</span><br><span class="line">  ) &#123;</span><br><span class="line">    var deltaX &#x3D; event.screenX - previousX;</span><br><span class="line">    var deltaY &#x3D; event.screenY - previousY;</span><br><span class="line">    var deltaD &#x3D; Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));</span><br><span class="line"></span><br><span class="line">    var deltaT &#x3D; event.timeStamp - previousT;</span><br><span class="line">    console.log(deltaD &#x2F; deltaT * 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX &#x3D; event.screenX;</span><br><span class="line">  previousY &#x3D; event.screenY;</span><br><span class="line">  previousT &#x3D; event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h3><p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.isTrusted &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p><h3 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h3><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dbclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">function giveDetails(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;p&#39;).onclick &#x3D; giveDetails;</span><br></pre></td></tr></table></figure><h2 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h2><h3 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h3><p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p><p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;my-checkbox&quot; &#x2F;&gt;</span><br><span class="line">var cb &#x3D; document.getElementById(&#39;my-checkbox&#39;);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e)&#123; e.preventDefault(); &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p><p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;my-input&quot; &#x2F;&gt;</span><br><span class="line">var input &#x3D; document.getElementById(&#39;my-input&#39;);</span><br><span class="line">input.addEventListener(&#39;keypress&#39;, checkName, false);</span><br><span class="line"></span><br><span class="line">function checkName(e) &#123;</span><br><span class="line">  if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p><h3 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h3><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function stopEvent(e) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, stopEvent, false);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p><h3 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h3><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p><p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function l1(e)&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function l2(e)&#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, l1, false);</span><br><span class="line">el.addEventListener(&#39;click&#39;, l2, false);</span><br></pre></td></tr></table></figure><p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p><h3 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h3><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.composedPath());</span><br><span class="line">&#125;, false);</span><br><span class="line">&#x2F;&#x2F; [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p><h2 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h2><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p><p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CustomEvent(type, options)</span><br></pre></td></tr></table></figure><p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p><ul><li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li></ul><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; new CustomEvent(&#39;build&#39;, &#123; &#39;detail&#39;: &#39;hello&#39; &#125;);</span><br><span class="line"></span><br><span class="line">function eventHandler(e) &#123;</span><br><span class="line">console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;build&#39;, function (e) &#123;</span><br><span class="line">console.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure><p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p><p>下面是另一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myEvent &#x3D; new CustomEvent(&#39;myevent&#39;, &#123;</span><br><span class="line">    detail: &#123;</span><br><span class="line">    foo: &#39;bar&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    bubbles: true,</span><br><span class="line">    cancelable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;myevent&#39;, function (event) &#123;</span><br><span class="line">console.log(&#39;Hello &#39; + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>Wilson Page, <a href="http://coding.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/">An Introduction To DOM Events</a></li><li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching">Using Firefox 1.5 caching</a></li><li>Craig Buckler, <a href="http://www.sitepoint.com/css3-animation-javascript-event-handlers/">How to Capture CSS3 Animation Events in JavaScript</a></li><li>Ray Nicholus, <a href="http://blog.garstasio.com/you-dont-need-jquery/events/">You Don’t Need jQuery!: Events</a></li></ul><h1 id="6-彻底理解浏览器的缓存机制"><a href="#6-彻底理解浏览器的缓存机制" class="headerlink" title="6.彻底理解浏览器的缓存机制"></a>6.彻底理解浏览器的缓存机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p><p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358082ff05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358033cdc4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635806ca887?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358079780e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><p>以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。</p><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359673e7d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63596c9de23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63597182316?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359acd19d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><p>那么强制缓存的缓存规则是什么？</p></blockquote><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><blockquote><p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p></blockquote><p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><p>接下来，我们直接看一个例子，如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635aa7b772b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>由上面的例子我们可以知道：</p><ul><li>HTTP响应报文中expires的时间值，是一个绝对值</li><li>HTTP响应报文中Cache-Control为max-age=600，是相对值</li></ul><p>由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p><p>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</p><p>了解强制缓存的过程后，我们拓展性的思考一下：</p><blockquote><p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635afa6f7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。</p><blockquote><p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p></blockquote><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p><p>访问<a href="https://heyingye.github.io/">heyingye.github.io/ </a> –&gt;200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io>/">heyingye.github.io&gt;</a> –&gt;200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p><p>过程如下：</p><ul><li><p>访问<a href="https://heyingye.github.io/">heyingye.github.io/</a></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b40660cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>关闭博客的标签页</p></li><li><p>重新打开<a href="https://heyingye.github.io/">heyingye.github.io/</a></p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b4f0233b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>刷新</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635bd572192?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>from disk memory</p></li></ul><blockquote><p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</p></blockquote><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p><ul><li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li><li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ul><p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><p>协商缓存生效，返回304，如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cbfff69d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>304</p><p>协商缓存失效，返回200和请求结果结果，如下</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cf070ff5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>200</p><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635d2a88984?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>last-modify</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635db6d62fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>If-Modified-Since</p><h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635e4dd628b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Etag</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ecb2cae0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>Etag-match</p><p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ed5f6d26?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="7-Chrome-浏览器架构"><a href="#7-Chrome-浏览器架构" class="headerlink" title="7.Chrome 浏览器架构"></a>7.Chrome 浏览器架构</h1><h2 id="CPU与GPU"><a href="#CPU与GPU" class="headerlink" title="CPU与GPU"></a>CPU与GPU</h2><p>﻿CPU和GPU作为计算机中最重要的两个计算单元直接决定了计算性能。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img data-src="https://static001.geekbang.org/infoq/94/9407812940681a84a4b4661b551da819.png" alt="img"></p><p>CPU是计算机的大脑，负责处理各种不同的任务。在过去，大多数CPU是单芯片的，核心被安置在同一个芯片上。更新的CPU可以支持多核心，运算能力大大加强。而最新的的cpu已经达到10核心20线程数的能力了。</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img data-src="https://static001.geekbang.org/infoq/8f/8fc555c4a70f7f844dbb34edec74cf1f.png" alt="img"></p><p>GPU是另一个计算机的组成部分，与CPU不同，GPU更擅长利用多核心同时处理单一的任务。像命名那样，GPU最初被用于处理图像。这就是为什么使用GPU可以更快、更顺畅的渲染页面内容。随着GPU的发展，越来越多的计算任务也可以使用GPU来处理。甚至有人说GPU是人工智能的大功臣，可见GPU已经不再仅用于图像处理上了。</p><h2 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/2a/2af38ddf296b92cd6bbbf97322774c33.png" alt="img"></p><p>我们可以把计算机自下而上分成三层：硬件、操作系统和应用。有了操作系统的存在，上层运行的应用可以使用操作系统提供的能力使用硬件资源而不会直接访问硬件资源。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/97/97afac83d32e43397ea484653bb6b1ec.png" alt="img"></p><p>一个进程是应用正在运行的程序。而线程是进程中更小的一部分。当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作。操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，这段私有的内存也会被释放。其实还有比线程更小的存在就是<strong>协程，而协成是运行在线程中更小的单位。async/await就是基于协程实现的。</strong></p><h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/b8/b8306ca61a00c7ccfa68476e61a0b105.png" alt="img"></p><p>﻿</p><p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以时用IPC(Inter Process Communication)。</p><p>﻿多数程序被设计成使用IPC来进行进程间的通信，好处在于当一个进程给另一个进程发消息而没有回应时，并不影响当前的进程继续工作。</p><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>﻿</p><p>借助进程和线程，浏览器可以被设计成单进程、多线程架构，或者利用IPC实现多进程、多线程架构。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/23/23162955642bb163b16a5d08bdbb3288.png" alt="img"></p><p>这里我们以Chrome多进程架构介绍，在Chrome中存在这不同种类型的进程，它们各司其职。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/89/898bb4e5c529e5d3280b6787a7d261a3.png" alt="img"></p><p>浏览器进程做为Chrome中最核心的进程管理着Chrome中的其他进程，而Renderer则负责渲染不同的站点。</p><h3 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h3><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/7b/7bc84e5abe039f836a0af8002d4a63fd.png" alt="img"></p><p>﻿</p><h4 id="浏览器进程（Browser-process）"><a href="#浏览器进程（Browser-process）" class="headerlink" title="浏览器进程（Browser process）"></a>浏览器进程（Browser process）</h4><p>浏览器进程负责管理Chrome应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。</p><h4 id="渲染进程（Renderer-process）"><a href="#渲染进程（Renderer-process）" class="headerlink" title="渲染进程（Renderer process）"></a>渲染进程（Renderer process）</h4><p>渲染进程负责站点的渲染，其中也包括JavaScript代码的运行，web worker的管理等。</p><h4 id="插件进程（Plugin-process）"><a href="#插件进程（Plugin-process）" class="headerlink" title="插件进程（Plugin process）"></a>插件进程（Plugin process）</h4><p>插件进程负责为浏览器提供各种额外的插件功能，例如flash。</p><h4 id="GPU进程（GPU-process）"><a href="#GPU进程（GPU-process）" class="headerlink" title="GPU进程（GPU process）"></a>GPU进程（GPU process）</h4><p>GPU进程负责提供成像的功能。</p><p>当然还有其他像扩展进程或工具进程等其他进程，可以在Chrome的Task Manager面板中查看，面板中列出了运行的进程和其占用的CPU、内存情况。</p><h3 id="多进程架构的好处"><a href="#多进程架构的好处" class="headerlink" title="多进程架构的好处"></a>多进程架构的好处</h3><p>当我们访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当我们在Chrome中打开三个页签同时访问三个站点时，如果其中一个没有响应，我们可以关闭它然后使用其他的页签，这是因为Chrome为每个站点创建一个独立的渲染进程，专门处理当前站点的渲染工作。如果所有的页面运行在同一个进程中，当有一个页面没有响应时，所有的页面就都卡住了。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/0e/0e8966939127660cee3f7aa05303721b.png" alt="img"></p><p>另一个好处是，借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。</p><p>﻿</p><p>虽然多进程的架构优于单进程架构，但由于进程独享自己的私有内存，以渲染进程为例，虽然渲染的站点不同，但工作内容大体相似，为了完成渲染工作它们会在自己的内存中包含相同的功能，例如V8引擎（用于解析和运行Javascript），这意味着这部分相同的功能需要占用每个进程的内存空间。为了节省内存，Chrome限制了最大进程数，最大进程数取决于硬件的能力，同时<strong>当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程</strong>。</p><h3 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h3><p>Chrome将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式提供，以解决多进程架构中的问题。</p><p>当Chrome运行在拥有强大硬件的计算机上时，会将一个服务以多个进程的方式实现，提高稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p><p><img data-src="https://static001.geekbang.org/infoq/72/72ab917eee34ffd4b8bb1352a8f73ad6.png" alt="img"></p><h3 id="基于站点隔离的渲染进程"><a href="#基于站点隔离的渲染进程" class="headerlink" title="基于站点隔离的渲染进程"></a>基于站点隔离的渲染进程</h3><p>﻿利用iframe我们可以在同一个页面访问不同站点的资源，但从安全的角度考虑，同源策略不允许一个站点在未得到同意的情况下访问其他站点的资源，所以从Chrome 67开始每个站点由独立的渲染进程处理被默认启用。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/fa/fa70a857e645bec8876257580a935282.png" alt="img"></p><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><p><img data-src="https://static001.geekbang.org/infoq/40/4006973a23f68ec28402353d48f91a57.png" alt="img"></p><p>浏览器进程负责处理除了渲染外的大部分工作，浏览器进程包括几个线程：</p><ul><li>UI 线程负责绘制工具栏中的按钮、地址栏等。</li><li>网络线程负责从网络中获取数据。</li><li>存储线程负责文件等功能。</li></ul><p>当我们在地址栏中输入一个地址时，浏览器进程中的UI线程最先得知这个动作，并开始处理。</p><h2 id="一次访问"><a href="#一次访问" class="headerlink" title="一次访问"></a>一次访问</h2><p>下面我们就从一次常见的访问入手，逐步了解浏览器是如何展示页面的。</p><h3 id="Step-1：输入处理"><a href="#Step-1：输入处理" class="headerlink" title="Step 1：输入处理"></a>Step 1：输入处理</h3><p>当我们在地址栏中输入时，UI线程会先判断我们输入的内容是要搜索的内容还是要访问一个站点，因为地址栏同时也是一个搜索框。</p><p><img data-src="https://static001.geekbang.org/infoq/d6/d619ac67749e633ae020812aa0b09bdd.png" alt="img"></p><h3 id="Step-2：访问开始"><a href="#Step-2：访问开始" class="headerlink" title="Step 2：访问开始"></a>Step 2：访问开始</h3><p>当我们按下回车开始访问时，UI线程将借助网络线程访问站点资源. 浏览器页签的标题上会出现加载中的图标，同时网络线程会根据适当的网络协议，例如DNS lookup和TLS为这次请求建立连接。</p><p><img data-src="https://static001.geekbang.org/infoq/74/749ccda4aca068ed34465407973dc3f9.png" alt="img"></p><p>当服务器返回给浏览器重定向请求时，网络线程会通知UI线程需要重定向，然后会以新的地址做开始请求资源。</p><h3 id="Step-3：处理响应数据"><a href="#Step-3：处理响应数据" class="headerlink" title="Step 3：处理响应数据"></a>Step 3：处理响应数据</h3><p><img data-src="https://static001.geekbang.org/infoq/a0/a049bd54e903004676c6f75ec11d373b.png" alt="img"></p><p>当网络线程收到来自服务器的数据时，会试图从数据中的前面的一些字节中得到数据的类型（<strong>Content-Type</strong>），以试图了解数据的格式。</p><p>当返回的数据类型是HTML时，会将数据传递给渲染进程做进一步的渲染工作。但是如果数据类型是zip文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或者下载工作。</p><p><img data-src="https://static001.geekbang.org/infoq/b4/b4797a3b5023a9de4ac03ad174e9bd3f.png" alt="img"></p><p>在开始渲染之前，网络线程要先检查数据的安全性，这里也是浏览器保证安全的地方。如果返回的数据来自一些恶意的站点，网络线程会显示警告的页面。同时，Cross Origin Read Blocking(CORB)策略也会确保跨域的敏感数据不会被传递给渲染进程。</p><h3 id="Step-4：渲染过程"><a href="#Step-4：渲染过程" class="headerlink" title="Step 4：渲染过程"></a>Step 4：渲染过程</h3><p>当所有的检查结束后，网络线程确信浏览器可以访问站点时，网络线程通知UI线程数据已经准备好了。UI线程会根据当前的站点找到一个渲染进程完成接下来的渲染工作。</p><p><img data-src="https://static001.geekbang.org/infoq/32/320ebdce97d9fb29329fd47c0c5f0c07.png" alt="img"></p><p>在第二步，UI线程将请求地址传递给网络线程时，UI线程就已经知道了要访问的站点。此时UI线程就可以开始查找或启动一个渲染进程，这个动作与让网络线程下载数据是同时的。如果网络线程按照预期获取到数据，则渲染进程就已经可以开始渲染了，这个动作减少了从网络线程开始请求数据到渲染进程可以开始渲染页面的时间。当然，如果出现重定向的请求时，提前初始化的渲染进程可能就不会被使用了，但相比正常访问站点的场景，重定向往往是少数，在实际工作中，也需要根据特定的场景给出特定的方案，不必追求完美的方案。</p><h3 id="Step-5：提交访问"><a href="#Step-5：提交访问" class="headerlink" title="Step 5：提交访问"></a>Step 5：提交访问</h3><p>经历前面的步骤，数据和渲染进程都已经准备好了。浏览器进程会通过IPC向渲染进程提交这次访问，同时也会保证渲染进程可以通过网络线程继续获取数据。一旦浏览器进程收到来自渲染进程的确认完毕的消息，就意味着访问的过程结束了，文档渲染的过程就开始了。</p><p>这时，地址栏显示出表明安全的图标，同时显示出站点的信息。访问历史中也会加入当前的站点信息。为了能恢复访问历史信息，当页签或窗口被关闭时，访问历史的信息会被存储在硬盘中。</p><p><img data-src="https://static001.geekbang.org/infoq/b9/b9882cfdfbc700b2698116669bf40d4e.png" alt="img"></p><h3 id="Extra-Step：加载完毕"><a href="#Extra-Step：加载完毕" class="headerlink" title="Extra Step：加载完毕"></a>Extra Step：加载完毕</h3><p>当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面。当渲染进程”结束”渲染工作，会给浏览器进程发送消息，这个消息会在页面中所有子页面（frame）结束加载后发出，也就是onLoad事件触发后发送。当收到”结束”消息后，UI线程会隐藏页签标题上的加载状态图标，表明页面加载完毕。</p><p>但这里”结束”并不意味着所有的加载工作都结束了，因为可能还有JavaScript在加载额外的资源或者渲染新的视图。</p><p><img data-src="https://static001.geekbang.org/infoq/b9/b93f199ad2138be6e445d1ceb4416033.png" alt="img"></p><h2 id="访问不同的站点"><a href="#访问不同的站点" class="headerlink" title="访问不同的站点"></a>访问不同的站点</h2><p>﻿一次普通的访问到此就结束了。当我们输入另外一个地址时，浏览器进程会重复上面的过程。但是在开始新的访问前，会确认当前的站点是否关心<code>beforeunload</code>事件。</p><p><code>beforeunload</code>事件可以提醒用户是否要访问新的站点或者关闭页签，如果用户拒绝则新的访问或关闭会被阻止。</p><p>由于所有的包括渲染、运行Javascript的工作都发生在渲染进程中，浏览器进程需要在新的访问开始前与渲染进程确认当前的站点是否关心<code>unload</code>。</p><p><img data-src="https://static001.geekbang.org/infoq/71/71402d5b3a3f7d5629a242727e606079.png" alt="img"></p><p>如果一次访问是从一个渲染进程中发起的，例如用户点击一个链接或者运行JavaScript代码<code>location = &#39;http://newsite.com&#39;</code>时，渲染进程首先检查<code>beforeunload</code>。然后再执行和浏览器进程初始化访问同样的步骤，只不过区别在于这样的访问请求是由渲染进程向浏览器进程发起的。</p><p>当新的站点请求被创建时，一个独立的渲染进程将被用于处理这个请求。为了支持像<code>unload</code>的事件触发，老的渲染进程需要保持住当前的状态。更详细的生命周期介绍可以参考<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events">Page lifecycle</a>。</p><p><img data-src="https://static001.geekbang.org/infoq/e0/e074926b6b24cae624f6c1c906c16616.png" alt="img"></p><h2 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h2><p>Service worker是一种可以web开发者控制缓存的技术。如果Service worker被实现成从本地存储获取数据时，那么原本的请求就不会被浏览器发送给服务器了。</p><p>﻿</p><p>值得注意的是，Service worker中的代码是运行在渲染进程中的。当访问开始时，网络线程会根据域名检查是否有Service worker会处理当前地址的请求，如果有，则UI线程会找到对应的渲染进程去执行Service worker的代码，而Service worker可以让开发者决定这个请求是从本地存储还是从网络中获取数据。</p><p><img data-src="https://static001.geekbang.org/infoq/8c/8c45c55d238b901239d0eb4bd40f2892.png" alt="img"></p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/fd/fdeaee16c665e81bc59f42122080916f.png" alt="img"></p><h3 id="访问预加载"><a href="#访问预加载" class="headerlink" title="访问预加载"></a>访问预加载</h3><p>如果Service worker最终决定要从网络中获取数据时，我们会发现这种跨进程的通信会造成一些延迟。<a href="https://developers.google.com/web/updates/2017/02/navigation-preload">Navigation Preload</a>是一种可以在Service worker启动的同时加载资源的优化机制。借助特殊的请求头，服务器可以决定返回什么样的内容给浏览器。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/21/212631fa2520d730f17b0461ddae71d6.png" alt="img"></p><h3 id="渲染进程负责页面的内容"><a href="#渲染进程负责页面的内容" class="headerlink" title="渲染进程负责页面的内容"></a>渲染进程负责页面的内容</h3><p>渲染进程负责所有发生在浏览器页签中的事情。在一个渲染进程中，主线程负责解析，编译或运行代码等工作，当我们使用Worker时，Worker线程会负责运行一部分代码。合成线程和光栅线程是也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。</p><p>渲染进程最重要的工作就是将HTML、CSS和Javascript代码转换成一个可以与用户产生交互的页面。</p><p><img data-src="https://static001.geekbang.org/infoq/bd/bdfa66a4ef1fbd2805797bc4cd90f8d8.png" alt="img"></p><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>下面的章节主要介绍渲染进程如何将从网络线程中获取的文本转化成图像的过程。</p><h4 id="DOM的创建"><a href="#DOM的创建" class="headerlink" title="DOM的创建"></a>DOM的创建</h4><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受HTML数据，主线程开始解析HTML文本字符串，并且将其转化成<strong>Document Object Model（DOM）</strong>。</p><p>DOM是一种浏览器内部用于表达页面结构的数据，同时也为Web开发者提供了操作页面元素的接口，让web开发者可以在Javascript代码中获取和操作页面中的元素。</p><p>将HTML文本转化成DOM的标准被<a href="https://html.spec.whatwg.org/">HTML Standard</a>定义。我们会发现在转化过程中浏览器从来不会抛出异常，类似关闭标签的丢失，开始、关闭标签匹配错误等等。这是因为HTML标准中定义了要静默的处理这些错误，如果对此感兴趣可以阅读<a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a>。</p><h4 id="额外资源的加载"><a href="#额外资源的加载" class="headerlink" title="额外资源的加载"></a>额外资源的加载</h4><p>一个网站通常还会使用类似图片，样式文件和JavaScript代码等额外的资源。这些资源也需要从网络或缓存中获取。主线程在转化HTML的过程中理应挨个加载它们，但是为了提高效率，预加载扫描（Preload Scanner）与转换过程会同时运行着。当预加载扫描在分析器分析HTML过程中发现了类似img或link这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p><p><img data-src="https://static001.geekbang.org/infoq/fa/fa689d6a31b8687522c58774c8d9d064.png" alt="img"></p><h4 id="JavaScript会阻塞转化过程"><a href="#JavaScript会阻塞转化过程" class="headerlink" title="JavaScript会阻塞转化过程"></a>JavaScript会阻塞转化过程</h4><p>当HTML分析器发现<code>&lt;script&gt;</code>标签时，会暂停接下来的HTML转化工作，然后加载、解析并且运行Javascript代码。因为在Javascript代码中可能会使用类似<code>document.write</code>这样的API去改变DOM的结构。这就是为什么HTML分析器必须等待Javascript代码运行结束才能继续分析的原因。</p><h4 id="告诉浏览器要如何加载资源"><a href="#告诉浏览器要如何加载资源" class="headerlink" title="告诉浏览器要如何加载资源"></a>告诉浏览器要如何加载资源</h4><p>如果我们的Javascript代码并不需要改变DOM，可以为<code>&lt;script&gt;</code>标签添加<code>async</code>或<code>defer</code>属性，这样浏览器就会异步的加载这些资源并且不会阻塞HTML转化过程。<strong>如果script标签是由JavaScript代码创建的，标签的async属性会默认为true。</strong>同时我们也可以使用一些预加载技术，比如<code>&lt;link ref=&quot;preload&quot;&gt;</code>来通知浏览器这些资源需要越快下载越好。</p><h4 id="样式计算（Style-calculation）"><a href="#样式计算（Style-calculation）" class="headerlink" title="样式计算（Style calculation）"></a>样式计算（Style calculation）</h4><p>对于展示一个页面，光有DOM是不够的，因为我们还需要样式来让页面变得更美观。主线程会解析样式（CSS）并决定每个DOM元素的样式。这些样式取决于CSS选择器的范围，在浏览器开发者工具中我们可以看到这些信息。</p><p><img data-src="https://static001.geekbang.org/infoq/fb/fb7d195814a04c6ed98eab8dbda477c6.png" alt="img"></p><p>即使我们没有给DOM指定任何的样式，<code>&lt;h1&gt;</code>标签也会比<code>&lt;h2&gt;</code>标签显示的大。这是因为浏览器为不同的标签内置了不同的样式。可以通过<a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/resources/html.css">Chromium源代码</a>得到这些默认样式。</p><h4 id="布局（layout）"><a href="#布局（layout）" class="headerlink" title="布局（layout）"></a>布局（layout）</h4><p>完成了样式计算工作后，渲染进程已经知道了DOM的结构和每个节点的样式，但是依然不足以渲染一个页面。想象一下，让你在电话中向朋友描述一张图：“图中有一个大红色圆和一个小的、蓝色的方块”是不足以让朋友知道这张图到底是什么样的。</p><p><img data-src="https://static001.geekbang.org/infoq/06/0658494542e14f7db66b913c02c03202.png" alt="img"></p><p>布局是为元素指定几何信息的过程。主线程遍历DOM结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的布局树（Layout tree）。布局树的结构与DOM树的结构十分相似，但只包含将会在页面中显示的元素。<strong>当一个元素的样式被设置成display: none时，元素就不会出现在布局树中，但那些样式被设置成visiblility：hidden的元素会出现在布局树中。</strong>相似的，当我们使用一个包含内容的伪元素（例如<code>p::before &#123; content: &#39;Hi!&#39; &#125;</code>）时，元素会出现在布局树中即使这个元素不存在于DOM树中，这也是为什么我们<strong>使用DOM提供的API无法获取伪元素</strong>的原因。</p><p><img data-src="https://static001.geekbang.org/infoq/0c/0c1de85206f0d177f93a70931a0f8272.png" alt="img"></p><p>描述页面布局信息是一项具有挑战性的工作，即使在只有块元素的页面中也必须要考虑字体的大小和在哪里换行，因为在计算下一个元素的位置时需要知道上一个元素的尺寸和形状。</p><p>CSS可以让元素浮动、可以让元素在父元素中溢出，可以改变文字的方向。可以想象，在布局这个阶段是多么繁重的工作。在Chrome中，有一整个团队在维护布局工作，更详细的信息可以观看<a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA">视频</a>。</p><h4 id="绘制（Paint）"><a href="#绘制（Paint）" class="headerlink" title="绘制（Paint）"></a>绘制（Paint）</h4><p><img data-src="https://static001.geekbang.org/infoq/d8/d8fe81b968531c8b3d4767006ea9725d.png" alt="img"></p><p>有了DOM、样式和布局还是无法完成渲染工作。试想，当我们试图复制一张图画。我们知道图画中元素的尺寸、形状和位置，我们还需要知道绘制这些元素的顺序。</p><p>例如，当一个元素z-index属性被设置后，绘制的顺序会导致渲染成错误的结果。</p><p><img data-src="https://static001.geekbang.org/infoq/11/116fb1ec64e618a7562788911bca8d75.png" alt="img"></p><p>在这个阶段，主线程遍历布局树并创建绘制记录，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。</p><p><img data-src="https://static001.geekbang.org/infoq/a6/a68fd128fc59b9b2bed3511fcf223c94.png" alt="img"></p><h4 id="渲染过程是昂贵的"><a href="#渲染过程是昂贵的" class="headerlink" title="渲染过程是昂贵的"></a>渲染过程是昂贵的</h4><p>在渲染过程中，任何一个步骤中产生的数据变化都会引起后续一系列的的变化。例如，当布局树改变时，绘制需要重构页面中变化的部分。</p><p>当一些元素有动画发生时，浏览器需要在每一帧中绘制这些元素。当无法保证每一帧绘制的连续性时，用户就会感觉到卡顿。</p><p><img data-src="https://static001.geekbang.org/infoq/54/54a9da693ebba8579317ff57be2993ea.png" alt="img"></p><p>正常情况下渲染操作可以与屏幕刷新保持同步，但由于这些操作运行在主线程中，也就意味这些操作可能被正在运行的Javascript代码所阻塞。</p><p><img data-src="https://static001.geekbang.org/infoq/6b/6bd8886a8c2b26a72105c7a2fba7bf3a.png" alt="img"></p><p>为了不影响渲染操作，我们可以将Javascript操作优化成小块，然后使用<code>requestAnimationFrame()</code>，关于如何优化可以参考<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">Optimize JavaScript Exectuion</a>。当需要大量计算时，也可以使用Worker来避免阻塞主进程。</p><p><img data-src="https://static001.geekbang.org/infoq/45/45d6db6a394174c914eb37e13743f94d.png" alt="img"></p><h4 id="合成（Compositing）"><a href="#合成（Compositing）" class="headerlink" title="合成（Compositing）"></a>合成（Compositing）</h4><p>现在，浏览器已经知道了文档结构、每一个元素的样式，元素的几何信息，绘制的顺序。将这些信息转化成屏幕上像素的过程叫做光栅化，光栅化是图形学的范畴。</p><p><img data-src="https://static001.geekbang.org/infoq/9e/9ed512afc63c664458faf1bd42247cc0.gif" alt="img"></p><p>传统的做法是将可视区域的内容进行光栅化。随着用户滚动页面，不断的光栅化更多的区域。然而对于现代浏览器，有着更复杂的的过程，这个过程被称做合成。</p><p><img data-src="https://static001.geekbang.org/infoq/ae/ae1b6d19e8aeb45841f04bbfa72760dd.gif" alt="img"></p><p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组合成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层合成新的帧，动画则可以通过移动层来实现。</p><p>﻿</p><h4 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a>层（Layer）</h4><p>﻿</p><p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对开发者来说，当某一部分需要用独立的层渲染，我们可以使用css属性<code>will-change</code>让浏览器创建层，关于浏览器如何生成层的标准可自行查阅。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/b0/b08901dee7af151982f600e6a7a6ba43.png" alt="img"></p><p>layer.png</p><p>虽然通过分层可以优化浏览器性能，但并不意味着应该给每个元素一个层，过多的层反而影响性能，所以在层的划分上应该具体形况具体分析。</p><p>﻿</p><h4 id="栅格线程与合成线程"><a href="#栅格线程与合成线程" class="headerlink" title="栅格线程与合成线程"></a>栅格线程与合成线程</h4><p>当布局树和绘制顺序确定以后，主线程会将这些信息提交给合成线程。合成线程会光栅化各个层。一个层包含的内容可能是一个完整的页面，也可能是页面的部分，所以合成线程将层拆分成许多块，并将它们发送给栅格线程。栅格线程光栅化这些块并将它们存储在GPU缓存中。</p><p><img data-src="https://static001.geekbang.org/infoq/37/371b5fa654d59f0c8ccb2f4f0658c20a.png" alt="img"></p><p>合成线程可以决定栅格线程光栅块的优先级，这样可以保证用户能看到的部分可以先被光栅化。一个层也会包含多种块以支持类似缩放这样的功能。</p><p>当块被光栅化后，合成线程会使用draw quads收集这些信息并创建合成帧（Compositor frame）。</p><h4 id="Draw-quads"><a href="#Draw-quads" class="headerlink" title="Draw quads"></a>Draw quads</h4><p>存储在缓存中，包含类似块位置这样的信息，用于描述如何使用块合成页面。</p><h4 id="Compositor-frame"><a href="#Compositor-frame" class="headerlink" title="Compositor frame"></a>Compositor frame</h4><p>用于存储表现页面一帧中包含哪些Draw quads的集合。</p><p>然后一个合成帧被提交给浏览器进程。这时如果浏览器UI有变化，或者插件的UI有变化时，另一个合成帧就会被创建出来。所以每当有交互发生时，合成线程就会创建更多的合成帧然后通过GPU将新的部分渲染出来。</p><p><img data-src="https://static001.geekbang.org/infoq/39/397d4949099dd6d1aaffcb55e8678e37.png" alt="img"></p><p>合成的好处在于其独立于主线程。合成线程不需要等待样式计算和Javascript代码的运行。这也是为什么合成更适合优化交互性能，但如果布局或者绘制需要重新计算则主线程是必须要参与的。</p><p>﻿</p><p>本质上，浏览器的渲染过程就是将文本转换成图像的过程，而当用户与页面发生交互动作时，则显示新的图像。在这个过程中由渲染进程中的主线程完成计算工作，由合成线程和栅格线程完成图像的绘制工作。而在计算过程中，还有强制布局、重排、重绘等更加细节的概念会在后面的文章中做讲解。</p><h3 id="从浏览器的角度看事件"><a href="#从浏览器的角度看事件" class="headerlink" title="从浏览器的角度看事件"></a>从浏览器的角度看事件</h3><p>当我们听到事件时，通常会联想到在一个文本框中输入或者单击鼠标，但从浏览器的角度看，输入事件意味着所有的用户动作。鼠标滚轮滚动或者屏幕触摸都是输入事件。</p><p>﻿</p><p>当用户与页面发生交互时，浏览器进程首先接收到事件，然而，浏览器进程只关心事件发生时是在哪个页签中，所以浏览器进程会将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会恰当的找到事件发生的元素并且触发事件监听器。</p><p><img data-src="https://static001.geekbang.org/infoq/7f/7f8581ec78d48302c8ea81f713cdfa56.png" alt="img"></p><h3 id="合成线程对事件的处理"><a href="#合成线程对事件的处理" class="headerlink" title="合成线程对事件的处理"></a>合成线程对事件的处理</h3><p>在前面的章节中，我们知道了合成线程可以通过合成技术合成不同的光栅层优化性能，如果页面并不监听任何事件，合成线程可以完全独立于主线程生成新的合成帧。但如果页面监听了事件呢？</p><h4 id="标记“慢滚动”区域"><a href="#标记“慢滚动”区域" class="headerlink" title="标记“慢滚动”区域"></a>标记“慢滚动”区域</h4><p>由于运行Javascript是主线程的工作，当页面被合成线程合成过，合成线程会标记那些有事件监听的区域。有了这些信息，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理。如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p><p><img data-src="https://static001.geekbang.org/infoq/6f/6fda6b7355162ca393787e870630a083.png" alt="img"></p><h4 id="在事件监听时标记"><a href="#在事件监听时标记" class="headerlink" title="在事件监听时标记"></a>在事件监听时标记</h4><p>在web开发中常见的方式就是事件代理。利用事件冒泡，我们可以在目标元素的上层元素中监听事件。参照下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#39;touchstart&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  if (event.target &#x3D;&#x3D;&#x3D; area) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>﻿通过这种写法，可以更高效的监听事件。但如果从浏览器的角度看，此时整个页面会被标记成“慢滚动”区域。这意味着虽然页面中的某些部分并不需要事件监听，但合成线程依然要在每次交互发生后等待主线程处理事件，合成线程的优化效果不复存在。</p><p><img data-src="https://static001.geekbang.org/infoq/f2/f2e60c76e1cb2b104a46c0da8787d229.png" alt="img"></p><p>为了解决这个问题，我们可在事件代理时传入<code>passive: true</code><strong>（IE不支持）</strong>参数。这样告诉渲染线程，依然需要将事件发送给主线程处理，但不需要等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#39;touchstart&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">    if (event.target &#x3D;&#x3D;&#x3D; area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;passive: true&#125;);</span><br></pre></td></tr></table></figure><p>关于使用passive改善滚屏性能，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">MDN 使用passive改善滚屏性能</a>。</p><h4 id="查找事件目标"><a href="#查找事件目标" class="headerlink" title="查找事件目标"></a>查找事件目标</h4><p><img data-src="https://static001.geekbang.org/infoq/0e/0eb159798080da4adc7ffb76cf184ffa.png" alt="img"></p><p>当渲染线程将事件发送给主线程后，第一件事就是找到事件触发的目标。通过在渲染过程中生成的绘制信息，可以根据坐标找到目标元素。</p><h4 id="减少发送给主线程的事件数量"><a href="#减少发送给主线程的事件数量" class="headerlink" title="减少发送给主线程的事件数量"></a>减少发送给主线程的事件数量</h4><p>为了保证动画的顺畅，需要显示器在每秒刷新60次。对于典型的触摸事件由合成线程提交给主线程的事件频率可以达到每秒60-120次，对于典型的鼠标事件每秒会发送100次。事件发送的频率通常比屏幕刷新频率要高。</p><p>如果类似<code>touchmove</code>这样的事件每秒向主线程发送120次可能会造成主线程执行时间过长而影响性能。</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/61/6101cc07df5e744efb2a88208f1d1e52.png" alt="img"></p><p>为了减少发送给主线程的事件数量，Chrome合并了连续的事件。类似<code>wheel</code>，<code>mousewheel</code>，<code>mousemove</code>，<code>pointermove</code>，<code>touchmove</code>这样的事件会被延迟到下一次<code>requestAnimationFrame</code>前触发.</p><p>﻿</p><p><img data-src="https://static001.geekbang.org/infoq/53/53005a8114a736ca071a333946664ffd.png" alt="img"></p><p>而任何的离散事件，类似<code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>和 <code>touchend</code>都会立即被发送给主线程处理。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>到此，我们已经可以通过从用户在浏览器地址栏中的一次输入到页面图像的显示了解浏览器是如何工作的。这里我们总结一下。</p><ul><li>浏览器进程做为最重要的进程负责大多数页签外部的工作，包括地址栏显示、网络请求、页签状态管理等。</li><li>不同的渲染进程负责不同的站点渲染工作，渲染进程间彼此独立。</li><li>渲染进程在渲染页面的过程中会通过浏览器进程获取站点资源，只有安全的资源才会被渲染进程接收到。</li><li>渲染进程中主线程负责除了图像生成外绝大多数工作，如何减少主线程上代码的运行是交互性能优化的关键。</li><li>渲染进程中的合成线程和栅格线程负责图像生成，利用分层技术可以优化图像生成的效率。</li><li>当用户与页面发生交互时，事件的传播途径从浏览器进程到渲染进程的合成线程再根据事件监听的区域决定是否要传递给渲染进程的主线程处理。</li></ul><h1 id="8-浏览器的工作原理"><a href="#8-浏览器的工作原理" class="headerlink" title="8.浏览器的工作原理"></a>8.浏览器的工作原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 <code>google.com</code> 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p><h3 id="我们要讨论的浏览器"><a href="#我们要讨论的浏览器" class="headerlink" title="我们要讨论的浏览器"></a>我们要讨论的浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 <a href="http://gs.statcounter.com/">StatCounter 浏览器统计数据</a>，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p><h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p><p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p><p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签设置选项</li><li>用于刷新和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p><h3 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="headerlink" title="浏览器的高层结构"></a>浏览器的高层结构</h3><p>浏览器的主要组件为 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#1_1">1.1</a>)：</p><ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png" alt="img">图：浏览器的主要组件。</p><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>呈现引擎的作用嘛…当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。</p><p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p><h3 id="呈现引擎-1"><a href="#呈现引擎-1" class="headerlink" title="呈现引擎"></a>呈现引擎</h3><p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p><p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 <a href="http://webkit.org/">webkit.org</a>。</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>然后进行如下所示的基本流程：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png" alt="img">图：呈现引擎的基本流程。</p><p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#DOM">DOM</a> 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Render_tree_construction">呈现树</a>。</p><p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p><p>呈现树构建完毕之后，进入“<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#layout">布局</a>”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Painting">绘制</a> - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p><p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p><h4 id="主流程示例"><a href="#主流程示例" class="headerlink" title="主流程示例"></a>主流程示例</h4><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="img">图：WebKit 主流程</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg" alt="img">图：Mozilla 的 Gecko 呈现引擎主流程 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_6">3.6</a>)</p><p>从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p><p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p><h3 id="解析-综述"><a href="#解析-综述" class="headerlink" title="解析 - 综述"></a>解析 - 综述</h3><p>解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p><p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p><p>示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png" alt="img">图：数学表达式树节点</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#context_free_grammar">与上下文无关的语法</a>。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p><h4 id="解析器和词法分析器的组合"><a href="#解析器和词法分析器的组合" class="headerlink" title="解析器和词法分析器的组合"></a>解析器和词法分析器的组合</h4><p>解析的过程可以分成两个子过程：词法分析和语法分析。</p><p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p><p>语法分析是应用语言的语法规则的过程。</p><p>解析器通常将解析工作分给以下两个组件来处理：<strong>词法分析器</strong>（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而<strong>解析器</strong>负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png" alt="img">图：从源文档到解析树</p><p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p><p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png" alt="img">图：编译流程</p><h4 id="解析示例"><a href="#解析示例" class="headerlink" title="解析示例"></a>解析示例</h4><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p><p>词汇：我们用的语言可包含整数、加号和减号。</p><p>语法：</p><ol><li>构成语言的语法单位是表达式、项和运算符。</li><li>我们用的语言可以包含任意数量的表达式。</li><li>表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。</li><li>运算符是加号或减号。</li><li>项是一个整数或一个表达式</li></ol><p>让我们分析一下 2 + 3 - 1。<br>匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。</p><h4 id="词汇和语法的正式定义"><a href="#词汇和语法的正式定义" class="headerlink" title="词汇和语法的正式定义"></a>词汇和语法的正式定义</h4><p>词汇通常用<a href="http://www.regular-expressions.info/">正则表达式</a>表示。</p><p>例如，我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INTEGER :0|[1-9][0-9]*</span><br><span class="line">PLUS : +</span><br><span class="line">MINUS: -</span><br></pre></td></tr></table></figure><p>正如您所看到的，这里用正则表达式给出了整数的定义。</p><p>语法通常使用一种称为 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> 的格式来定义。我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expression :&#x3D;  term  operation  term</span><br><span class="line">operation :&#x3D;  PLUS | MINUS</span><br><span class="line">term :&#x3D; INTEGER | expression</span><br></pre></td></tr></table></figure><p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅<a href="http://en.wikipedia.org/wiki/Context-free_grammar">关于与上下文无关的语法的维基百科文章</a>。</p><h4 id="解析器类型"><a href="#解析器类型" class="headerlink" title="解析器类型"></a>解析器类型</h4><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p><p>让我们来看看这两种解析器会如何解析我们的示例：</p><p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p><p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p><table><thead><tr><th>堆栈</th><th>输入</th></tr></thead><tbody><tr><td></td><td>2 + 3 - 1</td></tr><tr><td>项</td><td>+ 3 - 1</td></tr><tr><td>项运算</td><td>3 - 1</td></tr><tr><td>表达式</td><td>- 1</td></tr><tr><td>表达式运算符</td><td>1</td></tr><tr><td>表达式</td><td></td></tr></tbody></table><p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p><h4 id="自动生成解析器"><a href="#自动生成解析器" class="headerlink" title="自动生成解析器"></a>自动生成解析器</h4><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p><p>WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> 以及用于创建解析器的 <a href="http://www.gnu.org/software/bison/">Bison</a>（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p><h3 id="HTML-解析器"><a href="#HTML-解析器" class="headerlink" title="HTML 解析器"></a>HTML 解析器</h3><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p><h4 id="HTML-语法定义"><a href="#HTML-语法定义" class="headerlink" title="HTML 语法定义"></a>HTML 语法定义</h4><p>HTML 的词汇和语法在 W3C 组织创建的<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#w3c">规范</a>中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。</p><h4 id="非与上下文无关的语法"><a href="#非与上下文无关的语法" class="headerlink" title="非与上下文无关的语法"></a>非与上下文无关的语法</h4><p>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p><p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p><p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p><p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p><p>区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。</p><p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p><h4 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h4><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 <a href="http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a> 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p><p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：<a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a></p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“<a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt; &lt;img src&#x3D;&quot;example.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>可翻译成如下的 DOM 树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt="img">图：示例标记的 DOM 树</p><p>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a>。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：<a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。</p><p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。</p><h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p><p>原因在于：</p><ol><li>语言的宽容本质。</li><li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li><li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 <code>document.write</code>，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li></ol><p>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。</p><p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">HTML5 规范详细地描述了解析算法</a>。此算法由两个阶段组成：标记化和树构建。</p><p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png" alt="img">图：HTML 解析流程（摘自 HTML5 规范）</p><h4 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h4><p>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p><p>基本示例 - 将下面的 HTML 代码标记化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>初始状态是数据状态。遇到字符 <code>&lt;</code> 时，状态更改为<strong>“标记打开状态”</strong>。接收一个 <code>a-z</code> 字符会创建“起始标记”，状态更改为<strong>“标记名称状态”</strong>。这个状态会一直保持到接收 <code>&gt;</code> 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 <code>html</code> 标记。</p><p>遇到 <code>&gt;</code> 标记时，会发送当前的标记，状态改回<strong>“数据状态”</strong>。<code>&lt;body&gt;</code> 标记也会进行同样的处理。目前 <code>html</code> 和 <code>body</code> 标记均已发出。现在我们回到<strong>“数据状态”</strong>。接收到 <code>Hello world</code> 中的 <code>H</code> 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 <code>&lt;</code>。我们将为 <code>Hello world</code> 中的每个字符都发送一个字符标记。</p><p>现在我们回到<strong>“标记打开状态”</strong>。接收下一个输入字符 <code>/</code> 时，会创建 <code>end tag token</code> 并改为<strong>“标记名称状态”</strong>。我们会再次保持这个状态，直到接收 <code>&gt;</code>。然后将发送新的标记，并回到<strong>“数据状态”</strong>。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png" alt="img">图：对示例输入进行标记化</p><h4 id="树构建算法"><a href="#树构建算法" class="headerlink" title="树构建算法"></a>树构建算法</h4><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p><p>让我们来看看示例输入的树构建过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是<strong>“initial mode”</strong>。接收 HTML 标记后转为<strong>“before html”</strong>模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p><p>然后状态将改为<strong>“before head”</strong>。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p><p>现在我们进入了<strong>“in head”</strong>模式，然后转入<strong>“after head”</strong>模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为<strong>“in body”</strong>。</p><p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p><p>接收 body 结束标记会触发<strong>“after body”</strong>模式。现在我们将接收 HTML 结束标记，然后进入<strong>“after after body”</strong>模式。接收到文件结束标记后，解析过程就此结束。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif" alt="img">图：示例 HTML 的树构建</p><h4 id="解析结束后的操作"><a href="#解析结束后的操作" class="headerlink" title="解析结束后的操作"></a>解析结束后的操作</h4><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。</p><p>您可以<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">在 HTML5 规范中查看标记化和树构建的完整算法</a></p><h4 id="浏览器的容错机制"><a href="#浏览器的容错机制" class="headerlink" title="浏览器的容错机制"></a>浏览器的容错机制</h4><p>您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p><p>以下面的 HTML 代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;mytag&gt;</span><br><span class="line">  &lt;&#x2F;mytag&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">    Really lousy HTML</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p><p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p><p>HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p><blockquote><p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。</p><p>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。</p><p>我们至少要能够处理以下错误情况：</p><ol><li>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。</li><li>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。</li><li>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。</li><li>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。</li></ol></blockquote><p>让我们看一些 WebKit 容错的示例：</p><h5 id="使用了-而不是"><a href="#使用了-而不是" class="headerlink" title="使用了  而不是 "></a>使用了 </br> 而不是 <br></h5><p>有些网站使用了 </br> 而不是 <br>。为了与 IE 和 Firefox 兼容，WebKit 将其与 <br> 做同样的处理。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p><h5 id="离散表格"><a href="#离散表格" class="headerlink" title="离散表格"></a>离散表格</h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。<br>比如以下的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>WebKit 会将其层次结构更改为两个同级表格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (m_inStrayTableContent &amp;&amp; localName &#x3D;&#x3D; tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure><p>WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。</p><h5 id="嵌套的表单元素"><a href="#嵌套的表单元素" class="headerlink" title="嵌套的表单元素"></a>嵌套的表单元素</h5><p>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement &#x3D; new HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过于复杂的标记层次结构"><a href="#过于复杂的标记层次结构" class="headerlink" title="过于复杂的标记层次结构"></a>过于复杂的标记层次结构</h5><p>代码的注释已经说得很清楚了。</p><blockquote><p>示例网站 <a href="http://www.liceo.edu.mx/">www.liceo.edu.mx</a> 嵌套了约 1500 个标记，全都来自一堆 <b> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned i &#x3D; 0;</span><br><span class="line">for (HTMLStackElem* curr &#x3D; m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName &#x3D;&#x3D; tagName;</span><br><span class="line">     curr &#x3D; curr-&gt;next, i++) &#123; &#125;</span><br><span class="line">return i !&#x3D; cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="放错位置的-html-或者-body-结束标记"><a href="#放错位置的-html-或者-body-结束标记" class="headerlink" title="放错位置的 html 或者 body 结束标记"></a>放错位置的 html 或者 body 结束标记</h5><p>同样，代码的注释已经说得很清楚了。</p><blockquote><p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;tagName &#x3D;&#x3D; htmlTag || t-&gt;tagName &#x3D;&#x3D; bodyTag )</span><br><span class="line">        return;</span><br></pre></td></tr></table></figure><p>所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p><h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，<a href="http://www.w3.org/TR/CSS2/grammar.html">CSS 规范定义了 CSS 的词法和语法</a>。</p><p>让我们来看一些示例：<br>词法语法（词汇）是针对各个标记用正则表达式定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment   \&#x2F;\*[^*]*\*+([^&#x2F;*][^*]*\*+)*\&#x2F;</span><br><span class="line">num   [0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii  [\200-\377]</span><br><span class="line">nmstart   [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar    [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name    &#123;nmchar&#125;+</span><br><span class="line">ident   &#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。</p><p>语法是采用 BNF 格式描述的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : <span class="string">&#x27;.&#x27;</span> IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : <span class="string">&#x27;[&#x27;</span> S* IDENT S* [ [ <span class="string">&#x27;=&#x27;</span> | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] <span class="string">&#x27;]&#x27;</span></span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : <span class="string">&#x27;:&#x27;</span> [ IDENT | FUNCTION S* [IDENT S*] <span class="string">&#x27;)&#x27;</span> ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>解释：这是一个规则集的结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.error</span> , <span class="selector-tag">a</span><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">    : selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。</p><h4 id="WebKit-CSS-解析器"><a href="#WebKit-CSS-解析器" class="headerlink" title="WebKit CSS 解析器"></a>WebKit CSS 解析器</h4><p>WebKit 使用 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#parser_generators">Flex 和 Bison</a> 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png" alt="img">图：解析 CSS</p><h3 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p><h3 id="呈现树构建"><a href="#呈现树构建" class="headerlink" title="呈现树构建"></a>呈现树构建</h3><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。<br>WebKits RenderObject 类是所有呈现器的基类，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RenderObject&#123;</span><br><span class="line">  virtual void layout();</span><br><span class="line">  virtual void paint(PaintInfo);</span><br><span class="line">  virtual void rect repaintRect();</span><br><span class="line">  Node* node;  &#x2F;&#x2F;the DOM node</span><br><span class="line">  RenderStyle* style;  &#x2F;&#x2F; the computed style</span><br><span class="line">  RenderLayer* containgLayer; &#x2F;&#x2F;the containing z-index layer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。<br>框的类型会受到与节点相关的“display”样式属性的影响（请参阅<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#style_computation">样式计算</a>章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">    Document* doc &#x3D; node-&gt;document();</span><br><span class="line">    RenderArena* arena &#x3D; doc-&gt;renderArena();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    switch (style-&gt;display()) &#123;</span><br><span class="line">        case NONE:</span><br><span class="line">            break;</span><br><span class="line">        case INLINE:</span><br><span class="line">            o &#x3D; new (arena) RenderInline(node);</span><br><span class="line">            break;</span><br><span class="line">        case BLOCK:</span><br><span class="line">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case INLINE_BLOCK:</span><br><span class="line">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case LIST_ITEM:</span><br><span class="line">            o &#x3D; new (arena) RenderListItem(node);</span><br><span class="line">            break;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。<br>在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 <code>createRenderer</code> 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p><h5 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h5><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。</p><p>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p><p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt="img">图：呈现树及其对应的 DOM 树 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_1">3.1</a>)。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。</p><h5 id="构建呈现树的流程"><a href="#构建呈现树的流程" class="headerlink" title="构建呈现树的流程"></a>构建呈现树的流程</h5><p>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 <code>FrameConstructor</code>，由该构造器解析样式（请参阅<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#style">样式计算</a>）并创建框架。</p><p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。</p><p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 <code>ViewPortFrame</code>，而 WebKit 称之为 <code>RenderView</code>。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p><p>请参阅<a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">关于处理模型的 CSS2 规范</a>。</p><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p><p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。</p><p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。</p><p>样式计算存在以下难点：</p><ol><li><p>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</p></li><li><p>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p><p>例如下面这个组合选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div div div div&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着规则适用于作为 3 个 div 元素的子代的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>。如果您要检查规则是否适用于某个指定的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。</p></li><li><p>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。</p></li></ol><p>让我们来看看浏览器是如何处理这些问题的：</p><h5 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h5><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li><li>任何元素都没有 ID</li><li>标记名称应匹配</li><li>类属性应匹配</li><li>映射属性的集合必须是完全相同的</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li><li>元素中不能有任何 inline 样式属性</li><li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li></ol><h5 id="Firefox-规则树"><a href="#Firefox-规则树" class="headerlink" title="Firefox 规则树"></a>Firefox 规则树</h5><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image035.png" alt="img">图：Firefox 样式上下文树 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#2_2">2.2</a>)</p><p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p><p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p><p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/tree.png" alt="img"></p><p>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。</p><p>让我们看看规则树如何帮助我们减少工作。</p><h5 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。</p><p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p><h5 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。<br>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p><p>如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在<strong>上下文树</strong>中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。</p><p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p><p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享<strong>整个样式上下文</strong>。</p><p>让我们来看一个例子，假设我们有如下 HTML 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        this is a &lt;span class&#x3D;&quot;big&quot;&gt; big error &lt;&#x2F;span&gt;</span><br><span class="line">        this is also a</span><br><span class="line">        &lt;span class&#x3D;&quot;big&quot;&gt; very  big  error&lt;&#x2F;span&gt; error</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div2&quot;&gt;another error&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>还有如下规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;<span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;<span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;<span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;<span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;<span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure><p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。<br>形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image027.png" alt="img">图：规则树</p><p>上下文树如下图所示（节点名 : 指向的规则节点）：</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image029.png" alt="img">图：上下文树</p><p>假设我们解析 HTML 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p><p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p><p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p><p>第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p><p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。<br>例如，如果我们在某个段落中添加 font 规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure><p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。</p><p>在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。</p><p>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue1">1</a> 和问题 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue3">3</a>。Firefox 规则树还有助于按照正确的顺序应用属性。</p><h5 id="对规则进行处理以简化匹配"><a href="#对规则进行处理以简化匹配" class="headerlink" title="对规则进行处理以简化匹配"></a>对规则进行处理以简化匹配</h5><p>样式规则有一些来源：</p><ul><li><p>外部样式表或样式元素中的 CSS 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>inline 样式属性及类似内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style&#x3D;&quot;color:blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li><li><p>HTML 可视化属性（映射到相关的样式规则）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p bgcolor&#x3D;&quot;blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure></li></ul><p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p><p>我们之前在<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#issue2">第 2 个问题</a>中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p><p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。<br>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#4_1">4.1</a>)。</p><p>我们以如下的样式规则为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.error &#123;color:red&#125;</span><br><span class="line">#messageDiv &#123;height:50px&#125;</span><br><span class="line">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。<br>对于下面的 HTML 代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;error&quot;&gt;an error occurred &lt;&#x2F;p&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;messageDiv&quot;&gt;this is a message&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。<br>例如，如果 div 的对应规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。</p><p>WebKit 和 Firefox 都进行了这一处理。</p><h5 id="以正确的层叠顺序应用规则"><a href="#以正确的层叠顺序应用规则" class="headerlink" title="以正确的层叠顺序应用规则"></a>以正确的层叠顺序应用规则</h5><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p><p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p><h5 id="样式表层叠顺序"><a href="#样式表层叠顺序" class="headerlink" title="样式表层叠顺序"></a>样式表层叠顺序</h5><p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p><ol><li>浏览器声明</li><li>用户普通声明</li><li>作者普通声明</li><li>作者重要声明</li><li>用户重要声明</li></ol><p>浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Specificity">特异性</a>进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p><h5 id="特异性"><a href="#特异性" class="headerlink" title="特异性"></a>特异性</h5><p>选择器的特异性由 <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">CSS2 规范</a>定义如下：</p><ul><li>如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li><li>记为选择器中 ID 属性的个数 (= b)</li><li>记为选择器中其他属性和伪类的个数 (= c)</li><li>记为选择器中元素名称和伪元素的个数 (= d)</li></ul><p>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。</p><p>您使用的进制取决于上述类别中的最高计数。<br>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。</p><p>一些示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*             &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,0,0,0 *&#x2F;</span><br><span class="line">li            &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;1 -&gt; specificity &#x3D; 0,0,0,1 *&#x2F;</span><br><span class="line">li:first-line &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class="line">ul li         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class="line">ul ol+li      &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;3 -&gt; specificity &#x3D; 0,0,0,3 *&#x2F;</span><br><span class="line">h1 + *[rel&#x3D;up]&#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;1 -&gt; specificity &#x3D; 0,0,1,1 *&#x2F;</span><br><span class="line">ul ol li.red  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;3 -&gt; specificity &#x3D; 0,0,1,3 *&#x2F;</span><br><span class="line">li.red.level  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;2 d&#x3D;1 -&gt; specificity &#x3D; 0,0,2,1 *&#x2F;</span><br><span class="line">#x34y         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;1 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,1,0,0 *&#x2F;</span><br><span class="line">style&#x3D;&quot;&quot;          &#x2F;* a&#x3D;1 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 1,0,0,0 *&#x2F;</span><br></pre></td></tr></table></figure><h5 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h5><p>找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“&gt;”运算符来实现排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 &#x3D; r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 &#x3D; r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 &#x3D;&#x3D; spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="渐进式处理"><a href="#渐进式处理" class="headerlink" title="渐进式处理"></a>渐进式处理</h4><p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p><p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_5">3.5</a>)。</p><p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p><p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <code>&lt;html&gt;</code> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</p><p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。</p><p>所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p><h4 id="Dirty-位系统"><a href="#Dirty-位系统" class="headerlink" title="Dirty 位系统"></a>Dirty 位系统</h4><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p><p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p><h4 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h4><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p><ol><li>影响所有呈现器的全局样式更改，例如字体大小更改。</li><li>屏幕大小调整。</li></ol><p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p><p><img data-src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/reflow.png" alt="img">图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#3_6">3.6</a>)。</p><h4 id="异步布局和同步布局"><a href="#异步布局和同步布局" class="headerlink" title="异步布局和同步布局"></a>异步布局和同步布局</h4><p>增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。<br>请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。<br>全局布局往往是同步触发的。<br>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。<br>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。</p><h4 id="布局处理"><a href="#布局处理" class="headerlink" title="布局处理"></a>布局处理</h4><p>布局通常具有以下模式：</p><ol><li>父呈现器确定自己的宽度。</li><li>父呈现器依次处理子呈现器，并且：<ol><li>放置子呈现器（设置 x,y 坐标）。</li><li>如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。</li></ol></li><li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。</li><li>将其 dirty 位设置为 false。</li></ol><p>Firefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。<br>Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p><h4 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h4><p>呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。<br>例如以下 div 的宽度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width:30%&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：</p><ul><li><p>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientWidth() - paddingLeft() - paddingRight()</span><br></pre></td></tr></table></figure><p>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。</p></li><li><p>元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。</p></li><li><p>然后加上水平方向的边框和补白。</p></li></ul><p>现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。<br>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。</p><p>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><h4 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h4><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p><h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p><a href="http://www.w3.org/TR/CSS21/zindex.html">CSS2 规范定义了绘制流程的顺序</a>。绘制的顺序其实就是元素进入<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext">堆栈样式上下文</a>的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><h4 id="Firefox-显示列表"><a href="#Firefox-显示列表" class="headerlink" title="Firefox 显示列表"></a>Firefox 显示列表</h4><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。</p><p>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p><h4 id="WebKit-矩形存储"><a href="#WebKit-矩形存储" class="headerlink" title="WebKit 矩形存储"></a>WebKit 矩形存储</h4><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。</p><h3 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h3><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p><h3 id="呈现引擎的线程"><a href="#呈现引擎的线程" class="headerlink" title="呈现引擎的线程"></a>呈现引擎的线程</h3><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。<br>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure><h1 id="9-内存泄露"><a href="#9-内存泄露" class="headerlink" title="9.内存泄露"></a>9.<a href="https://segmentfault.com/a/1190000020231307">内存泄露</a></h1><p>用户一般不会在一个 Web 页面停留比较久，即使有一点内存泄漏，重载页面内存也会跟着释放。而且浏览器也有自动回收内存的机制，所以我们前端其实并没有像 C、C++ 这类语言一样，特别关注内存泄漏的问题。</p><p>但是如果我们对内存泄漏没有什么概念，有时候还是有可能因为内存泄漏，导致页面卡顿。了解内存泄漏，如何避免内存泄漏，也是我们提升前端技能的必经之路。</p><h2 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h2><blockquote><p>在硬件级别上，计算机内存由大量触发器组成。每个触发器包含几个晶体管，能够存储一个位。单个触发器可以通过唯一标识符寻址，因此我们可以读取和覆盖它们。因此，从概念上讲，我们可以把我们的整个计算机内存看作是一个巨大的位数组，我们可以读和写。</p></blockquote><p>这么底层的概念，了解下就好，绝大多数数情况下，JavaScript 语言作为你们高级语言，无需我们使用二进制进直接进行读和写。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>内存也是有<strong>生命周期</strong>的，不管什么程序语言，一般可以按顺序分为三个周期：</p><ul><li><p>分配期</p><p>分配所需要的内存</p></li><li><p>使用期</p><p>使用分配到的内存（读、写）</p></li><li><p>释放期</p><p>不需要时将其释放和归还</p></li></ul><p>内存分配 -&gt; 内存使用 -&gt; 内存释放。</p><h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98">内存</a>。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p></blockquote><p>如果内存不需要时，没有经过生命周期的<strong>释放期</strong>，那么就存在<strong>内存泄漏</strong>。</p><p>内存泄漏简单理解：无用的内存还在占用，得不到释放和归还。比较严重时，无用的内存会持续递增，从而导致整个系统卡顿，甚至崩溃。</p><h2 id="JavaScript-内存管理机制"><a href="#JavaScript-内存管理机制" class="headerlink" title="JavaScript 内存管理机制"></a>JavaScript 内存管理机制</h2><blockquote><p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 <code>malloc()</code>和<code>free()</code>。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。</p></blockquote><p>JavaScript 内存管理机制和内存的<strong>生命周期</strong>是一一对应的。首先需要<strong>分配内存</strong>，然后<strong>使用内存</strong>，最后<strong>释放内存</strong>。</p><p>其中 JavaScript 语言<strong>不需要程序员手动</strong>分配内存，绝大部分情况下也不需要手动释放内存，对 JavaScript 程序员来说通常就是使用内存（即使用变量、函数、对象等）。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>JavaScript 定义变量就会自动分配内存的。<strong>我们只需了解 JavaScript 的内存是自动分配的就足够了</strong>。</p><p>看下内存自动分配的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给数值变量分配内存</span><br><span class="line">let number &#x3D; 123; </span><br><span class="line">&#x2F;&#x2F; 给字符串分配内存</span><br><span class="line">const string &#x3D; &quot;xianshannan&quot;; </span><br><span class="line">&#x2F;&#x2F; 给对象及其包含的值分配内存</span><br><span class="line">const object &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: null</span><br><span class="line">&#125;; </span><br><span class="line">&#x2F;&#x2F; 给数组及其包含的值分配内存（就像对象一样）</span><br><span class="line">const array &#x3D; [1, null, &quot;abra&quot;]; </span><br><span class="line">&#x2F;&#x2F; 给函数（可调用的对象）分配内存</span><br><span class="line">function func(a)&#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><blockquote><p>使用值的过程实际上是对分配内存进行<strong>读取与写入</strong>的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p></blockquote><p>根据上面的内存自动分配例子，我们继续内存使用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写入内存</span><br><span class="line">number &#x3D; 234;</span><br><span class="line">&#x2F;&#x2F; 读取 number 和 func 的内存，写入 func 参数内存</span><br><span class="line">func(number);</span><br></pre></td></tr></table></figure><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>前端界一般称<strong>垃圾内存回收</strong>为 <code>GC</code>（Garbage Collection，即垃圾回收）。</p><p><strong>内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，如果存在这些情况，需要我们手动清理内存。</strong></p><p>以前一些老版本的浏览器的 JavaScript 回收机制没那么完善，经常出现一些 bug 的内存泄漏，不过现在的浏览器基本都没这些问题了，已过时的知识这里就不做深究了。</p><p>这里了解下现在的 JavaScript 的垃圾内存的两种回收方式，熟悉下这两种算法可以帮助我们理解一些内存泄漏的场景。</p><h4 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h4><blockquote><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p>看下下面的例子，“这个对象”的内存被回收了吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; “这个对象”分配给 a 变量</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; b 引用“这个对象”</span><br><span class="line">var b &#x3D; a; </span><br><span class="line">&#x2F;&#x2F; 现在，“这个对象”的原始引用 a 被 b 替换了</span><br><span class="line">a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>当前执行环境中，“这个对象”内存还没有被回收的，需要手动释放“这个对象”的内存（当然是还没离开执行环境的情况下），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 或者 b &#x3D; 1，反正替换“这个对象”就行了</span><br></pre></td></tr></table></figure><p>这样引用的”这个对象”的内存就被回收了。</p><p>ES6 把<strong>引用</strong>有区分为<strong>强引用</strong>和<strong>弱引用</strong>，这个目前只有在 Set 和 Map 中才有。</p><p><strong>强引用</strong>才会有<strong>引用计数</strong>叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（手动回收的前提在于<strong>标记清除法</strong>还没执行，还处于当前执行环境）。</p><p>而<strong>弱引用</strong>没有触发<strong>引用计数</strong>叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。</p><h4 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h4><blockquote><p>当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收</p></blockquote><p>环境可以理解为我们的作用域，但是全局作用域的变量只会在页面关闭才会销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设这里是全局变量</span><br><span class="line">&#x2F;&#x2F; b 被标记进入环境</span><br><span class="line">var b &#x3D; 2;</span><br><span class="line">function test() &#123;</span><br><span class="line">  var a &#x3D; 1;</span><br><span class="line">  &#x2F;&#x2F; 函数执行时，a 被标记进入环境</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数执行结束，a 被标记离开环境，被回收</span><br><span class="line">&#x2F;&#x2F; 但是 b 就没有被标记离开环境</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h2 id="JavaScript-内存泄漏的一些场景"><a href="#JavaScript-内存泄漏的一些场景" class="headerlink" title="JavaScript 内存泄漏的一些场景"></a>JavaScript 内存泄漏的一些场景</h2><p>JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况。程序员要让浏览器内存泄漏，浏览器也是管不了的。</p><p><strong>下面有些例子是在执行环境中，没离开当前执行环境，还没触发标记清除法。所以你需要读懂上面 JavaScript 的内存回收机制，才能更好理解下面的场景。</strong></p><h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在全局作用域下定义</span><br><span class="line">function count(number) &#123;</span><br><span class="line">  &#x2F;&#x2F; basicCount 相当于 window.basicCount &#x3D; 2;</span><br><span class="line">  basicCount &#x3D; 2;</span><br><span class="line">  return basicCount + number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在 eslint 帮助下，这种场景现在基本没人会犯了，eslint 会直接报错，了解下就好。</p><h3 id="被遗忘的计时器"><a href="#被遗忘的计时器" class="headerlink" title="被遗忘的计时器"></a>被遗忘的计时器</h3><p>无用的计时器忘记清理是新手最容易犯的错误之一。</p><p>就拿一个 vue 组件来做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    refresh() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取一些数据</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setInterval(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 轮询获取数据</span><br><span class="line">      this.refresh()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，<code>setInterval</code> 还是在运行的，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候清除计时器，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    refresh() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取一些数据</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.refreshInterval &#x3D; setInterval(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 轮询获取数据</span><br><span class="line">      this.refresh()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    clearInterval(this.refreshInterval)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的事件监听器"><a href="#被遗忘的事件监听器" class="headerlink" title="被遗忘的事件监听器"></a>被遗忘的事件监听器</h3><p>无用的事件监听器忘记清理是新手最容易犯的错误之一。</p><p>还是继续使用 vue 组件做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里做一些操作</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，resize 事件还是在监听中，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候移除相关的事件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.resizeEventCallback &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里做一些操作</span><br><span class="line">    &#125;</span><br><span class="line">    window.addEventListener(&#39;resize&#39;, this.resizeEventCallback)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    window.removeEventListener(&#39;resize&#39;, this.resizeEventCallback)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的-ES6-Set-成员"><a href="#被遗忘的-ES6-Set-成员" class="headerlink" title="被遗忘的 ES6 Set 成员"></a>被遗忘的 ES6 Set 成员</h3><p>如果对 Set 不熟悉，可以看<a href="http://es6.ruanyifeng.com/#docs/set-map#Set">这里</a>。</p><p>如下是有内存泄漏的（成员是引用类型的，即对象）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Set();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">value&#x3D; null;</span><br></pre></td></tr></table></figure><p>需要改成这样，才没内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Set();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">map.delete(value);</span><br><span class="line">value &#x3D; null;</span><br></pre></td></tr></table></figure><p>有个更便捷的方式，使用 WeakSet，WeakSet 的成员是<strong>弱引用</strong>，内存回收不会考虑到这个引用是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new WeakSet();</span><br><span class="line">let value &#x3D; &#123; test: 22&#125;;</span><br><span class="line">map.add(value);</span><br><span class="line"></span><br><span class="line">value &#x3D; null;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的-ES6-Map-键名"><a href="#被遗忘的-ES6-Map-键名" class="headerlink" title="被遗忘的 ES6 Map 键名"></a>被遗忘的 ES6 Map 键名</h3><p>如果对 Map 不熟悉，可以看<a href="http://es6.ruanyifeng.com/#docs/set-map#Map">这里</a>。</p><p>如下是有内存泄漏的（键值是引用类型的，即对象）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><p>需要改成这样，才没内存泄漏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new Map();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line"></span><br><span class="line">map.delete(key);</span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><p>有个更便捷的方式，使用 WeakMap，WeakMap 的键名是<strong>弱引用</strong>，内存回收不会考虑到这个引用是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let map &#x3D; new WeakMap();</span><br><span class="line">let key &#x3D; new Array(5 * 1024 * 1024);</span><br><span class="line">map.set(key, 1);</span><br><span class="line"></span><br><span class="line">key &#x3D; null;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的订阅发布事件监听器"><a href="#被遗忘的订阅发布事件监听器" class="headerlink" title="被遗忘的订阅发布事件监听器"></a>被遗忘的订阅发布事件监听器</h3><p>这个跟上面的<strong>被遗忘的事件监听器</strong>的道理是一样的。</p><p>假设订阅发布事件有三个方法 <code>emit</code> 、<code>on</code> 、<code>off</code> 三个方法。</p><p>还是继续使用 vue 组件做例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;onClick&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import customEvent from &#39;event&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      customEvent.emit(&#39;test&#39;, &#123; type: &#39;click&#39; &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    customEvent.on(&#39;test&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 一些逻辑</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>上面的组件销毁的时候，自定义 test 事件还是在监听中，里面涉及到的内存都是没法回收的（浏览器会认为这是必须的内存，不是垃圾内存），需要在组件销毁的时候移除相关的事件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;onClick&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import customEvent from &#39;event&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick() &#123;</span><br><span class="line">      customEvent.emit(&#39;test&#39;, &#123; type: &#39;click&#39; &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    customEvent.on(&#39;test&#39;, data &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 一些逻辑</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    customEvent.off(&#39;test&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="被遗忘的闭包"><a href="#被遗忘的闭包" class="headerlink" title="被遗忘的闭包"></a>被遗忘的闭包</h3><p>闭包是经常使用的，闭包能给我们带来很多便利。</p><p>首先看下这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function closure() &#123;</span><br><span class="line">  const name &#x3D; &#39;xianshannan&#39;</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    return name</span><br><span class="line">      .split(&#39;&#39;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const reverseName &#x3D; closure()</span><br><span class="line">&#x2F;&#x2F; 这里调用了 reverseName</span><br><span class="line">reverseName();</span><br></pre></td></tr></table></figure><p>上面有没有内存泄漏？</p><p>上面是没有内存泄漏的，因为<code>name</code> 变量是要用到的（非垃圾）。这也是从侧面反映了闭包的缺点，内存占用相对高，量多了会有性能影响。</p><p>但是改成这样就是有内存泄漏的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function closure() &#123;</span><br><span class="line">  const name &#x3D; &#39;xianshannan&#39;</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    return name</span><br><span class="line">      .split(&#39;&#39;)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const reverseName &#x3D; closure()</span><br></pre></td></tr></table></figure><p>在当前执行环境未结束的情况下，严格来说，这样是有内存泄漏的，<code>name</code> 变量是被 <code>closure</code> 返回的函数调用了，但是返回的函数没被使用，这个场景下 <code>name</code> 就属于垃圾内存。<code>name</code> 不是必须的，但是还是占用了内存，也不可被回收。</p><p>当然这种也是极端情况，很少人会犯这种低级错误。这个例子可以让我们更清楚的认识内存泄漏。</p><h3 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h3><p>每个页面上的 DOM 都是占用内存的，假设有一个页面 A 元素，我们获取到了 A 元素 DOM 对象，然后赋值到了一个变量（内存指向是一样的），然后移除了页面的 A 元素，如果这个变量由于其他原因没有被回收，那么就存在内存泄漏，如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.elements &#x3D; &#123;</span><br><span class="line">      button: document.querySelector(&#39;#button&#39;),</span><br><span class="line">      div: document.querySelector(&#39;#div&#39;),</span><br><span class="line">      span: document.querySelector(&#39;#span&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeButton() &#123;</span><br><span class="line">    document.body.removeChild(this.elements.button)</span><br><span class="line">    &#x2F;&#x2F; this.elements.button &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const a &#x3D; new Test()</span><br><span class="line">a.removeButton()</span><br></pre></td></tr></table></figure><p>上面的例子 button 元素 虽然在页面上移除了，但是内存指向换为了 <code>this.elements.button</code>，内存占用还是存在的。所以上面的代码还需要这样写： <code>this.elements.button = null</code>，手动释放这个内存。</p><h2 id="如何发现内存泄漏？"><a href="#如何发现内存泄漏？" class="headerlink" title="如何发现内存泄漏？"></a>如何发现内存泄漏？</h2><p>内存泄漏时，内存一般都是会周期性的增长，我们可以借助谷歌浏览器的开发者工具进行判别。</p><p>这里不进行详细的开发者工具使用说明，详细看<a href="https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn">谷歌开发者工具</a>，不过谷歌浏览器是不断迭代更新的，有些文档落后了，界面长得不一样。</p><p>本人测试的谷歌版本为：<strong>版本 76.0.3809.100（正式版本） （64 位）</strong>。</p><p>这里针对下面例子进行一步一步的排查和找到问题出现在哪里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;run&quot;&gt;运行&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button id&#x3D;&quot;stop&quot;&gt;停止&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const arr &#x3D; []</span><br><span class="line">      for (let i &#x3D; 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        arr.push(i)</span><br><span class="line">      &#125;</span><br><span class="line">      let newArr &#x3D; []</span><br><span class="line"></span><br><span class="line">      function run() &#123;</span><br><span class="line">        newArr &#x3D; newArr.concat(arr)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let clearRun</span><br><span class="line"></span><br><span class="line">      document.querySelector(&#39;#run&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">        clearRun &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">          run()</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      document.querySelector(&#39;#stop&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">        clearInterval(clearRun)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面例子的代码可以直接运行的，怎么运行我就不多说了。</p><h3 id="第一步：确定是否是内存泄漏问题"><a href="#第一步：确定是否是内存泄漏问题" class="headerlink" title="第一步：确定是否是内存泄漏问题"></a>第一步：确定是否是内存泄漏问题</h3><p>访问上面的代码页面，打开谷歌开发者工具，切换至 <strong>Performance</strong> 选项，勾选 <code>Memory</code> 选项。</p><p>在页面上点击<strong>运行按钮</strong>，然后在开发者工具上面点击左上角的录制按钮，10 秒后在页面上点击<strong>停止按钮</strong>，5 秒后停止内存录制。得到的内存走势如下：</p><p><img data-src="https://segmentfault.com/img/bVbxaaT" alt="clipboard.png"></p><p>由上图可知，10 秒之前内存周期性增长，10 后点击了停止按钮，内存平稳，不再递增。</p><p>我们可以使用内存走势图判断当前页面是否有内存泄漏。经过测试上面的代码 <code>20000</code> 个数组项改为 <code>20</code> 个数组项，内存走势也一样能看出来。</p><h3 id="第二步：查找内存泄漏出现的位置"><a href="#第二步：查找内存泄漏出现的位置" class="headerlink" title="第二步：查找内存泄漏出现的位置"></a>第二步：查找内存泄漏出现的位置</h3><p>上一步确认是内存泄漏问题后，我们继续利用谷歌开发者工具进行问题查找。</p><p>访问上面的代码页面，打开谷歌开发者工具，切换至 <strong>Memory</strong> 选项。页面上点击运行按钮，然后点击开发者工具左上角录制按钮，录制完成后继续点击录制，知道录制完三个为止。然后点击页面的停止按钮，再连续录制 3 次内存（不要清理之前的录制）。下图就是进行这些步骤后的截图：</p><p><img data-src="https://segmentfault.com/img/bVbxaaO" alt="clipboard.png"></p><p>从这里也可以看出，点击运行按钮后，内存在不断递增。点击停止按钮后，内存就平稳了。虽然我们也可以使用这样的方式来判别是否存在内存泄漏，但是不够第一步的方法便捷，走势图也更直观。</p><p>然后第二步的主要目的来了，记录 JavaScript 堆内存才是内存录制的主要目的，我们可以看到哪个堆占用的内存更高。</p><p>在刚才的录制中选择 Snapshot 3 ，然后按照 <strong>Shallow Size</strong> 进行逆序排序（不了解的可以看<a href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101?hl=zh-cn">内存术语</a>），如下：</p><p><img data-src="https://segmentfault.com/img/bVbxaaL" alt="clipboard.png"></p><p>从内存记录中，发现 array 对象占用最大，展开后发现，第一个 <code>object elements</code> 占用最大，选择这个 <code>object elements</code> 后可以在下面看到 <code>newArr</code> 变量，然后点击 <code>test:23</code>，只要是高亮下划线的地方都可以进去看看 （测试页面是 test.html），可以跳转到 <code>newArr</code> 附近。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">维基百科-内存泄漏</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li><li><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></li><li><a href="https://juejin.im/post/5b684f30f265da0f9f4e87cf">javascript 垃圾回收机制</a></li><li><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML" scheme="https://hxy1997.xyz/tags/HTML/"/>
    
    <category term="浏览器" scheme="https://hxy1997.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>一起愉快刷题</title>
    <link href="https://hxy1997.xyz/2021/03/09/%E4%B8%80%E8%B5%B7%E6%84%89%E5%BF%AB%E5%88%B7%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/09/%E4%B8%80%E8%B5%B7%E6%84%89%E5%BF%AB%E5%88%B7%E9%A2%98/</id>
    <published>2021-03-08T16:02:39.000Z</published>
    <updated>2021-03-30T13:14:55.211Z</updated>
    
    <content type="html"><![CDATA[<p>按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号</p><span id="more"></span><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h4 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a>03. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h4><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;= n &lt;= 100000</p></blockquote><p>解法一</p><p>哈希表，时间复杂度为O(N)，空间复杂度为O(N)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 新建无重复的set</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.has(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二</p><p>置换,时间复杂度为O(N)，空间复杂度为O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> * 置换法</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历元素</span><br><span class="line">    for (let i &#x3D; 0; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">        &#x2F;&#x2F;   当前数字</span><br><span class="line">        let cur &#x3D; nums[i];</span><br><span class="line">        &#x2F;&#x2F; 当前位置是否是自身可能已经排行</span><br><span class="line">        if (cur !&#x3D;&#x3D; i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前位置的数放在原来的索引的位置上</span><br><span class="line">            if (cur !&#x3D;&#x3D; nums[cur]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 暂时存储</span><br><span class="line">                let temp &#x3D; nums[cur];</span><br><span class="line">                nums[cur] &#x3D; cur;</span><br><span class="line">                cur &#x3D; temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p></blockquote><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>双指针，时间复杂度为O(m+n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;boolean&#125;&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findNumberIn2DArray &#x3D; function(matrix, target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 排除长或宽为0</span><br><span class="line">    if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0) return false;</span><br><span class="line">    &#x2F;&#x2F; 长</span><br><span class="line">    let lenX &#x3D; matrix.length;</span><br><span class="line">    &#x2F;&#x2F; 宽</span><br><span class="line">    let lenY &#x3D; matrix[0].length;</span><br><span class="line">    &#x2F;&#x2F; 行指针和列指针</span><br><span class="line">    let x &#x3D; 0, y &#x3D; lenY - 1;</span><br><span class="line">    &#x2F;&#x2F; 不越界</span><br><span class="line">    while(x &lt; lenX &amp;&amp; y &gt;&#x3D; 0)&#123;</span><br><span class="line">        if (matrix[x][y] &#x3D;&#x3D; target)&#123;</span><br><span class="line">            &#x2F;&#x2F; 找到目标</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (matrix[x][y] &gt; target)&#123;</span><br><span class="line">            &#x2F;&#x2F; 大于目标列指针减小</span><br><span class="line">            y--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 小于目标行指针增加</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 越界说明找不到</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><blockquote><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p>限制：</p><blockquote><p>0 &lt;= s 的长度 &lt;= 10000</p></blockquote><p>正则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> * 正则表达式</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;\s&#x2F;g, &quot;%20&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> * 库函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.split(&#39; &#39;).join(&#39;%20&#39;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p>无需翻转链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var reversePrint &#x3D; function(head) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数组</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 不断移动链表</span><br><span class="line">    while(head !&#x3D; null)&#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻转链表，额外空间降为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var reversePrint &#x3D; function(head) &#123;</span><br><span class="line">    if (!head) return [];</span><br><span class="line">    &#x2F;&#x2F; 之前的和当前指针</span><br><span class="line">    let pre &#x3D; head, cur &#x3D; head.next;</span><br><span class="line">    &#x2F;&#x2F; 反转链表</span><br><span class="line">    while(cur !&#x3D; null)&#123;</span><br><span class="line">        pre.next &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; head;</span><br><span class="line">        head &#x3D; cur;</span><br><span class="line">        cur &#x3D; pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 头指针</span><br><span class="line">    cur &#x3D; head;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a>07.<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/"> 重建二叉树</a></h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure><p>直接递归划分子前序遍历和中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; preorder</span><br><span class="line"> * @param &#123;number[]&#125; inorder</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归出口</span><br><span class="line">    if (preorder.length &lt;&#x3D; 0) return null;</span><br><span class="line">    &#x2F;&#x2F; 前序遍历第一个节点为根节点</span><br><span class="line">    let node &#x3D; new TreeNode(preorder[0]);</span><br><span class="line">    &#x2F;&#x2F; 找到中序遍历对应的节点</span><br><span class="line">    let i &#x3D; inorder.indexOf(preorder[0]);</span><br><span class="line">    &#x2F;&#x2F; 左节点递归构造子二叉树</span><br><span class="line">    node.left &#x3D; buildTree(preorder.slice(1, i + 1), inorder.slice(0, i));</span><br><span class="line">    &#x2F;&#x2F; 右节点递归构造子二叉树</span><br><span class="line">    node.right &#x3D; buildTree(preorder.slice(i + 1, preorder.length), inorder.slice(i + 1, inorder.length));</span><br><span class="line">    &#x2F;&#x2F; 返回根节点</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>牺牲空间优化速度，保存每个子节点 在中序遍历中的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    if (preorder.length &#x3D;&#x3D;&#x3D; 0) return null;</span><br><span class="line">    const map &#x3D; new Map();</span><br><span class="line">    const len &#x3D; inorder.length;</span><br><span class="line">    &#x2F;&#x2F; 空间换时间</span><br><span class="line">    for (let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        map.set(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    function tree (pre, inor, pre_start, pre_end, inor_start, inor_end) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根节点</span><br><span class="line">        const root_val &#x3D; pre[pre_start];</span><br><span class="line">        const root &#x3D; new TreeNode(root_val);</span><br><span class="line">        &#x2F;&#x2F; 在中序遍历中的位置</span><br><span class="line">        const inor_root_index &#x3D; map.get(root_val);</span><br><span class="line">        &#x2F;&#x2F; 左子树长度</span><br><span class="line">        const lsonLen &#x3D; inor_root_index - inor_start;</span><br><span class="line">        &#x2F;&#x2F; 右子树长度</span><br><span class="line">        const rsonLen &#x3D; inor_end - inor_root_index;</span><br><span class="line">        &#x2F;&#x2F; 左子树构建</span><br><span class="line">        if (lsonLen &gt; 0) &#123;</span><br><span class="line">            root.left &#x3D; tree(pre, inor, pre_start + 1, pre_start + 1 + lsonLen, inor_start, inor_root_index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右子树构建</span><br><span class="line">        if (rsonLen &gt; 0) &#123;</span><br><span class="line">            root.right &#x3D; tree(pre, inor, pre_start + 1 + lsonLen, pre_end, inor_root_index + 1, inor_end);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return tree(preorder, inorder, 0, len - 1, 0, len - 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09.用两个栈实现队列"></a>09.<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h4><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue &#x3D; new MyQueue();</span><br><span class="line">myQueue.push(1); &#x2F;&#x2F; queue is: [1]</span><br><span class="line">myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); &#x2F;&#x2F; return 1</span><br><span class="line">myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]</span><br><span class="line">myQueue.empty(); &#x2F;&#x2F; return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p>使用第一个栈作为入栈，第二个栈作为出栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initialize your data structure here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">var MyQueue &#x3D; function() &#123;</span><br><span class="line">this.stack1 &#x3D; [];</span><br><span class="line">this.stack2 &#x3D; [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Push element x to the back of queue. </span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MyQueue.prototype.push &#x3D; function(x) &#123;</span><br><span class="line">this.stack1.push(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Removes the element from in front of queue and returns that element.</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MyQueue.prototype.pop &#x3D; function() &#123;</span><br><span class="line">if (this.stack2.length) &#123;</span><br><span class="line">return this.stack2.pop();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while (this.stack1.length) &#123;</span><br><span class="line">this.stack2.push(this.stack1.pop());</span><br><span class="line">&#125;</span><br><span class="line">return this.stack2.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Get the front element.</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MyQueue.prototype.peek &#x3D; function() &#123;</span><br><span class="line">if (this.stack2.length) &#123;</span><br><span class="line">return this.stack2[this.stack2.length - 1];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">while (this.stack1.length) &#123;</span><br><span class="line">this.stack2.push(this.stack1.pop());</span><br><span class="line">&#125;</span><br><span class="line">return this.stack2[this.stack2.length - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns whether the queue is empty.</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">MyQueue.prototype.empty &#x3D; function() &#123;</span><br><span class="line">if (this.stack1.length &#x3D;&#x3D; 0 &amp;&amp; this.stack2.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="line"> * var obj &#x3D; new MyQueue()</span><br><span class="line"> * obj.push(x)</span><br><span class="line"> * var param_2 &#x3D; obj.pop()</span><br><span class="line"> * var param_3 &#x3D; obj.peek()</span><br><span class="line"> * var param_4 &#x3D; obj.empty()</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title="10. 斐波那契数列"></a>10. <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列</a></h4><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>动态规划已经优化好的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; N</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> * 动态规划</span><br><span class="line"> *&#x2F;</span><br><span class="line">var fib &#x3D; function(N) &#123;</span><br><span class="line">    &#x2F;&#x2F; 长度不够</span><br><span class="line">    if (N &lt; 2) return N;</span><br><span class="line">    &#x2F;&#x2F; 优化的动态规划</span><br><span class="line">    let dp0 &#x3D; 0, dp1 &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 动态规划</span><br><span class="line">    for (let i &#x3D; 2; i &lt;&#x3D; N; i++) &#123;</span><br><span class="line">        let temp &#x3D; dp0 + dp1;</span><br><span class="line">        dp0 &#x3D; dp1;</span><br><span class="line">        dp1 &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp1 % 1000000007;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通项公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; N</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> * 通项公式</span><br><span class="line"> *&#x2F;</span><br><span class="line">var fib &#x3D; function(N) &#123;</span><br><span class="line">    const sqrt5 &#x3D; Math.sqrt(5);</span><br><span class="line">    const fibN &#x3D; Math.pow((1 + sqrt5) &#x2F; 2, N) - Math.pow((1 - sqrt5) &#x2F; 2, N);</span><br><span class="line">    return Math.round(fibN &#x2F; sqrt5);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-寻找旋转排序数组中的最小值"><a href="#11-寻找旋转排序数组中的最小值" class="headerlink" title="11.寻找旋转排序数组中的最小值 "></a>11.<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 </a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><p>二分查找法（这里考虑了会重复的情况）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> * 二分查找</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findMin &#x3D; function(nums) &#123;</span><br><span class="line">    &#x2F;&#x2F; 长度</span><br><span class="line">    let n &#x3D; nums.length;</span><br><span class="line">    if (n &#x3D;&#x3D;&#x3D; 0) return 0;</span><br><span class="line">    &#x2F;&#x2F; 左右指针</span><br><span class="line">    let left &#x3D; 0, right &#x3D; n - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        &#x2F;&#x2F; 中间节点</span><br><span class="line">        let mid &#x3D; left + ((right - left) &gt;&gt;&gt; 1);</span><br><span class="line">        if (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">            &#x2F;&#x2F; 中&lt;右 ,排除中（不包含中）到右</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125; else if (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            &#x2F;&#x2F; 中&gt;右 ,排除左到中（包含中）</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (nums[mid] &#x3D;&#x3D;&#x3D; nums[right]) &#123;</span><br><span class="line">            if (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 左&gt;中 ,排除中（不包含中）到右</span><br><span class="line">                right &#x3D; mid;</span><br><span class="line">            &#125; else if (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                &#x2F;&#x2F; 左&lt;中 ,左节点就是最小</span><br><span class="line">                right &#x3D; left;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 右指针左移</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[left];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li></ul><p>回溯法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var exist &#x3D; function(board, word) &#123;</span><br><span class="line">    let row &#x3D; board.length;</span><br><span class="line">    let col &#x3D; board[0].length;</span><br><span class="line"></span><br><span class="line">    function dfs (i, j, board, word, index) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断不符合条件</span><br><span class="line">        if(i &lt; 0 || i &gt;&#x3D; row || j &lt; 0 || j &gt; col || board[i][j] !&#x3D;&#x3D; word[index]) return false;</span><br><span class="line">        &#x2F;&#x2F; word遍历完了</span><br><span class="line">        if(index &#x3D;&#x3D;&#x3D; word.length - 1) return true;</span><br><span class="line">        &#x2F;&#x2F; 记录到board的值</span><br><span class="line">        let tmp &#x3D; board[i][j];</span><br><span class="line">        &#x2F;&#x2F; 锁上，因为后续的递归是4个方向上的，无法保证上一个方向的值</span><br><span class="line">        board[i][j] &#x3D; &#39;-&#39;;</span><br><span class="line">        let res &#x3D;  dfs(i - 1, j, board, word, index + 1) || dfs(i + 1, j, board, word, index + 1) || dfs(i, j - 1, board, word, index + 1) || dfs(i, j + 1, board, word, index + 1);     </span><br><span class="line">        &#x2F;&#x2F; 恢复现场</span><br><span class="line">        board[i][j] &#x3D; tmp;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历整个board，找到初始位置点</span><br><span class="line">    for(let i &#x3D; 0; i &lt; row; i++)&#123;</span><br><span class="line">        for(let j &#x3D; 0; j &lt; col; j++)&#123;</span><br><span class="line">            if (dfs(i, j, board, word, 0)) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没找到</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h4><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><p>思路是如果一个数从上方和左方无法访问，从下方和右方也无法 访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var movingCount &#x3D; function(m, n, k) &#123;</span><br><span class="line">    if (!k) return 1;</span><br><span class="line">    let vis &#x3D; new Array(m);</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    var countSum &#x3D; function (n)&#123;</span><br><span class="line">        let sum &#x3D; 0;</span><br><span class="line">        while (n) &#123;</span><br><span class="line">            sum +&#x3D; n % 10;</span><br><span class="line">            n &#x3D; Math.floor(n &#x2F; 10);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        vis[i] &#x3D; new Array(n);</span><br><span class="line">        for (let j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            let sum &#x3D; countSum(i) + countSum(j);</span><br><span class="line">            if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                vis[i][j] &#x3D; sum &lt;&#x3D; k;</span><br><span class="line">            &#125; else if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                vis[i][j] &#x3D; vis[i][j - 1] &amp;&amp; (sum &lt;&#x3D; k);</span><br><span class="line">            &#125; else if (j &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                vis[i][j] &#x3D; vis[i - 1][j] &amp;&amp; (sum &lt;&#x3D; k);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                vis[i][j] &#x3D; (vis[i - 1][j] || vis[i][j - 1]) &amp;&amp; (sum &lt;&#x3D; k);</span><br><span class="line">            &#125;</span><br><span class="line">            if (vis[i][j]) count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="14-整数拆分"><a href="#14-整数拆分" class="headerlink" title="14.整数拆分"></a>14.<a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h4><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 <em>n</em> 不小于 2 且不大于 58。</p><p>尽可能拆分更多的3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var cuttingRope &#x3D; function(n) &#123;</span><br><span class="line">    if (n &lt; 4) return n - 1;</span><br><span class="line">    let r &#x3D; Math.floor(n &#x2F; 3);</span><br><span class="line">    switch (n % 3) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            return Math.pow(3, r) % 1000000007;</span><br><span class="line">        case 1:</span><br><span class="line">            return 4 * Math.pow(3, r - 1) % 1000000007;</span><br><span class="line">        case 2:</span><br><span class="line">            return 2 * Math.pow(3, r) % 1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-位1的个数"><a href="#15-位1的个数" class="headerlink" title="15.位1的个数"></a>15.<a href="https://leetcode-cn.com/problems/number-of-1-bits/">位1的个数</a></h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li></ul><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p><strong>进阶</strong>：</p><ul><li>如果多次调用这个函数，你将如何优化你的算法？</li></ul><p>位运算通过n &amp;= n - 1消去末尾的1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n - a positive integer</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var hammingWeight &#x3D; function(n) &#123;</span><br><span class="line">    let number &#x3D; 0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        number++;</span><br><span class="line">        n &amp;&#x3D; n - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><p>先把问题转换求幂为正数的情况，再通过幂的位运算求出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var myPow &#x3D; function(x, n) &#123;</span><br><span class="line">    if (x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; 1) return x;</span><br><span class="line">    x &#x3D; n &gt;&#x3D; 0 ? x: 1 &#x2F; x;</span><br><span class="line">    if(n !&#x3D; -2147483648)&#123;</span><br><span class="line">        n &#x3D; n &gt;&#x3D; 0 ? n: -n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        n &#x3D; 2147483648 &#x2F; 2;</span><br><span class="line">        x &#x3D; x * x; </span><br><span class="line">    &#125;</span><br><span class="line">    let res &#x3D; 1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if (n &amp; 1) res *&#x3D; x;</span><br><span class="line">        x *&#x3D; x;</span><br><span class="line">        n &gt;&gt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.<a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h4><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aa&quot; p &#x3D; &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ab&quot; p &#x3D; &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aab&quot; p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;mississippi&quot; p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 20</code></li><li><code>0 &lt;= p.length &lt;= 30</code></li><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><p>没什么好说的，动态规划走起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;string&#125; p</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 动态规划法</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isMatch &#x3D; function(s, p) &#123;</span><br><span class="line">    if (!p) return !s;</span><br><span class="line">    let m &#x3D; s.length, n &#x3D; p.length;</span><br><span class="line">    &#x2F;&#x2F; dp[i][j]表示s前i个字符子串和p前j个字符子串是否匹配</span><br><span class="line">    let dp &#x3D; Array.from(Array(m + 1), () &#x3D;&gt; Array(n + 1).fill(false));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    dp[0][0] &#x3D; true;</span><br><span class="line">    for (let j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">        if (p[j - 1] &#x3D;&#x3D; &#39;*&#39;)&#123;</span><br><span class="line">            dp[0][j] &#x3D; dp[0][j - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 主函数</span><br><span class="line">    for (let i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">        for (let j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; s第i个字符与p第j个字符相同或p第j个字符为.</span><br><span class="line">            if (s[i - 1] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;) &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">            &#125; else if (j &gt;&#x3D; 2 &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; p第j个字符为*</span><br><span class="line">                &#x2F;&#x2F; s第i个字符与p第j-1个字符相同或p第j-1个字符为.</span><br><span class="line">                if ((s[i - 1] &#x3D;&#x3D; p[j - 2] || p[j - 2] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i][j] &#x3D; dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2]</span><br><span class="line">                    dp[i][j] &#x3D; dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i][j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化一下空间，这个空间压缩稍微费点事，要考虑原本默认为false的所有情况，相对有点繁琐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;string&#125; p</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 动态规划法 路径压缩</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isMatch &#x3D; function(s, p) &#123;</span><br><span class="line">    if (!p) return !s;</span><br><span class="line">    let m &#x3D; s.length, n &#x3D; p.length;</span><br><span class="line">    &#x2F;&#x2F; dp[i][j]表示s前i个字符子串和p前j个字符子串是否匹配</span><br><span class="line">    &#x2F;&#x2F; let dp &#x3D; Array.from(Array(m + 1), () &#x3D;&gt; Array(n + 1).fill(false));</span><br><span class="line">    let dp &#x3D; new Array(n + 1).fill(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    &#x2F;&#x2F; dp[0][0] &#x3D; true;</span><br><span class="line">    dp[0] &#x3D; true;</span><br><span class="line">    for (let j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">        if (p[j - 1] &#x3D;&#x3D; &#39;*&#39;)&#123;</span><br><span class="line">            &#x2F;&#x2F; dp[0][j] &#x3D; dp[0][j - 2];</span><br><span class="line">            dp[j] &#x3D; dp[j - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[0] &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 主函数</span><br><span class="line">    for (let i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">        let pre &#x3D; i &#x3D;&#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">        for (let j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">            let temp &#x3D; dp[j];</span><br><span class="line">            &#x2F;&#x2F; s第i个字符与p第j个字符相同或p第j个字符为.</span><br><span class="line">            if (s[i - 1] &#x3D;&#x3D; p[j - 1] || p[j - 1] &#x3D;&#x3D; &#39;.&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">                dp[j] &#x3D; pre;</span><br><span class="line">            &#125; else if (j &gt;&#x3D; 2 &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; p第j个字符为*</span><br><span class="line">                &#x2F;&#x2F; s第i个字符与p第j-1个字符相同或p第j-1个字符为.</span><br><span class="line">                if ((s[i - 1] &#x3D;&#x3D; p[j - 2] || p[j - 2] &#x3D;&#x3D; &#39;.&#39;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i][j - 1] 单个字符匹配的情况; dp[i - 1][j] 多个字符匹配的情况; dp[i][j - 2] 没有匹配的情况</span><br><span class="line">                    &#x2F;&#x2F; dp[i][j] &#x3D; dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];</span><br><span class="line">                    dp[j] &#x3D; dp[j - 1] || dp[j] || dp[j - 2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; dp[i][j] &#x3D; dp[i][j - 2];</span><br><span class="line">                    dp[j] &#x3D; dp[j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[j] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            pre &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><p>利用js内置的isNaN函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isNumber &#x3D; function(s) &#123;</span><br><span class="line">    s &#x3D; s.trim();</span><br><span class="line">    if(!s) return false;</span><br><span class="line">    return !isNaN(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采用正则表达式，这个很直观，就是要耐心写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isNumber &#x3D; function(s) &#123;</span><br><span class="line">&#x2F;&#x2F; 去除前后空格后，符号（可选）+数字（e之前可以是）+e&#x2F;E之后的整数（可以没有)</span><br><span class="line">    return &#x2F;^[+-]?\d*(\.\d+)?([eE][+-]?\d+)?$&#x2F;.test(s.trim());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有限自动状态机，这个真的难写，自己想都要想很久，更别说写了，重在理解状态机的概念，比如promise本质就是个状态机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 有限状态自动机</span><br><span class="line"> * 0 起始的空格</span><br><span class="line"> * 1 e 之前的符号</span><br><span class="line"> * 2 .之前的数字</span><br><span class="line"> * 3 .之后的数字</span><br><span class="line"> * 4 当.之前为空之后的数字</span><br><span class="line"> * 5 e</span><br><span class="line"> * 6 e之后的符号</span><br><span class="line"> * 7 e之后的数字</span><br><span class="line"> * 8 尾部的空格</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isNumber &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始状态为0</span><br><span class="line">    let state &#x3D; 0, </span><br><span class="line">        &#x2F;&#x2F; 最后是否能结束</span><br><span class="line">        finals &#x3D; [0, 0, 0, 1, 0, 1, 1, 0, 1],</span><br><span class="line">        &#x2F;&#x2F; 状态转移表</span><br><span class="line">        transfer &#x3D; [[ 0, 1, 6, 2,-1,-1],</span><br><span class="line">                    [-1,-1, 6, 2,-1,-1],</span><br><span class="line">                    [-1,-1, 3,-1,-1,-1],</span><br><span class="line">                    [ 8,-1, 3,-1, 4,-1],</span><br><span class="line">                    [-1, 7, 5,-1,-1,-1],</span><br><span class="line">                    [ 8,-1, 5,-1,-1,-1],</span><br><span class="line">                    [ 8,-1, 6, 3, 4,-1],</span><br><span class="line">                    [-1,-1, 5,-1,-1,-1],</span><br><span class="line">                    [ 8,-1,-1,-1,-1,-1]], </span><br><span class="line">        &#x2F;&#x2F; 读取字符串中元素</span><br><span class="line">        make &#x3D; (c) &#x3D;&gt; &#123;</span><br><span class="line">            switch(c) &#123;</span><br><span class="line">                case &quot; &quot;: return 0;</span><br><span class="line">                case &quot;+&quot;:</span><br><span class="line">                case &quot;-&quot;: return 1;</span><br><span class="line">                case &quot;.&quot;: return 3;</span><br><span class="line">                case &quot;e&quot;:</span><br><span class="line">                case &quot;E&quot;:return 4;</span><br><span class="line">                default:</span><br><span class="line">                    let code &#x3D; c.charCodeAt();</span><br><span class="line">                    if(code &gt;&#x3D; 48 &amp;&amp; code &lt;&#x3D; 57) &#123;</span><br><span class="line">                        return 2;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return 5;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#x2F;&#x2F; 遍历字符串</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 转移结果</span><br><span class="line">        state &#x3D; transfer[state][make(s[i])];</span><br><span class="line">        &#x2F;&#x2F; 小于0表示着不表示字符</span><br><span class="line">        if (state &lt; 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return finals[state];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p> <strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ol><li><code>0 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10000</code></li></ol><p>额外空间O(1)，时间O(N)需要使用双指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var exchange &#x3D; function (nums) &#123;</span><br><span class="line">    if (!nums.length) return nums;</span><br><span class="line">    &#x2F;&#x2F; 双指针</span><br><span class="line">    let left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (nums[left] &amp; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 奇数则不操作</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 偶数则与右指针交换元素</span><br><span class="line">            [nums[left], nums[right]] &#x3D; [nums[right], nums[left]];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点"></a>22.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><p>采用双指针解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getKthFromEnd &#x3D; function(head, k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 空指针返回</span><br><span class="line">    if(head &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 快慢指针</span><br><span class="line">    let fast &#x3D; head, slow &#x3D; head;</span><br><span class="line">    &#x2F;&#x2F; 循环</span><br><span class="line">    for (let i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 快指针到达末尾</span><br><span class="line">        if (fast &#x3D;&#x3D;&#x3D; null) return null;</span><br><span class="line">        fast &#x3D; fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 快指针达到末尾</span><br><span class="line">    while(fast !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        fast &#x3D; fast.next;</span><br><span class="line">        slow &#x3D; slow.next</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h4><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>迭代法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reverseList &#x3D; function(head) &#123;</span><br><span class="line">    if(head &#x3D;&#x3D; null) return null;</span><br><span class="line">    let pre &#x3D; head, cur &#x3D; head.next;</span><br><span class="line">    while(cur !&#x3D; null)&#123;</span><br><span class="line">        pre.next &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; head;</span><br><span class="line">        head &#x3D; cur;</span><br><span class="line">        cur &#x3D; pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reverseList &#x3D; function(head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    const newHead &#x3D; reverseList(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="25-合并两个有序链表"><a href="#25-合并两个有序链表" class="headerlink" title="25. 合并两个有序链表"></a>25.<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/"> 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>双指针，O(m+n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var mergeTwoLists &#x3D; function(l1, l2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 头指针</span><br><span class="line">    let dummy &#x3D; new ListNode(0);</span><br><span class="line">    &#x2F;&#x2F; 当前指针</span><br><span class="line">    let cur &#x3D; dummy;</span><br><span class="line">    &#x2F;&#x2F; 两个数组均有数</span><br><span class="line">    while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">        if (l1.val &lt;&#x3D; l2.val) &#123;</span><br><span class="line">            cur.next &#x3D; l1;</span><br><span class="line">            l1 &#x3D; l1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur.next &#x3D; l2;</span><br><span class="line">            l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当前指针前进</span><br><span class="line">        cur &#x3D; cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将未遍历完的赋值</span><br><span class="line">    cur.next &#x3D; l1 ? l1 : l2;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><p>难度简单119</p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>   4  /  \ 2   7 / \  / \1  3 6  9</code><br>镜像输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4  &#x2F;  \ 7   2 &#x2F; \  &#x2F; \9  6 3  1</span><br></pre></td></tr></table></figure><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p> <strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var invertTree &#x3D; function(root) &#123;</span><br><span class="line">    &#x2F;&#x2F;terminator</span><br><span class="line">    if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;process </span><br><span class="line">    const temp &#x3D; root.left;</span><br><span class="line">    root.left &#x3D;root.right;</span><br><span class="line">    root.right &#x3D; temp;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; drill down</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; reverse states</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a></h4><p>难度简单190</p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li></ul><p>双指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; headA</span><br><span class="line"> * @param &#123;ListNode&#125; headB</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">    let pointA &#x3D; headA, pointB &#x3D; headB;</span><br><span class="line">    while (pointA !&#x3D; pointB) &#123;</span><br><span class="line">        pointA &#x3D; pointA? pointA.next: headB;</span><br><span class="line">        pointB &#x3D; pointB? pointB.next: headA;</span><br><span class="line">    &#125;</span><br><span class="line">    return pointA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; headA</span><br><span class="line"> * @param &#123;ListNode&#125; headB</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">    const map &#x3D; new Map();</span><br><span class="line">    let node &#x3D; headA;</span><br><span class="line">    while (node) &#123;</span><br><span class="line">        map.set(node, true);</span><br><span class="line">        node &#x3D; node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node &#x3D; headB;</span><br><span class="line">    while (node) &#123;</span><br><span class="line">        if (map.has(node)) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        node &#x3D; node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 - I.二叉树的深度"></a>55 - I.<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p>采用递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var maxDepth &#x3D; function(root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D;&#x3D; null) return 0;</span><br><span class="line">    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归剪枝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var maxDepth &#x3D; function(root) &#123;</span><br><span class="line">    if(!root) return 0</span><br><span class="line">    let max &#x3D; 0</span><br><span class="line">    function deepFun(node, d)&#123;</span><br><span class="line">        if(!node.left &amp;&amp; !node.right)&#123;</span><br><span class="line">            if(max &lt; d + 1) max &#x3D; d + 1</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.left) deepFun(node.left, d + 1)</span><br><span class="line">        if(node.right) deepFun(node.right, d + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    deepFun(root, 0)</span><br><span class="line">    return max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题部分"><a href="#专题部分" class="headerlink" title="专题部分"></a>专题部分</h1><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h3><p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><blockquote><p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p></blockquote><p>示例 2:</p><blockquote><p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p></blockquote><p>因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因此贪心策略</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">g</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContentChildren = <span class="function"><span class="keyword">function</span>(<span class="params">g, s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 按孩子要求先排序</span></span><br><span class="line">    g.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="comment">// 按饼干尺寸先排序</span></span><br><span class="line">    s.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="comment">// 孩子从小到大编号</span></span><br><span class="line">    <span class="keyword">let</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 保证循环</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">        <span class="comment">// 贪心选择给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干</span></span><br><span class="line">        <span class="keyword">if</span> (g[child] &lt;= s[cookie]) child++;</span><br><span class="line">        <span class="comment">// 饼干数+1</span></span><br><span class="line">        cookie++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><strong><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></strong></h3><p>每个孩子有一个评分，如果评分高于旁边的孩子，则被分配的糖果数量也必须更多，求最少总糖果数量，使得每个孩子都有糖果。</p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1：</p><blockquote><p>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p></blockquote><p>贪心策略，从左往右和从右往左各遍历一遍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">ratings</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> * 两次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> candy = <span class="function"><span class="keyword">function</span>(<span class="params">ratings</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = ratings.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &lt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            num[i - <span class="number">1</span>] = <span class="built_in">Math</span>.max(num[i - <span class="number">1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    <span class="keyword">return</span> num.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><strong><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></strong></h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p><blockquote><p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p><p>输出: 1</p></blockquote><p>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p><blockquote><p>输入: [ [1,2], [1,2], [1,2] ]</p><p>输出: 2</p></blockquote><p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p><blockquote><p>输入: [ [1,2], [2,3] ]</p><p>输出: 0</p></blockquote><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><p>计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> eraseOverlapIntervals = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 序列长度</span></span><br><span class="line">    <span class="keyword">let</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 初始化删除区间数为0</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 排序后，初始化区间尾为最小值</span></span><br><span class="line">    <span class="keyword">let</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前开头小于结尾，需要删除</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; x_end) &#123;</span><br><span class="line">            <span class="comment">// 需要删除该项</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间结尾</span></span><br><span class="line">            x_end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h3><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><p>任何左括号 ( 必须有相应的右括号 )。<br>任何右括号 ) 必须有相应的左括号 ( 。<br>左括号 ( 必须在对应的右括号之前 )。</p><p>可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。<br>一个空字符串也被视为有效字符串</p><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: True</p></blockquote><p>示例 2:</p><blockquote><p>输入: “(*)”<br>输出: True</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(*))”<br>输出: True</p></blockquote><p>贪心将（出栈，使用栈来实现</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个栈分别存放左括号和*</span><br><span class="line">    let left &#x3D; [], star &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left.push(i);</span><br><span class="line">        &#x2F;&#x2F; *号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star.push(i);</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先出栈</span><br><span class="line">            if(left.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star.length &#x3D;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号出栈</span><br><span class="line">                star.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号出栈</span><br><span class="line">                left.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; *数量不足以抵消左括号</span><br><span class="line">    if(left.length &gt; star.length) return false;</span><br><span class="line">    &#x2F;&#x2F; 两个都有</span><br><span class="line">    while(left.length &amp;&amp; star.length)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号在*右侧</span><br><span class="line">        if(left.pop() &gt; star.pop()) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历两次实现损失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 模拟栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分别存放剩余左括号和*数量</span><br><span class="line">    let left &#x3D; 0, star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择左括号</span><br><span class="line">            if(left &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号数量-1</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 存放剩余右括号数量</span><br><span class="line">    let right &#x3D; 0;</span><br><span class="line">    star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; s.length - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">        &#x2F;&#x2F; 右括号数量-1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) right++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 左括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择右括号</span><br><span class="line">            if(right &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; )号数量-1</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><blockquote><p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p></blockquote><p>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p><blockquote><p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p></blockquote><p>提示：</p><p>1 &lt;= people.length &lt;= 2000<br>0 &lt;= hi &lt;= 106<br>0 &lt;= ki &lt; people.length<br>题目数据确保队列可以被重建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; people</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> * 贪心算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reconstructQueue &#x3D; function(people) &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先按照身高h降序排列，同时如果身高相同那么按照k增序，个高的人忽略前面个矮的人</span><br><span class="line">    people.sort((a, b) &#x3D;&gt; a[0] &#x3D;&#x3D;&#x3D; b[0] ? a[1] - b[1] : b[0] - a[0]);</span><br><span class="line">    &#x2F;&#x2F; 结果数组</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 先安排高个子的位置</span><br><span class="line">    for (let i &#x3D; 0; i &lt; people.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先安排高个子k小,再安排高个子k大的</span><br><span class="line">        res.splice(people[i][1], 0, people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1663-具有给定数值的最小字符串"><a href="#1663-具有给定数值的最小字符串" class="headerlink" title="1663. 具有给定数值的最小字符串"></a><a href="https://leetcode-cn.com/problems/smallest-string-with-a-given-numeric-value/">1663. 具有给定数值的最小字符串</a></h3><p><strong>小写字符</strong> 的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p><p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>&quot;abe&quot;</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p><p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p><p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p><ul><li><code>x</code> 是 <code>y</code> 的一个前缀；</li><li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 27</span><br><span class="line">输出：&quot;aay&quot;</span><br><span class="line">解释：字符串的数值为 1 + 1 + 25 &#x3D; 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, k &#x3D; 73</span><br><span class="line">输出：&quot;aaszz&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>n &lt;= k &lt;= 26 * n</code><br>贪心算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getSmallestString &#x3D; function(n, k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 结果字符串</span><br><span class="line">    let ans &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F; 剩下的字符个数</span><br><span class="line">    for (let rest &#x3D; n; rest &gt;&#x3D; 1; rest--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 贪心将当前位置取序号最小的字母，后面尽可能取最接近26的数</span><br><span class="line">        let bound &#x3D; k - 26 * (rest - 1);</span><br><span class="line">        if (bound &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 选择当前基底的数</span><br><span class="line">            ans +&#x3D; String.fromCharCode(&#39;a&#39;.charCodeAt() + bound +  - 1);</span><br><span class="line">            k -&#x3D; bound;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 先选择加入a</span><br><span class="line">            ans +&#x3D; &#39;a&#39;;</span><br><span class="line">            k -&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.<a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h3><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>进阶：</strong></p><p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p>链表中节点的数目范围是 <code>[0, 104]</code></p></li><li><p><code>-105 &lt;= Node.val &lt;= 105</code></p></li><li><p><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</p></li></ul><p>快慢指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">    let fast &#x3D; head, slow &#x3D; head;</span><br><span class="line">    while (fast !&#x3D;&#x3D; null &amp;&amp; fast.next !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        fast &#x3D; fast.next.next;</span><br><span class="line">        slow &#x3D; slow.next;</span><br><span class="line">        if (fast &#x3D;&#x3D; slow) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="堆栈队列"><a href="#堆栈队列" class="headerlink" title="堆栈队列"></a>堆栈队列</h2><h3 id="678-有效的括号字符串-1"><a href="#678-有效的括号字符串-1" class="headerlink" title="678.有效的括号字符串"></a>678.<a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">有效的括号字符串</a></h3><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol><p>使用两个栈模拟<code>（ </code>号和 <code>*</code>号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个栈分别存放左括号和*</span><br><span class="line">    let left &#x3D; [], star &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left.push(i);</span><br><span class="line">        &#x2F;&#x2F; *号位置入栈</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star.push(i);</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先出栈</span><br><span class="line">            if(left.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star.length &#x3D;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号出栈</span><br><span class="line">                star.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号出栈</span><br><span class="line">                left.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; *数量不足以抵消左括号</span><br><span class="line">    if(left.length &gt; star.length) return false;</span><br><span class="line">    &#x2F;&#x2F; 两个都有</span><br><span class="line">    while(left.length &amp;&amp; star.length)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号在*右侧</span><br><span class="line">        if(left.pop() &gt; star.pop()) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为遍历两次优化栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 模拟栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">var checkValidString &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分别存放剩余左括号和*数量</span><br><span class="line">    let left &#x3D; 0, star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; 0; i &lt; s.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 左括号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) left++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 右括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择左括号</span><br><span class="line">            if(left &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; (号数量-1</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 存放剩余右括号数量</span><br><span class="line">    let right &#x3D; 0;</span><br><span class="line">    star &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 遍历数组</span><br><span class="line">    for(let i &#x3D; s.length - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">        &#x2F;&#x2F; 右括号数量-1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;)&quot;) right++;</span><br><span class="line">        &#x2F;&#x2F; *号数量+1</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;*&quot;) star++;</span><br><span class="line">        &#x2F;&#x2F; 左括号</span><br><span class="line">        if(s[i] &#x3D;&#x3D; &quot;(&quot;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 优先选择右括号</span><br><span class="line">            if(right &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F; 两个都没有，出错</span><br><span class="line">                if(star &lt;&#x3D; 0) return false;</span><br><span class="line">                &#x2F;&#x2F; *号数量-1</span><br><span class="line">                star--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; )号数量-1</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215.数组中的第K个最大元素"></a>215.<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h3><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p>方法一，直接用库函数 时间复杂度：O(nlogn)，空间复杂度：O(logn)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var findKthLargest &#x3D; function(nums, k) &#123;</span><br><span class="line">    nums.sort((a, b) &#x3D;&gt; b - a);</span><br><span class="line">    return nums[k - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二，构造k个元素的小顶堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findKthLargest &#x3D; function(nums, k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从 nums 中取出前 k 个数，构建一个小顶堆</span><br><span class="line">    buildHeap(nums, k);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 从 k 位开始遍历数组</span><br><span class="line">    for(let i &#x3D; k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if(nums[0] &lt; nums[i]) &#123;</span><br><span class="line">            &#x2F;&#x2F; 替换并堆化</span><br><span class="line">            nums[0] &#x3D; nums[i];</span><br><span class="line">            heapify(nums, k, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回堆顶元素</span><br><span class="line">    return nums[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原地建堆，从后往前，自上而下式建小顶堆</span><br><span class="line">let buildHeap &#x3D; (arr, k) &#x3D;&gt; &#123;</span><br><span class="line">    if(k &#x3D;&#x3D;&#x3D; 1) return;</span><br><span class="line">    &#x2F;&#x2F; 从最后一个非叶子节点开始，自上而下式堆化</span><br><span class="line">    for(let i &#x3D; Math.floor((k - 1) &#x2F; 2); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        heapify(arr, k, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆化</span><br><span class="line">let heapify &#x3D; (arr, k, i) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 自上而下式堆化</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        let minIndex &#x3D; i;</span><br><span class="line">        &#x2F;&#x2F; 比较和左节点</span><br><span class="line">        if(2 * i + 1 &lt; k &amp;&amp; arr[2 * i + 1] &lt; arr[i]) &#123;</span><br><span class="line">            minIndex &#x3D; 2 * i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 比较和右节点</span><br><span class="line">        if(2 * i + 2 &lt; k &amp;&amp; arr[2 * i + 2] &lt; arr[minIndex]) &#123;</span><br><span class="line">            minIndex &#x3D; 2 * i + 2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minIndex !&#x3D;&#x3D; i) &#123;</span><br><span class="line">            &#x2F;&#x2F; 交换和子节点种较小的那个</span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">            i &#x3D; minIndex;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前节点比左右节点都小，当前位置不用下沉</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 交换</span><br><span class="line">let swap &#x3D; (arr, i , j) &#x3D;&gt; &#123;</span><br><span class="line">    let temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：快速排序 时间复杂度：平均时间复杂度O(n)，最坏情况时间复杂度为O(n<sup>2</sup>)，空间复杂度：O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置</span><br><span class="line"> * 在遍历过程中保持循环不变量的语义</span><br><span class="line"> * 1、[left + 1, j] &lt; nums[left]</span><br><span class="line"> * 2、(j, i] &gt;&#x3D; nums[left]</span><br><span class="line"> *</span><br><span class="line"> * @param nums</span><br><span class="line"> * @param left</span><br><span class="line"> * @param right</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">function partition(nums, left, right) &#123;</span><br><span class="line">    let pivot &#x3D; nums[left];</span><br><span class="line">    let j &#x3D; left;</span><br><span class="line">    for (let i &#x3D; left + 1; i &lt;&#x3D; right; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; pivot) &#123;</span><br><span class="line">            &#x2F;&#x2F; 小于 pivot 的元素都被交换到前面</span><br><span class="line">            j++;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;&#x3D; pivot</span><br><span class="line">     swap(nums, j, left);</span><br><span class="line">     &#x2F;&#x2F; 交换以后 [left, j - 1] &lt; pivot, nums[j] &#x3D; pivot, [j + 1, right] &gt;&#x3D; pivot</span><br><span class="line">     return j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function swap(nums, i, j) &#123;</span><br><span class="line">    let temp &#x3D; nums[i];</span><br><span class="line">    nums[i] &#x3D; nums[j];</span><br><span class="line">    nums[j] &#x3D; temp;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findKthLargest &#x3D; function(nums, k) &#123;</span><br><span class="line">    let len &#x3D; nums.length;</span><br><span class="line">    let left &#x3D; 0;</span><br><span class="line">    let right &#x3D; len - 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 转换一下，第 k 大元素的索引是 len - k</span><br><span class="line">    let target &#x3D; len - k;</span><br><span class="line"></span><br><span class="line">    while(true) &#123;</span><br><span class="line">        let index &#x3D; partition(nums, left, right);</span><br><span class="line">        if (index &#x3D;&#x3D; target) &#123;</span><br><span class="line">            return nums[target];</span><br><span class="line">        &#125; else if (index &lt; target) &#123;</span><br><span class="line">            left &#x3D; index + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right &#x3D; index - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h2><h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. <a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></h3><p>难度简单624</p><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p>牛顿迭代法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mySqrt &#x3D; function(x) &#123;</span><br><span class="line">    let s &#x3D; x;</span><br><span class="line">    while (s * s &gt; x) &#123;</span><br><span class="line">        s &#x3D; (s + x &#x2F; s) &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var mySqrt &#x3D; function(x) &#123;</span><br><span class="line">    if (x &#x3D;&#x3D; 0) return x;</span><br><span class="line">    let l &#x3D; 1, r &#x3D; x, mid, sqrt;</span><br><span class="line">    while (l &lt;&#x3D; r) &#123;</span><br><span class="line">        mid &#x3D; l + ((r - l) &gt;&gt; 1);</span><br><span class="line">        sqrt &#x3D; Math.floor(x &#x2F; mid);</span><br><span class="line">        if (sqrt &#x3D;&#x3D; mid) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if (mid &gt; sqrt) &#123;</span><br><span class="line">            r &#x3D; mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. <a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h3><p>难度中等1221</p><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>直接用track记录路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;* 主函数，输入一组不重复的数字，返回它们的全排列 *&#x2F;</span><br><span class="line">var permute &#x3D; function(nums) &#123;</span><br><span class="line">    const res &#x3D; [];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录「路径」</span><br><span class="line">    const track &#x3D; [];</span><br><span class="line">    const n &#x3D; nums.length;</span><br><span class="line">    const isVisited &#x3D; new Array(n).fill(false);</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 路径：记录在 track 中</span><br><span class="line">    &#x2F;&#x2F; 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="line">    &#x2F;&#x2F; 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="line">    function backtrack (nums, track)&#123;</span><br><span class="line">        &#x2F;&#x2F; 触发结束条件</span><br><span class="line">        if (track.length &#x3D;&#x3D;&#x3D; n)&#123;</span><br><span class="line">            res.push([...track]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 排除不合法的选择</span><br><span class="line">            if (!isVisited[i])&#123;</span><br><span class="line">                &#x2F;&#x2F; 做选择</span><br><span class="line">                isVisited[i] &#x3D; true;</span><br><span class="line">                track.push(nums[i]);</span><br><span class="line">                &#x2F;&#x2F; 进入下一层决策树</span><br><span class="line">                backtrack(nums, track);</span><br><span class="line">                &#x2F;&#x2F; 取消选择</span><br><span class="line">                isVisited[i] &#x3D; false;</span><br><span class="line">                track.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="寻找和为定值的多个数"><a href="#寻找和为定值的多个数" class="headerlink" title="寻找和为定值的多个数"></a>寻找和为定值的多个数</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数n和sum，从数列1，2，3…….n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function getAllCombin(array, n, sum, temp) &#123;</span><br><span class="line">   if (temp.length &#x3D;&#x3D;&#x3D; n) &#123;</span><br><span class="line">     if (temp.reduce((t, c) &#x3D;&gt; t + c) &#x3D;&#x3D;&#x3D; sum) &#123;</span><br><span class="line">       return temp;</span><br><span class="line">     &#125;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line">   for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">     const current &#x3D; array.shift();</span><br><span class="line">     temp.push(current);</span><br><span class="line">     const result &#x3D; getAllCombin(array, n, sum, temp);</span><br><span class="line">     if (result) &#123;</span><br><span class="line">       return result;</span><br><span class="line">     &#125;</span><br><span class="line">     temp.pop();</span><br><span class="line">     array.push(current);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> const arr &#x3D; [1, 2, 3, 4, 5, 6];</span><br><span class="line"></span><br><span class="line"> console.log(getAllCombin(arr, 3, 10, []));</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层序遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return [];</span><br><span class="line">    let queue &#x3D; [root];</span><br><span class="line">    let level &#x3D; 0;</span><br><span class="line">    let number &#x3D; [];</span><br><span class="line">    while (queue.length !&#x3D; 0) &#123;</span><br><span class="line">        let l &#x3D; queue.length;</span><br><span class="line">        number[level] &#x3D; []</span><br><span class="line">        for (let i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">            let node &#x3D; queue.shift();</span><br><span class="line">            number[level][i] &#x3D; node.val;</span><br><span class="line">            if (node.left !&#x3D;&#x3D; null) queue.push(node.left);</span><br><span class="line">            if (node.right !&#x3D;&#x3D; null) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="260-只出现一次的数字"><a href="#260-只出现一次的数字" class="headerlink" title="260. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字</a></h3><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p> <strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,0]</span><br><span class="line">输出：[-1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：[1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li></ul><p>找到两个数异或结果，根据最低位分别对数据进行抑或操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function FindNumsAppearOnce( array ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 抑或结果</span><br><span class="line">    let xor_result &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 长度</span><br><span class="line">    const n &#x3D; array.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        xor_result ^&#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 除了最后1位1，全部置零</span><br><span class="line">    let flag &#x3D; xor_result &amp; (-xor_result);</span><br><span class="line">    &#x2F;&#x2F; 有无标志位</span><br><span class="line">    let has_flag &#x3D; 0, hasnot_flag &#x3D; 0;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (array[i] &amp; flag) &#123;</span><br><span class="line">            &#x2F;&#x2F; 标志位为1的抑或结果</span><br><span class="line">            has_flag ^&#x3D; array[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 标志位为0的抑或结果</span><br><span class="line">            hasnot_flag ^&#x3D; array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (has_flag &lt; hasnot_flag) &#123;</span><br><span class="line">        return [has_flag, hasnot_flag];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [hasnot_flag, has_flag];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据结构和算法" scheme="https://hxy1997.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css面试题</title>
    <link href="https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-06T04:02:39.000Z</published>
    <updated>2021-03-13T02:01:45.719Z</updated>
    
    <content type="html"><![CDATA[<p>CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧</p><span id="more"></span><h1 id="1-css盒模型简介"><a href="#1-css盒模型简介" class="headerlink" title="1.css盒模型简介"></a>1.<a href="https://www.cnblogs.com/112233-j/p/12600228.html">css盒模型简介</a></h1><p>盒子模型，英文即box model。无论是div、span、还是a都是盒子。</p><p>但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。</p><h3 id="盒子中的区域"><a href="#盒子中的区域" class="headerlink" title="盒子中的区域"></a>盒子中的区域</h3><p>一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>盒子模型的示意图：</p><p><img data-src="http://img.smyhvae.com/20170727_2128.png" alt="img"></p><p>代码演示：</p><p><img data-src="http://img.smyhvae.com/20170727_2326.png" alt="img"></p><p>上面这个盒子，width:200px; height:200px; 但是真实占有的宽高是302*302。 这是因为还要加上padding、border。</p><p>注意：<strong>宽度和真实占有宽度，不是一个概念！</strong>来看下面这例子。</p><h3 id="标准盒模型和IE盒模型"><a href="#标准盒模型和IE盒模型" class="headerlink" title="标准盒模型和IE盒模型"></a>标准盒模型和IE盒模型</h3><blockquote><p>我们目前所学习的知识中，以标准盒子模型为准。</p></blockquote><p>标准盒子模型：</p><p><img data-src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt="img"></p><p>IE盒子模型：</p><p><img data-src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt="img"></p><p>上图显示：</p><p>在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>CSS盒模型和IE盒模型的区别：</p><ul><li>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li></ul><p>注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。</p><h3 id="lt-body-gt-标签也有margin"><a href="#lt-body-gt-标签也有margin" class="headerlink" title="&lt;body&gt;标签也有margin"></a><code>&lt;body&gt;</code>标签也有margin</h3><p><code>&lt;body&gt;</code>标签有必要强调一下。很多人以为<code>&lt;body&gt;</code>标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是<code>&lt;document&gt;</code>，即浏览器。而<code>&lt;body&gt;</code>是<code>&lt;document&gt;</code>的儿子。浏览器给<code>&lt;body&gt;</code>默认的margin大小是8个像素，此时<code>&lt;body&gt;</code>占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;EditPlus®&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="css"><span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin</span>: <span class="number">30px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>有生之年<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>狭路相逢<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码中，我们对div标签设置了边距等信息。打开google浏览器，按住F12，显示效果如下：</p><p><img data-src="http://img.smyhvae.com/20151003_27.png" alt="img"></p><h3 id="认识width、height"><a href="#认识width、height" class="headerlink" title="认识width、height"></a>认识width、height</h3><p>一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。</p><p>比如说，丈量稿纸，前端开发工程师只会丈量内容宽度：</p><p><img data-src="http://img.smyhvae.com/20170727_2329.png" alt="img"></p><p>下面这两个盒子，真实占有宽高，都是302*302：</p><p>盒子1：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>盒子2：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实占有宽度 = 左border + 左padding + width + 右padding + 右border</p><p>上面这两个盒子的盒模型图如下：</p><p><img data-src="http://img.smyhvae.com/20170728_0925.png" alt="img"></p><p><strong>如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width</strong>。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。</p><h3 id="认识padding"><a href="#认识padding" class="headerlink" title="认识padding"></a>认识padding</h3><h4 id="padding区域也有颜色"><a href="#padding区域也有颜色" class="headerlink" title="padding区域也有颜色"></a>padding区域也有颜色</h4><p>padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充<strong>所有border以内的区域。</strong></p><p>效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1005.png" alt="img"></p><h4 id="padding有四个方向"><a href="#padding有四个方向" class="headerlink" title="padding有四个方向"></a>padding有四个方向</h4><p>padding是4个方向的，所以我们能够分别描述4个方向的padding。</p><p>方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。</p><p>小属性的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padding-top: 30px;</span><br><span class="line">padding-right: 20px;</span><br><span class="line">padding-bottom: 40px;</span><br><span class="line">padding-left: 100px;</span><br></pre></td></tr></table></figure><p>综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding:30px 20px 40px 100px;</span><br></pre></td></tr></table></figure><p>如果写了四个值，则顺序为：上、右、下、左。</p><p>如果只写了三个值，则顺序为：上、右、下。??和右一样。</p><p>如果只写了两个值，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding: 30px 40px;</span><br></pre></td></tr></table></figure><p>则顺序等价于：30px 40px 30px 40px;</p><p>要懂得，<strong>用小属性层叠大属性</strong>。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding: 20px;</span><br><span class="line">padding-left: 30px;</span><br></pre></td></tr></table></figure><p>上面的padding对应盒子模型为：</p><p><img data-src="http://img.smyhvae.com/20170728_1039.png" alt="img"></p><p>下面的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-left: 30px;</span><br><span class="line">padding: 20px;</span><br></pre></td></tr></table></figure><p>第一行的小属性无效，因为被第二行的大属性层叠掉了。</p><p>下面的题，会做了，说明你明白了。</p><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><p><strong>题目1</strong>：说出下面盒子真实占有宽高，并画出盒模型图。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><p><img data-src="http://img.smyhvae.com/20170728_1048.png" alt="img"></p><p><strong>题目2</strong>：说出下面盒子真实占有宽高，并画出盒模型图。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">40px</span> <span class="number">50px</span> <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><p><code>padding-left:10px；</code> 和<code>padding-right:20px;</code> 没用，因为后面的padding大属性，层叠掉了他们。</p><p>盒子模型如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1100.png" alt="img"></p><p><strong>题目3</strong>：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p><p><img data-src="http://img.smyhvae.com/20170728_1401.png" alt="img"></p><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width:123px;</span><br><span class="line">height:123px;</span><br><span class="line">padding:20px 40px;</span><br><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><p><strong>题目4</strong>：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p><p><img data-src="http://img.smyhvae.com/20170728_1402.png" alt="img"></p><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">width:123px;</span><br><span class="line">height:123px;</span><br><span class="line">padding:20px;</span><br><span class="line">padding-right:40px;</span><br><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><h4 id="一些元素，默认带有padding"><a href="#一些元素，默认带有padding" class="headerlink" title="一些元素，默认带有padding"></a>一些元素，默认带有padding</h4><p>一些元素，默认带有<code>padding</code>，比如ul标签。如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1413.png" alt="img"></p><p>上图显示，不加任何样式的ul，也是有40px的padding-left。</p><p>所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。</p><p>可以使用<code>*</code>进行清除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>*</code>的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;</span><br><span class="line">    margin:0;</span><br><span class="line">    padding:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认识border"><a href="#认识border" class="headerlink" title="认识border"></a>认识border</h3><p>border就是边框。边框有三个要素：像素（粗细）、线型、颜色。</p><p>颜色如果不写，默认是黑色。另外两个属性不写，要命了，显示不出来边框。</p><h4 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h4><p>border的所有的线型如下：（我们可以通过查看<code>CSS参考手册</code>得到）</p><p><img data-src="http://img.smyhvae.com/20170728_1435.png" alt="img"></p><p>比如<code>border:10px ridge red;</code>这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已）</p><p><img data-src="http://img.smyhvae.com/20170728_1619.png" alt="img"></p><p>如果公司里面的设计师是处女座的，追求极高的<strong>页面还原度</strong>，那么不能使用css来制作边框。就要用到图片，就要切图了。</p><p>所以，比较稳定的border-style就几个：solid、dashed、dotted。</p><h4 id="border拆分"><a href="#border拆分" class="headerlink" title="border拆分"></a>border拆分</h4><p>border是一个大综合属性。比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:1px solid red;</span><br></pre></td></tr></table></figure><p>就是把4个边框，都设置为1px宽度、线型实线、red颜色。</p><p>PS：小技巧：在sublime text中，为了快速输入<code>border:1px solid red;</code>这个属性，可以直接输入<code>bd</code>，然后选第二个后回车。</p><p>border属性是能够被拆开的，有两大种拆开的方式：</p><ul><li>（1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的）</li><li>（2）按方向拆开：border-top、border-right、border-bottom、border-left。</li></ul><p>现在我们明白了：<strong>一个border属性，是由三个小属性综合而成的</strong>。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-width:10px 20px;</span><br><span class="line">border-style:solid dashed dotted;</span><br><span class="line">border-color:red green blue yellow;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1516.png" alt="img"></p><p>（1）按三要素拆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-width:10px;    &#x2F;&#x2F;边框宽度</span><br><span class="line">border-style:solid;   &#x2F;&#x2F;线型</span><br><span class="line">border-color:red;     &#x2F;&#x2F;颜色。</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>(2)按方向来拆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top:10px solid red;</span><br><span class="line">border-right:10px solid red;</span><br><span class="line">border-bottom:10px solid red;</span><br><span class="line">border-left:10px solid red;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>（3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">border-top-width:10px;</span><br><span class="line">border-top-style:solid;</span><br><span class="line">border-top-color:red;</span><br><span class="line">border-right-width:10px;</span><br><span class="line">border-right-style:solid;</span><br><span class="line">border-right-color:red;</span><br><span class="line">border-bottom-width:10px;</span><br><span class="line">border-bottom-style:solid;</span><br><span class="line">border-bottom-color:red;</span><br><span class="line">border-left-width:10px;</span><br><span class="line">border-left-style:solid;</span><br><span class="line">border-left-color:red;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br></pre></td></tr></table></figure><p>工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1606.png" alt="img"></p><p>为了实现上方效果，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br><span class="line">border-right-color:blue;</span><br></pre></td></tr></table></figure><p><img data-src="http://img.smyhvae.com/20170728_1608.png" alt="img"></p><p>为了实现上方效果，写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border:10px solid red;</span><br><span class="line">border-style:solid dashed;</span><br></pre></td></tr></table></figure><p>border可以没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border:none;</span><br></pre></td></tr></table></figure><p>可以某一条边没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-left: none;</span><br></pre></td></tr></table></figure><p>也可以调整左边边框的宽度为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-left-width: 0;</span><br></pre></td></tr></table></figure><h4 id="举例：利用border属性画一个三角形（小技巧）"><a href="#举例：利用border属性画一个三角形（小技巧）" class="headerlink" title="举例：利用border属性画一个三角形（小技巧）"></a>举例：利用border属性画一个三角形（小技巧）</h4><p>步骤如下：</p><p>（1）当我们设置盒子的width和height为0时，此时效果如下：</p><p><img data-src="http://img.smyhvae.com/20170728_1640.png" alt="img"></p><p>（2）然后将border的底部取消：</p><p><img data-src="http://img.smyhvae.com/20170728_1645.png" alt="img"></p><p>（3）最后设置border的左边和右边为白色：</p><p><img data-src="http://img.smyhvae.com/20170728_1649.png" alt="img"></p><p>这样，一个三角形就画好了。</p><p><a href="http://www.yanhuangxueyuan.com/HTML5/icon.html">CSS绘制三角形</a> 讲解的是利用boder外边框属性绘制各种三角形的案例。</p><p><a href="http://www.yanhuangxueyuan.com/HTML5/icon.html">CSS绘制圆(弧)</a> 讲解如何利用CSS的基本属性圆角border-radius绘制与圆、圆弧相关的图形。</p><h1 id="2-CSS-选择器"><a href="#2-CSS-选择器" class="headerlink" title="2.CSS 选择器"></a>2.<a href="https://segmentfault.com/a/1190000013424772">CSS 选择器</a></h1><blockquote><p>摘自 MDN web docs</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>选择器是 CSS 规则的一部分且位于 CSS 声明块前。</p><p><img data-src="https://segmentfault.com/img/remote/1460000013424775?w=644&h=188" alt="image"></p><p>选择器可以被分为以下类别：</p><ul><li><code>简单选择器（Simple selectors）</code>：通过元素类型、class 或 id 匹配一个或多个元素。</li><li><code>属性选择器（Attribute selectors）</code>：通过 属性 / 属性值 匹配一个或多个元素。</li><li><code>伪类（Pseudo-classes）</code>：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。</li><li><code>伪元素（Pseudo-elements）</code>:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。</li><li><code>组合器（Combinators）</code>：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择 divs 的直系子节点的段落，或者直接跟在 headings 后面的段落。</li><li><code>多用选择器（Multiple selectors）</code>：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li></ul><h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><h3 id="类型选择器（又名：元素选择器）"><a href="#类型选择器（又名：元素选择器）" class="headerlink" title="类型选择器（又名：元素选择器）"></a>类型选择器（又名：元素选择器）</h3><p>此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。</p><h3 id="类选择器（Class-selectors）"><a href="#类选择器（Class-selectors）" class="headerlink" title="类选择器（Class selectors）"></a>类选择器（Class selectors）</h3><p>类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。</p><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>ID选择器由哈希/磅符号 (#)组成，后面是给定元素的ID名称。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己选择的ID是什么。 这是选择单个元素的最有效的方式。</p><blockquote><p>重要提示：一个ID名称必须在文件中是唯一的。关于重复ID的行为是不可预测的，比如在一些浏览器只是第一个实例计算，其余的将被忽略。</p></blockquote><h3 id="通用选择器（Universal-selector）"><a href="#通用选择器（Universal-selector）" class="headerlink" title="通用选择器（Universal selector）"></a>通用选择器（Universal selector）</h3><p>通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。</p><blockquote><p>重要提示：使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。不会有太多的情况下，您想使用此选择。</p></blockquote><h3 id="组合器（Combinators）"><a href="#组合器（Combinators）" class="headerlink" title="组合器（Combinators）"></a>组合器（Combinators）</h3><p>在CSS中，组合器允许您将多个选择器组合在一起，这允许您在其他元素中选择元素，或者与其他元素相邻。四种可用的类型是：</p><ul><li>后代选择器——（空格键）——允许您选择嵌套在另一个元素中的某个元素（不一定是直接的后代;例如，它可以是一个孙子）。</li><li>子选择器—— &gt; ——允许您选择一个元素，该元素是另一个元素的直接子元素。</li><li>相邻兄弟选择器—— + ——允许您选择一个元素，它是另一个元素的直接兄弟元素(也就是说，在它的旁边，在层次结构的同一层)。</li><li>通用兄弟选择器—— ~ — —允许您选择其他元素的兄弟元素(例如，在层次结构中的相同级别，但不一定就在它的旁边)。</li></ul><table><thead><tr><th>Combinators</th><th>Select</th></tr></thead><tbody><tr><td>A,B</td><td>匹配满足A（和/或）B的任意元素.</td></tr><tr><td>A B</td><td>匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）</td></tr><tr><td>A &gt; B</td><td>匹配任意元素，满足条件：B是A的直接子节点</td></tr><tr><td>A + B</td><td>匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）</td></tr><tr><td>A ~ B</td><td>匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</td></tr></tbody></table><blockquote><p>注：相邻兄弟选择器和通用兄弟选择器只会“向后”选择，DOM结构靠前的兄弟元素不在选择范围内。</p></blockquote><p>这里有一个简单的例子来展示这些工作是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">  &lt;h2&gt;Heading 1&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Heading 2&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;Paragraph 3&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;Paragraph 4&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br><span class="line">section p &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">section &gt; p &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 + p &#123;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 ~ p &#123;</span><br><span class="line">  border: 1px dashed black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS样式的HTML如下所示：</p><p><img data-src="https://img-blog.csdnimg.cn/20210307112422139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjc1MjU3NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择器是这样工作的：</p><ul><li>section p选择了所有的 <code>&lt;p&gt;</code> 元素——前两个 <code>&lt;p&gt;</code> 都是 <code>&lt;section&gt;</code> 元素的直接子元素，而后面的两个 <code>&lt;p&gt;</code> 元素是 <code>&lt;section&gt;</code> 元素的孙子元素(它们在 <code>&lt;div&gt;</code>里面)。因此，所有的段落文本都是蓝色的。</li><li>section &gt; p 只选择前两个 <code>&lt;p&gt;</code> 元素，这两个元素是 <code>&lt;section&gt;</code> 元素的直接子元素（但后两个 <code>&lt;p&gt;</code>元素不是，它们不是直接的子元素）。所以只有前两段有黄色的背景色。</li><li>h2 + p 只选择在相同层次结构的 <code>&lt;h2&gt;</code> 元素之后直接相连的 <code>&lt;p&gt;</code> 元素—— 在本例中是第一和第三段。因此，这些文本都是大写的。</li><li>h2 ~ p 选择任何在相同的层级上（还有之后的） <code>&lt;h2&gt;</code> 元素的 <code>&lt;p&gt;</code> 元素 ——在这种情况下，所有的段落符合此条件。因此，所有的这些都有一个虚线的边界。</li></ul><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器是一种特殊类型的选择器，它根据元素的 属性和属性值来匹配元素。它们的通用语法由方括号([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： <strong>存在和值属性选择器</strong> 和<strong>子串值属性选择器</strong>。</p><h3 id="存在和值（Presence-and-value）属性选择器"><a href="#存在和值（Presence-and-value）属性选择器" class="headerlink" title="存在和值（Presence and value）属性选择器"></a>存在和值（Presence and value）属性选择器</h3><p>这些属性选择器尝试匹配精确的属性值：</p><ul><li>[attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。</li><li>[attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。</li><li>[attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。</li></ul><h3 id="子串值（Substring-value）属性选择器"><a href="#子串值（Substring-value）属性选择器" class="headerlink" title="子串值（Substring value）属性选择器"></a>子串值（Substring value）属性选择器</h3><p>这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：</p><ul><li>[attr|=val] : 选择attr属性的值以val（包括val）或val-开头的元素（-用来处理语言编码）。</li><li>[attr^=val] : 选择attr属性的值以val开头（包括val）的元素。</li><li>[attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。</li><li>[attr*=val] : 选择attr属性的值中包含字符串val的元素。</li></ul><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><h3 id="伪类（Pseudo-class）"><a href="#伪类（Pseudo-class）" class="headerlink" title="伪类（Pseudo-class）"></a>伪类（Pseudo-class）</h3><p>一个 CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类（pseudo-class）</a> 是一个以冒号(:)作为前缀的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个 checkbox 被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个孩子元素时。</p><p>:active<br>:any<br>:checked<br>:default<br>:dir()<br>:disabled<br>:empty<br>:enabled<br>:first<br>:first-child<br>:first-of-type<br>:fullscreen<br>:focus<br>:hover<br>:indeterminate<br>:in-range<br>:invalid<br>:lang()<br>:last-child<br>:last-of-type<br>:left<br>:link<br>:not()<br>:nth-child()<br>:nth-last-child()<br>:nth-last-of-type()<br>:nth-of-type()<br>:only-child<br>:only-of-type<br>:optional<br>:out-of-range<br>:read-only<br>:read-write<br>:required<br>:right<br>:root<br>:scope<br>:target<br>:valid<br>:visited</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements">伪元素（Pseudo-element）</a>跟伪类很像，但它们又有不同的地方。它们都是关键字 —— 但这次伪元素前缀是两个冒号 (::) —— 同样是添加到选择器后面达到指定某个元素的某个部分。</p><p>::after<br>::before<br>::first-letter<br>::first-line<br>::selection<br>::backdrop</p><p><a href="https://segmentfault.com/t/css">css</a></p><h2 id="CSS三大特性——-继承、-优先级和层叠。"><a href="#CSS三大特性——-继承、-优先级和层叠。" class="headerlink" title="CSS三大特性—— 继承、 优先级和层叠。"></a>CSS三大特性—— <strong>继承、 优先级和层叠。</strong></h2><p><strong>继承：</strong>即子类元素继承父类的样式;</p><p><strong>优先级：</strong>是指不同类别样式的权重比较;</p><p><strong>层叠：</strong>是说当数量相同时，通过层叠(后者覆盖前者)的样式。</p><h2 id="css选择符分类"><a href="#css选择符分类" class="headerlink" title="css选择符分类"></a>css选择符分类</h2><p>首先来看一下css选择符(css选择器)有哪些?</p><p>　　1.标签选择器(如：body,div,p,ul,li)</p><p>　　2.类选择器(如：class=”head”,class=”head_logo”)</p><p>　　3.ID选择器(如：id=”name”,id=”name_txt”)</p><p>　　4.全局选择器(如：*号)</p><p>　　5.组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</p><p>　　6.后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</p><p>　　7.群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</p><p>　　8.继承选择器(如：div p,注意两选择器用空格键分开)</p><p>　　9.伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</p><p>　　10.字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</p><p>　　11.子选择器 (如：div&gt;p ,带大于号&gt;)</p><p>　　12.CSS 相邻兄弟选择器器 (如：h1+p,带加号+)</p><h2 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h2><p>当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义。</p><p><strong>不同级别</strong></p><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式</p></li><li><p>id选择器</p></li><li><p>类选择器</p></li><li><p>标签选择器</p></li><li><p>通配符选择器</p></li><li><p>浏览器自定义或继承</p><p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p></li></ol><p><strong>同一级别</strong></p><p>同一级别中后写的会覆盖先写的样式</p><p>上面的级别还是很容易看懂的，但是有时候有些规则是多个级别的组合，像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        div.test&#123;</span><br><span class="line">            background-COLOR:#a00;</span><br><span class="line">            width:100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .test.test2&#123;</span><br><span class="line">            background-COLOR:#0e0;</span><br><span class="line">            width:100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;test test2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>到底div是应用那条规则呢，有个简单的计算方法（经园友提示，权值实际并不是按十进制，用数字表示只是说明思想，一万个class也不如一个id权值高）</p><ul><li><p>内联样式表的权值为 1000</p></li><li><p>ID 选择器的权值为 100</p></li><li><p>Class 类选择器的权值为 10</p></li><li><p>HTML 标签选择器的权值为 1</p><p>我们可以把选择器中规则对应做加法，比较权值，如果权值相同那就后面的覆盖前面的了，div.class的权值是1+10=11，而.test1 .test2的权值是10+10=20，所以div会应用.test1 .test2变成绿色</p><p><img data-src="https://images2015.cnblogs.com/blog/625717/201612/625717-20161223085747964-420267465.png" alt="img"></p></li></ul><h2 id="另外一种理解方式："><a href="#另外一种理解方式：" class="headerlink" title="另外一种理解方式："></a>另外一种理解方式：</h2><p>　　CSS优先级：是由四个级别和各级别的出现次数决定的。</p><p>　　四个级别分别为：行内选择符、ID选择符、类别选择符、元素选择符。</p><p>　　优先级的算法：</p><p>　　每个规则对应一个初始”四位数”：0、0、0、0</p><p>　　若是 行内选择符，则加1、0、0、0</p><p>　　若是 ID选择符，则加0、1、0、0</p><p>　　若是 类选择符/属性选择符/伪类选择符，则分别加0、0、1、0</p><p>　　若是 元素选择符/伪元素选择符，则分别加0、0、0、1</p><p>　　算法：将每条规则中，选择符对应的数相加后得到的”四位数“，从左到右进行比较，大的优先级越高。　　</p><h2 id="需注意的："><a href="#需注意的：" class="headerlink" title="需注意的："></a>需注意的：</h2><p>　　①、!important的优先级是最高的，但出现冲突时则需比较”四位数“;</p><p>　　②、优先级相同时，则采用就近原则，选择最后出现的样式;</p><p>　　③、继承得来的属性，其优先级最低;</p><p>　　!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><p>　　*css选择器使用强烈建议采用低权重原则，利于充分发挥css的继承性，复用性，模块化、组件化。</p><h2 id="CSS选择器的解析原则"><a href="#CSS选择器的解析原则" class="headerlink" title="CSS选择器的解析原则"></a><strong>CSS选择器的解析原则</strong></h2><p>​     以前一直认为选择器的定位DOM元素是从左向右的方向，查看了网上的相关资料之后才发现原来自己一直都是错的。郑重的声明选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。<a href="http://blog.csdn.net/jinboker/article/details/52126021">为什么CSS选择器是从右往左解析 ？？？</a></p><h2 id="简洁、高效的css"><a href="#简洁、高效的css" class="headerlink" title="简洁、高效的css"></a><strong>简洁、高效的css</strong></h2><p>​    所谓高效就是让浏览器查找更少的元素标签来确定匹配的style元素。</p><p>   1.不要再ID选择器前使用标签名</p><p>​    解释：ID选择是唯一的，加上标签名相当于画蛇添足了，没必要。</p><p>   2.不要在类选择器前使用标签名</p><p>   解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆如（p.colclass{color：red;} 和 span.colclass{color:red;}</p><p>   3.尽量少使用层级关系；</p><p>​     #divclass p.colclass{color:red;}改为  .colclass{color:red;}</p><p>   4.使用类选择器代替层级关系（如上）</p><h1 id="3-BFC-原理"><a href="#3-BFC-原理" class="headerlink" title="3. BFC 原理"></a>3. BFC 原理</h1><h2 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ul><li>普通流 (normal flow)</li></ul><blockquote><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p></blockquote><ul><li>浮动 (float)</li></ul><blockquote><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p></blockquote><ul><li>绝对定位 (absolute positioning)</li></ul><blockquote><p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p></blockquote><h2 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>那么 BFC 是什么呢？</p><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p><p>**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>**</p><p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h2 id="三、触发-BFC"><a href="#三、触发-BFC" class="headerlink" title="三、触发 BFC"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h2 id="四、BFC-特性及应用"><a href="#四、BFC-特性及应用" class="headerlink" title="四、BFC 特性及应用"></a>四、BFC 特性及应用</h2><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.container &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，两个盒子边距就变成了 200px</p><p><img data-src="https://pic2.zhimg.com/80/v2-5b8d6e8b2b507352900c1ece00018855_720w.png" alt="img"></p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img data-src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img"></p><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span>我是一个没有设置浮动, </span><br><span class="line">也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img data-src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img"></p><p>这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p><h1 id="4-position"><a href="#4-position" class="headerlink" title="4. position"></a>4. position</h1><h2 id="1-static"><a href="#1-static" class="headerlink" title="1. static"></a>1. static</h2><p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .static &#123;</span><br><span class="line">                position: static;</span><br><span class="line">                top: 10px;</span><br><span class="line">                left: 10px;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;static&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>金黄色方块会在左上角显示，没有偏移。</p><h2 id="2-fixed"><a href="#2-fixed" class="headerlink" title="2. fixed"></a>2. fixed</h2><p>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p><p>这个比较好理解，只和窗口有关，与父元素，文档流都无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed-outer &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                top: 20px;</span><br><span class="line">                left: 20px;</span><br><span class="line">                width: 20px;</span><br><span class="line">                height: 20px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed-inner &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                top: 40px;</span><br><span class="line">                left: 40px;</span><br><span class="line">                width: 20px;</span><br><span class="line">                height: 20px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body  bgcolor&#x3D;&quot;#999&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;fixed-outer&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;fixed-inner&quot;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301141019698-644310256.png" alt="img"></p><p>left就是左边界距离视窗左边距的位置，right就是右边界距离视窗右边距的位置，top，bottom同理。top和bottom或者left和right同时存在，只有top或者left生效。</p><p>小广告效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .fixed &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                right: 0px;</span><br><span class="line">                bottom: 50px;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;fixed&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;&lt;p&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="3-relative"><a href="#3-relative" class="headerlink" title="3. relative"></a>3. relative</h2><p>生成相对定位的元素，相对于其正常位置进行定位。</p><p>相对元素正常应该在的位置移动，元素所占的空间位置不变，但是显示的位置发生偏移。</p><p>left是向右偏移，right是向左偏移（这么说好奇怪，但是…应该没错吧……），top向下偏移，bottom向上偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            * &#123;</span><br><span class="line">                padding: 0;</span><br><span class="line">                margin: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .div &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .relative1 &#123;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 10px;</span><br><span class="line">                top: 10px;</span><br><span class="line">                border-color: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .relative2 &#123;</span><br><span class="line">                position: relative;</span><br><span class="line">                right: 10px;</span><br><span class="line">                bottom: 10px;</span><br><span class="line">                border-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div relative1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;div relative2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301145327838-51205356.png" alt="img"></p><h2 id="4-absolute"><a href="#4-absolute" class="headerlink" title="4. absolute"></a>4. absolute</h2><p>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。(如果没有这样的父元素呢？emmm……应该是整个文档最外层的框……吧……</p><p>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p><p>absolute元素会附带 display:block 效果，同时，设置absolute后，元素会脱离文档流。</p><p>\1. 如果不设置”left”, “top”, “right” 以及 “bottom”，会显示在正常应该显示的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .relative &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 100px;</span><br><span class="line">                top: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 1px solid red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;relative&quot;&gt;</span><br><span class="line">            outer</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301160725057-1706791347.png" alt="img"></p><p>\2. 设置了偏移……（一下父元素全部指 static 定位以外的第一个父元素</p><p>设置了left 将以父元素的左边界为基准 向右偏移 垂直方向和之前相同。</p><p>设置了right 将以父元素的右边界为基准 向左偏移 垂直方向和之前相同。</p><p>设置了top 将以父元素的上边界为基准 向下偏移 水平方向和之前相同。</p><p>设置了bottom 将以父元素的下边界为基准 向上偏移 水平方向和之前相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .relative &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height: 300px;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">                position: relative;</span><br><span class="line">                left: 100px;</span><br><span class="line">                top: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute1, .absolute2, .absolute3, .absolute4, .absolute5 &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                border: 2px solid red;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute2 &#123;</span><br><span class="line">                left: 60px;</span><br><span class="line">                border-color: green;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute3 &#123;</span><br><span class="line">                right: 10px;</span><br><span class="line">                border-color: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute4 &#123;</span><br><span class="line">                top: 0;</span><br><span class="line">                border-color: pink;</span><br><span class="line">            &#125;</span><br><span class="line">            .absolute5 &#123;</span><br><span class="line">                bottom: 10px;</span><br><span class="line">                border-color: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;relative&quot;&gt;</span><br><span class="line">            outer</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute3&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute4&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;absolute5&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://images2018.cnblogs.com/blog/670878/201803/670878-20180301162703536-1368636423.png" alt="img"></p><h2 id="5-others"><a href="#5-others" class="headerlink" title="5. others"></a>5. others</h2><p>inherit：继承父元素的值。</p><p>initial： 初始值，即默认值，static。</p><p>unset： 非继承属性，相当于initial，static。</p><h2 id="6-navigation-bar"><a href="#6-navigation-bar" class="headerlink" title="6. navigation bar"></a>6. navigation bar</h2><p>效果见右下角</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;position&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .right-nav * &#123;</span><br><span class="line">                margin: 0;</span><br><span class="line">                padding: 0;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav &#123;</span><br><span class="line">                position: fixed;</span><br><span class="line">                right: 10px;</span><br><span class="line">                bottom: 150px;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li &#123;</span><br><span class="line">                list-style-type: none !important;</span><br><span class="line">                position: relative;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li a &#123;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">                display: block;</span><br><span class="line">                width: 150px;</span><br><span class="line">                line-height: 30px;</span><br><span class="line">                text-align: center;</span><br><span class="line">                background: #666;</span><br><span class="line">                border-bottom: 1px solid;</span><br><span class="line">                color: #fff;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li a:hover, .right-nav li a:active  &#123;</span><br><span class="line">                background: #ccc;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav .summary &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                right: 150px;</span><br><span class="line">                top: 0px;</span><br><span class="line">                line-height: 30px;</span><br><span class="line">                height: 30px;</span><br><span class="line">                width: 400px;</span><br><span class="line">                background: #ccc;</span><br><span class="line">                color: #fff;</span><br><span class="line">                text-align: center;</span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .right-nav li:hover .summary &#123;</span><br><span class="line">                display: block;</span><br><span class="line">                font-size: 12px;</span><br><span class="line">                border-right: 1px solid #fff;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right-nav&quot;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#static&quot;&gt;1. static&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;默认值。没有定位，元素出现在正常的流中。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#fixed&quot;&gt;2. fixed&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成绝对定位的元素，相对于浏览器窗口进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#relative&quot;&gt;3. relative&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成相对定位的元素，相对于其正常位置进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#absolute&quot;&gt;4. absolute&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#others&quot;&gt;5. others&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;inherit &amp; initial &amp; unset&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;wenruo&#x2F;p&#x2F;8488254.html#navigation-bar&quot;&gt;6. navigation bar&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;summary&quot;&gt;根据定位写一个导航栏。&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h1 id="5-flex-布局"><a href="#5-flex-布局" class="headerlink" title="5.flex 布局"></a>5.flex 布局</h1><p>网页布局（layout）是 CSS 的一个重点应用。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="img"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt="img"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="img"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p><p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p><h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">      <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p><p>它可能有4个值。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p><blockquote><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul></blockquote><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h1 id="6-css样式优先级"><a href="#6-css样式优先级" class="headerlink" title="6.css样式优先级"></a>6.css样式优先级</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>权重决定了你css规则怎样被浏览器解析直到生效。“css权重关系到你的css规则是怎样显示的”。</li><li>当很多的样式被应用到某一个元素上时，权重是一个决定哪种样式生效，或者是优先级的过程。</li><li>每个选择器都有自己的权重。你的每条css规则，都包含一个权重级别。 这个级别是由不同的选择器加权计算的，通过权重，不同的样式最终会作用到你的网页中 。</li><li>如果两个选择器同时作用到一个元素上，权重高者生效。</li></ol><h2 id="权重记忆口诀："><a href="#权重记忆口诀：" class="headerlink" title="权重记忆口诀："></a><strong>权重记忆口诀</strong>：</h2><p><em>从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。</em></p><p><img data-src="https://pic3.zhimg.com/80/v2-b1a9fedf320754acb1d7766c6548d5f6_720w.jpg" alt="img">css权重值记忆图</p><p>接下来增加一下记忆，下面是我瞎写的一个样式，只看选择器那里就可以了，具体样式请忽略，我分别用了id选择器、class选择器和标签选择器各一次。</p><p><img data-src="https://pic3.zhimg.com/80/v2-f27a0588280e867a3bc3ed17c7643cf6_720w.jpg" alt="img"></p><h2 id="样式重复多写情况"><a href="#样式重复多写情况" class="headerlink" title="样式重复多写情况"></a><strong>样式重复多写情况</strong></h2><p>在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的，在开发中基本不会使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这条生效 */</span></span><br><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的权重，权重值高则生效"><a href="#不同的权重，权重值高则生效" class="headerlink" title="不同的权重，权重值高则生效"></a><strong>不同的权重，权重值高则生效</strong></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>权重高的样式生效<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 权重值：1 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="comment">/* 权重值：10 */</span></span></span><br><span class="line">.box2&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="comment">/* 权重值：100 */</span></span></span><br><span class="line">#box&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: green;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-4428f2f2ad22f0541b5c49ec42f261c4_720w.jpg" alt="img">id的权重高，所以id选择器中的样式生效</p><p>从上面的例子不难看出，id选择器的权重值高于其它2种选择器的权重值，所以id选择器中的样式生效了。</p><h2 id="important-提升样式优先级"><a href="#important-提升样式优先级" class="headerlink" title="!important(提升样式优先级)"></a><strong>!important(提升样式优先级)</strong></h2><p>!important的作用是提升样式优先级，如果加了这句的样式的优先级是最高的。不过我这里*<strong>建议大家一下，!important最好不要使用。*</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: blue <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#box</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot; style=&quot;background-color: red;width: 100px;height: 100px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-dffaab8e727068ed415d2e93f11cab30_720w.jpg" alt="img">!important 优先级是最高的，不建议使用</p><h2 id="两种样式都使用-important时"><a href="#两种样式都使用-important时" class="headerlink" title="两种样式都使用!important时"></a><strong>两种样式都使用!important时</strong></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>当两个样式都使用!important时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.box&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red <span class="meta">!important</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: green <span class="meta">!important</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当两个样式都使用!important时，权重值大的优先级更高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic1.zhimg.com/80/v2-78a61330c654eb406693bcbea09fc728_720w.jpg" alt="img">当两个样式都使用!important时，权重值大的优先级更高</p><h2 id="important应用于简写样式"><a href="#important应用于简写样式" class="headerlink" title="!important应用于简写样式"></a><strong>!important应用于简写样式</strong></h2><p>如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被作用上!important。</p><p>例如：<em>background: blue !important;</em></p><p><img data-src="https://pic1.zhimg.com/80/v2-7d88d39b30972d1b20ef5ba2e96d46d4_720w.jpg" alt="img">简单写的样式如果使用!important，子属性也会默认加上important</p><p>上述结果可以看出，background的子属性都加上了!important，到这里，我提醒一下开发者们，这种复合性样式不建议大量使用，如果里面的属性大多数是可以用到的，还是可以写复合性样式的。我经常看到一些开发都，给某一元素加上颜色，经常性的写成这样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: red;</span><br></pre></td></tr></table></figure><p>这个样式从表面来说，和background-color:red;一样可以实现效果。</p><p>这时你可以通过浏览器的调试工具来查看它具体的样式：</p><p><img data-src="https://pic3.zhimg.com/80/v2-891cb936a5d21fd220732e8d01908bb6_720w.jpg" alt="img">goolge下的效果图</p><p>使用复合写法的时候，它不光只加载了背景颜色样式，还加载了其它一些样式。可想而知，如果一个项目的前台全部都采用复合写法的方式，第设置一个background样式时background相关的样式都会被加载进去，这样性能一定非常差，这也是一种不合理的设计方 案，而单例写法却看不到这种情况。 </p><p><strong>行内、内联和外联样式优先级</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>css优先级<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">        &#125;</span><br><span class="line">        #box&#123;</span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 行内样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: red;width: 100px;height: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-ca7b3c40edc41399cf0224c91137551b_720w.jpg" alt="img">效果图</p><p>根据权重值来计算，行内样式的权重值最大，所以行内样式生效了。</p><p><strong>内联和外联样式优先级</strong></p><p>这里我曾经一直以为内联样式的优先级一定大于外联样式的，直到最近的几天我才发现我一直都学错了，所以这里也是给大家提个醒，希望自己也牢记这个教训。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* styles.css */</span></span><br><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>1.外联样式写前面，内联样式写后面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>内联和外联样式的优先级问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#div&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-5558422e14755b5dc2ce0eb0f2ae6ec7_720w.jpg" alt="img">内联样式生效</p><p>2.内联样式写前面，外联样式写后面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>内联和外联样式的优先级问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#div&#123;</span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;css/styles.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联样式生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-3350f183180f050442665e45f69971cb_720w.jpg" alt="img">外联样式生效</p><p>上面的例子足以说明内联样式的优先级并不一定比外联样式高，因为css样式是单线程，依次从上向下加载的，这也就证明了*<strong>内联样式和外联样式的优先级和加载顺序有关*</strong>。</p><p>总结一下：**<em>!important &gt; 行内样式 &gt; 内联样式 and 外联样式**</em></p><p><img data-src="https://pic1.zhimg.com/80/v2-bb8fc596d248f2c30bae77b565fded84_720w.jpg" alt="img">样式优先级</p><p><strong>样式应用于非目标标签时</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>样式应用于非目标标签时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red&#125;;</span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>: blue&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 选中非目标元素的情况下，离目标越近者优先 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>神来之笔<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-a2eed077c5ad66f7de820538fb585217_720w.jpg" alt="img">效果图</p><p><strong>权重相等的情况下</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>权重相等的情况下<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 权重值：201 */</span></span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span> <span class="selector-id">#box2</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/* 权重值：201,离目标最近 */</span></span></span><br><span class="line"><span class="css"><span class="selector-id">#box</span> <span class="selector-id">#box3</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同等权重下,靠近目标的优先 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;boxs3&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic4.zhimg.com/80/v2-e5bed8244d8296206d76cec0f825dacf_720w.jpg" alt="img">同等权重下,靠近目标的优先</p><p><strong>总结</strong></p><ol><li>常用选择器权重优先级：*<strong>!important &gt; id &gt; class &gt; tag*</strong></li><li>!important可以提升样式优先级，但不建议使用。如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：<em>background: blue !important;</em></li><li>如果两条样式都使用!important，则权重值高的优先级更高</li><li>在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的</li><li>样式指向同一元素，权重规则生效，权重大的被应用</li><li>样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用</li><li>样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用</li></ol><h1 id="7-圣杯布局和双飞翼布局"><a href="#7-圣杯布局和双飞翼布局" class="headerlink" title="7.圣杯布局和双飞翼布局"></a>7.圣杯布局和双飞翼布局</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/11/16a0c9554c172710?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="字面意思"><a href="#字面意思" class="headerlink" title="字面意思"></a>字面意思</h2><p>圣杯布局和双飞翼布局从字面意思来看是这样的：</p><blockquote><p>一个像圣杯或者像展翅的禽类这样的布局</p></blockquote><p><strong>通俗的来说就是左右两栏固定宽度，中间部分自适应的三栏布局。</strong></p><h3 id="两者本质"><a href="#两者本质" class="headerlink" title="两者本质"></a>两者本质</h3><p><img data-src="https://user-gold-cdn.xitu.io/2019/9/5/16cfefeb90d9ec0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><ol><li>首先把left、middle、right都放出来</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;</li></ol><p><strong>接下来比较重要了：</strong></p><ol><li>给left、middle、right设置position: relative;</li><li>left设置 left: -leftWidth, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ol><hr><p>我注意到圣杯布局的left、middle、right都有position: relative;</p><p>设:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.left width:200px</span><br><span class="line">.right width:220px</span><br></pre></td></tr></table></figure><p>那么下面的这些属性为什么要存在？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container上面的paddind</span><br><span class="line">.left 的left: -200px;</span><br><span class="line">.right 的right: -220px;</span><br></pre></td></tr></table></figure><p><strong>因为不这样设置  会遮挡middle的内容</strong></p><p>可以自己尝试一下下</p><hr><p>圣杯布局示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;圣杯布局&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .header,</span><br><span class="line">    .footer &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      font-weight: bolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .footer &#123;</span><br><span class="line">      background-color: goldenrod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">      padding: 0 220px 0 200px;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .middle,</span><br><span class="line">    .right &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      float: left;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      left: -200px;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-left: -220px;</span><br><span class="line">      right: -220px;</span><br><span class="line">      width: 220px;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .middle &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;middle&quot;&gt;</span><br><span class="line">      &lt;h4&gt;middle&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">        middlemiddlemiddlemiddlemiddle</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">      &lt;h4&gt;left&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">      &lt;h4&gt;right&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightright</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;footer&quot;&gt;footer&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。</p><p>这样可以先做好主体部分，然后再将附属部分放到合适的位置！</p><ol><li>首先把left、middle、right都放出来, middle中增加inner</li><li>给它们三个设置上float: left, 脱离文档流；</li><li>一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档</li><li>left、right设置上各自的宽度</li><li>middle设置width: 100%;</li></ol><p><strong>接下来与圣杯布局不一样的地方：</strong></p><ol><li>left设置 margin-left: -100%, right设置 right: -rightWidth;</li><li>container设置padding: 0, rightWidth, 0, leftWidth;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;双飞翼布局&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .header,</span><br><span class="line">    .footer &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      font-weight: bolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .footer &#123;</span><br><span class="line">      background-color: goldenrod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left,</span><br><span class="line">    .middle,</span><br><span class="line">    .right &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .left &#123;</span><br><span class="line">      margin-left: -100%;</span><br><span class="line">      width: 200px;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .right &#123;</span><br><span class="line">      margin-left: -220px;</span><br><span class="line">      width: 220px;</span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .middle &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .inner &#123;</span><br><span class="line">      margin: 0 220px 0 200px;</span><br><span class="line">      min-height: 130px;</span><br><span class="line">      background: blue;</span><br><span class="line">      word-break: break-all;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;middle&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;inner&quot;&gt;</span><br><span class="line">        &lt;h4&gt;middle&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddlemiddlemiddlemiddle</span><br><span class="line">          middlemiddlemiddlemiddlemiddle</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">      &lt;h4&gt;left&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">        leftleftleftleftleftleftleftleftleftleftleftleft</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">      &lt;h4&gt;right&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightrightrightrightright</span><br><span class="line">        rightrightrightrightrightrightright</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;footer&quot;&gt;footer&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>圣杯布局在DOM结构上显得更加直观和自然；</p><p>双飞翼布局省去了很多css，而且由于不用使用定位，可以获得比圣杯布局更小最小宽度；</p><p>说到这里需要注意一下  由于双飞翼布局会一直随着浏览器可视区域宽度减小从而不断挤压中间部分宽度。</p><p>所以需要设置给页面一个min-width &gt; LeftWidth + RightWidth；</p><hr><p>还有一件事就是他们在单独部分内容扩充的时候，童鞋们可能发现了 底部会参差不齐。</p><p>在我的老师那里知道了最简单的解决办法 / 笑哭</p><blockquote><p>给left、middle、right设置上 padding-bottom: 9999px; margin-bottom: -9999px;</p></blockquote><p>就让他变得无限高，但是又给他送回去了。真的是让我脑洞大开！！！</p><h1 id="8-CSS3新特性"><a href="#8-CSS3新特性" class="headerlink" title="8.CSS3新特性"></a>8.CSS3新特性</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>css3这个相信大家不陌生了，是个非常有趣，神奇的东西！有了css3，js都可以少写很多！我之前也写过关于css3的文章，也封装过css3的一些小动画。个人觉得css3不难，但是很难用得好，用得顺手，最近我也在过一遍css3的一些新特性（不是全部，是我在工作上常用的，或者觉得有用的），以及一些实例，就写了这一篇总结！希望，这篇文章能帮到大家认识css3。写这篇文章主要是让大家能了解css3的一些新特性，以及基础的用法，感觉css3的魅力！如果想要用好css3，这个得靠大家继续努力学习，寻找一些讲得更深入的文章或者书籍了！如果大家有什么其他特性推荐的，欢迎补充！大家一起学习，进步！</p><blockquote><p>看这篇文章，代码可以不用看得过于仔细！这里主要是想让大家了解css3的新特性！代码也是很基础的用法。我给出代码主要是让大家在浏览器运行一下，让大家参考和调试。不要只看代码，只看代码的话，不会知道哪个代码有什么作用的，建议边看效果边看代码。</p></blockquote><h2 id="2-过渡"><a href="#2-过渡" class="headerlink" title="2.过渡"></a>2.过渡</h2><p>过渡，是我在项目里面用得最多的一个特性了！也相信是很多人用得最多的一个例子！我平常使用就是想让一些交互效果（主要是hover动画），变得生动一些，不会显得那么生硬！好了，下面进入正文！</p><p>引用菜鸟教程的说法：CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容：指定要添加效果的CSS属性指定效果的持续时间。</p><h3 id="2-1语法"><a href="#2-1语法" class="headerlink" title="2-1语法"></a>2-1语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*&#x2F;</span><br><span class="line">transition：width,.5s,ease,.2s</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*&#x2F;</span><br><span class="line">transition：all,.5s</span><br></pre></td></tr></table></figure><p>上面例子是简写模式，也可以分开写各个属性（这个在下面就不再重复了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br></pre></td></tr></table></figure><h3 id="2-2实例-hover效果"><a href="#2-2实例-hover效果" class="headerlink" title="2-2实例-hover效果"></a>2-2实例-hover效果</h3><p><img data-src="https://segmentfault.com/img/bVTbJs?w=467&h=139" alt="clipboard.png"></p><p>上面两个按钮，第一个使用了过渡，第二个没有使用过渡，大家可以看到当中的区别，用了过渡之后是不是没有那么生硬，有一个变化的过程，显得比较生动。<br>当然这只是一个最简单的过渡例子，两个按钮的样式代码，唯一的区别就是，第一个按钮加了过渡代码<code>transition: all .5s;</code></p><h3 id="2-3实例-下拉菜单"><a href="#2-3实例-下拉菜单" class="headerlink" title="2-3实例-下拉菜单"></a>2-3实例-下拉菜单</h3><p><img data-src="https://segmentfault.com/img/bVTbLy?w=592&h=570" alt="clipboard.png"></p><p>上面两个菜单，第一个没有使用过渡，第二个使用过渡，大家明显看到区别，使用了过渡看起来也是比较舒服！代码区别就是有过渡的ul的上级元素(祖先元素)有一个类名（ul-transition）。利用这个类名，设置ul的过渡<code>.ul-transition ul&#123;transform-origin: 0 0;transition: all .5s;&#125;</code></p><p>可能大家不知道我在说什么！我贴下代码吧</p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;demo-hover demo-ul t_c&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;fllil&quot;&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;html&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;div&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;h1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;js&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;string&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;array&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;object&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;number&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;css3&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;transition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;animation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;框架&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;vue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;react&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;demo-hover demo-ul ul-transition t_c&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;fllil&quot;&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;html&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;div&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;h1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;js&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;string&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;array&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;object&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;number&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;css3&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;transition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;animation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;javascript:;&quot;&gt;框架&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;vue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href&#x3D;&quot;#&quot;&gt;react&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.demo-ul&#123;margin-bottom: 300px;&#125;</span><br><span class="line">    .demo-ul li&#123;</span><br><span class="line">        padding: 0 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background: #f90;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li a&#123;</span><br><span class="line">        display: block;</span><br><span class="line">        height: 40px;</span><br><span class="line">        line-height: 40px;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li ul&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100%;</span><br><span class="line">        top: 40px;</span><br><span class="line">        left: 0;</span><br><span class="line">        transform: scaleY(0);</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .ul-transition ul&#123;</span><br><span class="line">        transform-origin: 0 0;</span><br><span class="line">        transition: all .5s;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li:hover ul&#123;</span><br><span class="line">        transform: scaleY(1);</span><br><span class="line">    &#125;</span><br><span class="line">    .demo-ul li ul li&#123;</span><br><span class="line">        float: none;</span><br><span class="line">        background: #0099ff;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个可以说是过渡很基础的用法，过渡用法灵活，功能也强大，结合js，可以很轻松实现各种效果（焦点图，手风琴）等，以及很多意想不到的效果。这个靠大家要去挖掘！</p><h2 id="3-动画"><a href="#3-动画" class="headerlink" title="3.动画"></a>3.动画</h2><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬！</p><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3-1.语法"></a>3-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）</span><br></pre></td></tr></table></figure><p>例子1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear;</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear 2s;</span><br></pre></td></tr></table></figure><p>例子3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*无限执行logo2-line动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*&#x2F;</span><br><span class="line">animation: logo2-line 2s linear alternate infinite;</span><br></pre></td></tr></table></figure><p>还有一个重要属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animation-fill-mode : none | forwards | backwards | both;</span><br><span class="line">&#x2F;*none：不改变默认行为。    </span><br><span class="line">forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。    </span><br><span class="line">backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 </span><br><span class="line">both：向前和向后填充模式都被应用。  *&#x2F;      </span><br></pre></td></tr></table></figure><h3 id="3-2-logo展示动画"><a href="#3-2-logo展示动画" class="headerlink" title="3-2.logo展示动画"></a>3-2.logo展示动画</h3><p><img data-src="https://segmentfault.com/img/bVTdn3?w=776&h=220" alt="clipboard.png"></p><p>这个是我用公司logo写的动画，没那么精细</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;reset.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.logo-box&#123;</span><br><span class="line">    width: 600px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    font-size: 0;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box div&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo-text&#123;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo1&#123;</span><br><span class="line">    animation: logo1 1s ease-in 2s;</span><br><span class="line">    animation-fill-mode:backwards;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo-text&#123;</span><br><span class="line">    animation: logoText 1s ease-in 3s;</span><br><span class="line">    animation-fill-mode:backwards;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo2&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20px;</span><br><span class="line">    left: 20px;</span><br><span class="line">    animation: logo2-middle 2s ease-in;</span><br><span class="line">&#125;</span><br><span class="line">.logo-box .logo2 img&#123;</span><br><span class="line">    animation: logo2-line 2s linear;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logo1 &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform:rotate(180deg);</span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform:rotate(0deg);</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logoText &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform:translateX(30px);</span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform:translateX(0);</span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes logo2-line &#123;</span><br><span class="line">    0% &#123; transform: translateX(200px)&#125;</span><br><span class="line">    25% &#123; transform: translateX(150px)&#125;</span><br><span class="line">    50% &#123; transform: translateX(100px)&#125;</span><br><span class="line">    75% &#123; transform: translateX(50px)&#125;</span><br><span class="line">    100% &#123; transform: translateX(0); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes logo2-middle &#123;</span><br><span class="line">    0% &#123; transform: translateY(0);     &#125;</span><br><span class="line">    25% &#123; transform: translateY(-100px);     &#125;</span><br><span class="line">    50% &#123; transform: translateY(0);     &#125;</span><br><span class="line">    75% &#123; transform: translateY(-50px);     &#125;</span><br><span class="line">    100% &#123; transform: translateY(0); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo-box&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo1&quot;&gt;&lt;img src&#x3D;&quot;logo1.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo2&quot;&gt;&lt;img src&#x3D;&quot;logo2.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;logo-text&quot;&gt;&lt;img src&#x3D;&quot;logo3.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;wraper&quot;&gt;&lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>下面让大家看一个专业级别的</p><p><img data-src="https://segmentfault.com/img/bVTdpk?w=734&h=214" alt="clipboard.png"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        font-family: Arial,&quot;Helvetica Neue&quot;,Helvetica,sans-serif;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background: #fff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .center &#123;</span><br><span class="line">        margin: 80px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .so &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line">        background: #ffffff;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner * &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        animation-iteration-count: infinite;</span><br><span class="line">        animation-duration: 3.5s;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .name &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        font-size: 54px;</span><br><span class="line">        left: 130px;</span><br><span class="line">        top: 95px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .name .b &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack-box &#123;</span><br><span class="line">        top: 100px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box &#123;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">        left: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box div &#123;</span><br><span class="line">        background: #BCBBBB;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .bottom &#123;</span><br><span class="line">        bottom: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .left &#123;</span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .right &#123;</span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 103px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .top &#123;</span><br><span class="line">        top: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack &#123;</span><br><span class="line">        left: 22px;</span><br><span class="line">        top: 22px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .inner-item &#123;</span><br><span class="line">        background: #F48024;</span><br><span class="line">        width: 71px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item &#123;</span><br><span class="line">        transition: transform 0.3s;</span><br><span class="line">        width: 291px;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(1) &#123;</span><br><span class="line">        transform: rotate(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(2) &#123;</span><br><span class="line">        transform: rotate(12deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(3) &#123;</span><br><span class="line">        transform: rotate(24deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(4) &#123;</span><br><span class="line">        transform: rotate(36deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack div:nth-child(5) &#123;</span><br><span class="line">        transform: rotate(48deg);</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box &#123;</span><br><span class="line">        animation-name: box;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .top &#123;</span><br><span class="line">        animation-name: box-top;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .left &#123;</span><br><span class="line">        animation-name: box-left;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .right &#123;</span><br><span class="line">        animation-name: box-right;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .box .bottom &#123;</span><br><span class="line">        animation-name: box-bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack-box &#123;</span><br><span class="line">        animation-name: stack-box;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack &#123;</span><br><span class="line">        animation-name: stack;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .inner-item &#123;</span><br><span class="line">        animation-name: stack-items;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(1) &#123;</span><br><span class="line">        animation-name: stack-item-1;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(2) &#123;</span><br><span class="line">        animation-name: stack-item-2;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(3) &#123;</span><br><span class="line">        animation-name: stack-item-3;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(4) &#123;</span><br><span class="line">        animation-name: stack-item-4;</span><br><span class="line">    &#125;</span><br><span class="line">    .so .inner .stack .item:nth-child(5) &#123;</span><br><span class="line">        animation-name: stack-item-5;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-1 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-2 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-3 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-4 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-item-5 &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-items &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-top &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        6% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        59% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-bottom &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes box-right &#123;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes stack-box &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        40% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        83% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;so center&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;inner&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;stack-box&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;stack&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;inner-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;bottom&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;top&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;name&quot;&gt;</span><br><span class="line">            stack&lt;span class&#x3D;&quot;b&quot;&gt;overflow&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-loading效果"><a href="#3-3-loading效果" class="headerlink" title="3-3.loading效果"></a>3-3.loading效果</h3><p><img data-src="https://segmentfault.com/img/bVTdrH?w=1192&h=951" alt="clipboard.png"></p><p>这个代码实在太多了，大家直接上网址看吧。<a href="http://www.html5tricks.com/demo/css3-loading-cool-styles/index.html">css3-loading</a></p><h3 id="3-4-音乐震动条"><a href="#3-4-音乐震动条" class="headerlink" title="3-4.音乐震动条"></a>3-4.音乐震动条</h3><p><img data-src="https://segmentfault.com/img/bVTdsN?w=260&h=155" alt="clipboard.png"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;纯CSS3模拟跳动的音符效果&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;margin:0;padding:0;list-style: none;&#125;</span><br><span class="line">    body&#123;background-color: #efefef;&#125;</span><br><span class="line">    .demo-music &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 200px;</span><br><span class="line">      top: 120px;</span><br><span class="line">      zoom: 1.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music .music &#123;</span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      -webkit-transform: translate(-40px, -25px);</span><br><span class="line">      transform: translate(-40px, -25px);</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves &#123;</span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 12px;</span><br><span class="line">      left: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves li &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 12%;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      margin-right: 1px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves li span &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background: #09f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li1 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li2 span &#123;</span><br><span class="line">      animation: waves 0.9s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.9s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li3 span &#123;</span><br><span class="line">      animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li4 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li5 span &#123;</span><br><span class="line">      animation: waves 0.7s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.7s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .demo-music #waves .li6 span &#123;</span><br><span class="line">      animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 0.8s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line">    @-webkit-keyframes waves &#123;</span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes waves &#123;</span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;demo-music&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;music&quot;&gt;</span><br><span class="line">      &lt;ul id&#x3D;&quot;waves&quot; class&#x3D;&quot;movement&quot;&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li1&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li2&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li3&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li4&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li5&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li class&#x3D;&quot;li6&quot;&gt;&lt;span class&#x3D;&quot;ani-li&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;music-state&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="4-形状转换"><a href="#4-形状转换" class="headerlink" title="4.形状转换"></a>4.形状转换</h2><p>这一部分，分2d转换和3d转换。有什么好玩的，下面列举几个！</p><h3 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4-1.语法"></a>4-1.语法</h3><p>transform:适用于2D或3D转换的元素<br>transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)</p><h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4-2.实例"></a>4-2.实例</h3><p>transform:rotate(30deg);</p><p><img data-src="https://segmentfault.com/img/bVTdyC?w=284&h=218" alt="clipboard.png"></p><p>transform:translate(30px,30px);</p><p><img data-src="https://segmentfault.com/img/bVTdAC?w=501&h=450" alt="clipboard.png"></p><p>transform:scale(.8);</p><p><img data-src="https://segmentfault.com/img/bVTdAT?w=404&h=373" alt="clipboard.png"></p><p>transform: skew(10deg,10deg);</p><p><img data-src="https://segmentfault.com/img/bVTdBj?w=280&h=160" alt="clipboard.png"></p><p>transform:rotateX(180deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHv?w=142&h=97" alt="clipboard.png"></p><p>transform:rotateY(180deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHA?w=142&h=97" alt="clipboard.png"></p><p>transform:rotate3d(10,10,10,90deg);</p><p><img data-src="https://segmentfault.com/img/bVTdHU?w=182&h=114" alt="clipboard.png"></p><h2 id="5-选择器"><a href="#5-选择器" class="headerlink" title="5.选择器"></a>5.选择器</h2><p>css3提供的选择器可以让我们的开发，更加方便！这个大家都要了解。下面是css3提供的选择器。</p><p><img data-src="https://segmentfault.com/img/bVTd2d?w=780&h=728" alt="clipboard.png"></p><p>图片来自w3c。这一块建议大家去w3c看（<a href="http://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册</a>），那里的例子通俗易懂。我不重复讲了。<br>提供的选择器里面，基本都挺好用的。但是我觉得有些不会很常用，比如，<code>:root，:empty，:target，:enabled，:checked</code>。而且几个不推荐使用，网上的说法是性能较差<code>[attribute*=value]，[attribute$=value]，[attribute^=value]</code>，这个我没用过，不太清楚。</p><h2 id="6-阴影"><a href="#6-阴影" class="headerlink" title="6.阴影"></a>6.阴影</h2><p>以前没有css3的时候，或者需要兼容低版本浏览器的时候，阴影只能用图片实现，但是现在不需要，css3就提供了！</p><h3 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6-1.语法"></a>6-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;</span><br></pre></td></tr></table></figure><h3 id="6-1-例子"><a href="#6-1-例子" class="headerlink" title="6-1.例子"></a>6-1.例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:100px;</span><br><span class="line">    background:#09f;</span><br><span class="line">    box-shadow: 10px 10px 5px #888888;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTd9F?w=364&h=151" alt="clipboard.png"></p><h2 id="7-边框"><a href="#7-边框" class="headerlink" title="7.边框"></a>7.边框</h2><h3 id="7-1-边框图片"><a href="#7-1-边框图片" class="headerlink" title="7-1.边框图片"></a>7-1.边框图片</h3><h4 id="7-1-1-语法"><a href="#7-1-1-语法" class="headerlink" title="7-1-1.语法"></a>7-1-1.语法</h4><p>border-image: 图片url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;</p><h4 id="7-1-2-例子"><a href="#7-1-2-例子" class="headerlink" title="7-1-2.例子"></a>7-1-2.例子</h4><p>边框图片（来自菜鸟教程）</p><p><img data-src="https://segmentfault.com/img/bVTefk?w=81&h=81" alt="clipboard.png"></p><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.demo &#123;</span><br><span class="line">    border: 15px solid transparent;</span><br><span class="line">    padding: 15px;   </span><br><span class="line">    border-image: url(border.png);</span><br><span class="line">    border-image-slice: 30;</span><br><span class="line">    border-image-repeat: round;</span><br><span class="line">    border-image-outset: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果</p><p><img data-src="https://segmentfault.com/img/bVTeeg?w=601&h=91" alt="clipboard.png"></p><p>有趣变化</p><p><img data-src="https://segmentfault.com/img/bVTefm?w=617&h=444" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTefl?w=617&h=444" alt="clipboard.png"></p><p>那个更好看，大家看着办</p><h3 id="7-2-边框圆角"><a href="#7-2-边框圆角" class="headerlink" title="7-2.边框圆角"></a>7-2.边框圆角</h3><h4 id="7-2-1-语法"><a href="#7-2-1-语法" class="headerlink" title="7-2-1.语法"></a>7-2-1.语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-radius: n1,n2,n3,n4;</span><br><span class="line">border-radius: n1,n2,n3,n4&#x2F;n1,n2,n3,n4;</span><br><span class="line">&#x2F;*n1-n4四个值的顺序是：左上角，右上角，右下角，左下角。*&#x2F;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-例子"><a href="#7-2-2-例子" class="headerlink" title="7-2-2.例子"></a>7-2-2.例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:2px solid #a1a1a1;</span><br><span class="line">    padding:10px 40px; </span><br><span class="line">    background:#dddddd;</span><br><span class="line">    text-align:center;</span><br><span class="line">    width:300px;</span><br><span class="line">    border-radius:25px 0 25px 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;border-radius&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTegF?w=486&h=82" alt="clipboard.png"></p><h2 id="8-背景"><a href="#8-背景" class="headerlink" title="8.背景"></a>8.背景</h2><p>这一块主要讲css3提供背景的三个属性</p><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h3><p>制定背景绘制（显示）区域</p><p>默认情况（从边框开始绘制）</p><p><img data-src="https://segmentfault.com/img/bVTeqt?w=533&h=251" alt="clipboard.png"></p><p>从padding开始绘制（显示），不算border,，相当于把border那里的背景给裁剪掉！（background-clip: padding-box;）</p><p><img data-src="https://segmentfault.com/img/bVTeqv?w=533&h=255" alt="clipboard.png"></p><p>只在内容区绘制（显示），不算padding和border，相当于把padding和border那里的背景给裁剪掉！（background-clip: content-box;）</p><p><img data-src="https://segmentfault.com/img/bVTeqy?w=537&h=244" alt="clipboard.png"></p><h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h3><p>引用菜鸟教程的说法：background-Origin属性指定background-position属性应该是相对位置</p><p>下面的div初始的html和css代码都是一样的。如下<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:10px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background:url(&#39;logo.png&#39;) no-repeat,#ccc;</span><br><span class="line">    background-position:0px 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下，background-origin不同的三种情况</p><p><img data-src="https://segmentfault.com/img/bVZGAM?w=800&h=506" alt="图片描述"></p><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><p>这个相信很好理解，就是制定背景的大小<br>下面的div初始的html和css代码都是一样的。如下<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:1px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background:url(&#39;test.jpg&#39;) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgk7?w=1016&h=768" alt="clipboard.png"></p><h3 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h3><p>这个没什么，就是在一张图片，使用多张背景图片，代码如下！<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;两张图片的背景&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    border:1px dashed black;</span><br><span class="line">    padding:35px;</span><br><span class="line">    background-size: contain;</span><br><span class="line">    background:url(&#39;test.jpg&#39;) no-repeat left,url(logo.png) no-repeat right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTglS?w=999&h=199" alt="clipboard.png"></p><h2 id="9-反射"><a href="#9-反射" class="headerlink" title="9.反射"></a>9.反射</h2><p>这个也可以说是倒影，用起来也挺有趣的。</p><h3 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9-1.语法"></a>9-1.语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</span><br></pre></td></tr></table></figure><h3 id="9-2-下倒影"><a href="#9-2-下倒影" class="headerlink" title="9-2.下倒影"></a>9-2.下倒影</h3><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.reflect-bottom-p &#123;</span><br><span class="line">    padding-bottom: 300px;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">.reflect-bottom &#123;</span><br><span class="line">    -webkit-box-reflect: below;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTeoE?w=518&h=669" alt="clipboard.png"></p><h3 id="9-2-右倒影（有偏移）"><a href="#9-2-右倒影（有偏移）" class="headerlink" title="9-2.右倒影（有偏移）"></a>9-2.右倒影（有偏移）</h3><p><img data-src="https://segmentfault.com/img/bVTeoU?w=994&h=351" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;右倒影同时有偏移&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-right-translate&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.reflect-right-translate &#123;</span><br><span class="line">    -webkit-box-reflect: right 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-下倒影（渐变）"><a href="#9-3-下倒影（渐变）" class="headerlink" title="9-3.下倒影（渐变）"></a>9-3.下倒影（渐变）</h3><p><img data-src="https://segmentfault.com/img/bVTepo?w=507&h=668" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影（渐变）&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom-mask&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reflect-bottom-mask &#123;</span><br><span class="line">    -webkit-box-reflect: below 0 linear-gradient(transparent, white);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-下倒影（图片遮罩）"><a href="#9-3-下倒影（图片遮罩）" class="headerlink" title="9-3.下倒影（图片遮罩）"></a>9-3.下倒影（图片遮罩）</h3><p>使用的图片</p><p><img data-src="https://segmentfault.com/img/bVTepE?w=200&h=200" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTepD?w=510&h=672" alt="clipboard.png"></p><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;下倒影（png图片）&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;reflect-bottom-p&quot;&gt;&lt;img src&#x3D;&quot;test.jpg&quot; class&#x3D;&quot;reflect-bottom-img&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.reflect-bottom-img &#123;</span><br><span class="line">    -webkit-box-reflect: below 0 url(shou.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-文字"><a href="#10-文字" class="headerlink" title="10.文字"></a>10.文字</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>语法：<code>word-break: normal|break-all|keep-all;</code><br>例子和运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgo9?w=511&h=446" alt="clipboard.png"></p><p>语法：<code>word-wrap: normal|break-word;</code><br>例子和运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgpp?w=602&h=423" alt="clipboard.png"></p><blockquote><p>超出省略号这个，主要讲<code>text-overflow</code>这个属性，我直接讲实例的原因是<code>text-overflow</code>的三个写法，<code>clip|ellipsis|string</code>。<code>clip</code>这个方式处理不美观，不优雅。<code>string</code>只在火狐兼容。</p></blockquote><p><img data-src="https://segmentfault.com/img/bVTgpF?w=595&h=299" alt="clipboard.png"></p><h3 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h3><p>这个其实有三行代码，禁止换行，超出隐藏，超出省略号<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;This is some long text that will not fit in the box&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:200px; </span><br><span class="line">    border:1px solid #000000;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">    white-space:nowrap; </span><br><span class="line">    text-overflow:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTgqd?w=292&h=42" alt="clipboard.png"></p><h3 id="多行超出省略号"><a href="#多行超出省略号" class="headerlink" title="多行超出省略号"></a>多行超出省略号</h3><p>超出省略号。这个对于大家来说，不难！但是以前如果是多行超出省略号，就只能用js模拟！现在css3提供了多行省略号的方法！遗憾就是这个暂时只支持webkit浏览器！</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;    </span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:400px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">    overflow : hidden;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>效果图</p><p><img data-src="https://segmentfault.com/img/bVTd6V?w=491&h=74" alt="clipboard.png"></p><p>这样发现边框贴着难看，要撑开一点，但是撑开上下边框不要使用padding!因为会出现下面这个效果。</p><p><img data-src="https://segmentfault.com/img/bVTd66?w=527&h=102" alt="clipboard.png"></p><p>正确姿势是这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">    width:400px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">    overflow : hidden;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    padding:0 10px;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">    line-height:30px;</span><br><span class="line">    height:60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img data-src="https://segmentfault.com/img/bVTd7k?w=478&h=104" alt="clipboard.png"></p><p>这样写，就算在不是webkit内核的浏览器，也可以优雅降级（高度=行高*行数（webkit-line-clamp））！</p><p><img data-src="https://segmentfault.com/img/bVTd7u?w=481&h=108" alt="clipboard.png"></p><h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>语法：text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。<br>例子：<code>text-shadow: 0 0 10px #f00;</code><br>效果</p><p><img data-src="https://segmentfault.com/img/bVTgnR?w=378&h=78" alt="clipboard.png"></p><h2 id="11-颜色"><a href="#11-颜色" class="headerlink" title="11.颜色"></a>11.颜色</h2><p>这个其实就是css3提供了新的颜色表示方法。</p><h3 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h3><p>一个是rgba（rgb为颜色值，a为透明度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: rgba(255,00,00,1);</span><br><span class="line">background: rgba(00,00,00,.5);</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgri?w=924&h=81" alt="clipboard.png"></p><h3 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h3><p>h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”<br>这个我姿势了解过，没用过，这里简单给一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color: hsla( 112, 72%, 33%, 0.68);</span><br><span class="line">background-color: hsla( 49, 65%, 60%, 0.68);</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgqS?w=934&h=72" alt="clipboard.png"></p><h2 id="12-渐变"><a href="#12-渐变" class="headerlink" title="12.渐变"></a>12.渐变</h2><p>css3的渐变可以说是一大亮点，提供了线性渐变，径向渐变，圆锥渐变（w3c和菜鸟教程都没有提及，是我从一篇文章了解到，但是我自己在谷歌浏览器尝试，却是一个无效的写法！大家如果知道怎么用，请告知！感谢）<br>渐变这一部分，由于用法灵活，功能也强大，这个写起来很长，写一点又感觉没什么意思，我这里贴几个链接教程给大家，在文章我不多说了，毕竟我也是从那几个地方学的，他们写得也是比我好，比我详细！</p><p><a href="http://www.w3cplus.com/content/css3-gradient">CSS3 Gradient</a><br><a href="http://www.w3cplus.com/css3/new-css3-linear-gradient.html">再说CSS3渐变——线性渐变</a><br><a href="http://www.w3cplus.com/css3/new-css3-radial-gradient.html">再说CSS3渐变——径向渐变</a><br><a href="http://www.cnblogs.com/coco1s/p/7079529.html">神奇的 conic-gradient 圆锥渐变</a>（这篇就是看我看到圆锥渐变的文章）</p><h2 id="13-Filter（滤镜）"><a href="#13-Filter（滤镜）" class="headerlink" title="13.Filter（滤镜）"></a>13.Filter（滤镜）</h2><p>css3的滤镜也是一个亮点，功能强大，写法也灵活。</p><p>例子代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; &#x2F;&gt;</span><br><span class="line">&lt;p&gt;黑白色filter: grayscale(100%)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter: grayscale(100%);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;褐色filter:sepia(1)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:sepia(1);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;饱和度saturate(2)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:saturate(2);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;色相旋转hue-rotate(90deg)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:hue-rotate(90deg);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;反色filter:invert(1)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:invert(1);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;透明度opacity(.5)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:opacity(.5);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;亮度brightness(.5)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:brightness(.5);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;对比度contrast(2)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:contrast(2);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;模糊blur(3px)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:blur(3px);&quot;&#x2F;&gt;</span><br><span class="line">&lt;p&gt;阴影drop-shadow(5px 5px 5px #000)&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;filter:drop-shadow(5px 5px 5px #000);&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgyB?w=504&h=357" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzW?w=528&h=716" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzY?w=511&h=728" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgzZ?w=511&h=721" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgz0?w=513&h=723" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgPQ?w=519&h=715" alt="clipboard.png"></p><h2 id="14-弹性布局"><a href="#14-弹性布局" class="headerlink" title="14.弹性布局"></a>14.弹性布局</h2><p>这里说的弹性布局，就是flex；这一块要讲的话，必须要全部讲完，不讲完没什么意思，反而会把大家搞蒙！讲完也是很长，所以，这里我也只贴教程网址。博客讲的很好，很详细！</p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程：实例篇</a></p><h2 id="15-栅格布局"><a href="#15-栅格布局" class="headerlink" title="15.栅格布局"></a>15.栅格布局</h2><p>栅格化布局，就是grid；这一块和flex一样，要讲就必须讲完。这块的内容和flex差不多，也有点长，这里我也贴链接，这个链接讲得也很详细！</p><p><a href="http://www.jianshu.com/p/d183265a8dad">Grid布局指南</a></p><h2 id="16-多列布局"><a href="#16-多列布局" class="headerlink" title="16.多列布局"></a>16.多列布局</h2><p>这一块，我也是了解过，我觉得多列应该还是挺有用的。虽然我没在项目中用过，下面我简单说下！举个例子！这个属性，建议加私有前缀，兼容性有待提高！<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;newspaper&quot;&gt;</span><br><span class="line">当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.newspaper</span><br><span class="line">&#123;</span><br><span class="line">    column-count: 3;</span><br><span class="line">    -webkit-column-count: 3;</span><br><span class="line">    -moz-column-count: 3;</span><br><span class="line">    column-rule:2px solid #000;</span><br><span class="line">    -webkit-column-rule:2px solid #000;</span><br><span class="line">    -mox-column-rule:2px solid #000;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img data-src="https://segmentfault.com/img/bVTgRx?w=587&h=163" alt="clipboard.png"></p><h2 id="17-盒模型定义"><a href="#17-盒模型定义" class="headerlink" title="17.盒模型定义"></a>17.盒模型定义</h2><p>box-sizing这个属性，网上说法是：属性允许您以特定的方式定义匹配某个区域的特定元素。</p><p>这个大家看着可能不知道在说什么，简单粗暴的理解就是：box-sizing:border-box的时候，边框和padding包含在元素的宽高之内！如下图</p><p><img data-src="https://segmentfault.com/img/bVZDJZ?w=1040&h=797" alt="图片描述"></p><p>box-sizing:content-box的时候，边框和padding不包含在元素的宽高之内！如下图</p><p><img data-src="https://segmentfault.com/img/bVZDJ5?w=950&h=876" alt="图片描述"></p><h2 id="18-媒体查询"><a href="#18-媒体查询" class="headerlink" title="18.媒体查询"></a>18.媒体查询</h2><p>媒体查询，就在监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式！在做响应式的网站里面，是必不可少的一环！不过由于我最近的项目都是使用rem布局。所以媒体查询就没怎么用了！但是，媒体查询，还是很值得一看的！说不定哪一天就需要用上了！</p><p>例子代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt; </span><br><span class="line">&lt;title&gt;&lt;&#x2F;title&gt; </span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 960px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: darkgoldenrod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width: 480px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: lightgreen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;重置浏览器窗口查看效果！&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgPW?w=1022&h=157" alt="clipboard.png"></p><h2 id="19-混合模式"><a href="#19-混合模式" class="headerlink" title="19.混合模式"></a>19.混合模式</h2><p>混合模式，就像photoshop里面的混合模式！这一块，我了解过，在项目上没用过，但是我觉得这个应该不会没有用武之地！<br>css3的混合模式，两个（background-blend-mode和mix-blend-mode）。这两个写法和显示效果都非常像！区别就在于background-blend-mode是用于同一个元素的背景图片和背景颜色的。mix-blend-mode用于一个元素的背景图片或者颜色和子元素的。看以下代码，区别就出来了！</p><blockquote><p>这一块图片很多，大家看图片快速扫一眼，看下什么效果就好！</p></blockquote><h3 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h3><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            width: 480px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:url(&#39;test.jpg&#39;)no-repeat,#09f;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!----&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;multiply正片叠底&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: multiply;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;screen滤色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: screen;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;overlay叠加&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: overlay;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;darken变暗&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: darken;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;lighten变亮&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: lighten;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-dodge颜色减淡模式&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color-dodge;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-burn颜色加深&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color-burn;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hard-light强光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: hard-light;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;soft-light柔光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: soft-light;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;difference差值&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: difference;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;exclusion排除&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: exclusion;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hue色相&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: hue;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;saturation饱和度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: saturation;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color颜色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: color;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;luminosity亮度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;background-blend-mode: luminosity;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgPX?w=502&h=362" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgPZ?w=506&h=710" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP0?w=512&h=711" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP1?w=516&h=711" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP2?w=514&h=353" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP3?w=523&h=709" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP6?w=521&h=708" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgP9?w=544&h=713" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQa?w=525&h=705" alt="clipboard.png"></p><h3 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h3><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            padding: 20px;</span><br><span class="line">            width: 480px;</span><br><span class="line">            background: #09f;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;原图&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;multiply正片叠底&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: multiply;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;screen滤色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: screen;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;overlay叠加&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: overlay;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;darken变暗&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: darken;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;lighten变亮&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: lighten;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-dodge颜色减淡模式&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color-dodge;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color-burn颜色加深&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color-burn;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hard-light强光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: hard-light;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;soft-light柔光&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: soft-light;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;difference差值&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: difference;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;exclusion排除&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: exclusion;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;hue色相&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: hue;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;saturation饱和度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: saturation;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;color颜色&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: color;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;p&gt;luminosity亮度&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src&#x3D;&quot;test.jpg&quot; style&#x3D;&quot;mix-blend-mode: luminosity;&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img data-src="https://segmentfault.com/img/bVTgQd?w=556&h=406" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQf?w=550&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQk?w=554&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQm?w=554&h=398" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQp?w=551&h=401" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQs?w=544&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQv?w=568&h=402" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQx?w=555&h=391" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQz?w=563&h=404" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgQB?w=553&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjea?w=556&h=399" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTgSP?w=551&h=396" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjeh?w=560&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjem?w=558&h=400" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjep?w=547&h=402" alt="clipboard.png"></p><p><img data-src="https://segmentfault.com/img/bVTjeq?w=551&h=395" alt="clipboard.png"></p><h1 id="9-CSS样式隔离"><a href="#9-CSS样式隔离" class="headerlink" title="9.CSS样式隔离"></a>9.CSS样式隔离</h1><p>CSS in JS，意思就是使用 js 语言写 css，完全不需要些单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。</p><p>CSS in JS 其实是一种编写思想，目前已经有超过 40 多种方案的实现，最出名的是 styled-components。</p><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import styled from &quot;styled-components&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个带样式的 h1 标签</span><br><span class="line">const Title &#x3D; styled.h1&#96;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个带样式的 section 标签</span><br><span class="line">const Wrapper &#x3D; styled.section&#96;</span><br><span class="line">  padding: 4em;</span><br><span class="line">  background: papayawhip;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过属性动态定义样式</span><br><span class="line">const Button &#x3D; styled.button&#96;</span><br><span class="line">  background: $&#123;props &#x3D;&gt; (props.primary ? &quot;palevioletred&quot; : &quot;white&quot;)&#125;;</span><br><span class="line">  color: $&#123;props &#x3D;&gt; (props.primary ? &quot;white&quot; : &quot;palevioletred&quot;)&#125;;</span><br><span class="line"></span><br><span class="line">  font-size: 1em;</span><br><span class="line">  margin: 1em;</span><br><span class="line">  padding: 0.25em 1em;</span><br><span class="line">  border: 2px solid palevioletred;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 样式复用</span><br><span class="line">const TomatoButton &#x3D; styled(Button)&#96;</span><br><span class="line">  color: tomato;</span><br><span class="line">  border-color: tomato;</span><br><span class="line">&#96;;</span><br><span class="line"></span><br><span class="line">&lt;Wrapper&gt;</span><br><span class="line">  &lt;Title&gt;Hello World, this is my first styled component!&lt;&#x2F;Title&gt;</span><br><span class="line">  &lt;Button primary&gt;Primary&lt;&#x2F;Button&gt;</span><br><span class="line">&lt;&#x2F;Wrapper&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，我们直接在 js 中编写 css，案例中在定义源生 html 时就创建好了样式，在使用的时候就可以渲染出带样式的组件了。</p><p>除此之外，还有其他比较出名的库：</p><ul><li>emotion</li><li>radium</li><li>glamorous</li></ul><p>日常的开发模式 存在以下痛点。</p><ul><li>全局污染：CSS 选择器的作用域是全局的，所以很容易引起选择器冲突；而为了避免全局冲突，又会导致类命名的复杂度上升</li><li>复用性低：CSS 缺少抽象的机制，选择器很容易出现重复，不利于维护和复用</li></ul><p>对于这个问题，也有一些方案。 vue 框架已经帮我们实现了 css 模块化, 通过 style 标签的 scoped 指令定义作用域，通过编译为该作用域所有标签生成唯一的属性。如图： <img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b86cc72b94e4df49adb0fba1ffee3eb~tplv-k3u1fbpfcp-zoom-1.image" alt="img"> 但是 react 并未给我们实现，我们可能会能通过其它方案来实现，如：约定 css class 命名规范(命名空间) 加上业务前缀，或者封装组件, 或者<a href="https://bemcss.com/">BEM 命名规范(block-element-modife)</a>/<a href="https://segmentfault.com/a/1190000012705634">BEM 简介</a>、 但并不能解决根源问题，反而使代码更难维护。</p><h2 id="目前主流的-css-模块化分为-css-modules-和-css-in-js-两种方案"><a href="#目前主流的-css-模块化分为-css-modules-和-css-in-js-两种方案" class="headerlink" title="目前主流的 css 模块化分为 css modules 和 css in js 两种方案"></a>目前主流的 css 模块化分为 css modules 和 css in js 两种方案</h2><h3 id="css-modules"><a href="#css-modules" class="headerlink" title="css modules"></a>css modules</h3><blockquote><p>CSS Modules 指的是我们像 import js 一样去引入我们的 css 代码，代码中的每一个类名都是引入对象的一个属性, 编译时会将 css 类名 加上唯一 hash。</p></blockquote><p>css module 需要 webpack 配置 css-loader 或者 scss-loader , module 为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>, <span class="comment">// 开启模块化</span></span><br><span class="line">        localIdentName: <span class="string">&#x27;[path][name]-[local]-[hash:base64:5]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图所示： <img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e81eff3bce7b4d168b7cf72899d75325~tplv-k3u1fbpfcp-zoom-1.image" alt="效果图"></p><p>讲解一下 localIdentName 自定义生成的类名格式，可选参数有：</p><ul><li>[path]表示样式表相对于项目根目录所在的路径(默认不拼接)</li><li>[name] 表示样式表文件名称</li><li>[local] 表示样式表的类名定义名称</li><li>[hash:length] 表示 32 位的 hash 值 注意：只有类名选择器和 ID 选择器才会被模块化控制，类似 body h2 span 这些标签选择器是不会被模块化控制</li></ul><p>css module 作用域</p><ul><li>作用域默认为 local 即只在当前模块生效</li><li>global 被 :global 包裹起来的类名，不会被模块化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加上 :global 会全局样式 */</span></span><br><span class="line">:<span class="function"><span class="title">global</span>(<span class="params">.<span class="built_in">global</span>-color</span>)</span> &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  :<span class="function"><span class="title">global</span>(<span class="params">.common-width</span>)</span> &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css module 高级使用</p><ul><li>和外部样式混用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用classNames</span></span><br><span class="line"><span class="keyword">const</span> wrapperClassNames = classNames(&#123;</span><br><span class="line">  <span class="string">&#x27;common-show&#x27;</span>: visible,</span><br><span class="line">  <span class="string">&#x27;common-hide&#x27;</span>: !visible,</span><br><span class="line">  [styles1[<span class="string">&#x27;view-wrapper&#x27;</span>]]: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;div className=&#123;wrapperClassNames&#125;&gt;&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串</span></span><br><span class="line">&lt;div className=&#123;<span class="string">`<span class="subst">$&#123;styles1.content&#125;</span> <span class="subst">$&#123;styles1.color&#125;</span> common-show`</span>&#125;&gt;</span><br><span class="line">  我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容我是文章内容</span><br><span class="line">&lt;/div&gt;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>覆盖第三方 UI 库</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* 覆盖第三方UI库 样式*/</span>&#125;</span><br><span class="line">&lt;div className=&#123;styles1[<span class="string">&#x27;am-button-custom-wrapper&#x27;</span>]&#125;&gt;</span><br><span class="line">  &lt;Button type=&#123;<span class="string">&#x27;primary&#x27;</span>&#125; onClick=&#123;<span class="function">() =&gt;</span> toggle()&#125;&gt;</span><br><span class="line">     &#123;visible ? <span class="string">&#x27;隐藏&#x27;</span> : <span class="string">&#x27;显示&#x27;</span>&#125;</span><br><span class="line">  &lt;/Button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  覆盖第三方UI库的 样式</span></span><br><span class="line">.am-button-custom-wrapper &#123;</span><br><span class="line">  :<span class="built_in">global</span> &#123;</span><br><span class="line">    .am-button-primary &#123;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css in js"></a>css in js</h3><ul><li>style 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  color: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">  backgroundColor: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://emotion.sh/docs/introduction">emotion</a></p></li><li><p>styled-components</p><blockquote><p><a href="https://styled-components.com/docs/basics#extending-styles">styled-components</a> 是针对 React 写的一套 css in js 框架, 在你使用 styled-components 进行样式定义的同时，你也就创建了一个 React 组件。<a href="https://www.jianshu.com/p/27788be90605">css in js </a></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">const DivWrapper = styled.div`</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: $&#123;(props) =&gt; props.color&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 封装第三方组件库</span><br><span class="line">const AntdButtonWrapper = styled(Button)`</span><br><span class="line">  <span class="attribute">color</span>: <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 通过属性动态定义样式</span><br><span class="line">const MyButton = styled.button`</span><br><span class="line">  <span class="attribute">background</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;palevioletred&#x27;</span> : <span class="string">&#x27;white&#x27;</span>)&#125;;</span><br><span class="line">  <span class="attribute">color</span>: $&#123;(props) =&gt; (props.primary ? <span class="string">&#x27;white&#x27;</span> : <span class="string">&#x27;palevioletred&#x27;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid palevioletred;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 样式复用</span><br><span class="line">const TomatoButton = styled(MyButton)`</span><br><span class="line">  <span class="attribute">color</span>: tomato;</span><br><span class="line">  <span class="attribute">border-color</span>: tomato;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 创建关键帧</span><br><span class="line">const rotate = keyframes`</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  `;</span><br><span class="line"></span><br><span class="line">// 创建动画组件</span><br><span class="line">const Rotate = styled.div`</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">animation</span>: $&#123;rotate&#125; <span class="number">2s</span> linear infinite;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure></li></ul><p>styled-components 优势: 支持将 props 以插值的方式传递给组件,以调整组件样式, 跨平台可在 RN 和 next 中使用。 缺点： 预处理器和后处理器不兼容。</p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/30/16f5477372d2bee3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="总结"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.im/post/6844904034281734151#heading-9">梳理 CSS 模块化 </a></li><li><a href="https://www.cnblogs.com/yy17yy/p/11618775.html">styled-component, emotion and jss 对比</a></li></ul><h1 id="10-CSS性能优化"><a href="#10-CSS性能优化" class="headerlink" title="10.CSS性能优化"></a>10.CSS性能优化</h1><h2 id="提高性能的方法有哪些"><a href="#提高性能的方法有哪些" class="headerlink" title="提高性能的方法有哪些?"></a>提高性能的方法有哪些?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 合并css文件，如果页面加载<span class="number">10</span>个css文件,每个文件1k，那么也要比只加载一个100k的css文件慢。</span><br><span class="line"><span class="number">2.</span> 减少css嵌套，最好不要嵌套三层以上。</span><br><span class="line"><span class="number">3.</span> 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能。</span><br><span class="line"><span class="number">4.</span> 建立公共样式类，把相同样式提取出来作为公共类使用。</span><br><span class="line"><span class="number">5.</span> 减少通配符*或者类似[hidden=<span class="string">&quot;true&quot;</span>]这类选择器的使用，挨个查找所有...这性能能好吗？</span><br><span class="line"><span class="number">6.</span> 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</span><br><span class="line"><span class="number">7.</span> 拆分出公共css文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独css文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</span><br><span class="line"><span class="number">8.</span> 不用css表达式，表达式只是让你的代码显得更加酷炫，但是对性能的浪费可能是超乎你想象的。</span><br><span class="line"><span class="number">9.</span> 少用css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择normolize.css。</span><br><span class="line"><span class="number">10.</span> cssSprite，合成所有icon图片，用宽高加上background-position的背景图方式显现icon图，这样很实用，减少了http请求。</span><br><span class="line"><span class="number">11.</span> 善后工作，css压缩(在线压缩工具 YUI Compressor)</span><br><span class="line"><span class="number">12.</span> GZIP压缩，是一种流行的文件压缩算法。</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote><p><strong>&gt; \</strong>1. 避免使用@import，外部的css文件中使用@import会使得页面在加载时增加额外的延迟。****</p></blockquote><p>首先，使用@import引入css会影响浏览器的并行下载。使用@import引用的css文件只有在引用它的那个css文件被下载，解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析，构建render tree等一系列操作，这就导致浏览器无法并行下载<br>所需的样式文件。<br>其次，多个@import会导致下载顺序紊乱，在IE中，@import会引发资源文件的下载顺序被打乱，即排列在@import后面的js文件优先于@import下载，并且打乱甚至破坏@import自身的并行下载。<br>所以不要使用这一方法，使用link标签就行了。</p><blockquote><p><strong>&gt; \</strong>2.避免过分重排****</p></blockquote><ul><li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow</li><li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，这个过程叫做reflow</li><li>页面上任何一个节点触发来reflow，会导致他的子节点和祖先节点重新渲染</li><li>导致reflow发生的情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1. 改变窗口的大小  </span><br><span class="line"> 2. 改变文字的大小</span><br><span class="line"> 3. 添加 删除样式表</span><br><span class="line"> 4. 内容的改变 输入框输入内容也会</span><br><span class="line"> 5. 伪类的激活</span><br><span class="line"> 6. 操作class属性</span><br><span class="line"> 7. 脚本操作dom js改变css类</span><br><span class="line"> 8. 计算offsetWidth和offsetHeight</span><br><span class="line"> 9. 设置style属性</span><br><span class="line"> 10.改变元素的内外边距 </span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure><ul><li>常见重排元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1. 大小有关的 width,height,padding,margin,border-width,border,min-height</span><br><span class="line"> 2. 布局有关的 display,top,position,<span class="built_in">float</span>,left,right,bottom</span><br><span class="line"> 3. 字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</span><br><span class="line"> 4. 隐藏有关的 overflow,overflow-x,overflow-y</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><ul><li>减少reflow对性能的影响的建议</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1. 不要一条条的修改dom的样式，预先定义好class，然后修改dom的classname</span><br><span class="line"> 2. 不要修改影响范围较大的dom</span><br><span class="line"> 3. 为动画元素使用绝对定位</span><br><span class="line"> 4. 不要table布局，因为一个很小的改动会造成整个table重新布局</span><br><span class="line"> 5. 避免设置大量的style属性，通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好使用class属性</span><br><span class="line"> 6. 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><blockquote><p><strong>&gt; \</strong>repaint****</p></blockquote><ol><li>当一个元素的外观被改变，但是布局没有改变的情况</li><li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li><li>常见的重绘元素</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - 颜色 color,background</span><br><span class="line"> - 边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</span><br><span class="line"> - 背景有关 background,backgound-image,background-position,background-repeat,background-size</span><br><span class="line">123</span><br></pre></td></tr></table></figure><blockquote><p><strong>&gt; CSS动画</strong></p></blockquote><ol><li>css动画启用GPU加速，应用GPU的图形性能对浏览器中的一些图形操作交给GPU完成。canvas2D，布局合成，css3转换，css3d变换，webGL，视频</li><li>2d加速</li><li>3d加速</li></ol><blockquote><p><strong>&gt; 文件压缩</strong></p></blockquote><p>性能优化时最容易想到的，也是最常见的方法，就是文件压缩，这一方案往往效果显著<br>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具webpack，gulp/grunt，rollup，压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><blockquote><p><strong>&gt; 去除无用CSS</strong></p></blockquote><p>虽然文件压缩能够降低文件大小，但css文件压缩通常只会去除无用的空格，这样就限制来css文件的压缩比例。如果压缩后的文件仍然超过来预期的大小，可以试着找到并删除代码中无用的css。<br>一般情况下，会存在这两种无用的CSS代码：</p><ol><li>不同元素或者其他情况下的重复代码，</li><li>整个页面内没有生效的CSS代码</li></ol><blockquote><p><strong>&gt; 有选择地使用选择器</strong></p></blockquote><p>css选择器的匹配是从右向左进行的，这一策略导致来不同种类的选择器之间的性能也存在差异。相比于 #markdown-content-h3,显然使用 #markdown.content h3时，浏览器生成渲染树所要花费的时间更多。因为后者需要先找到DOM中的所有h3元素，再过滤掉祖先元素不是.content的，最后过滤掉.content不是#markdown的。试想，页面中的元素更多，那么匹配所要花费的时间代价自然更高。<br>显得浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微，此外不同选择器在不同浏览器中的性能表现也不统一，在编写css的时候无法兼顾每种浏览器，鉴于这两点，在使用选择器时，尽量记住以下几点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1. 保持简单，不要使用嵌套过多过于复杂的选择器</span><br><span class="line"> 2. 通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</span><br><span class="line"> 3. 不要使用类选择器和ID选择器修饰元素标签，如：h3<span class="comment">#markdown-content，这一多此一举，还会降低效率</span></span><br><span class="line"> 4. 不要为了追求速度而放弃可读性和可维护性</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>TIPS：为什么css选择器是从右向左匹配的？<br>css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p><blockquote><p><strong>&gt; 减少使用昂贵的属性</strong></p></blockquote><p>在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价，而页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写css时，应该尽量减少使用昂贵属性，如:<br>box-shadow, border-radius, filter, 透明度, :nth-child等<br>当然并不是不要使用这些属性，这些都是经常使用的属性，只是这里可以作为一个了解。当有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p><blockquote><p><strong>&gt; 硬件加速的好坏</strong></p></blockquote><ol><li>仅仅依靠GPU还是不行的，许多动画还是需要CPU的介入，连接cpu和GPU的总带宽不是无限的，所以需要注意数据在cpu和GPU之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输。</li><li>一个重点是了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存。</li><li><code>**chrome://flags/#composited-layer-borders**</code>观察的地址。</li><li>每一个dom元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层</li><li>另一个重点是保持GPU和CPU之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给GPU。</li><li>因为为了高性能，动画开始之后避免层的更新也是非常重要的，避免动画进行中其他层一直更新导致拥堵。</li><li>也就是使用这些css属性来实现动画：transformation, opacity, filter</li><li>使用性能工具检测优化的合理性，timeline检测优化是否合理，还需要实现自动操作来做性能回归测试。</li><li>检测层数和层更新次数是非常有用的。</li></ol><h1 id="11-CSS中的层叠上下文和层叠顺序"><a href="#11-CSS中的层叠上下文和层叠顺序" class="headerlink" title="11.CSS中的层叠上下文和层叠顺序"></a>11.CSS中的层叠上下文和层叠顺序</h1><h3 id="零、世间的道理都是想通的"><a href="#零、世间的道理都是想通的" class="headerlink" title="零、世间的道理都是想通的"></a>零、世间的道理都是想通的</h3><p>在这个世界上，凡事都有个先后顺序，凡物都有个论资排辈。比方说食堂排队打饭，对吧，讲求先到先得，总不可能一拥而上。再比如说话语权，老婆的话永远是对的，领导的话永远是对的。</p><p>在CSS届，也是如此。只是，一般情况下，大家歌舞升平，看不出什么差异，即所谓的众生平等。但是，当发生冲突发生纠葛的时候，显然，是不可能做到完全等同的，先后顺序，身份差异就显现出来了。例如，杰克和罗斯，只能一人浮在木板上，此时，出现了冲突，结果大家都知道的。那对于CSS世界中的元素而言，所谓的“冲突”指什么呢，其中，很重要的一个层面就是“层叠显示冲突”。</p><p>默认情况下，网页内容是没有偏移角的垂直视觉呈现，当内容发生层叠的时候，一定会有一个前后的层叠顺序产生，有点类似于真实世界中论资排辈的感觉。</p><p>而要理解网页中元素是如何“论资排辈”的，就需要深入理解CSS中的层叠上下文和层叠顺序。</p><p>我们大家可能都熟悉CSS中的<code>z-index</code>属性，需要跟大家讲的是，<code>z-index</code>实际上只是CSS层叠上下文和层叠顺序中的一叶小舟。</p><h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p>这里出现了一个名词-<strong>z轴</strong>，指的是什么呢？</p><p>表示的是用户与屏幕的这条看不见的垂直线（参见下图示意-红线）：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/z-aris.png" alt="网页中z轴示意"></p><p>层叠上下文是一个概念，跟「<a href="http://www.zhangxinxu.com/wordpress/?p=4588">块状格式化上下文(BFC)</a>」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p><p>怎么个具象化法呢？</p><p>你可以<strong>把「层叠上下文」理解为当官</strong>：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p><p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p><p><img data-src="https://image.zhangxinxu.com/image/emtion/point.gif" alt="你懂的"></p><h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C/Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p><p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p><p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p><p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p><img data-src="https://image.zhangxinxu.com/image/emtion/point.gif" alt="你懂的"></p><p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p><h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的<strong>层叠上下文和层叠水平是概念</strong>，而这里的<strong>层叠顺序是规则</strong>。</p><p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_223349.png" alt="层叠顺序"></p><p>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。上面是我自己手动重绘的中文版同时补充很多其他地方绝对没有的重要知识信息。</p><p>缺失的关键信息包括：</p><ol><li>位于最低水平的<code>border</code>/<code>background</code>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li><li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li><li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。</li></ol><p>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？<br><img data-src="https://image.zhangxinxu.com/image/emtion/ask.gif" alt="疑问"><br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_235108.png" alt="层叠顺序元素的标注说明"></p><p>诸如<code>border</code>/<code>background</code>一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p><p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。例如，文字和浮动图片重叠的时候：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-07_235830.jpg" alt="浮动和文字重叠"></p><p>上面说的这些层叠顺序规则还是老时代的，如果把CSS3也牵扯进来。</p><h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p><ol><li><strong>谁大谁上：</strong>当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li><li><strong>后来居上：</strong>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p><h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）；</li><li>层叠上下文可以阻断元素的混合模式（见<a href="http://www.zhangxinxu.com/wordpress/?p=5155">此文第二部分说明</a>）；</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><p>翻译成真实世界语言就是：</p><ul><li>当官的比老百姓更有机会面见圣上；</li><li>领导下去考察，会被当地官员阻隔只看到繁荣看不到真实民情；</li><li>一个家里，爸爸可以当官，孩子也是可以同时当官的。但是，孩子这个官要受爸爸控制。</li><li>自己当官，兄弟不占光。有什么福利或者变故只会影响自己的孩子们。</li><li>每个当官的都有属于自己的小团体，当家眷管家发生摩擦磕碰的时候（包括和其他官员的家眷管家），都是要优先看当官的也就是主子的脸色。</li></ul><h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p><p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p><ol><li><strong>皇亲国戚</strong>派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li><li><strong>科考入选</strong>派：z-index值为数值的定位元素的传统层叠上下文。</li><li><strong>其他当官途径</strong>：其他CSS3属性。</li></ol><p>//zxx: 下面很多例子是实时CSS效果，建议您去<a href="http://www.zhangxinxu.com/wordpress/?p=5115">原地址浏览</a>，以便预览更准确的效果。</p><p><strong>①. 根层叠上下文</strong><br>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left</code>/<code>top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p><p><strong>②. 定位元素与传统层叠上下文</strong><br>对于包含有<code>position:relative</code>/<code>position:absolute</code>的定位元素，以及FireFox/IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p><p>知道了这一点，有些现象就好理解了。</p><p>如下HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:auto;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm2.jpg&quot; style&#x3D;&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p><p>下面，我们对父级简单调整下，把<code>z-index:auto</code>改成层叠水平一致的<code>z-index:0</code>, 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;position:absolute; z-index:2;&quot;&gt;    &lt;-- 横妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;position:relative; z-index:0;&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm2.jpg&quot; style&#x3D;&quot;position:relative; z-index:1;&quot;&gt;    &lt;-- 竖妹子 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p>大家会发现，尼玛反过来了，竖着的妹子(mm2)这回趴在了横着的妹子(mm1)身上。</p><p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循“<strong>谁大谁上</strong>”的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p><p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则“<strong>后来居上</strong>”，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p><p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6/IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6/IE7的<code>z-index</code>会搞死人的原因。</p><p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p><p><strong>③. CSS3与新时代的层叠上下文</strong><br>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/">对overflow隐藏对position:fixed定位的影响</a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p><p>如下：</p><ol><li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li><li>元素的<code>opacity</code>值不是<code>1</code>.</li><li>元素的<code>transform</code>值不是<code>none</code>.</li><li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li><li>元素的<code>filter</code>值不是<code>none</code>.</li><li>元素的<code>isolation</code>值是<code>isolate</code>.</li><li><code>will-change</code>指定的属性值为上面任意一个。</li><li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li></ol><p>基本上每一项都有很多槽点。</p><p><strong>1. display:flex|inline-flex与层叠上下文</strong><br>注意，这里的规则有些<del>负责</del>复杂。要满足两个条件才能形成层叠上下文：条件1是父级需要是<code>display:flex</code>或者<code>display:inline-flex</code>水平，条件2是子元素的z-index不是<code>auto</code>，必须是数值。此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是flex父级元素。</p><p>眼见为实，给大家上例子吧。</p><p>如下HTML和CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.box &#123;  &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    &#x2F;* 此时该div是普通元素，z-index无效 *&#x2F;</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     &#x2F;* 注意这里是负值z-index *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，妹子跑到蓝色背景的下面了。为什么呢？层叠顺序图可以找到答案，如下：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-08_235511.png" alt="负值z-index的层叠顺序"></p><p>从上图可以看出负值z-index的层叠顺序在block水平元素的下面，而蓝色背景<code>div</code>元素是个普通元素，因此，妹子直接穿越过去，在蓝色背景后面的显示了。</p><p>现在，我们CSS微调下，增加<code>display:flex</code>, 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; display: flex; &#125;</span><br><span class="line">.box &gt; div &#123; background-color: blue; z-index: 1; &#125;    &#x2F;* 此时该div是层叠上下文元素，同时z-index生效 *&#x2F;</span><br><span class="line">.box &gt; div &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;     &#x2F;* 注意这里是负值z-index *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，妹子在蓝色背景上面显示了，为什么呢？层叠顺序图可以找到答案，如下：<br><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-08_235217.png" alt="img"></p><p>从上图可以看出负值<code>z-index</code>的层叠顺序在当前第一个父层叠上下文元素的上面，而此时，那个<code>z-index</code>值为<code>1</code>的蓝色背景<code>&lt;div&gt;</code>的父元素的<code>display</code>值是<code>flex</code>，一下子升官发财变成层叠上下文元素了，于是，图片在蓝色背景上面显示了。这个现象也证实了层叠上下文元素是<code>flex</code>子元素，而不是<code>flex</code>容器元素。</p><p>另外，另外，这个例子也颠覆了我们传统的对<code>z-index</code>的理解。在CSS2.1时代，<code>z-index</code>属性必须和定位元素一起使用才有作用，但是，在CSS3的世界里，非定位元素也能和<code>z-index</code>愉快地搞基。</p><p><strong>2. opacity与层叠上下文</strong><br>我们直接看代码，原理和上面例子一样，就不解释了。</p><p>如下HTML和CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.box &#123; background-color: blue;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>然后价格透明度，例如50%透明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; opacity: 0.5;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>原因就是半透明元素具有层叠上下文，妹子图片的<code>z-index:-1</code>无法穿透，于是，在蓝色背景上面乖乖显示了。</p><p><strong>3. transform与层叠上下文</strong><br>应用了<a href="http://www.zhangxinxu.com/wordpress/2010/11/css3-transitions-transforms-animation-introduction/">transform变换</a>的元素同样具有菜单上下文。</p><p>我们直接看应用后的结果，如下CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; transform: rotate(15deg);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>妹子同样在蓝色背景之上。</p><p><strong>4. mix-blend-mode与层叠上下文</strong><br><code>mix-blend-mode</code>类似于PS中的混合模式，之前专门有文章介绍-“<a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/">CSS3混合模式mix-blend-mode简介</a>”。</p><p>元素和白色背景混合。无论哪种模式，要么全白，要么没有任何变化。为了让大家有直观感受，因此，下面例子我特意加了个原创平铺背景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; mix-blend-mode: darken;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>需要注意的是，目前，IE浏览器(包括IE14)还不支持<code>mix-blend-mode</code>，因此，要想看到妹子在背景色之上，请使用Chrome或FireFox。</p><p>同样的，因为蓝色背景元素升级成了层叠上下文，因此，<code>z-index:-1</code>无法穿透，在蓝色背景上显示了。</p><p><strong>5. filter与层叠上下文</strong><br>此处说的<code>filter</code>是CSS3中规范的滤镜，不是旧IE时代私有的那些，虽然目的类似。同样的，我之前有提过，例如<a href="http://www.zhangxinxu.com/wordpress/2012/08/css-svg-filter-image-grayscale/">图片的灰度</a>或者<a href="http://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/">图片的毛玻璃效果</a>等。</p><p>我们使用常见的模糊效果示意下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; filter: blur(5px);  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>好吧，果然被你猜对了，妹子蓝色床上躺着，只是你眼镜摘了，看得有些不够真切罢了。</p><p><strong>6. isolation:isolate与层叠上下文</strong><br><code>isolation:isolate</code>这个声明是<code>mix-blend-mode</code>应运而生的。默认情况下，<code>mix-blend-mode</code>会混合z轴所有层叠在下面的元素，要是我们不希望某个层叠的元素参与混合怎么办呢？就是使用<code>isolation:isolate</code>。由于一言难尽，我特意为此写了篇文章：“<a href="http://www.zhangxinxu.com/wordpress/?p=5155">理解CSS3 isolation: isolate的表现和作用</a>”，解释了其阻隔混合模式的原理，建议大家看下。</p><p>要演示这个效果，我需要重新设计下，如下HTML结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;img&#x2F;mm2.jpg&quot; class&#x3D;&quot;mode&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;mm1.jpg&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>CSS主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  &#x2F;* 竖妹子绝对定位，同时混合模式 *&#x2F;</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，横妹子被混合模式了。此时，我们给妹子所在容器增加<code>isolation:isolate</code>，如下CSS所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.mode &#123;</span><br><span class="line">  &#x2F;* 竖妹子绝对定位，同时混合模式 *&#x2F;</span><br><span class="line">  position: absolute; mix-blend-mode: darken;</span><br><span class="line">&#125;    </span><br><span class="line">.box &#123;</span><br><span class="line">  background: blue; isolation:isolate;         </span><br><span class="line">&#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现横着的妹子跑到蓝色背景上面了。这表明确实创建了层叠上下文。</p><p><strong>7. will-change与层叠上下文</strong><br>关于<code>will-change</code>，如果有同学还不了解，可以参见我之前写的文章：“<a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/">使用CSS3 will-change提高页面滚动、动画等渲染性能</a>”。</p><p>都是类似的演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; background-color: blue; will-change: transform;  &#125;</span><br><span class="line">.box &gt; img &#123; </span><br><span class="line">  position: relative; z-index: -1; right: -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>果然不出所料，妹子上了蓝色的背景。</p><h3 id="七、层叠上下文与层叠顺序"><a href="#七、层叠上下文与层叠顺序" class="headerlink" title="七、层叠上下文与层叠顺序"></a>七、层叠上下文与层叠顺序</h3><p>本文多次提到，一旦普通元素具有了层叠上下文，其层叠顺序就会变高。那它的层叠顺序究竟在哪个位置呢？</p><p>这里需要分两种情况讨论：</p><ol><li>如果层叠上下文元素不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>可看成<code>z:index:0</code>级别；</li><li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li></ol><p>于是乎，我们上面提供的层叠顺序表，实际上还是缺少其他重要信息。我又花功夫重新绘制了一个更完整的7阶层叠顺序图（同样的版权所有，商业请购买，可得无水印大图）：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201601/2016-01-09_211116.png" alt="更完整的7阶层叠顺序图"></p><p>大家知道为什么定位元素会层叠在普通元素的上面吗？</p><p>其根本原因就在于，元素一旦成为定位元素，其<code>z-index</code>就会自动生效，此时其<code>z-index</code>就是默认的<code>auto</code>，也就是<code>0</code>级别，根据上面的层叠顺序表，就会覆盖<code>inline</code>或<code>block</code>或<code>float</code>元素。</p><p>而不支持z-index的层叠上下文元素天然<code>z-index:auto</code>级别，也就意味着，层叠上下文元素和定位元素是一个层叠顺序的，于是当他们发生层叠的时候，遵循的是“后来居上”准则。</p><p>我们可以速度测试下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;mm1&quot; style&#x3D;&quot;position:relative&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm2&quot; style&#x3D;&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm2&quot; style&#x3D;&quot;transform:scale(1);&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;mm1&quot; style&#x3D;&quot;position:relative&quot;&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><br><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm2.jpg" alt="img"><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p>会发现，两者样式一模一样，仅仅是在DOM流中的位置不一样，导致他们的层叠表现不一样，后面的妹子趴在了前面妹子的身上。这也说明了，层叠上下文元素的层叠顺序就是<code>z-index:auto</code>级别。</p><p><strong>z-index值与层叠顺序</strong><br>如果元素支持z-index值，则层叠顺序就要好理解些了，比较数值大小嘛，小盆友都会，本质上是应用的“谁大谁上”的准则。在以前，我们只需要关心定位元素的z-index就好，但是，在CSS3时代，flex子项也支持<code>z-index</code>，使得我们面对的情况比以前要负复杂。然而，好的是，规则都是一样的，对于<code>z-index</code>的使用和表现也是如此，套用上面的7阶层叠顺序表就可以了。</p><p>同样，举个简单例子，看下<code>z-index:-1</code>和<code>z-index:1</code>变化对层叠表现的影响，如下两段HTML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;z-index:-1;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;display:flex; background:blue;&quot;&gt;</span><br><span class="line">   &lt;img src&#x3D;&quot;mm1.jpg&quot; style&#x3D;&quot;z-index:1;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最后，会发现，<code>z-index:-1</code>跑到了背景色小面，而<code>z-index:1</code>高高在上。</p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><img data-src="https://image.zhangxinxu.com/image/study/s/s256/mm1.jpg" alt="img"></p><p><strong>一个与层叠上下文相关的有趣的显示现象</strong><br>在实际项目中，我们可能会渐进使用CSS3的fadeIn淡入animation效果增强体验，于是，我们可能就会遇到类似下面的现象：</p><p>您可以狠狠地点击这里：<a href="http://www.zhangxinxu.com/study/201601/css3-fadein-animation-stacking-context.html">CSS3 fadeIn淡入animation动画有趣现象</a></p><p>有一个绝对定位的黑色半透明层覆盖在图片上，默认显示是这样的：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201801/2018-01-09_004641.png" alt="文字在妹子上"></p><p>但是，一旦图片开始走fadeIn淡出的CSS3动画，文字跑到图片后面去了<img data-src="https://mat1.gtimg.com/www/mb/images/face/36.gif" alt="img">：</p><p><img data-src="https://image.zhangxinxu.com/image/blog/201801/2018-01-09_004654.png" alt="文字跑到图片后面"></p><p>为什么会这样？</p><p>实际上，学了本文的内容，就很简单了！fadeIn动画本质是<code>opacity</code>透明度的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes fadeIn &#123;</span><br><span class="line">  0% &#123; </span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要知道，<code>opacity</code>的值不是<code>1</code>的时候，是具有层叠上下文的，层叠顺序是<code>z-index:auto</code>级别，跟没有<code>z-index</code>值的<code>absolute</code>绝对定位元素是平起平坐的。而本demo中的文字元素在图片元素的前面，于是，当CSS3动画只要不是最终一瞬间的<code>opacity: 1</code>，位于DOM流后面的图片就会遵循“后来居上”准则，覆盖文字。</p><p>这就是原因，于是，我们想要解决这个问题就很简单。</p><ol><li>调整DOM流的先后顺序；</li><li>提高文字的层叠顺序，例如，设置<code>z-index:1</code>;</li></ol><h3 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p><p>我发现很多重构小伙伴都有z-index滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p><p>实际上，在我看来，觉得多数常见，z-index根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6/IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p><p>OK，本文已经够长了，就不多啰嗦了。</p><p>行为匆忙，出错在所难免，欢迎大力指正。也欢迎各种形式的交流，或者指出文中概念性的错误。</p><p>感谢阅读！</p><h1 id="12-div居中"><a href="#12-div居中" class="headerlink" title="12.div居中"></a>12.div居中</h1><h2 id="使div水平垂直居中"><a href="#使div水平垂直居中" class="headerlink" title="使div水平垂直居中"></a>使div水平垂直居中</h2><h3 id="1-flex-布局实现-（元素已知宽度）"><a href="#1-flex-布局实现-（元素已知宽度）" class="headerlink" title="1. flex 布局实现 （元素已知宽度）"></a>1. flex 布局实现 （元素已知宽度）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1eccc17f7ff91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>内部 div 要有宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码:</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;           </span><br><span class="line">        background-color: #ccc;            </span><br><span class="line">        display: flex;            </span><br><span class="line">        display: -webkit-flex;            </span><br><span class="line">        justify-content: center;            </span><br><span class="line">        align-items: center;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="2-position-（元素已知宽度）"><a href="#2-position-（元素已知宽度）" class="headerlink" title="2. position （元素已知宽度）"></a>2. position （元素已知宽度）</h3><p>​            父元素设置为：position: relative;</p><p>​            子元素设置为：position: absolute;</p><p>​            距上50%，据左50%，然后减去元素自身宽度的一半距离就可以实现</p><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ecd08d952a7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CSS代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        left: 50%;            </span><br><span class="line">        top: 50%;            </span><br><span class="line">        margin: -50px 0 0 -50px;        </span><br><span class="line">    &#125;    </span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="3-position-transform-（元素未知宽度）"><a href="#3-position-transform-（元素未知宽度）" class="headerlink" title="3. position transform （元素未知宽度）"></a>3. position transform （元素未知宽度）</h3><p>如果元素未知宽度，只需将上面例子中的<code> margin: -50px 0 0 -50px;</code>替换为：**<code>transform: translate(-50%,-50%);</code>**</p><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ecf67eb4c5a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        top: 50%;            </span><br><span class="line">        left: 50%;            </span><br><span class="line">        transform: translate(-50%, -50%);        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="4-position（元素已知宽度）（left，right，top，bottom为0，maigin：auto-）"><a href="#4-position（元素已知宽度）（left，right，top，bottom为0，maigin：auto-）" class="headerlink" title="4. position（元素已知宽度）（left，right，top，bottom为0，maigin：auto ）"></a>4. position（元素已知宽度）（left，right，top，bottom为0，maigin：auto ）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ed33c6187453?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;           </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        top: 0;            </span><br><span class="line">        bottom: 0;            </span><br><span class="line">        left: 0;            </span><br><span class="line">        right: 0;            </span><br><span class="line">        margin: auto;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line"> &lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"><a href="#★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）" class="headerlink" title="★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"></a>★第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ed5caebd6979?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        position: relative;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        &#x2F;* 如果不设置宽高，将铺满整个父级*&#x2F;            </span><br><span class="line">        background-color: pink;            </span><br><span class="line">        position: absolute;            </span><br><span class="line">        left: 0;            </span><br><span class="line">        right: 0;            </span><br><span class="line">        top: 0;            </span><br><span class="line">        bottom: 0;            </span><br><span class="line">        margin: auto;            </span><br><span class="line">        text-align: center;                    </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML:</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="5-table-cell-布局实现"><a href="#5-table-cell-布局实现" class="headerlink" title="5. table-cell 布局实现"></a>5. table-cell 布局实现</h3><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        vertical-align: middle;                    </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        margin-left: 100px;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;         </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="使内容（文字，图片）水平垂直居中（table-cell-布局）"><a href="#使内容（文字，图片）水平垂直居中（table-cell-布局）" class="headerlink" title="使内容（文字，图片）水平垂直居中（table-cell 布局）"></a>使内容（文字，图片）水平垂直居中（table-cell 布局）</h2><p>行元素 text-align ：center；</p><p>块元素 ：margin ：0 auto；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-align : center  给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中</span><br><span class="line">line-height : 值为元素的高度，可以使元素的文本内容垂直居中</span><br><span class="line">margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级）</span><br></pre></td></tr></table></figure><p><code>display：table-cell </code>会使元素表现的类似一个表格中的单元格td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对margin值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。</p><p>小结： </p><ol><li><p>不要与 float：left， position : absolute， 一起使用 </p></li><li><p>可以实现大小不固定元素的垂直居中 </p></li><li><p>margin 设置无效，响应 padding 设置 </p></li><li><p>对高度和宽度高度敏感 </p></li><li><p>不要对 display：table-cell 使用百分比设置宽度和高度</p></li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><h3 id="1-使文字水平垂直居中"><a href="#1-使文字水平垂直居中" class="headerlink" title="1. 使文字水平垂直居中"></a>1. 使文字水平垂直居中</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1ee843df854e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        text-align: center;&#x2F;*使元素水平居中 *&#x2F;            </span><br><span class="line">        vertical-align: middle;&#x2F;*使元素垂直居中 *&#x2F;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;love&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>给父级设置 display : table，子集设置 display：tablecell ，子集会充满全屏</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1eed995e17eef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: red;            </span><br><span class="line">        display: table;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box .a&#123;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        vertical-align: middle;            </span><br><span class="line">        text-align: center;            </span><br><span class="line">        background-color: blue;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML ：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="2-图片水平垂直居中"><a href="#2-图片水平垂直居中" class="headerlink" title="2. 图片水平垂直居中"></a>2. 图片水平垂直居中</h3><p>效果图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f0a0dfeb3002?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        width: 300px;            </span><br><span class="line">        height: 300px;            </span><br><span class="line">        background-color: skyblue;            </span><br><span class="line">        display: table-cell;            </span><br><span class="line">        text-align: center;            </span><br><span class="line">        vertical-align: middle;        </span><br><span class="line">    &#125;        </span><br><span class="line">    img&#123;            </span><br><span class="line">        &#x2F;* 设置成块元素后，text-align：center 就会失效 *&#x2F;            </span><br><span class="line">        width: 100px;            </span><br><span class="line">        height: 100px;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;    </span><br><span class="line">    &lt;img src&#x3D;&quot;1.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>中间的图片会随着外层容器的大小而自动水平垂直居中，其实原理和文字水平垂直居中一模一样</p><h3 id="3-元素两端垂直对齐"><a href="#3-元素两端垂直对齐" class="headerlink" title="3. 元素两端垂直对齐"></a>3. 元素两端垂直对齐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;        </span><br><span class="line">    *&#123;            </span><br><span class="line">        padding: 0;            </span><br><span class="line">        margin: 0;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .box&#123;            </span><br><span class="line">        display: table;            </span><br><span class="line">        width: 90%;            </span><br><span class="line">        margin: 10px  auto;            </span><br><span class="line">        padding: 10px;             </span><br><span class="line">        border: 1px solid green;            </span><br><span class="line">        height: 100px;        </span><br><span class="line">    &#125;        </span><br><span class="line">    .left,.right&#123;            </span><br><span class="line">        display: table-cell;                        </span><br><span class="line">        width: 20%;            </span><br><span class="line">        border: 1px solid red;                 </span><br><span class="line">    &#125;        </span><br><span class="line">    .center&#123;            </span><br><span class="line">        &#x2F;* padding-top: 10px; *&#x2F;            </span><br><span class="line">        height: 100px;            </span><br><span class="line">        background-color: green;        </span><br><span class="line">    &#125;    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是左边&lt;&#x2F;p&gt;        </span><br><span class="line">    &lt;&#x2F;div&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;center&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是中间&lt;&#x2F;p&gt;       </span><br><span class="line">    &lt;&#x2F;div&gt;        </span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;            </span><br><span class="line">        &lt;p&gt;我是右边&lt;&#x2F;p&gt;        </span><br><span class="line">    &lt;&#x2F;div&gt;    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>效果：<img data-src="https://user-gold-cdn.xitu.io/2019/4/15/16a1f1e596191dfa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中 center 的顶部没有与左右两侧对齐，原因是 left 中的 <p> 有一个 margin-top ， 而表格布局中默认是文字顶部对齐的，所以 center 会向下移动到首行文字基线对齐，解决办法是为 center 添加与左右两侧中 margin-top 较大者等值的 padding-top 即可。 </p><h1 id="13-CSS浮动"><a href="#13-CSS浮动" class="headerlink" title="13.CSS浮动"></a>13.<a href="https://segmentfault.com/a/1190000012739764">CSS浮动</a></h1><p>页面布局是CSS的一个重点应用，例如：<br><img data-src="https://segmentfault.com/img/bVuVFG" alt="图片描述"></p><p>而实现页面布局主要应用到两种方法，一种是<strong>CSS浮动</strong>，一种是<strong>Flexbox</strong>（IE9以上），本文主要讲的是CSS浮动，下一篇文章将阐述Flexbox。</p><h2 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h2><p><strong>什么是浮动元素：</strong>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。</p><blockquote><p><strong>常规流：</strong>页面上从左往右，从上往下排列的元素流，就是常规流<br><strong>脱离常规流：</strong>绝对定位，fixed定位的元素有自己固定的位置，脱离了常规流<br><strong>包含块：</strong>一个元素离它最近的块级元素是它的包含块</p></blockquote><p>下面详细描述以上的内容，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.border &#123;</span><br><span class="line">  border: 2px solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.common-div &#123;</span><br><span class="line">  width: 160px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float-red &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #fcc;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float-blue &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #09c;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;border&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;float-red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;common-div&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;float-blue&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码显示的样子如下：<br><img data-src="https://segmentfault.com/img/bV1Cjj?w=1482&h=394" alt="图片描述"></p><ul><li>块级元素认为浮动元素不存在：红色的块级元素没有受到粉色浮动元素的影响，还展示在左上角的位置，但是被粉色元素盖住了左边的部分</li><li>浮动元素会影响行内元素：文字部分被蓝色浮动元素影响，空出了蓝色浮动元素的部分</li><li>浮动元素会间接影响了包含块的布局：浮动元素影响了文字部分吗，使之多出了一行，文字部分撑高了最外面的border框，所以间接影响了包含块的布局。</li></ul><p>其中，<strong>浮动元素的摆放</strong>会遵循如下的规则：</p><ul><li>尽量靠上</li><li>尽量靠左</li><li>尽量一个挨着一个</li><li>不能超出包含块，除非元素比包含块更宽</li><li>不能超过所在行的最高点</li><li>不能超过它前面浮动元素的最高点</li><li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>浮动元素并不能撑起包含块，这和我们的预期并不相符。通过以下的办法可以将包含块撑开，称之为<strong>闭合浮动</strong></p></blockquote><p><img data-src="https://segmentfault.com/img/bV1CkU?w=798&h=248" alt="图片描述"><br><img data-src="https://segmentfault.com/img/bV1Ck1?w=802&h=248" alt="图片描述"></p><h3 id="闭合浮动的方法："><a href="#闭合浮动的方法：" class="headerlink" title="闭合浮动的方法："></a>闭合浮动的方法：</h3><ul><li><strong>BFC:</strong> 1) 包含块设置overflow:hidden 或者 2)包含块设置display:table-cell/table/flex…</li></ul><blockquote><p><strong>BFC：块级格式化上下文。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。</strong><br>只要<strong>符合以下的条件就是BFC:</strong></p><ol><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol></blockquote><p>相应的背景文档可以参阅：<a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">《BFC的神奇原理》</a></p><ul><li><strong>伪元素</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">    content: &#39;&#39;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>clear:both;意味着块级元素的左边和右边都不能有浮动元素。在包含块的末尾建立了一个内容为空的伪元素，并设置clear:both，使这个元素位于所有的浮动元素之后，从而撑开了包含块的高。</p></blockquote><ul><li><strong>包含块自己也浮动</strong></li></ul><p>这个方法也是w3c使用的方法。不过，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记。</p><p>相应的背景文档：<a href="http://www.w3school.com.cn/css/css_positioning_floating.asp">《W3C CSS浮动》</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CSS" scheme="https://hxy1997.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-04T11:14:39.000Z</published>
    <updated>2021-03-27T13:15:27.189Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。</p><span id="more"></span><h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章主要介绍进程与线程的区别与联系相关知识点，也是我们面试过程中，经常会问到的一个问题。希望通过这篇文章，能让大家理解相关知识点~</p><p>涉及面试题：</p><ul><li>1.进程与线程之间有什么区别？</li><li>2.进程、线程都各有什么特点？</li><li>3.进程之间的是怎么进行交互的呢？</li><li>4.什么是缓冲区溢出？</li><li>5.进程之间如何进行交互？</li><li>6.线程之间如何进行交互？</li></ul><blockquote><p>上面的面试题可以看出，其实都是一回事，只是换了一种提问方式，只要我们能掌握核心要点，随便面试官怎么提问，我们都能轻松应对！</p></blockquote><h2 id="1-小例子："><a href="#1-小例子：" class="headerlink" title="1. 小例子："></a>1. 小例子：</h2><blockquote><p>我们生活中有许许多多关于进程与线程的小例子，比如：1.我们使用打开一个微信软件，这个时候就开启了一个进程，<br>当我们在微信里面进行各种操作（查看朋友圈，扫一扫…），这么多的操作就是线程。<br>所以我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。</p></blockquote><blockquote><p><strong>来源百度百科：</strong></p></blockquote><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><blockquote><p>我们简单总结下：</p></blockquote><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p><h2 id="2-深入理解："><a href="#2-深入理解：" class="headerlink" title="2. 深入理解："></a>2. 深入理解：</h2><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3bb5683b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-1-进程-线程-内存-文件-网络句柄"><a href="#2-1-进程-线程-内存-文件-网络句柄" class="headerlink" title="2.1 进程(线程+内存+文件/网络句柄)"></a>2.1 进程(线程+内存+文件/网络句柄)</h3><p>我们通过上面的图片进行进一步理解：</p><p><strong>“内存”：</strong> 我们通常所理解的内存是我们所见到的(2G/4G/8G/16G)物理内存,它为什么会在进程之中呢？ 实际上，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。 否则的话会出现一个问题：我们把指针的值改一改就指向其他进程的内存了，通过这样我们岂不是就可以看到其他进程中”微信”或者是”网上银行”的信息， 这样的话，那我们的微信聊天记录或者是银行账户的信息就都被别人找到了，这是一个很危险的信号！显然这样是不可能的。</p><p><strong>“文件/网络句柄”：</strong> 它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。</p><p><strong>“线程”：</strong> 接下来，我们就要介绍一下我们的“线程”有关知识</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3ba97f25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-2-线程-栈-PC-TLS"><a href="#2-2-线程-栈-PC-TLS" class="headerlink" title="2.2 线程(栈+PC+TLS)"></a>2.2 线程(栈+PC+TLS)</h3><h4 id="2-2-1-栈"><a href="#2-2-1-栈" class="headerlink" title="2.2.1 栈:"></a>2.2.1 栈:</h4><p>我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。 那么我们的栈里面有什么呢？ 我们从主线程的入口main函数，会不断的进行函数调用， 每次调用的时候，会把所有的参数和返回地址压入到栈中。</p><h4 id="2-2-2-PC："><a href="#2-2-2-PC：" class="headerlink" title="2.2.2 PC："></a>2.2.2 PC：</h4><p>Program Counter 程序计数器，操作系统真正运行的是一个个的线程， 而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。 计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的 这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。</p><h5 id="2-2-2-1-缓冲区溢出"><a href="#2-2-2-1-缓冲区溢出" class="headerlink" title="2.2.2.1 缓冲区溢出"></a>2.2.2.1 缓冲区溢出</h5><p>例如我们经常听到一个漏洞：<strong>缓冲区溢出</strong> 这是什么意思呢？ 例如：我们有个地方要输入用户名，本来是用来存数据的地方。 然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了 我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码 写入到用户名框中，来植入进来。我们的解决方法就是，用用户名的长度来限制不要超过 用户名的缓冲区的大小来解决。</p><h4 id="2-3-TLS"><a href="#2-3-TLS" class="headerlink" title="2.3 TLS:"></a>2.3 TLS:</h4><p>全称：thread local storage 之前我们看到每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢?答案是有的，就是TLS。 可以用来存储我们线程所独有的数据。 可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p><h3 id="3-小结："><a href="#3-小结：" class="headerlink" title="3.小结："></a>3.小结：</h3><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了. 2.一个程序至少有一个进程,一个进程至少有一个线程. 3.进程是资源分配的最小单位，线程是程序执行的最小单位。 4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.</p><h1 id="2-进程间通信"><a href="#2-进程间通信" class="headerlink" title="2.进程间通信"></a>2.进程间通信</h1><h2 id="一、进程间通信的概念"><a href="#一、进程间通信的概念" class="headerlink" title="一、进程间通信的概念"></a>一、进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="img"></p><p>进程间通信模型</p><h2 id="二、进程间通信的7种方式"><a href="#二、进程间通信的7种方式" class="headerlink" title="二、进程间通信的7种方式"></a>二、进程间通信的7种方式</h2><p><strong>第一类：传统的Unix通信机制</strong><br> <strong>1. 管道/匿名管道(pipe)</strong></p><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt="img"></p><p>进程间管道通信模型</p></li></ul><p><strong>管道的实质：</strong><br> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><p><strong>2. 有名管道(FIFO)</strong><br> 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><p><strong>3. 信号(Signal)</strong></p><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-3eed8cca67aa9f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p><p>信号的生命周期</p><p><strong>4. 消息(Message)队列</strong></p><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649">延伸阅读：消息队列C语言的实践</a></li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><p><strong>5. 共享内存(share memory)</strong></p><ul><li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p></li><li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="img"></p><p>共享内存原理图</p></li></ul><p><strong>6. 信号量(semaphore)</strong><br> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br> （3）<strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</p><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com/?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp" alt="img"></p><p>两个进程使用一个二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="img"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284/format/webp" alt="img"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><p><strong>7. 套接字(socket)</strong><br> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/319/format/webp" alt="img"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> 原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p></blockquote><p><strong>套接字通信的建立</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2575b81bbab6b67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/437/format/webp" alt="img"></p><p>Socket通信基本流程</p><p><strong>服务器端</strong><br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。<br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。<br> <a href="https://link.jianshu.com/?t=http://developer.51cto.com/art/201509/490775.htm">延伸阅读 ：Java socket编程</a></p><h2 id="三、参考引用"><a href="#三、参考引用" class="headerlink" title="三、参考引用"></a>三、参考引用</h2><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">1. 进程间通信–管道 </a><br> <a href="https://link.jianshu.com/?t=http://blog.csdn.net/ljianhui/article/details/10253345">2. Linux进程间通信——使用共享内存</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3230564.html">3. 进程间通信—共享内存</a><br> <a href="https://link.jianshu.com/?t=http://www.cnblogs.com/diyingyun/archive/2011/12/04/2275229.html">4. 信号量与互斥锁</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-23193900-id-3194924.html">5. 信号量</a></p><h1 id="3-进程调度策略"><a href="#3-进程调度策略" class="headerlink" title="3.进程调度策略"></a>3.进程调度策略</h1><h2 id="1-先来先服务调度算法："><a href="#1-先来先服务调度算法：" class="headerlink" title="1.先来先服务调度算法："></a>1.先来先服务调度算法：</h2><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h2 id="2-短作业-进程-优先调度算法："><a href="#2-短作业-进程-优先调度算法：" class="headerlink" title="2.短作业(进程)优先调度算法："></a>2.短作业(进程)优先调度算法：</h2><p>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h2 id="3-高优先权优先调度算法："><a href="#3-高优先权优先调度算法：" class="headerlink" title="3.高优先权优先调度算法："></a>3.高优先权优先调度算法：</h2><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><h3 id="3-1-非抢占式优先权算法："><a href="#3-1-非抢占式优先权算法：" class="headerlink" title="3.1) 非抢占式优先权算法："></a>3.1) 非抢占式优先权算法：</h3><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><h3 id="3-2-抢占式优先权调度算法："><a href="#3-2-抢占式优先权调度算法：" class="headerlink" title="3.2) 抢占式优先权调度算法："></a>3.2) 抢占式优先权调度算法：</h3><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><h3 id="3-3-容易出现优先级倒置现象："><a href="#3-3-容易出现优先级倒置现象：" class="headerlink" title="3.3)容易出现优先级倒置现象："></a>3.3)容易出现优先级倒置现象：</h3><p>优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p><h3 id="3-4-优先级反转案例解释："><a href="#3-4-优先级反转案例解释：" class="headerlink" title="3.4)优先级反转案例解释："></a>3.4)优先级反转案例解释：</h3><p>不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。</p><h3 id="3-5-优先级倒置解决方案："><a href="#3-5-优先级倒置解决方案：" class="headerlink" title="3.5)优先级倒置解决方案："></a>3.5)优先级倒置解决方案：</h3><p>​       (3.5.1）设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。<br>​     （3.5.2）优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。<br>​       这里还有一个八卦，1997年的美国的火星探测器（使用的就是vxworks)就遇到一个优先级反转问题引起的故障。简单说下，火星探测器有一个信息总线，有一个高优先级的总线任务负责总线数据的存取，访问总线都需要通过一个互斥锁（共享资源出现了）；还有一个低优先级的，运行不是很频繁的气象搜集任务，它需要对总线写数据，也就同样需要访问互斥锁；最后还有一个中优先级的通信任务，它的运行时间比较长。平常这个系统运行毫无问题，但是有一天，在气象任务获得互斥锁往总线写数据的时候，一个中断发生导致通信任务被调度就绪，通信任务抢占了低优先级的气象任务，而无巧不成书的是，此时高优先级的总线任务正在等待气象任务写完数据归还互斥锁，但是由于通信任务抢占了CPU并且运行时间比较长，导致气象任务得不到CPU时间也无法释放互斥锁，本来是高优先级的总线任务也无法执行，总线任务无法及时执行的后果被探路者认为是一个严重错误，最后就是整个系统被重启。Vxworks允许优先级继承，然而遗憾的工程师们将这个选项关闭了。<br>​     （3.5.3）第三种方法就是临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</p><h2 id="4、高响应比优先调度算法："><a href="#4、高响应比优先调度算法：" class="headerlink" title="4、高响应比优先调度算法："></a>4、高响应比优先调度算法：</h2><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p><img data-src="https://img-blog.csdn.net/20180922085248936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>   在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h2 id="5、时间片轮转法："><a href="#5、时间片轮转法：" class="headerlink" title="5、时间片轮转法："></a>5、时间片轮转法：</h2><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p><h2 id="6、多级反馈队列调度算法："><a href="#6、多级反馈队列调度算法：" class="headerlink" title="6、多级反馈队列调度算法："></a>6、多级反馈队列调度算法：</h2><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p><p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p><p>(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p><p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p><p><img data-src="https://img-blog.csdn.net/20180922085249110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？<br>批处理系统常用调度算法：<br>①、先来先服务：FCFS<br>②、最短作业优先<br>③、最短剩余时间优先<br>④、响应比最高者优先</p><p>分时系统调度算法：<br>①、轮转调度<br>②、优先级调度<br>③、多级队列调度<br>④、彩票调度</p><p>实时系统调度算法：<br>①、单比率调度<br>②、限期调度<br>③、最少裕度法</p><h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h1><p>死锁是什么，以及在并发程序中如何避免死锁一直是面试官偏爱的一个问题。<br> 本文尽量以最简洁的示例来帮助你快速理解，掌握死锁发生的原因及其解决方法。在阅读接下来的内容之前，你必须具备java中独占锁与线程之间通信的基本知识。</p><p><strong>死锁</strong><br> 当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p>下面用一个非常简单的死锁示例来帮助你理解死锁的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取String.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">线程b尝试获取String.class</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">无限阻塞下去</span><br></pre></td></tr></table></figure><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>教科书般的回答应该是，结合“哲学家就餐”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p><p>造成死锁必须达成的4个条件（原因）：</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p><ol><li>互斥条件 —&gt; 独占锁的特点之一。</li><li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li><li>不剥夺条件 —&gt; 独占锁的特点之一。</li><li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li></ol><p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p><p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p><p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是否能够简单明了的在面试中阐述清楚死锁产生的原因，并给出解决死锁的方案，可以体现程序员在面对对并发问题时思路是否清晰，对并发的基础掌握是否牢固等等。<br> 而且在实际项目中并发模块的逻辑往往比本文的示例复杂许多，所以写并发应用之前一定要充分理解本文所总结的要点，并切记，并发程序编程在不显著影响程序性能的情况下，一定要尽可能的保守。</p><h1 id="5-I-O-多路复用，select-poll-epoll-详解"><a href="#5-I-O-多路复用，select-poll-epoll-详解" class="headerlink" title="5.I/O 多路复用，select / poll / epoll 详解"></a>5.I/O 多路复用，select / poll / epoll 详解</h1><h2 id="从阻塞-I-O-到-I-O-多路复用"><a href="#从阻塞-I-O-到-I-O-多路复用" class="headerlink" title="从阻塞 I/O 到 I/O 多路复用"></a>从阻塞 I/O 到 I/O 多路复用</h2><p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用<strong>多线程</strong>来处理多个文件描述符。</p><p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在<strong>一个线程</strong>里<em>轮询</em>多个文件描述符是否就绪。</p><p>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查<strong>一个</strong>文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。</p><p>因此引入了 I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p><blockquote><p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p></blockquote><p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：<strong>如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回</strong>。使用非阻塞 I/O 检查每个描述符的就绪状态。</p><p>如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><p>I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。这部分内容可以查看最下文 <a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">Redis 的线程模型</a>。</p><h3 id="为什么-I-O-多路复用内部需要使用非阻塞-I-O"><a href="#为什么-I-O-多路复用内部需要使用非阻塞-I-O" class="headerlink" title="为什么 I/O 多路复用内部需要使用非阻塞 I/O"></a>为什么 I/O 多路复用内部需要使用非阻塞 I/O</h3><p>I/O 多路复用<strong>内部</strong>会遍历集合中的每个文件描述符，判断其是否就绪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for fd in read_set</span><br><span class="line">    if（ readable(fd) ) &#x2F;&#x2F; 判断 fd 是否就绪</span><br><span class="line">        count++</span><br><span class="line">        FDSET(fd, &amp;res_rset) &#x2F;&#x2F; 将 fd 添加到就绪集合中</span><br><span class="line">        break</span><br><span class="line">...</span><br><span class="line">return count</span><br></pre></td></tr></table></figure><p>这里的 <code>readable(fd)</code> 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 <code>fd</code> 未就绪时，<code>select</code> 会阻塞在这个文件描述符上，无法检查下个文件描述符。</p><p>注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，见下文<a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#whynonblock">为什么边缘触发必须使用非阻塞 I/O</a>。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="函数签名与参数"><a href="#函数签名与参数" class="headerlink" title="函数签名与参数"></a>函数签名与参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds,</span><br><span class="line">            fd_set *restrict readfds,</span><br><span class="line">            fd_set *restrict writefds,</span><br><span class="line">            fd_set *restrict errorfds,</span><br><span class="line">            struct timeval *restrict timeout);</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="什么是文件描述符-fd"><a href="#什么是文件描述符-fd" class="headerlink" title="什么是文件描述符 fd"></a>什么是文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">这篇文章</a>以图示的方式对文件描述符作了深入地讲解，可以进一步阅读。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。</p><p>可以这样理解：<strong>socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现</strong>。socket 与 fd 是一一对应的。<strong>通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件</strong>。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;select.h&gt;   </span><br><span class="line">int FD_ZERO(int fd, fd_set *fdset);  &#x2F;&#x2F; 将 fd_set 所有位置 0</span><br><span class="line">int FD_CLR(int fd, fd_set *fdset);   &#x2F;&#x2F; 将 fd_set 某一位置 0</span><br><span class="line">int FD_SET(int fd, fd_set *fd_set);  &#x2F;&#x2F; 将 fd_set 某一位置 1</span><br><span class="line">int FD_ISSET(int fd, fd_set *fdset); &#x2F;&#x2F; 检测 fd_set 某一位是否为 1</span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img data-src="https://imageslr.github.io/media/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 采用链表的方式存储文件描述符，没有最大存储数量的限制。</p><p>从性能开销上看，poll 和 select 的差别不大。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><p><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</p></li><li><p><code>fd</code> 表示要监听的目标文件描述符</p></li><li><p><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</p></li><li><p><code>op</code>表示要对<code>fd</code>执行的操作，有以下几种：</p><ul><li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li><li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li></ul></li><li><p><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</p></li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">               int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll 的优点"></a>epoll 的优点</h3><p>一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p><p>对于“性能开销大”，<code>epoll_ctl</code> 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 <code>select</code> 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p><blockquote><p>相当于时间复杂度从 O(n) 降为 O(1)</p></blockquote><p>此外，每次调用 <code>select</code> 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递。这也大大提高了效率。</p><h3 id="水平触发、边缘触发"><a href="#水平触发、边缘触发" class="headerlink" title="水平触发、边缘触发"></a>水平触发、边缘触发</h3><p><code>select</code> 只支持水平触发，<code>epoll</code> 支持水平触发和边缘触发。</p><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。</p><p>区别：边缘触发效率更高，<strong>减少了事件被重复触发的次数</strong>，函数不会返回大量用户程序可能不需要的文件描述符。</p><blockquote><p>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li><p>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</p></li><li><p><code>select</code> 可以使用阻塞 I/O</p><p>。通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure><p>获取到所有可读的文件描述符后，遍历每个文件描述符，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read</span><br></pre></td></tr></table></figure><p>一次</p><p>数据（见上文</p><p>select 示例</p><p>）</p><ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll</span><br></pre></td></tr></table></figure><p>的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知</p><ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul></li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。</p><h2 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h2><p>Redis 是一个单线程的工作模型，使用 I/O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？</p><p>I/O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I/O 请求时，先将它挂起，切换到别的线程；当 I/O 设备就绪时，再切换回该线程。总之，<strong>多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景</strong>。</p><p>而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I/O 操作，因此<strong>多线程频繁的上下文切换反而是一种负优化</strong>。Redis 选择基于非阻塞 I/O 的 <strong>I/O 多路复用机制</strong>，在单线程里<strong>并发</strong>处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。</p><p>不过 redis 在最新的几个版本中也引入了多线程，目的是：</p><ol><li>异步处理删除操作。当删除超大键值对的时候，单线程内同步地删除可能会阻塞待处理的任务</li><li>应对网络 I/O 的场景，网络 I/O 是慢速 I/O。redis6 吞吐量提高了 1 倍</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://linux.die.net/man/7/epoll">Linux man page - epoll</a></li><li><a href="https://linux.die.net/man/2/epoll_create">Linux man page - epoll_create</a></li><li><a href="https://linux.die.net/man/2/epoll_ctl">Linux man page - epoll_ctl</a></li><li><a href="https://linux.die.net/man/2/epoll_wait">Linux man page - epoll_wait</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="操作系统" scheme="https://hxy1997.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>前端性能</title>
    <link href="https://hxy1997.xyz/2021/02/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    <id>https://hxy1997.xyz/2021/02/25/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/</id>
    <published>2021-02-24T16:02:39.000Z</published>
    <updated>2021-03-13T14:04:05.307Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化的相关内容，好好掌握消化，其实这一部分实用性远高于应试性，很考验各位前端仔的实战水平的</p><span id="more"></span><h1 id="1-RAIL模型"><a href="#1-RAIL模型" class="headerlink" title="1.RAIL模型"></a>1.RAIL模型</h1><p>RAIL是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。</p><p>有以下四个方面：</p><ul><li>Response</li><li>Animation</li><li>Idle</li><li>Load</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2020/7/13/1734894ee7aaf2b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="RAIL示意图"></p><h2 id="1-聚焦用户"><a href="#1-聚焦用户" class="headerlink" title="1.聚焦用户"></a>1.聚焦用户</h2><p>以下是用户对性能延迟的感知：</p><table><thead><tr><th>延迟时间</th><th>用户感知</th></tr></thead><tbody><tr><td>0-16ms</td><td>很流畅</td></tr><tr><td>0-100ms</td><td>基本流畅</td></tr><tr><td>100-1000ms</td><td>感觉到网站上有一些加载任务</td></tr><tr><td>1000ms or more</td><td>失去耐心了</td></tr><tr><td>10000ms or more</td><td>直接离开，不会再访问了</td></tr></tbody></table><h2 id="2-Response-事件处理最好在50ms内完成"><a href="#2-Response-事件处理最好在50ms内完成" class="headerlink" title="2.Response: 事件处理最好在50ms内完成"></a>2.Response: 事件处理最好在50ms内完成</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>用户的输入到响应的时间不超过100ms，给用户的感受是瞬间就完成了。</li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>事件处理函数在50ms内完成，考虑到idle task的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations等，不适用于drag和scroll。</li><li>复杂的js计算尽可能放在后台，如web worker，避免对用户输入造成阻塞</li><li>超过50ms的响应，一定要提供反馈，比如倒计时，进度百分比等。</li></ul><blockquote><p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。</p></blockquote><p>下图是idle task对input response的影响：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/7/13/173489db13875e5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Idle Task示意图"></p><h2 id="3-Animation-在10ms内产生一帧"><a href="#3-Animation-在10ms内产生一帧" class="headerlink" title="3.Animation: 在10ms内产生一帧"></a>3.Animation: 在10ms内产生一帧</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul><li>产生每一帧的时间不要超过10ms，为了保证浏览器60帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧。</li><li>旨在视觉上的平滑。用户对帧率变化感知很敏感。</li></ul><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>在一些高压点上，比如动画，不要去挑战cpu，尽可能地少做事，如：取offset，设置style等操作。尽可能地保证60帧的体验。</li><li>在渲染性能上，针对不同的动画做一些特定优化</li></ul><blockquote><p>动画不只是UI的视觉效果，以下行为都属于</p><ul><li>视觉动画，如渐隐渐显，tweens，loading等</li><li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离</li><li>拖拽，缩放，经常伴随着用户行为</li></ul></blockquote><h2 id="4-Idle-最大化空闲时间"><a href="#4-Idle-最大化空闲时间" class="headerlink" title="4.Idle: 最大化空闲时间"></a>4.Idle: 最大化空闲时间</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul><li>最大化空闲时间，以增大50ms内响应用户输入的几率</li></ul><h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">requestIdleCallback API</a></li><li>在空闲时间内执行的任务尽量控制在50ms以内，如果更长的话，会影响input handle的pending时间</li><li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务</li></ul><h2 id="5-Load-传输内容到页面可交互的时间不超过5秒"><a href="#5-Load-传输内容到页面可交互的时间不超过5秒" class="headerlink" title="5.Load: 传输内容到页面可交互的时间不超过5秒"></a>5.Load: 传输内容到页面可交互的时间不超过5秒</h2><p>如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率</p><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><ul><li>优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的3G网络手机上打开时间不超过5秒</li><li>对于第二次打开，尽量不超过2秒</li></ul><h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 <a href="https://www.webpagetest.org/easy">WebPageTest</a> 来测试</li><li>要注意的是，即使用户的网络是4G，但因为丢包或者网络波动，可能会比预期的更慢</li><li><a href="https://web.dev/render-blocking-resources/">禁用渲染阻塞的资源，延后加载</a></li><li>可以采用 <a href="https://web.dev/native-lazy-loading/">lazy load</a>，<a href="https://web.dev/reduce-javascript-payloads-with-code-splitting/">code-splitting</a> 等 <a href="https://web.dev/fast/">其他优化</a> 手段，让第一次加载的资源更少</li></ul><h2 id="分析RAIL用的工具"><a href="#分析RAIL用的工具" class="headerlink" title="分析RAIL用的工具"></a>分析RAIL用的工具</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li><li><a href="https://web.dev/measure/">Lighthouse</a></li><li><a href="https://webpagetest.org/easy">WebPageTest</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RAIL是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p><ul><li>聚焦用户</li><li>100ms内响应用户的输入</li><li>10ms内产生1帧，在滚动或者动画执行时</li><li>最大化主线程的空闲时间</li><li>5s内让网页变得可交互</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://web.dev/rail/">web.dev/rail/</a></p><h1 id="2-前端性能优化"><a href="#2-前端性能优化" class="headerlink" title="2.前端性能优化"></a>2.前端性能优化</h1><h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h2><p>当浏览器想要获取远程的数据时，我们的性能之旅就开始了。然而，我们并不会立即动身（发送请求）。在计算机领域，很多性能问题都会通过增加缓存来解决，前端也不例外。和许多后端服务一样，前端缓存也是多级的。下面让我们一起来具体看一看。</p><h3 id="1-1本地数据存储"><a href="#1-1本地数据存储" class="headerlink" title="1. 1本地数据存储"></a>1. 1本地数据存储</h3><p>通过结合本地存储，可以在业务代码侧实现缓存。</p><p>对于一些请求，我们可以直接在业务代码侧进行缓存处理。缓存方式包括 <code>localStorage</code>、<code>sessionStorage</code>、<code>indexedDB</code>。把这块加入缓存的讨论也许会有争议，但利用好它确实能在程序侧达到一些类似缓存的能力。</p><p>例如，我们的页面上有一个日更新的榜单，我们可以做一个当日缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当用户加载站点中的榜单组件时，可以通过该方法获取榜单数据</span><br><span class="line">async function readListData() &#123;</span><br><span class="line">    const info &#x3D; JSON.parse(localStorage.getItem(&#39;listInfo&#39;));</span><br><span class="line">    if (isExpired(info.time, +(new Date))) &#123;</span><br><span class="line">        const list &#x3D; await fetchList();</span><br><span class="line">        localStorage.setItem(&#39;listInfo&#39;, JSON.stringify(&#123;</span><br><span class="line">            time: +(new Date),</span><br><span class="line">            list: list</span><br><span class="line">        &#125;));</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 大家都比较了解了，<code>indexedDB</code> 可能会了解的更少一些。想快速了解 <code>indexedDB</code> 使用方式可以看<a href="https://medium.com/free-code-camp/a-quick-but-complete-guide-to-indexeddb-25f030425501">这篇文章</a>[1]。</p><p>从前端视角看，这是一种本地存储；但如果从整个系统的维度来看，很多时候其实也是缓存链条中的一环。对于一些特殊的、轻量级的业务数据，可以考虑使用本地存储作为缓存。</p><h3 id="1-2-内存缓存（Memory）"><a href="#1-2-内存缓存（Memory）" class="headerlink" title="1.2. 内存缓存（Memory）"></a>1.2. 内存缓存（Memory）</h3><p>当你访问一个页面及其子资源时，有时候会出现一个资源被使用多次，例如图标。由于该资源已经存储在内存中，再去请求反而多此一举，浏览器内存则是最近、最快的响应场所。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/1-cache/img/memcache.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/1-cache/img/memcache.png" alt="memory cache"></a></p><p>内存缓存并无明确的标准规定，它与 HTTP 语义下的缓存关联性不大，算是浏览器帮我们实现的优化，很多时候其实我们意识不到。</p><p>对内存缓存感兴趣，可以在<a href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/">这篇文章</a>[2]的 Memory Cache 部分进一步了解。</p><h3 id="1-3-Cache-API"><a href="#1-3-Cache-API" class="headerlink" title="1.3. Cache API"></a>1.3. Cache API</h3><p>当我们没有命中内存缓存时，是否就开始发送请求了呢？其实不一定。</p><p>在这时我们还可能会碰到 Cache API 里的缓存，提到它就不得不提一下 Service Worker 了。它们通常都是配合使用的。</p><p>首先明确一下，这层的缓存没有规定说该缓存什么、什么情况下需要缓存，它只是提供给了客户端构建请求缓存机制的能力。如果你对 PWA 或者 Service Worker 很了解，应该非常清楚是怎么一回事。如果不了解也没有关系，我们可以简单看一下：</p><p>首先，Service Worker 是一个后台运行的独立线程，可以在代码中启用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(&#39;.&#x2F;sw.js&#39;).then(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 注册成功</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后需要处理一些 Service Worker 的生命周期事件，而其中与这里提到的缓存功能直接相关的则是请求拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; sw.js</span><br><span class="line">self.addEventListener(&#39;fetch&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果有cache则直接返回，否则通过fetch请求</span><br><span class="line">    e.respondWith(</span><br><span class="line">        caches.match(e.request).then(function (cache) &#123;</span><br><span class="line">            return cache || fetch(e.request);</span><br><span class="line">        &#125;).catch(function (err) &#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            return fetch(e.request);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。与内存缓存不同，Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。</p><p>Service Worker 与 Cache API 其实是一个功能非常强大的组合，能够实现堆业务的透明，在[兼容性](<a href="https://caniuse.com/#feat=serviceworkers&amp;search=service">https://caniuse.com/#feat=serviceworkers&amp;search=service</a> worker)上也可以做成渐进支持。还是非常推荐在业务中尝试的。当然上面代码简略了很多，想要进一步了解 Service Worker 和 Cache API 的使用可以看<a href="https://juejin.im/post/5aca14b6f265da237c692e6f">这篇文章</a>[3]。同时推荐使用 Google 的 <a href="https://developers.google.com/web/tools/workbox/">Workbox</a>。</p><h3 id="1-4-HTTP-缓存"><a href="#1-4-HTTP-缓存" class="headerlink" title="1.4. HTTP 缓存"></a>1.4. HTTP 缓存</h3><p>如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了。这个时候出现的就是我们所熟知的 HTTP 缓存规范。</p><p>HTTP 有一系列的规范来规定哪些情况下需要缓存请求信息、缓存多久，而哪些情况下不能进行信息的缓存。我们可以通过相关的 HTTP 请求头来实现缓存。</p><p>HTTP 缓存大致可以分为强缓存与协商缓存。</p><h4 id="1-4-1-强缓存"><a href="#1-4-1-强缓存" class="headerlink" title="1.4.1. 强缓存"></a>1.4.1. 强缓存</h4><p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”一般就是来源于硬盘。这也就是我们在 Chrome DevTools 上经常看到的「disk cache」。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/1-cache/img/diskcache.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/1-cache/img/diskcache.png" alt="disk cache"></a></p><p>与其相关的响应头则是 <code>Expires</code> 和 <code>Cache-Control</code>。在 <code>Expires</code> 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 <code>Cache-Control</code> 则可以通过给它设置一个 <code>max-age</code>，来控制过期时间。例如，<code>max-age=300</code> 就是表示在响应成功后 300 秒内，资源请求会走强缓存。</p><h4 id="1-4-2-协商缓存"><a href="#1-4-2-协商缓存" class="headerlink" title="1.4.2. 协商缓存"></a>1.4.2. 协商缓存</h4><p>你可能也感觉到了，强缓存不是那么灵活。如果我在 300 秒内更新了资源，需要怎么通知客户端呢？常用的方式就是通过协商缓存。</p><p>我们知道，远程请求慢的一大原因就是报文体积较大。协商缓存就是希望能通过先“问一问”服务器资源到底有没有过期，来避免无谓的资源下载。这伴随的往往会是 HTTP 请求中的 304 响应码。下面简单介绍一下实现协商缓存的两种方式：</p><p>一种协防缓存的方式是：服务器第一次响应时返回 <code>Last-Modified</code>，而浏览器在后续请求时带上其值作为 <code>If-Modified-Since</code>，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p><p>上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— <code>ETag</code>。服务器第一次响应时返回 <code>ETag</code>，而浏览器在后续请求时带上其值作为 <code>If-None-Match</code>。一般会用文件的 MD5 作为 <code>ETag</code>。</p><p>作为前端工程师，一定要善于应用 HTTP 缓存。如果想要了解更多关于 HTTP 缓存的内容，可以阅读<a href="https://github.com/amandakelake/blog/issues/41">这篇文章</a>[4]。</p><blockquote><p>上面这些的各级缓存的匹配机制里，都是包含资源的 uri 的匹配，即 uri 更改后不会命中缓存。也正是如此，我们目前在前端实践中都会把文件 HASH 加入到文件名中，避免同名文件命中缓存的旧资源。</p></blockquote><h3 id="1-5-Push-Cache"><a href="#1-5-Push-Cache" class="headerlink" title="1.5. Push Cache"></a>1.5. Push Cache</h3><p>假如很不幸，以上这些缓存你都没有命中，那么你将会碰到最后一个缓存检查 —— Push Cache。</p><p>Push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源。例如，你在请求 <a href="http://www.sample.com/">www.sample.com</a> 时，服务端不仅发送了页面文档，还一起推送了 关键 CSS 样式表。这也就避免了浏览器收到响应、解析到相应位置时才会请求所带来的延后。</p><p>不过 HTTP/2 Push Cache 是一个比较底层的网络特性，与其他的缓存有很多不同，例如：</p><ul><li>当匹配上时，并不会在额外检查资源是否过期；</li><li>存活时间很短，甚至短过内存缓存（例如有文章提到，Chrome 中为 5min 左右）；</li><li>只会被使用一次；</li><li>HTTP/2 连接断开将导致缓存直接失效；</li><li>……</li></ul><p>如果对 HTTP/2 Push 感兴趣，可以看看<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">这篇文章</a>[5]。</p><hr><p>好了，到目前为止，我们可能还没有发出一个真正的请求。这也意味着，在缓存检查阶段我们就会有很多机会将后续的性能问题扼杀在摇篮之中 —— 如果远程请求都不必发出，又何须优化加载性能呢？</p><p>所以，审视一下我们的应用、业务，看看哪些性能问题是可以在源头上解决的。</p><h2 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2.发送请求"></a>2.发送请求</h2><p>在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。</p><blockquote><p>在 HTTP 缓存中，我们其实也有发送请求；或者是在 HTTP/2 Push 下，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。</p></blockquote><h3 id="2-1-避免多余重定向"><a href="#2-1-避免多余重定向" class="headerlink" title="2.1. 避免多余重定向"></a>2.1. 避免多余重定向</h3><p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 uri。这时候就可以使用重定向，把访问原网址的用户重定向到新的 uri。还有是在一些登录场景下，会使用到重定向技术。</p><p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p><p>同时也不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p><h3 id="2-2-DNS-预解析"><a href="#2-2-DNS-预解析" class="headerlink" title="2.2. DNS 预解析"></a>2.2. DNS 预解析</h3><p>基本我们访问远程服务的时候，不会直接使用服务的出口 IP，而是使用域名。所以请求的一个重要环节就是域名解析。</p><p>DNS 服务本身是一个树状层级结构，其解析是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：</p><ol><li>先检查本地 hosts 文件中是否有映射，有则使用；</li><li>查找本地 DNS 缓存，有则返回；</li><li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li><li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li><li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li><li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li></ol><p>更详细的介绍可以看<a href="https://www.zhihu.com/question/23042131">这篇文章</a>[1]。</p><p>这里我们需要了解的是：</p><ul><li>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li><li>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。</li></ul><p><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch">DNS Prefetch</a>[2] 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;yourwebsite.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了👇</p><blockquote><p>user agent SHOULD resolve as early as possible</p></blockquote><h3 id="2-3-预先建立连接"><a href="#2-3-预先建立连接" class="headerlink" title="2.3. 预先建立连接"></a>2.3. 预先建立连接</h3><p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 <a href="https://www.w3.org/TR/resource-hints/#preconnect">Preconnect</a>[3] 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p><p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p><ul><li>首先，解析 Preconnect 的 url；</li><li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li><li>然后，默认先将 credential 设为 <code>true</code>，如果 cors 为 <code>Anonymous</code> 并且存在跨域，则将 credential 置为 <code>false</code>；</li><li>最后，进行连接。</li></ul><p>使用 Preconnect 只需要将 <code>rel</code> 属性设为 <code>preconnect</code> 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;sample.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>当然，你也可以设置 CORS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preconnect&quot; href&#x3D;&quot;&#x2F;&#x2F;sample.com&quot; crossorigin&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p><h3 id="2-4-使用-CDN"><a href="#2-4-使用-CDN" class="headerlink" title="2.4. 使用 CDN"></a>2.4. 使用 CDN</h3><p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p><p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p><p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p><p>想了解更多 CDN 的工作方式可以阅读<a href="https://yq.aliyun.com/articles/577708">这篇文章</a>[4]。</p><hr><p>下图是请求声明周期中各个阶段的示意图，可以帮助我们理解发送请求（以及接收响应）的流程。</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/2-request/img/resourcetiming.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/2-request/img/resourcetiming.png" alt="resource timing line"></a></p><hr><p>在缓存没法满足我们的情况下，就要开始真正发送请求了。从前端性能优化视角，我们会关注重定向、DNS 解析等问题，从而加速请求。但这块还预留了一小部分 —— 服务端的处理与响应。</p><p>过去，我们会将前端局限在浏览器中，但是随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务。所以咱们这次的旅程也会简单聊一下，在这一阶段可以做的一些优化。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.zhihu.com/question/23042131">DNS 的解析过程</a></li><li><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch">Resource Hints - DNS Prefetch</a></li><li><a href="https://www.w3.org/TR/resource-hints/#preconnect">Resource Hints - Preconnect</a></li><li><a href="https://yq.aliyun.com/articles/577708">CDN 之我见：原理篇</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing">Understanding Resource Timing</a></li><li><a href="https://www.geeksforgeeks.org/tcp-3-way-handshake-process/">TCP 3-Way Handshake Process</a></li><li><a href="https://www.geeksforgeeks.org/tcp-connection-termination/">TCP 4 wave hands</a></li><li><a href="https://mp.weixin.qq.com/s/3NKOCOeIUF2SGJnY7II9hA">图文还原HTTPS原理</a></li><li><a href="https://en.wikipedia.org/wiki/URL_redirection">URL redirection (wikipedia)</a></li></ol><h2 id="3-服务端响应"><a href="#3-服务端响应" class="headerlink" title="3.服务端响应"></a>3.服务端响应</h2><p>把这一部分放进前端性能优化并不是很严谨：</p><ul><li>其一，服务端有着服务端的通用技术手段，这块深入去研究，会是一个不一样的领域；</li><li>其二，我们既然在讨论前端性能优化，这部分主要还是指 NodeJS，但不是所有业务都使用 NodeJS。</li></ul><p>所以这里只会提一些实践中碰到的小点，辅以一些拓展阅读，希望能帮助大家抛砖引玉，开拓思维。</p><h3 id="3-1-使用流进行响应"><a href="#3-1-使用流进行响应" class="headerlink" title="3.1. 使用流进行响应"></a>3.1. 使用流进行响应</h3><p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p><p>例如 <a href="https://github.com/alienzhou/css-only-chat-node">css-only-chat-node</a> 就利用了这个特点来实现无刷新、无 JavaScript 的页面更新。</p><h3 id="3-2-业务聚合"><a href="#3-2-业务聚合" class="headerlink" title="3.2. 业务聚合"></a>3.2. 业务聚合</h3><p>BFF 非常合适做的一件事就是后端服务的聚合。</p><p>如果你有一个两个接口服务：第一个服务是先获取产品信息，再根据产品信息中的上架时间通过第二个服务获取该时间后的产品列表。这个业务逻辑如果放在前端（浏览器）处理将会串行发送两个请求。假设每个请求 200ms，那么就需要等待 400ms。如果引入 NodeJS，这一层可以放在 NodeJS 中实现。NodeJS 部署的位置一般离其他后端服务“更近”，例如同一个局域网。这类服务间的请求耗时显然更低，可能只需要 200(浏览器) + 30(NodeJS) * 2 = 260ms。</p><p>此外，如果一个业务需要在前端并发三、四个请求来获取完整数据，那么放在 NodeJS 的 BFF 层也是一个不错的选择。</p><h3 id="3-3-避免代码问题"><a href="#3-3-避免代码问题" class="headerlink" title="3.3. 避免代码问题"></a>3.3. 避免代码问题</h3><p>代码问题其实就非常细节了。简单列举一些常见的问题：</p><ul><li><code>async</code> <code>await</code> 的不当使用导致并行请求被串行化了；</li><li>频繁地 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 大对象；</li><li>正则表达式的灾难性回溯；</li><li>闭包导致的内存泄漏；</li><li>CPU 密集型任务导致事件循环 delay 严重；</li><li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；</li><li>……</li></ul><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/README.md">https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/README.md</a>)</p><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.yuque.com/office/yuque/0/2019/pdf/168578/1547529466557-357032b6-12fb-4e02-9682-076f498c1f42.pdf">你不知道的 Node.js 性能优化</a></li><li><a href="https://www.smashingmagazine.com/2018/06/nodejs-tools-techniques-performance-servers/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more">Keeping Node.js Fast: Tools, Techniques, And Tips For Making High-Performance Node.js Servers</a></li><li><a href="https://hackernoon.com/frontend-in-the-backend-a-pattern-for-cleaner-code-b497c92d0b49">Backend-in-the-frontend: a pattern for cleaner code</a></li><li><a href="https://github.com/aliyun-node/Node.js-Troubleshooting-Guide">Node.js 应用故障排查手册</a></li><li><a href="https://github.com/goldbergyoni/nodebestpractices">Node.js Best Practices</a></li></ol><h2 id="4-页面解析与处理"><a href="#4-页面解析与处理" class="headerlink" title="4.页面解析与处理"></a>4.页面解析与处理</h2><h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><p>这一阶段浏览器需要处理的东西很多，为了更好地理解性能优化，我们主要将其分为几个部分：</p><ul><li>页面 DOM 的解析；</li><li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li><li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li></ul><p>大致过程就是解析页面 DOM 结构，遇到外部资源就加载，加载好了就使用。但是由于这部分的内容比较多，所以在这一节里我们重点关注页面的解析（其他部分在写一节中介绍）。</p><h3 id="4-1-注意资源在页面文档中的位置"><a href="#4-1-注意资源在页面文档中的位置" class="headerlink" title="4.1. 注意资源在页面文档中的位置"></a>4.1. 注意资源在页面文档中的位置</h3><p>我们的目标是收到内容就尽快解析处理，页面有依赖的资源就尽快发送请求，收到响应则尽快处理。然而，这个美好的目标也有可能会被我们不小心破坏。</p><p>JavaScript 脚本和 CSS 样式表在关于 DOM 元素的属性，尤其是样式属性上都有操作的权利。这就像是一个多线程问题。服务端多线程编程中经常通过锁来保证线程间的互斥。回到咱们的前端，现在也是两方在竞争同一个资源，显然也是会有互斥的问题。这就带来了 DOM 解析、JavaScript 加载与执行、CSS 加载与使用之间的一些互斥关系。</p><p>仅仅看 DOM 与 CSS 的关系，则如下图所示：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/pipeline1.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/pipeline1.png" alt="pipeline for dom and css"></a></p><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，并行执行，非常完美。然而，当 JavaScript 入场之后，局面就变了：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/pipeline2.png"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/pipeline2.png" alt="pipeline for dom and css with js"></a></p><p>根据标准规范，在 JavaScript 中可以访问 DOM。因此当遇到 JavaScript 后会阻塞 DOM 的解析。于此同时，为避免 CSS 与 JavaScript 之间的竞态，CSSOM 的构建会阻塞 JavaScript 的脚本执行。总结起来就是 ——</p><blockquote><p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。</p></blockquote><p>所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <code>&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code>&lt;body&gt;</code> 的最后（即页面的尾部）。</p><p>关于这部分的一些解释可以看<a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/">这篇文章</a>[1]。</p><h3 id="4-2-使用-defer-和-async"><a href="#4-2-使用-defer-和-async" class="headerlink" title="4.2. 使用 defer 和 async"></a>4.2. 使用 defer 和 async</h3><p>上面提到了，当 DOM 解析遇到 JavaScript 脚本时，会停止解析，开始下载脚本并执行，再恢复解析，相当于是阻塞了 DOM 构建。</p><p>那除了将脚本放在 <code>body</code> 的最后，还有什么优化方法么？是有的。</p><p>可以使用 <code>defer</code> 或 <code>async</code> 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p><p><a href="https://github.com/alienzhou/fe-performance-journey/blob/master/4-parse/img/async-defer.jpeg"><img data-src="https://github.com/alienzhou/fe-performance-journey/raw/master/4-parse/img/async-defer.jpeg" alt="async defer"></a></p><p><code>defer</code> 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 <code>async</code> 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p><p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 <code>async</code> 可以有效避免这些非核心功能的加载影响页面解析速度。</p><h3 id="4-3-页面文档压缩"><a href="#4-3-页面文档压缩" class="headerlink" title="4.3. 页面文档压缩"></a>4.3. 页面文档压缩</h3><p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p><hr><p>说一句题外话，你知道与页面解析密切相关的 DOMContentLoaded 事件何时触发么？interactive/complete 等 readyState 具体代表什么么？如果不太了解可以从<a href="https://html.spec.whatwg.org/multipage/dom.html#current-document-readiness">HTML spec</a>[2]里看。</p><p>用原话来说就是：</p><blockquote><p>Returns “loading” while the Document is loading, “interactive” once it is finished parsing but still loading subresources, and “complete” once it has loaded.</p></blockquote><blockquote><p>The readystatechange event fires on the Document object when this value changes.</p></blockquote><blockquote><p>The DOMContentLoaded event fires after the transition to “interactive” but before the transition to “complete”, at the point where all subresources apart from async script elements have loaded.</p></blockquote><hr><p>好了，在这一站我们又了解了页面的解析过程及其性能优化。</p><h2 id="5-页面静态资源"><a href="#5-页面静态资源" class="headerlink" title="5.页面静态资源"></a>5.页面静态资源</h2><p>首先还是从宏观上来了解一下：</p><h3 id="5-1-总体原则"><a href="#5-1-总体原则" class="headerlink" title="5.1. 总体原则"></a>5.1. 总体原则</h3><p>这一部分会涉及到各类常见的静态资源：JavaScript 脚本、CSS 样式表、图片、字体等。不同资源的优化措施既有联系又有差别，后续会以各类资源为维度，针对性介绍其优化的关注点和手段。</p><p>但咱们还是要先从整体维度上进行一些分析。其实在总体原则上，各类资源的优化思路都是大体类似的，包括但不限于：</p><ul><li>减少不必要的请求</li><li>减少包体大小</li><li>降低应用资源时的消耗</li><li>利用缓存</li></ul><p>为了大家能更好理解各类优化实施策略从何而来，先初步扩展一下以上的思路。</p><h4 id="5-1-1-减少不必要的请求"><a href="#5-1-1-减少不必要的请求" class="headerlink" title="5.1.1. 减少不必要的请求"></a>5.1.1. 减少不必要的请求</h4><p>核心是希望能够减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。一个典型场景就是一些图库类型的网站，页面加载后可能需要请求十数张图片。</p><p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。因此，发送过多的“小”请求可能也不是一个很好的做法。</p><p>减少不必要的请求主要分为几个维度：</p><ul><li>对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；</li><li>对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；</li><li>对于可以合并的资源，进行资源合并也是一种方法。</li></ul><h4 id="5-1-2-减少包体大小"><a href="#5-1-2-减少包体大小" class="headerlink" title="5.1.2. 减少包体大小"></a>5.1.2. 减少包体大小</h4><p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好。</p><p>减少包体大小常用的方式包括了：</p><ul><li>使用适合当前资源的压缩技术；</li><li>避免再响应包体里“塞入”一些不需要的内容。</li></ul><h4 id="5-1-3-降低应用资源时的消耗"><a href="#5-1-3-降低应用资源时的消耗" class="headerlink" title="5.1.3. 降低应用资源时的消耗"></a>5.1.3. 降低应用资源时的消耗</h4><p>以上主要的关注点都在页面资源加载的效率，其实有些时候，浏览器去执行或使用资源的也是有消耗的。例如在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题。虽然今天的像 V8 这样的引擎已经很快了，但是一些不当的操作仍然会带来性能的损耗。</p><p>此外，像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。也许这些不太常成为性能杀手，但是某些特性场合下，了解它们也许会对你有所帮助。</p><h4 id="5-1-4-利用缓存"><a href="#5-1-4-利用缓存" class="headerlink" title="5.1.4. 利用缓存"></a>5.1.4. 利用缓存</h4><p>还记得咱们这趟旅程从哪出发的么？没错，缓存。</p><p>在旅程的第一站，我们介绍了浏览器访问一个 url 时的多级缓存策略。千万不要忘了，这些静态子资源也是网络请求，它们仍然可以利用之前介绍的完整缓存流程。缓存在很多时候会是一个帮你解决性能问题的非常有效的手段。</p><p>由于第一站已经对缓存进行了详细介绍，所以缓存这部分，在这一站里只会在针对资源类型再补充一些内容。</p><h3 id="5-2-针对各类资源的性能优化-🚀"><a href="#5-2-针对各类资源的性能优化-🚀" class="headerlink" title="5.2. 针对各类资源的性能优化 🚀"></a>5.2. 针对各类资源的性能优化 🚀</h3><p>以上的原则可以指导我们针对性地优化各类资源。下面我就以资源类型为维度，详细介绍其中涉及到的优化点与优化措施。</p><h4 id="5-2-1-JavaScript-优化"><a href="#5-2-1-JavaScript-优化" class="headerlink" title="5.2.1 JavaScript 优化"></a>5.2.1 <a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html">JavaScript 优化</a></h4><h5 id="1-减少不必要的请求"><a href="#1-减少不必要的请求" class="headerlink" title="1. 减少不必要的请求"></a>1. 减少不必要的请求</h5><p>在进行 JavaScript 优化时，我们还是秉承总体思路，首先就是减少不必要的请求。</p><h6 id="1-1-代码拆分（code-split）与按需加载"><a href="#1-1-代码拆分（code-split）与按需加载" class="headerlink" title="#1.1. 代码拆分（code split）与按需加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_1-1-%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%EF%BC%88code-split%EF%BC%89%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">#</a>1.1. 代码拆分（code split）与按需加载</h6><p>相信熟练使用 webpack 的同学对这一特性都不陌生。</p><p>虽然整体应用的代码非常多，但是很多时候，我们在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载。核心思路如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里加载 chat 组件相关资源 chat.js</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.src = <span class="string">&#x27;/static/js/chat.js&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在按钮点击的监听函数中，我动态添加了 <code>&lt;script&gt;</code> 元素。这样就可以实现在点击按钮时，才加载对应的 JavaScript 脚本。</p><p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a>[1] 来告诉 webpack 去做代码拆分。webpack 编译时会进行语法分析，之后遇到 dynamic import 就会认为这个模块是需要动态加载的。相应的，其子资源也会被如此处理（除非被其他非动态模块也引用了）。</p><p>在 webpack 中使用代码拆分最常见的一个场景是基于路由的代码拆分。目前很多前端应用都在使用 SPA（单页面应用）形式，或者 SPA 与 MPA（多页面应用）的结合体，这就会涉及到前端路由。而页面间的业务差异也让基于路由的代码拆分成为一个最佳实践。想了解如何在 react-router v4 中实现路由级别的代码拆分，可以看<a href="https://www.jianshu.com/p/547aa7b92d8c">这篇文章</a>[2]。</p><p>当然，如果你不使用 webpack 之类的构建工具，你也可以选择一个 AMD 模块加载器（例如 <a href="https://requirejs.org/">RequireJS</a>）来实现前端运行时上的异步依赖加载。</p><h6 id="1-2-代码合并"><a href="#1-2-代码合并" class="headerlink" title="#1.2. 代码合并"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_1-2-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6">#</a>1.2. 代码合并</h6><p>我们在总体思路里有提到，减少请求的一个方法就是合并资源。试想一个极端情况：我们现在不对 node_modules 中的代码进行打包合并，那么当我们请求一个脚本之前将可能会并发请求数十甚至上百个依赖的脚本库。同域名下的并发请求数过高会导致请求排队，同时还可能受到 TCP/IP 慢启动的影响。</p><p>当然，在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会帮你把依赖打包到一起的。不过当你使用其他一些工具时，就要注意了。例如使用 <a href="https://fis.baidu.com/fis3/docs/pack.html">FIS3</a> 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并。又或者使用 Gulp 这样的工具，也需要注意进行打包。</p><p>总之，千万不要让你的碎文件散落一地。</p><h5 id="2-减少包体大小"><a href="#2-减少包体大小" class="headerlink" title="#2. 减少包体大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F">#</a>2. 减少包体大小</h5><h6 id="2-1-代码压缩"><a href="#2-1-代码压缩" class="headerlink" title="#2.1. 代码压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-1-%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9">#</a>2.1. 代码压缩</h6><p>JavaScript 代码压缩比较常见的做法就是使用 <a href="http://lisperator.net/uglifyjs/">UglifyJS</a> 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 <a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a> 这样的功能插件。</p><p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/gzip1.51bd67d4.png" alt="响应头"></p><p>上图中响应头的 <code>Content-Encoding</code> 表示其使用了 gzip。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/gzip2.ab7a2dab.png" alt="压缩效果"></p><p>深色的数字表示压缩后的大小为 22.0KB，浅色部分表示压缩前的大小为 91.9KB，压缩比还是挺大的，很有效果。一般服务器都会内置相应模块来进行 gzip 处理，不需要我们单独编写压缩算法模块。例如在 Nginx 中就包含了 <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module</a>[3] 模块，通过简单的配置就可以开启。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span>            <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_types</span>      application/javascript application/x-javascript text/javascript;</span><br></pre></td></tr></table></figure><h6 id="2-2-Tree-Shaking"><a href="#2-2-Tree-Shaking" class="headerlink" title="#2.2. Tree Shaking"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-2-tree-shaking">#</a>2.2. Tree Shaking</h6><p>Tree Shaking 最早进入到前端的视线主要是因为 Rollup。后来在 webpack 中也被实现了。其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 B</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;module.A.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>可以看到，模块 B 引用了模块 A，但是只使用了 <code>add</code> 方法。因此 <code>minus</code> 方法相当于成为了 Dead Code，将它打包进去没有意义，该方法是永远不会被使用到的。</p><p>注意，我在上面的代码中使用了 ESM 规范的模块语法，而没有使用 CommonJS。这主要是由于 Tree Shaking 算是一种静态分析，而 ESM 本身是一种的静态的模块化规范，所有依赖可以在编译期确定。如果想要更好得在 webpack 中使用，可以在查看其<a href="https://webpack.js.org/guides/tree-shaking/">官网上的这部分内容</a>[4]。关于 Tree Shaking 的介绍也可以<a href="https://juejin.im/post/5a4dc842518825698e7279a9">从这里了解下</a>[5]。</p><p>注意，刚才说了 Tree Shaking 非常依赖于 ESM。像是前端流行的工具库 <a href="https://lodash.com/">lodash</a> 一般直接安装的版本是非 ESM 的，为了支持 Tree Shaking，我们需要去安装它的 ESM 版本 —— <a href="https://www.npmjs.com/package/lodash-es">lodash-es</a> 来<a href="https://www.zhihu.com/question/333421533/answer/764963886">实现 Tree Shaking</a>[6]。</p><p>此外，Chrome DevTools 也可以帮助你查看加载的 <a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage">JavaScript 代码的使用覆盖率</a>[7]。</p><h6 id="2-3-优化-polyfill-的使用"><a href="#2-3-优化-polyfill-的使用" class="headerlink" title="#2.3. 优化 polyfill 的使用"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-3-%E4%BC%98%E5%8C%96-polyfill-%E7%9A%84%E4%BD%BF%E7%94%A8">#</a>2.3. 优化 polyfill 的使用</h6><p>前端技术的一大特点就是需要考虑兼容性。为了让大家能顺畅地使用浏览器的新特性，一些程序员们开发了新特性对应的 polyfill，用于在非兼容浏览器上也能使用新特性的 API。后续升级不用改动业务代码，只需要删除相应的 polyfill 即可。</p><p>这种舒适的开发体验也让 polyfill 成为了很多项目中不可或缺的一份子。然而 polyfill 也是有代价的，它增加了代码的体积。毕竟 polyfill 也是 JavaScript 写的，不是内置在浏览器中，引入的越多，代码体积也越大。所以，只加载真正所需的 polyfill 将会帮助你减小代码体积。</p><p>首先，不是每个业务的兼容性要求都一样。因此，按你业务的场景来确定引入哪些 polyfill 是最合适的。然而，特性千千万，手动 import 或者添加 Babel Transformer 显然是一件成本极高的事。针对这点，我们可以通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来帮忙，许多前端工具（<a href="https://babeljs.io/docs/en/next/babel-preset-env.html#how-does-it-work">babel-preset-env</a>/<a href="https://github.com/postcss/autoprefixer#browsers">autoprefixer</a>/<a href="https://github.com/amilajack/eslint-plugin-compat#3-configure-target-browsers">eslint-plugin-compat</a>）都依赖于它。使用方式可以<a href="https://babeljs.io/docs/en/next/babel-preset-env.html">看这里</a>。</p><p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 <a href="https://youtu.be/reztLS3vomE?t=1254">Differential Serving</a>[8] 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;legacy.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在能够处理 <code>module</code> 属性的浏览器（具有很多新特性）上就只需加载 <code>main.mjs</code>（不包含 polyfill），而在老式浏览器下，则会加载 <code>legacy.js</code>（包含 polyfill）。</p><p>最后，其实在理想上，polyfill 最优的使用方式应该是根据浏览器特性来分发，同一个项目在不同的浏览器，会加载不同的 polyfill 文件。例如 <a href="https://polyfill.io/v3/">Polyfill.io</a> 就会根据请求头中的客户端特性与所需的 API 特性来按实际情况返回必须的 polyfill 集合。</p><h6 id="2-4-webpack"><a href="#2-4-webpack" class="headerlink" title="#2.4. webpack"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_2-4-webpack">#</a>2.4. webpack</h6><p>webpack 现在已经成为很多前端应用的构建工具，因此这里单独将其列了出来。我们可以通过 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 这个工具来查看打包代码里面各个模块的占用大小。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/webpack-bundle-analyzer.ebc4ca21.gif" alt="webpack-bundle-analyzer"></p><p>很多时候，打包体积过大主要是因为引入了不合适的包，对于如何优化依赖包的引入，这里有<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">一些建议可以帮助你减小 bundle 的体积</a>[9]。</p><h5 id="3-解析与执行"><a href="#3-解析与执行" class="headerlink" title="#3. 解析与执行"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a>3. 解析与执行</h5><p>除了 JavaScript 下载需要耗时外，脚本的解析与执行也是会消耗时间的。</p><h6 id="3-1-JavaScript-的解析耗时"><a href="#3-1-JavaScript-的解析耗时" class="headerlink" title="#3.1. JavaScript 的解析耗时"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-1-javascript-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%80%97%E6%97%B6">#</a>3.1. JavaScript 的解析耗时</h6><p>很多情况下，我们会忽略 JavaScript 文件的解析。一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/js-cost.d58178c5.png" alt="js 处理"></p><p>从<a href="https://twitter.com/addyosmani/status/830126731470073857">上图</a>可以看出，解析与编译消耗了好几百毫秒。所以换一个角度来说，删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p><p>同时，我们从前一节已经知道，JavaScript 的解析、编译和执行会阻塞页面解析，延迟用户交互。所以有时候，加载同样字节数的 JavaScript 对性能的影响可能会高于图片，因为图片的处理可以放在其他线程中并行执行。</p><h6 id="3-2-避免-Long-Task"><a href="#3-2-避免-Long-Task" class="headerlink" title="#3.2. 避免 Long Task"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-2-%E9%81%BF%E5%85%8D-long-task">#</a>3.2. 避免 Long Task</h6><p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑。如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/longtask.c0388c89.png" alt="long task"></p><p>例如在上图中，帧率下降明显的地方出现了 Long Task，伴随着的是有一段超过 700 ms 的脚本执行时间。而性能指标 FCP 与 DCL 处于其后，一定程度上可以认为，这个 Long Task 阻塞了主线程并拖慢了页面的加载时间，严重影响了前端性能与体验。</p><p>想要了解更多关于 Long Task 的内容，可以看看 <a href="https://w3c.github.io/longtasks/">Long Task 相关的标准</a>[10]。</p><h6 id="3-3-是否真的需要框架"><a href="#3-3-是否真的需要框架" class="headerlink" title="#3.3. 是否真的需要框架"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-3-%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A1%86%E6%9E%B6">#</a>3.3. 是否真的需要框架</h6><p>相信如果现在问大家，我们是否需要 React、Vue、Angular 或其他前端框架（库），大概率是肯定的。</p><p>但是我们可以换个角度来思考这个问题。类库/框架帮我们解决的问题之一是快速开发与后续维护代码，很多时候，类库/框架的开发者是需要在可维护性、易用性和性能上做取舍的。对于一个复杂的整站应用，使用框架给你的既定编程范式将会在各个层面提升你工作的质量。但是，对于某些页面，我们是否可以反其道行之呢？</p><p>例如产品经理反馈，咱们的落地页加载太慢了，用户容易流失。这时候你会开始优化性能，用上这次「性能之旅」里的各种措施。但你有没有考虑过，对于像落地页这样的、类似静态页的页面，是不是可以“返璞归真”？</p><p>也许你使用了 React 技术栈 —— 你加载了 React、Redux、React-Redux、一堆 Reducers…… 好吧，整个 JavaScript 可能快 1MB 了。更重要的是，这个页面如果是用于拉新的，这也代表着访问者并没有缓存可以用。好吧，为了一个静态页（或者还有一些非常简单的表单交互），用户付出了高额的成本，而原本这只需要 50 行不到的代码。所以有时候考虑使用原生 JavaScript 来实现它也是一种策略。Netflix 有一篇文章介绍了他们是<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">如何通过这种方式大幅缩减加载与操作响应时间的</a>[11]。</p><p>当然，还是强调一下，并不是说不要使用框架/类库，只是希望大家不要拘泥于某个思维定式。做工具的主人，而不是工具的“奴隶”。</p><h6 id="3-4-针对代码的优化"><a href="#3-4-针对代码的优化" class="headerlink" title="#3.4. 针对代码的优化"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_3-4-%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96">#</a>3.4. 针对代码的优化</h6><blockquote><p>请注意，截止目前（2019.08）以下内容不建议在生产环境中使用。</p></blockquote><p>还有一种优化思路是把代码变为最优状态。它其实算是一种编译优化。在一些编译型的静态语言上（例如 C++），通过编译器进行一些优化非常常见。</p><p>这里要提到的就是 facebook 推出的 <a href="https://prepack.io/">Prepack</a>。例如下面一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">&#x27;world&#x27;</span>;&#125;</span><br><span class="line">    <span class="built_in">global</span>.s = hello() + <span class="string">&#x27; &#x27;</span> + world();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>可以优化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不过很多时候，代码体积和运行性能是会有矛盾的。同时 Prepack 也还不够成熟，所以不建议在生产环境中使用。</p><h5 id="4-缓存"><a href="#4-缓存" class="headerlink" title="#4. 缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-%E7%BC%93%E5%AD%98">#</a>4. 缓存</h5><p>JavaScript 部分的缓存与我们在第一部分里提到的缓存基本一致，如果你记不太清了，<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">可以回到咱们的第一站</a>。</p><h6 id="4-1-发布与部署"><a href="#4-1-发布与部署" class="headerlink" title="#4.1. 发布与部署"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-1-%E5%8F%91%E5%B8%83%E4%B8%8E%E9%83%A8%E7%BD%B2">#</a>4.1. 发布与部署</h6><p>这里简单提一下：大多数情况下，我们对于 JavaScript 与 CSS 这样的静态资源，都会启动 HTTP 缓存。当然，可能使用强缓存，也可能使用协商缓存。当我们在强缓存机制上发布了更新的时候，如何让浏览器弃用缓存，请求新的资源呢？</p><p>一般会有一套配合的方式：首先在文件名中包含文件内容的 Hash，内容修改后，文件名就会变化；同时，设置不对页面进行强缓存，这样对于内容更新的静态资源，由于 uri 变了，肯定不会再走缓存，而没有变动的资源则仍然可以使用缓存。</p><p>上面说的主要涉及前端资源的发布和部署，详细可以看<a href="https://www.zhihu.com/question/20790576/answer/32602154">这篇内容</a>[12]，这里就不展开了。</p><h6 id="4-2-将基础库代码打包合并"><a href="#4-2-将基础库代码打包合并" class="headerlink" title="#4.2. 将基础库代码打包合并"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-2-%E5%B0%86%E5%9F%BA%E7%A1%80%E5%BA%93%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85%E5%90%88%E5%B9%B6">#</a>4.2. 将基础库代码打包合并</h6><p>为了更好利用缓存，我们一般会把不容易变化的部分单独抽取出来。例如一个 React 技术栈的项目，可能会将 React、Redux、React-Router 这类基础库单独打包出一个文件。</p><p>这样做的优点在于，由于基础库被单独打包在一起了，即使业务代码经常变动，也不会导致整个缓存失效。基础框架/库、项目中的 common、util 仍然可以利用缓存，不会每次发布新版都会让用户花费不必要的带宽重新下载基础库。</p><p>所以一种常见的策略就是<a href="https://juejin.im/post/5aed037b6fb9a07aa047e1e1">将基础库这种 Cache 周期较长的内容单独打包在一起</a>，利用缓存减少新版本发布后用户的访问速度。这种方法本质上是将缓存周期不同的内容分离了，隔离了变化。</p><p>webpack 在 v3.x 以及之前，可以通过 CommonChunkPlugin 来分离一些公共库。而升级到 v4.x 之后有了一个新的配置项 <code>optimization.splitChunks</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                commons: &#123;</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    automaticNamePrefix: <span class="string">&#x27;commons&#x27;</span>,</span><br><span class="line">                    test: <span class="regexp">/[\\/]node_modules[\\/]react|redux|react-redux/</span>,</span><br><span class="line">                    chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-3-减少-webpack-编译不当带来的缓存失效"><a href="#4-3-减少-webpack-编译不当带来的缓存失效" class="headerlink" title="#4.3. 减少 webpack 编译不当带来的缓存失效"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-%E5%87%8F%E5%B0%91-webpack-%E7%BC%96%E8%AF%91%E4%B8%8D%E5%BD%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88">#</a>4.3. 减少 webpack 编译不当带来的缓存失效</h6><p>由于 webpack 已经成为前端主流的构建工具，因此这里再特别提一下使用 webpack 时的一些注意点，减少一些不必要的缓存失效。</p><p>我们知道，对于每个模块 webpack 都会分配一个唯一的模块 ID，一般情况下 webpack 会使用自增 ID。这就可能导致一个问题：一些模块虽然它们的代码没有变化，但由于增/删了新的其他模块，导致后续所有的模块 ID 都变更了，文件 MD5 也就变化了。另一个问题在于，webpack 的入口文件除了包含它的 runtime、业务模块代码，同时还有一个用于异步加载的小型 manifest，任何一个模块的变化，最后必然会传导到入口文件。这些都会使得网站发布后，没有改动源码的资源也会缓存失效。</p><p>规避这些问题有一些常用的方式。</p><h6 id="4-3-1-使用-Hash-来替代自增-ID"><a href="#4-3-1-使用-Hash-来替代自增-ID" class="headerlink" title="#4.3.1. 使用 Hash 来替代自增 ID"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-1-%E4%BD%BF%E7%94%A8-hash-%E6%9D%A5%E6%9B%BF%E4%BB%A3%E8%87%AA%E5%A2%9E-id">#</a>4.3.1. 使用 Hash 来替代自增 ID</h6><p>你可以使用 <a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/">HashedModuleIdsPlugin 插件</a>，它会根据模块的相对路径来计算 Hash 值。当然，你也可以使用 webpack 提供的 <a href="https://webpack.js.org/configuration/optimization/#optimizationmoduleids"><code>optimization.moduleIds</code></a>，将其设置为 <code>hash</code>，或者选择其他合适的方式。</p><h6 id="4-3-2-将-runtime-chunk-单独拆分出来"><a href="#4-3-2-将-runtime-chunk-单独拆分出来" class="headerlink" title="#4.3.2. 将 runtime chunk 单独拆分出来"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-2-%E5%B0%86-runtime-chunk-%E5%8D%95%E7%8B%AC%E6%8B%86%E5%88%86%E5%87%BA%E6%9D%A5">#</a>4.3.2. 将 runtime chunk 单独拆分出来</h6><p>通过 <a href="https://webpack.js.org/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 配置可以让 webpack 把包含 manifest 的 runtime 部分单独分离出来，这样就可以尽可能限制变动影响的文件范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: &#123;</span><br><span class="line">            name: <span class="string">&#x27;runtime&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你对 webpack 模块化 runtime 运行的原理不太了解，可以看看<a href="https://juejin.im/post/5b82ac82f265da431d0e6d25">这篇文章</a>[13]。</p></blockquote><h6 id="4-3-3-使用-records"><a href="#4-3-3-使用-records" class="headerlink" title="#4.3.3. 使用 records"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#_4-3-3-%E4%BD%BF%E7%94%A8-records">#</a>4.3.3. 使用 records</h6><p>你可以通过 <a href="https://webpack.js.org/configuration/other-options/#recordspath"><code>recordsPath</code></a> 配置来让 webpack 产出一个包含模块信息记录的 JSON 文件，其中包含了一些模块标识的信息，可以用于之后的编译。这样在后续的打包编译时，对于被拆分出来的 Bundle，webpack 就可以根据 records 中的信息来尽量避免破坏缓存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  recordsPath: path.join(__dirname, <span class="string">&#x27;records.json&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果对上述避免或减少缓存失效的方法感兴趣，也可以再读一读<a href="https://survivejs.com/webpack/optimizing/separating-manifest/#using-records">这篇文章</a>14。在 webpack v5.x 的计划中，也有<a href="https://github.com/webpack/changelog-v5/blob/master/README.md#deterministic-chunk-and-module-ids">针对 module 和 chunk ID 的一些工作计划来提高长期缓存</a>。</p><hr><p>这一部分就到这里了，我们基于减少不必要的请求、减少包体大小、降低解析与执行消耗、利用缓存这四个基本思想，展开去看了 JavaScript 资源的性能优化措施有哪些。</p><p>下面我们就会进入前端三驾马车中的 CSS 部分了！</p><p><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html"></a></p><hr><h4 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://github.com/tc39/proposal-dynamic-import">Proposal Dynamic Import</a></li><li><a href="https://www.jianshu.com/p/547aa7b92d8c">在 react-router4 中进行代码拆分</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">Module ngx_http_gzip_module</a></li><li><a href="https://webpack.js.org/guides/tree-shaking/">Tree Shaking - webpack</a></li><li><a href="https://juejin.im/post/5a4dc842518825698e7279a9">Tree Shaking 性能优化实践 - 原理篇</a></li><li><a href="https://www.zhihu.com/question/333421533/answer/764963886">Tree Shaking for Lodash</a></li><li><a href="https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage">CSS and JS code coverage - Chrome DevTools</a></li><li><a href="https://youtu.be/reztLS3vomE?t=1254">Chrome Dev Summit 2018</a></li><li><a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">Optimize your libraries with webpack</a></li><li><a href="https://w3c.github.io/longtasks/">Long Tasks API 1</a></li><li><a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">A Netflix Web Performance Case Study</a></li><li><a href="https://www.zhihu.com/question/20790576/answer/32602154">大公司里怎样开发和部署前端代码？</a></li><li><a href="https://juejin.im/post/5b82ac82f265da431d0e6d25">webpack进阶：前端运行时的模块化设计与实现</a></li><li><a href="https://survivejs.com/webpack/optimizing/separating-manifest/#using-records">Separating a Manifest</a></li><li><a href="https://v8.dev/blog/cost-of-javascript-2019">The cost of JavaScript in 2019</a></li><li>[<a href="https://juejin.im/post/5d1f27285188252f275fdbb6">译] 2019 年的 JavaScript 性能</a></li><li><a href="https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366">webpack 4: Code Splitting, chunk graph and the splitChunks optimization</a></li><li><a href="https://www.cnblogs.com/zhuxian8/p/7197356.html">文本压缩算法的对比和选择</a></li><li><a href="https://zhuanlan.zhihu.com/p/42418273">简单聊聊 GZIP 的压缩原理与日常应用</a></li><li><a href="https://www.sciencedirect.com/topics/computer-science/text-compression">Text Compression</a></li><li><a href="https://medium.com/webpack/better-tree-shaking-with-deep-scope-analysis-a0b788c0ce77">Better tree shaking with deep scope analysis</a></li><li><a href="https://dev.to/goenning/how-we-reduced-our-initial-jscss-size-by-67-3ac0">How we reduced our initial JS/CSS size by 67%</a></li></ol><h3 id="5-3CSS-优化"><a href="#5-3CSS-优化" class="headerlink" title="5.3CSS 优化"></a>5.3<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html">CSS 优化</a></h3><p>在这一部分，我们来详细看一看与 CSS 相关的优化内容。其中一部分内容与 JavaScript 部分类似，另一部分可能是 CSS 特有的一些优化或注意事项。</p><h4 id="1-关键-CSS"><a href="#1-关键-CSS" class="headerlink" title="#1. 关键 CSS"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_1-%E5%85%B3%E9%94%AE-css">#</a>1. 关键 CSS</h4><p>在性能优化上，其实我们会更关注关键渲染路径（Critical Rendering Path，即 CRP），而不一定是最快加载完整个页面。</p><p>CRP 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS。识别出当前业务中的关键 CSS，优先下载与解析它，将会帮助我们更好降低延迟。</p><p>所以我们首先还是需要先建立好概念：很多时候，我们并不是在追求整体页面的最快加载，而是最核心最关键的那部分。例如在视频网站上可能是播放器，在文档站点可能是阅读器。</p><p>由于很多时候，关键 CSS 不会太大，因此有一种常见的优化措施是，将关键 CSS 的内容通过 <code>&lt;style&gt;</code> 标签内联到 <code>&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS。这样对于关键路径的渲染可以减少一次 RTT (Round-Trip Time)。用户可以更快看到一些页面初始的渲染结果。</p><p>经典的<a href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a">骨架屏</a>[1]可以算是这种思路的一个延展。我们会生成一个不包含实际功能的静态页面，将必要的脚本、样式、甚至图片（base64）资源都内联到其中，当用户访问时直接先返回该页面，就可以很快让用户看到页面结果，之后在异步渐进加载预渲染，就会让用户感觉“很快”。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/fb-skeleton.d4ea2857.png" alt="facebook skeleton"></p><p>骨架屏可以<a href="https://css-tricks.com/building-skeleton-screens-css-custom-properties/">手动编写</a>[2]，当然也可以通过<a href="https://github.com/ElemeFE/page-skeleton-webpack-plugin">编译插件</a>来帮助你<a href="https://zhuanlan.zhihu.com/p/34702561">自动生成</a>[3]骨架屏。</p><h4 id="2-优化资源请求"><a href="#2-优化资源请求" class="headerlink" title="#2. 优化资源请求"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82">#</a>2. 优化资源请求</h4><h5 id="2-1-按需加载"><a href="#2-1-按需加载" class="headerlink" title="#2.1. 按需加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-1-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">#</a>2.1. 按需加载</h5><p>与 JavaScript 类似，我们的 CSS 也是可以按需加载的。尤其在当下组件化盛行的潮流里，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片。在上一部分介绍的 <a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#user-content-11-%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD">webpack code split</a> 也会包含这一部分。</p><p>除了使用一些构建工具以及对应的插件外，你也可以使用 <a href="https://github.com/filamentgroup/loadCSS">loadCSS</a> 这样的库来实现 CSS 文件的按需异步加载。</p><h5 id="2-2-合并文件"><a href="#2-2-合并文件" class="headerlink" title="#2.2. 合并文件"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-2-%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6">#</a>2.2. 合并文件</h5><p>同样的，参照 JavaScript，我们也可以把一些 CSS 文件进行合并来减少请求数。</p><h5 id="2-3-请求的优先级排序"><a href="#2-3-请求的优先级排序" class="headerlink" title="#2.3. 请求的优先级排序"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-3-%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%92%E5%BA%8F">#</a>2.3. 请求的优先级排序</h5><p>浏览器中的各类请求是有优先级排序的。低优请求会被排在高优之后再发送。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/priority.7e69b357.png" alt="network priority"></p><p>不过可惜的是，浏览器没有将优先级排序的能力给我们直接开放出来。但在一些场景下，我们可以通过更合理的使用媒体类型和媒体查询来实现资源加载的优先级。下面会介绍一下这种方法。</p><p>一些网站为了达到不同屏幕之间的兼容，可能会使用媒体查询的方式来构建它的样式系统。一般而言，我们都会把样式代码写在一起，例如导航的在各类屏幕下的样式都会放在 <code>navigator.css</code> 下，列表都会放在 <code>list.css</code> 下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里带来的一个问题就是，在宽度小于 400px 的场景下，其实并不需要应用宽度 400px 以上的 CSS 样式。针对这个问题，<code>link</code> 标签上其实有一个 <code>media</code> 属性来处理媒体查询下的加载优先级。浏览器会优先下载匹配当前环境的样式资源，相对的，其他非匹配的优先级会下降。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.small.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 500px)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;list.small.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 500px)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样拆分后，当页面大于 500 px 时，<code>navigator.small.css</code> 和 <code>list.small.css</code> 的优先级会降低，同时，<strong>它们也不再会阻塞页面的渲染</strong>。需要注意的是，优先级降低代表可能会后加载，并非不加载。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/priority-css.7c9b4fdb.png" alt="css network priority"></p><h5 id="2-4-慎用-import"><a href="#2-4-慎用-import" class="headerlink" title="#2.4. 慎用 @import"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-4-%E6%85%8E%E7%94%A8-import">#</a>2.4. 慎用 <code>@import</code></h5><p>CSS 提供了一个 <code>@import</code> 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p><p>考虑 <code>index.css</code> 这个资源，页面上是这么引用的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>而在 <code>index.css</code> 中引用了 <code>other.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.css */</span></span><br><span class="line"><span class="keyword">@import</span> url(other.css);</span><br></pre></td></tr></table></figure><p>这样浏览器只有当下载了 <code>index.css</code> 并解析到其中 <code>@import</code> 时，才会再去请求 <code>other.css</code>。这是一个串行过程。</p><p>而如果我们把它改造为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>那就不需要等待 <code>index.css</code> 下载，几乎是并行执行了。</p><h5 id="2-5-谨慎对待-JavaScript-脚本的位置"><a href="#2-5-谨慎对待-JavaScript-脚本的位置" class="headerlink" title="#2.5. 谨慎对待 JavaScript 脚本的位置"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_2-5-%E8%B0%A8%E6%85%8E%E5%AF%B9%E5%BE%85-javascript-%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%8D%E7%BD%AE">#</a>2.5. 谨慎对待 JavaScript 脚本的位置</h5><p>在<a href="https://alienzhou.com/projects/fe-performance-journey/4-parse/#1-%E6%B3%A8%E6%84%8F%E8%B5%84%E6%BA%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE">第四站「页面解析与处理」</a>中，我们提到将 “JavaScript 脚本放到页面尾部、CSS 放到页面头部”的模式。这只是大多数情况的处理方式。对于一些特殊情况，我们还是需要特殊处理的。</p><p>还记得之前提到的一些统计类、监控类的第三方脚本么？一般而言，第三方会提供你如下一段脚本，然后推荐你内联到页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们希望通过这样的方式来尽快异步加载脚本。然而，如果我们一不小心出现了下面这样的操作，可能会事与愿违：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时，<code>navigator.css</code> 的加载会阻塞后面的 JavaScript 执行，这是为了防止后续脚本对样式的查询出现不确定性。所以，这两个资源就变成了串行加载。</p><p>要优化这个问题很简单 —— 调换一下顺序即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">&#x27;vendor.lib.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;navigator.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这时，<code>vendor.lib.js</code> 和 <code>navigator.css</code> 就会并行加载了。当然，你需要确保不需要查询 <code>navigator.css</code> 样式应用后的信息。</p><h4 id="3-减少包体大小"><a href="#3-减少包体大小" class="headerlink" title="#3. 减少包体大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-%E5%87%8F%E5%B0%91%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F">#</a>3. 减少包体大小</h4><h5 id="3-1-压缩"><a href="#3-1-压缩" class="headerlink" title="#3.1. 压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-1-%E5%8E%8B%E7%BC%A9">#</a>3.1. 压缩</h5><p>CSS 同样可以进行压缩，与 JavaScript 类似，也有相应的 CSS uglify 工具，例如 <a href="https://github.com/jakubpawlowicz/clean-css">clean-css</a>，可以优化代码、删除多余的换行与空格。</p><p>同时，由于 CSS 同样是文本内容，因此针对文本的各类压缩算法同样适用，最常用到的就是 gzip。如何在 Nginx 上开启它<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/javascript.html#user-content-21-%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9">之前也介绍过</a>，这里就不赘述了。</p><h5 id="3-2-选择合适的兼容性"><a href="#3-2-选择合适的兼容性" class="headerlink" title="#3.2. 选择合适的兼容性"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_3-2-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">#</a>3.2. 选择合适的兼容性</h5><p>对于 CSS 的 polyfill，同样可以配合 browserslist 来实现你的业务场景下的兼容性支持。比较常见的是配合 <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> 和 <a href="https://github.com/csstools/postcss-preset-env">PostCSS Preset Env</a> 来使用。可以根据指定的浏览器范围，决定使用哪些 CSS polyfill 来帮助你将新的 CSS 代码转换为旧的浏览器能识别的内容。</p><h4 id="4-解析与渲染树构建"><a href="#4-解析与渲染树构建" class="headerlink" title="#4. 解析与渲染树构建"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93%E6%A0%91%E6%9E%84%E5%BB%BA">#</a>4. 解析与渲染树构建</h4><h5 id="4-1-简化选择器"><a href="#4-1-简化选择器" class="headerlink" title="#4.1. 简化选择器"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-1-%E7%AE%80%E5%8C%96%E9%80%89%E6%8B%A9%E5%99%A8">#</a>4.1. 简化选择器</h5><p>在 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a> 一文中，作者介绍了样式计算的原理。虽然文章发布时间比较早了，但其中部分内容还是具有参考价值的。</p><p>其中指出了，样式数据是一个超大的结构，为每一个元素查找匹配的规则会造成性能问题，同时，复杂的层叠规则也会带来很高的复杂度。针对这些问题<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation">浏览器也做了很多优化</a>[4]。</p><p>正是由于这些问题，我们应该尽量避免不必要的选择器复杂度。例如下面这个复杂选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">main</span><span class="selector-class">.container</span> &gt; <span class="selector-tag">section</span><span class="selector-class">.intro</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type</span>(odd) + <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> <span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.pdf&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="comment">/* …… */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般情况下我们是不会写出如此复杂的选择器的。但有一个情况还是需要注意一下，就是使用 SASS、LESS 这样的工具时，避免过多的嵌套。以 LESS 为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">    <span class="selector-class">.item</span> &#123;</span><br><span class="line">        <span class="selector-class">.product</span> &#123;</span><br><span class="line">            <span class="selector-class">.intro</span> &#123;</span><br><span class="line">                <span class="selector-class">.pic</span> &#123;</span><br><span class="line">                    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于过多的嵌套，编译后会产生如下选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span> <span class="selector-class">.item</span> <span class="selector-class">.product</span> <span class="selector-class">.intro</span> <span class="selector-class">.pic</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以考虑使用类似 <a href="https://en.bem.info/">BEM</a> 这样的方式来进行 <a href="https://www.jianshu.com/p/900e26060c09">CSS className 的组织与命名</a>[5]，避免过多的嵌套层级。这里有<a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/">一篇文章</a>[6]介绍了选择器的匹配成本。</p><p>不过千万要注意了，代码的可维护性还是最重要的，不要为了过分简化选择器而放弃了代码语义和可维护性。我们仅仅是要尽量避免像上面那样的一些过分复杂的、或者不必要的繁琐的选择器。</p><h5 id="4-2-避免使用昂贵的属性"><a href="#4-2-避免使用昂贵的属性" class="headerlink" title="#4.2. 避免使用昂贵的属性"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-2-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%98%82%E8%B4%B5%E7%9A%84%E5%B1%9E%E6%80%A7">#</a>4.2. 避免使用昂贵的属性</h5><p>有一些 CSS 的属性在渲染上是有比较高的成本的，渲染速度相较而言也会慢些。在不同的浏览器上，具体的表现不太一致，但总体来说，下面一些属性是比较昂贵的：</p><ul><li>border-radius</li><li>box-shadow</li><li>opacity</li><li>transform</li><li>filter</li><li>position: fixed</li></ul><h5 id="4-3-使用先进的布局方式"><a href="#4-3-使用先进的布局方式" class="headerlink" title="#4.3. 使用先进的布局方式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_4-3-%E4%BD%BF%E7%94%A8%E5%85%88%E8%BF%9B%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F">#</a>4.3. 使用先进的布局方式</h5><p>对于页面布局，我们有很多方法，例如 <a href="https://juejin.im/post/5b3b56a1e51d4519646204bb">float、positioning、flex、grid</a>[7] 等。float 本身设计出来并非是为了处理复杂的布局，但是通过大家的发掘和研究，已经可以通过它来实现很多种布局形式了。基于兼容性考虑，float 也成为了流行的布局方式。</p><p>不过，<a href="https://www.zhihu.com/question/271492607">一些资料</a>[8]也指出，使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。 flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局。同时，虽然 flex 有<a href="https://caniuse.com/#search=flex">兼容性要求</a>，但由于很多 PC 站都不再兼容低版本 IE，因此也可以开始尝试使用它。</p><p>如果你之前对 flex 了解不多，这里有一个不错的<a href="https://scrimba.com/g/gflexbox">教程</a>可以帮你快速入门。</p><h4 id="5-利用缓存"><a href="#5-利用缓存" class="headerlink" title="#5. 利用缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#_5-%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98">#</a>5. 利用缓存</h4><p>与其他静态资源类似，我们仍然可以使用<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">各类缓存策略</a>来加速资源的加载。</p><p>此外，如果使用 webpack 作为构建工具，我们一般会使用 css-loader 和 style-loader，这样可以直接在 JavaScript 代码中 import 样式文件。不过这样带来的一个问题就是样式代码其实是耦合在 JavaScript 代码中的，通过运行时添加 <code>style</code> 标签注入页面。</p><p>一个更好的做法是在生产环境中将样式信息单独抽离成 CSS 文件，这样也可以更好地利用缓存。在 webpack v4.x 之前的版本中，我们习惯于用 <a href="https://github.com/webpack-contrib/extract-text-webpack-plugin">ExtractTextWebpackPlugin</a> 插件。不过在 v4.x 之后，对于 CSS 的抽取，推荐使用 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/">MiniCssExtractPlugin</a> 插件。它可以将样式信息单独抽离出 CSS 文件来。基础的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&#x27;[contenthash:8].css&#x27;</span>,</span><br><span class="line">      chunkFilename: <span class="string">&#x27;[contenthash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>相较于 JavaScript，用户对 CSS 的可控性可能会稍弱一些，基础的优化点也许没有那么多。但随着 CSS 特性（例如 <a href="https://codersblock.com/blog/say-hello-to-houdini-and-the-css-paint-api/">Houdini/CSS Paint API</a>）的不断发展，相信也会有更多我们需要关注的优化点。</p><h4 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/css.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a">Everything you need to know about skeleton screens</a></li><li><a href="https://css-tricks.com/building-skeleton-screens-css-custom-properties/">Building Skeleton Screens with CSS Custom Properties</a></li><li><a href="https://zhuanlan.zhihu.com/p/34702561">自动化生成 H5 骨架页面</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://www.jianshu.com/p/900e26060c09">使用 BEM-constructor 构建 CSS</a></li><li><a href="https://www.sitepoint.com/optimizing-css-id-selectors-and-other-myths/">Optimizing CSS: ID Selectors and Other Myths</a></li><li><a href="https://juejin.im/post/5b3b56a1e51d4519646204bb">一篇全面的CSS布局学习指南(译)</a></li><li><a href="https://www.zhihu.com/question/271492607">flex布局对性能的影响主要体现在哪方面？</a></li><li><a href="https://csswizardry.com/2018/11/css-and-network-performance/">CSS and Network Performance</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css">Render Blocking CSS</a></li><li><a href="https://blog.nextzy.me/how-to-write-css-for-a-great-performance-web-application-edf75bb8a8cc">How to write CSS for a great performance web application</a></li><li><a href="https://www.sitepoint.com/optimizing-css-performance/">20 Tips for Optimizing CSS Performance</a></li></ol><h3 id="5-4图片优化"><a href="#5-4图片优化" class="headerlink" title="5.4图片优化"></a>5.4<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html">图片优化</a></h3><p>优质的图片可以有效吸引用户，给用户良好的体验，所以随着互联网的发展，越来越多的产品开始使用图片来提升产品体验。相较于页面其他元素，图片的体积不容忽视。下图是截止 2019 年 6 月 <a href="https://httparchive.org/reports/page-weight?view=grid">HTTP Archive</a>[1] 上统计的网站上各类资源加载的体积：</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/overall.51635114.png" alt="overall"></p><p>可以看到，图片占据了半壁江山。同样，在一篇 2018 年的文章中，也提到了<a href="https://dougsillars.com/2018/05/21/state-of-the-web-top-image-optimization-strategies/?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more">图片在网站中体量的平均占比已经超过了 50%</a>[2]。然而，随着平均加载图片总字节数的增加，图片的请求数却再减少，这也说明网站使用的图片质量和大小正在不断提高。</p><p>所以，如果单纯从加载的字节数这个维度来看性能优化，那么很多时候，优化图片带来的流量收益要远高于优化 JavaScript 脚本和 CSS 样式文件。下面我们就来看看，如何优化图片资源。</p><h4 id="1-优化请求数"><a href="#1-优化请求数" class="headerlink" title="#1. 优化请求数"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-%E4%BC%98%E5%8C%96%E8%AF%B7%E6%B1%82%E6%95%B0">#</a>1. 优化请求数</h4><h5 id="1-1-雪碧图"><a href="#1-1-雪碧图" class="headerlink" title="#1.1. 雪碧图"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-1-%E9%9B%AA%E7%A2%A7%E5%9B%BE">#</a>1.1. 雪碧图</h5><p>图片可以合并么？当然。最为常用的图片合并场景就是<a href="https://css-tricks.com/css-sprites/">雪碧图（Sprite）</a>[3]。</p><p>在网站上通常会有很多小的图标，不经优化的话，最直接的方式就是将这些小图标保存为一个个独立的图片文件，然后通过 CSS 将对应元素的背景图片设置为对应的图标图片。这么做的一个重要问题在于，页面加载时可能会同时请求非常多的小图标图片，这就会受到浏览器并发 HTTP 请求数的限制。我见过一个没有使用雪碧图的页面，首页加载时需要发送 20+ 请求来加载图标。将图标合并为一张大图可以实现「20+ → 1」的巨大缩减。</p><p>雪碧图的核心原理在于设置不同的背景偏移量，大致包含两点：</p><ul><li>不同的图标元素都会将 <code>background-url</code> 设置为合并后的雪碧图的 uri；</li><li>不同的图标通过设置对应的 <code>background-position</code> 来展示大图中对应的图标部分。</li></ul><p>你可以用 Photoshop 这类工具自己制作雪碧图。当然比较推荐的还是将雪碧图的生成集成到前端自动化构建工具中，例如在 webpack 中使用 <a href="https://github.com/mixtur/webpack-spritesmith">webpack-spritesmith</a>，或者在 gulp 中使用 <a href="https://github.com/twolfson/gulp.spritesmith">gulp.spritesmith</a>。它们两者都是基于于 <a href="https://github.com/twolfson/spritesmith">spritesmith</a> 这个库，你也可以自己将这个库集成到你喜欢的构建工具中。</p><h5 id="1-2-懒加载"><a href="#1-2-懒加载" class="headerlink" title="#1.2. 懒加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-2-%E6%87%92%E5%8A%A0%E8%BD%BD">#</a>1.2. 懒加载</h5><p>我们知道，一般来说我们访问一个页面，浏览器加载的整个页面其实是要比可视区域大很多的，也是什么我们会提出“首屏”的概念。这就导致其实很多图片是不在首屏中的，如果我们都加载的话，相当于是加载了用户不一定会看到图片。而图片体积一般都不小，这显然是一种流量的浪费。这种场景在一些带图片的长列表或者配图的博客中经常会遇到。</p><p>解决的核心思路就是图片懒加载 —— 尽量只加载用户正在浏览或者即将会浏览到的图片。实现上来说最简单的就是通过监听页面滚动，判断图片是否进入视野，从而真正去加载图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadIfNeeded</span>(<span class="params">$img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bounding = $img..getBoundingClientRect();</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        getComputedStyle($img).display !== <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &amp;&amp; bounding.top &lt;= <span class="built_in">window</span>.innerHeight</span><br><span class="line">        &amp;&amp; bounding.bottom &gt;= <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        $img.src = $img.dataset.src;</span><br><span class="line">        $img.classList.remove(<span class="string">&#x27;lazy&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用了 throttle，你可以实现自己的 throttle，也可以使用 lodash</span></span><br><span class="line"><span class="keyword">const</span> lazy = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> $imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.lazy&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ($imgList.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazy);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;resize&#x27;</span>, lazy);</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;orientationchange&#x27;</span>, lazy);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $imgList.forEach(loadIfNeeded);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazy);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, lazy);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;orientationchange&#x27;</span>, lazy);</span><br></pre></td></tr></table></figure><p>对于页面上的元素只需要将原本的 <code>src</code> 值设置到 <code>data-src</code> 中即可，而 <code>src</code> 可以设置为一个统一的占位图。注意，由于页面滚动、缩放和横竖方向（移动端）都可能会改变可视区域，因此添加了三个监听。</p><p>当然，这是最传统的方法，现代浏览器还提供了一个更先进的 <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">Intersection Observer API</a>[4] 来做这个事，它可以通过更高效的方式来监听元素是否进入视口。考虑兼容性问题，在生产环境中建议使用对应的 <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill">polyfill</a>。</p><p>如果想使用懒加载，还可以借助一些已有的工具库，例如 <a href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a>、<a href="https://github.com/verlok/lazyload">verlok/lazyload</a>、<a href="https://github.com/tuupola/lazyload">tuupola/lazyload</a> 等。</p><p>在使用懒加载时也有一些注意点：</p><ul><li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li><li>设置合理的占位图，避免图片加载后的页面“抖动”。</li><li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup。</li></ul><p>对于占位图这块可以再补充一点。为了更好的用户体验，我们可以使用一个基于原图生成的体积小、清晰度低的图片作为占位图。这样一来不会增加太大的体积，二来会有很好的用户体验。<a href="https://www.guypo.com/introducing-lqip-low-quality-image-placeholders">LQIP (Low Quality Image Placeholders)</a>[5] 就是这种技术。目前也已经有了 <a href="https://github.com/zouhir/lqip">LQIP</a> 和 <a href="https://github.com/axe312ger/sqip">SQIP(SVG-based LQIP)</a> 的自动化工具可以直接使用。</p><p>如果你想了解更多关于图片懒加载的内容，这里有一篇更详尽的<a href="https://css-tricks.com/the-complete-guide-to-lazy-loading-images/">图片懒加载指南</a>[6]。</p><h5 id="1-3-CSS-中的图片懒加载"><a href="#1-3-CSS-中的图片懒加载" class="headerlink" title="#1.3. CSS 中的图片懒加载"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-3-css-%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">#</a>1.3. CSS 中的图片懒加载</h5><p>除了对于 <code>&lt;img&gt;</code> 元素的图片进行来加载，在 CSS 中使用的图片一样可以懒加载，最常见的场景就是 <code>background-url</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.login</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>-url: <span class="built_in">url</span>(<span class="string">/static/img/login.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个样式规则，如果不应用到具体的元素，浏览器不会去下载该图片。所以你可以通过切换 className 的方式，放心得进行 CSS 中图片的懒加载。</p><h5 id="1-4-内联-base64"><a href="#1-4-内联-base64" class="headerlink" title="#1.4. 内联 base64"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_1-4-%E5%86%85%E8%81%94-base64">#</a>1.4. 内联 base64</h5><p>还有一种方式是将图片转为 base64 字符串，并将其内联到页面中返回，即将原 url 的值替换为 base64。这样，当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可。</p><p>但是这种方式的一个缺点在于相同的图片，相比使用二进制，变成 base64 后体积会增大 33%。而全部内联进页面后，也意味着原本可能并行加载的图片信息，都会被放在页面请求中（像当于是串行了）。同时这种方式也不利于复用独立的文件缓存。所以，使用 base64 需要权衡，常用于首屏加载 CRP 或者骨架图上的一些小图标。</p><h4 id="2-减小图片大小"><a href="#2-减小图片大小" class="headerlink" title="#2. 减小图片大小"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-%E5%87%8F%E5%B0%8F%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F">#</a>2. 减小图片大小</h4><h5 id="2-1-使用合适的图片格式"><a href="#2-1-使用合适的图片格式" class="headerlink" title="#2.1. 使用合适的图片格式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-1-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F">#</a>2.1. 使用合适的图片格式</h5><p>使用合适的图片格式不仅能帮助你减少不必要的请求流量，同时还可能提供更好的图片体验。</p><p>图片格式是一个比较大的话题，<a href="https://www.sitepoint.com/what-is-the-right-image-format-for-your-website/">选择合适的格式</a>[7]有利于性能优化。这里我们简单总结一些。</p><p><strong>1) 使用 WebP：</strong></p><p>考虑<a href="https://css-tricks.com/using-webp-images/">在网站上使用 WebP 格式</a>[8]。在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式。WebP 无损压缩比 PNG 的体积小 26%，webP 的有损压缩比同质量的 JPEG 格式体积小 25-34%。同时 WebP 也支持透明度。下面提供了一种兼容性较好的写法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/static/img/perf.webp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/static/img/perf.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/img/perf.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2) 使用 SVG 应对矢量图场景：</strong></p><p>在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错。有时使用 SVG 格式会比相同的 PNG 或 JPEG 更小。</p><p><strong>3) 使用 video 替代 GIF：</strong></p><p>在<a href="https://caniuse.com/#feat=video">兼容性允许</a>的情况下考虑，可以在想要动图效果时使用视频，通过静音（muted）的 video 来代替 GIF。相同的效果下，<a href="https://youtu.be/reztLS3vomE?t=158">GIF 比视频（MPEG-4）大 5～20 倍</a>。<a href="https://www.smashingmagazine.com/2018/11/gif-to-video/">Smashing Magazine 上有篇文章</a>[9]详细介绍使用方式。</p><p><strong>4) 渐进式 JPEG：</strong></p><p>基线 JPEG (baseline JPEG) 会从上往下逐步呈现，类似下面这种：</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/baseline-jpeg.12d690f4.jpeg" alt="baseline jpeg"></p><p>而另一种<a href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式 JPEG (progressive JPEG)</a>[10] 则会从模糊到逐渐清晰，使人的感受上会更加平滑。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/progressive-jpeg.9dc04432.jpeg" alt="progressive jpeg"></p><p>不过渐进式 JPEG 的解码速度会慢于基线 JPEG，所以还是需要综合考虑 CPU、网络等情况，在实际的用户体验之上做权衡。</p><h5 id="2-2-图片质量的权衡"><a href="#2-2-图片质量的权衡" class="headerlink" title="#2.2. 图片质量的权衡"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-2-%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E7%9A%84%E6%9D%83%E8%A1%A1">#</a>2.2. 图片质量的权衡</h5><p>图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression）。顾名思义，有损压缩下，会损失一定的图片质量，无损压缩则能够在保证图片质量的前提下压缩数据大小。不过，无损压缩一般可以带来更可观的体积缩减。在使用有损压缩时，一般我们可以指定一个 0-100 的压缩质量。在大多数情况下，相较于 100 质量系数的压缩，80～85 的质量系数可以带来 30～40% 的大小缩减，同时对图片效果影响较小，即人眼不易分辨出质量效果的差异。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/jpeg-quality.db4579d5.jpg" alt="jpeg quality"></p><p>处理图片压缩可以使用 <a href="https://github.com/imagemin/imagemin">imagemin</a> 这样的工具，也可以进一步将它集成至 <a href="https://github.com/tcoopman/image-webpack-loader">webpack</a>、<a href="https://github.com/sindresorhus/gulp-imagemin">Gulp</a>、<a href="https://github.com/gruntjs/grunt-contrib-imagemin">Grunt</a> 这样的自动化工具中。</p><h5 id="2-3-使用合适的大小和分辨率"><a href="#2-3-使用合适的大小和分辨率" class="headerlink" title="#2.3. 使用合适的大小和分辨率"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-3-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87">#</a>2.3. 使用合适的大小和分辨率</h5><p>由于移动端的发展，屏幕尺寸更加多样化了。同一套设计在不同尺寸、像素比的屏幕上可能需要不同像素大小的图片来保证良好的展示效果；此外，响应式设计也会对不同屏幕上最佳的图片尺寸有不同的要求。</p><p>以往我们可能会在 1280px 宽度的屏幕上和 640px 宽度的屏幕上都使用一张 400px 的图，但很可能在 640px 上我们只需要 200px 大小的图片。另一方面，对于如今盛行的“2 倍屏”、“3 倍屏”也需要使用不同像素大小的资源。</p><p>好在 HTML5 在 <code>&lt;img&gt;</code> 元素上为我们提供了 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-srcset"><code>srcset</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes"><code>sizes</code></a> 属性，可以让浏览器根据屏幕信息选择需要展示的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;small.jpg 480w, large.jpg 1080w&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;50w&quot;</span> <span class="attr">src</span>=<span class="string">&quot;large.jpg&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>具体的使用方式可以看<a href="https://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/">这篇文章</a>[11]。</p><h5 id="2-4-删除冗余的图片信息"><a href="#2-4-删除冗余的图片信息" class="headerlink" title="#2.4. 删除冗余的图片信息"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-4-%E5%88%A0%E9%99%A4%E5%86%97%E4%BD%99%E7%9A%84%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF">#</a>2.4. 删除冗余的图片信息</h5><p>你也许不知道，很多图片含有一些非“视觉化”的元信息（metadata），带上它们可会<a href="https://www.keycdn.com/blog/image-metadata">导致体积增大与安全风险</a>[12]。元信息包括图片的 DPI、相机品牌、拍摄时的 GPS 等，可能导致 JPEG 图片大小增加 15%。同时，其中的一些隐私信息也可能会带来安全风险。</p><p>所以如果不需要的情况下，可以使用像 <a href="https://imageoptim.com/versions">imageOptim</a> 这样的工具来移除隐私与非关键的元信息。</p><h5 id="2-5-SVG-压缩"><a href="#2-5-SVG-压缩" class="headerlink" title="#2.5 SVG 压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_2-5-svg-%E5%8E%8B%E7%BC%A9">#</a>2.5 SVG 压缩</h5><p>在 2.1. 中提到，合适的场景下可以使用 SVG。针对 SVG 我们也可以进行一些压缩。压缩包括了两个方面：</p><p>首先，与图片不同，图片是二进制形式的文件，而 SVG 作为一种 XML 文本，同样是适合使用 gzip 压缩的。</p><p>其次，SVG 本身的信息、数据是可以压缩的，例如用相比用 <code>&lt;path&gt;</code> 画一个椭圆，直接使用 <code>&lt;ellipse&gt;</code> 可以节省文本长度。关于信息的“压缩”还有<a href="https://css-tricks.com/understanding-and-manually-improving-svg-optimization/">更多可以优化的点</a>[13]。<a href="https://github.com/svg/svgo">SVGGO</a> 是一个可以集成到我们构建流中的 NodeJS 工具，它能帮助我们进行 SVG 的优化。当然你也可以使用它提供的 <a href="https://jakearchibald.github.io/svgomg/">Web 服务</a>。</p><h4 id="3-缓存"><a href="#3-缓存" class="headerlink" title="#3. 缓存"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#_3-%E7%BC%93%E5%AD%98">#</a>3. 缓存</h4><p>与其他静态资源类似，我们仍然可以使用<a href="https://alienzhou.com/projects/fe-performance-journey/1-cache/">各类缓存策略</a>来加速资源的加载。</p><hr><p>图片作为现代 Web 应用的重要部分，在资源占用上同样也不可忽视。可以发现，在上面提及的各类优化措施中，同时附带了相应的工具或类库。平时我们主要的精力会放在 CSS 与 JavaScript 的优化上，因此在图片优化上可能概念较为薄弱，自动化程度较低。如果你希望更好得去贯彻图片的相关优化，非常建议将自动化工具引入到构建流程中。</p><p>除了上述的一些工具，这里再介绍两个非常好用的图片处理的自动化工具：<a href="https://github.com/lovell/sharp">Sharp</a> 和 <a href="https://github.com/oliver-moran/jimp">Jimp</a>。</p><hr><h4 id="参考资料-4"><a href="#参考资料-4" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/image.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://httparchive.org/reports/page-weight?view=grid">HTTP Archive: Page Weight Report</a></li><li><a href="https://dougsillars.com/2018/05/21/state-of-the-web-top-image-optimization-strategies/">State of the Web: Top Image Optimization Strategies</a></li><li><a href="https://css-tricks.com/css-sprites/">CSS Sprites: What They Are, Why They’re Cool, and How To Use Them</a></li><li><a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">IntersectionObserver’s Coming into View</a></li><li><a href="https://www.guypo.com/introducing-lqip-low-quality-image-placeholders">Introducing LQIP – Low Quality Image Placeholders</a></li><li><a href="https://css-tricks.com/the-complete-guide-to-lazy-loading-images/">The Complete Guide to Lazy Loading Images</a></li><li><a href="https://www.sitepoint.com/what-is-the-right-image-format-for-your-website/">What Is the Right Image Format for Your Website?</a></li><li><a href="https://css-tricks.com/using-webp-images/">Using WebP Images</a></li><li><a href="https://www.smashingmagazine.com/2018/11/gif-to-video/">Improve Animated GIF Performance With HTML5 Video</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式jpeg(progressive jpeg)图片及其相关</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/">响应式图片srcset全新释义sizes属性w描述符</a></li><li><a href="https://www.keycdn.com/blog/image-metadata">An Overview of Image Metadata - How It Affects Web Performance and Security</a></li><li><a href="https://css-tricks.com/understanding-and-manually-improving-svg-optimization/">Understanding and Manually Improving SVG Optimization</a></li><li><a href="https://images.guide/">Essential Image Optimization Guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/50280008">见微知著，Google Photos Web UI 完善之旅</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/">Automating image optimization</a></li><li><a href="http://deanhume.com/lazy-loading-images-using-intersection-observer/">Lazy loading images using Intersection Observer</a></li><li><a href="https://developers.google.com/web/updates/2019/02/intersectionobserver-v2">Trust is Good, Observation is Better—Intersection Observer v2</a></li><li><a href="https://web.dev/image-policies/">Image policies for fast load times and more</a></li></ol><h3 id="5-5字体优化"><a href="#5-5字体优化" class="headerlink" title="5.5字体优化"></a>5.5<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html">字体优化</a></h3><p>有些时候，内置的字体并不能满足我们的需求，如果我们希望使用一些更有设计性的字体，我们一般会使用 <code>@font-face</code> 来加载字体文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这种方式的一大问题在于，在字体加载的期间，浏览器页面是默认不展示文本内容的。即我们常说的 FOIT (Flash of Invisible Text)。在现代浏览器中，FOIT 持续至多 3 秒，会带来糟糕的用户体验。所以在字体这部分的性能优化中，主要关注点在于如何平滑的加载字体。下面有一些解决方案。</p><h4 id="1-font-display"><a href="#1-font-display" class="headerlink" title="#1. font-display"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_1-font-display">#</a>1. font-display</h4><p>你可以在 <code>@font-face</code> 中设置 <code>font-display: swap</code>，他可以让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，即先会使用默认字体样式展示文本，字体加载完毕后再将文本的字体样式进行替换。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">    <span class="attribute">font-display</span>: swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>font-display 的取值包括 <code>auto|block|swap|fallback|optional</code>，这里详细介绍了<a href="https://developers.google.com/web/updates/2016/02/font-display">各种值的使用场景</a>[1]。不过目前该属性的<a href="https://caniuse.com/#feat=css-font-rendering-controls">兼容性一般</a>。</p><h4 id="2-内联字体"><a href="#2-内联字体" class="headerlink" title="#2. 内联字体"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_2-%E5%86%85%E8%81%94%E5%AD%97%E4%BD%93">#</a>2. 内联字体</h4><p>我们在上一节介绍过，可以使用 base64 将图片“内联”到页面中。同样的，字体也可以使用这种方式，这样就避免异步加载字体时的 FOIT 或 FOUT。我们可以将字体文件转为 base64 的字符串，设置到 <code>@font-face</code> 里的 <code>src</code> 属性上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方式的局限性在于，在一个 <code>@font-face</code> 中只能加载加载一种字体类型。同时，与使用内联图片一样，这也会将本可以并行请求的数据量变为串行。</p><h4 id="3-使用-CSS-Font-Loading-API"><a href="#3-使用-CSS-Font-Loading-API" class="headerlink" title="#3. 使用 CSS Font Loading API"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_3-%E4%BD%BF%E7%94%A8-css-font-loading-api">#</a>3. 使用 CSS Font Loading API</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API">CSS Font Loading API</a> 是浏览器提供的，可以用来自定义控制字体加载的 API。这样你就可以在 JavaScript 中进行字体的加载，等加载完成后，再将需要应用新字体的元素设置为对应的样式，例如添加一个对应的 className。这里介绍了<a href="https://medium.com/@matuzo/getting-started-with-css-font-loading-e24e7ffaa791">如何使用 CSS Font Loading API</a>[2]。</p><p>不过目前 <a href="https://caniuse.com/#feat=font-loading">CSS Font Loading API 的兼容性</a>也不乐观。同时，由于一些困难也<a href="https://github.com/bramstein/fontloader#deprecated">无法实现一个完美的 polyfill</a>。因此如果想要使用类似的能力，可以考虑 <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a>这个库。基本的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> font = <span class="keyword">new</span> FontFaceObserver(<span class="string">&#x27;Samplefont&#x27;</span>);</span><br><span class="line"></span><br><span class="line">font.load(<span class="literal">null</span>, <span class="number">5000</span>).then(</span><br><span class="line">    () =&gt; <span class="built_in">document</span>.documentElement.classList.add(<span class="string">&#x27;loaded&#x27;</span>),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">&#x27;Font is not available&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loaded</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Samplefont, sans-serif;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-FOFT"><a href="#4-FOFT" class="headerlink" title="#4. FOFT"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#_4-foft">#</a>4. FOFT</h4><p>在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p><p>首先你需要了解的是，对于一种字体，它的斜体与粗体是有专门的字符集的；与此同时，如果你指定了某种字体的粗体，但浏览器没有加载，那么你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-synthesis"><code>font-synthesis</code></a> 属性来让浏览器帮你模拟。而当实际的粗体或斜体加载完毕后，再使用实际的字体集。</p><p>具体实践起会借助上面提到的 CSS Font Loading API 或者 Font Face Observer，实现当字体加载完毕后的样式修改。</p><hr><p>了解完字体的优化措施你会发现，它们主要集中于 <strong>如何通过加载策略来降低甚至消除 FOIT</strong>。当然上面提到的这些策略与技术你可以组合使用，以达到所需的优化效果。</p><p>如果还想了解更多关于字体加载的问题，可以看看这篇文章里总结的<a href="https://www.zachleat.com/web/comprehensive-webfonts/">各类加载策略</a>[3]，它还随文提供了相应的代码示例。</p><p><img data-src="https://alienzhou.com/projects/fe-performance-journey/assets/img/font-strategies.ef47066c.svg" alt="font strategy"></p><h4 id="参考资料-5"><a href="#参考资料-5" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/font.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://developers.google.com/web/updates/2016/02/font-display">Controlling Font Performance with font-display</a></li><li><a href="https://medium.com/@matuzo/getting-started-with-css-font-loading-e24e7ffaa791">Getting started with CSS Font Loading</a></li><li><a href="https://www.zachleat.com/web/comprehensive-webfonts/">A COMPREHENSIVE GUIDE TO FONT LOADING STRATEGIES</a></li></ol><h3 id="5-6视频优化"><a href="#5-6视频优化" class="headerlink" title="5.6视频优化"></a>5.6<a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html">视频优化</a></h3><p>视频作为一种重要的媒体形态，在网站中使用可以提高网站内容的丰富性，但同时对网络加载来说也是一个负担。所以会出现一些如下针对 Web 上视频的优化。</p><h4 id="1-使用合适的视频格式"><a href="#1-使用合适的视频格式" class="headerlink" title="#1. 使用合适的视频格式"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_1-%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F">#</a>1. 使用合适的视频格式</h4><p>与图片类似，不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4。除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。</p><p>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，不过<a href="https://caniuse.com/#feat=webm">兼容性相对来说也较差</a>。因此可以考虑在 <code>&lt;video&gt;</code> 中指定多个 <code>&lt;source&gt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/static/video/me.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/static/video/me.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，使用 <a href="https://www.youtube.com/watch?v=04lXWMcwdXA">AV1 编码</a>[1]会比 <a href="https://youtu.be/reztLS3vomE?t=356">VP9(WebM) 小约30%，比 x264(MPEG-4) 小约45-50%</a>[2]。</p><h4 id="2-视频压缩"><a href="#2-视频压缩" class="headerlink" title="#2. 视频压缩"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_2-%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9">#</a>2. 视频压缩</h4><p>对于视频，我们也可以进行有损与无损压缩，同样可以有效减少视频大小。下面列举了一些常用的工具：</p><ul><li><a href="https://handbrake.fr/">HandBrake</a></li><li><a href="https://www.freemake.com/free_video_converter/">Freemake</a></li><li><a href="http://www.selur.de/">Hybrid</a></li><li><a href="https://sourceforge.net/projects/megui/">MeGUI</a></li></ul><h4 id="3-移除不必要的音轨信息"><a href="#3-移除不必要的音轨信息" class="headerlink" title="#3. 移除不必要的音轨信息"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_3-%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%9F%B3%E8%BD%A8%E4%BF%A1%E6%81%AF">#</a>3. 移除不必要的音轨信息</h4><p>在上一节中我们提到，可以使用 <code>&lt;video&gt;</code> 代替 GIF 来实现动画，同时体积也会更小。由于在这种场景下本身就是不需要声音的，所以我们会将 <code>&lt;video&gt;</code> 设置为 <code>muted</code>。</p><p>那么，既然不需要声音，我们是不是可以直接移除掉音轨的数据？是的，这样做也会帮助进一步缩减视频的体积。</p><h4 id="4-使用“流”"><a href="#4-使用“流”" class="headerlink" title="#4. 使用“流”"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_4-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%B5%81%E2%80%9D">#</a>4. 使用“流”</h4><p>尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术。简单来说，使用 HLS 技术，你的视频会包含一个 <code>.m3u8</code> 的索引文件和一系列包含播放内容的 <code>.ts</code> 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p><p>你也可以尝试使用 <a href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP">MPEG-DASH</a>[3] 这个技术，目前开源社区也有一个配套的<a href="https://github.com/Dash-Industry-Forum/dash.js">客户端实现</a>。</p><h4 id="5-移除不必要的视频"><a href="#5-移除不必要的视频" class="headerlink" title="#5. 移除不必要的视频"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#_5-%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%A7%86%E9%A2%91">#</a>5. 移除不必要的视频</h4><p>对于不需要使用视频的场景，最好的优化方法就是去掉视频。例如在小屏幕上，你可以通过媒体查询来避免下载视频：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">650px</span>) &#123;</span><br><span class="line">    <span class="selector-id">#hero-video</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于视频的优化这里只介绍了一些基本的手段，但对于一个重度的视频网站来说，会包含例如播放器 SDK 的优化、数据预取、码率自适应等更多的优化内容，在 2019 GMTC 上，[B站分享了他们的缩减首帧耗时的一系列优化措施](<a href="https://static001.geekbang.org/con/42/pdf/3841774823/file/%E8%B0%AD%E5%85%86%E6%AD%86%E2%80%94GMTC">https://static001.geekbang.org/con/42/pdf/3841774823/file/谭兆歆—GMTC</a> B站的视频体验进化之路 - bilibili .pdf)[4]。所以这里算是一个抛砖引玉。</p><p>此外，虽然上面介绍了一些视频处理的软件工具，但是如果有更高的定制化或集成需求，建议使用 <a href="https://www.ffmpeg.org/">FFmpeg</a>[5] 或其<a href="https://github.com/FFmpeg/FFmpeg#libraries">背后的这些包</a>。</p><h4 id="参考资料-6"><a href="#参考资料-6" class="headerlink" title="#参考资料"></a><a href="https://alienzhou.com/projects/fe-performance-journey/5-subresources/video.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a>参考资料</h4><ol><li><a href="https://www.youtube.com/watch?v=04lXWMcwdXA">a technial overview of the AV1</a></li><li><a href="https://youtu.be/reztLS3vomE?t=356">Speed Essentials: Key Techniques for Fast Websites (Chrome Dev Summit 2018)</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP">Dynamic Adaptive Streaming over HTTP (Wikipedia)</a></li><li>[B 站的视频体验进化之路](<a href="https://static001.geekbang.org/con/42/pdf/3841774823/file/%E8%B0%AD%E5%85%86%E6%AD%86%E2%80%94GMTC">https://static001.geekbang.org/con/42/pdf/3841774823/file/谭兆歆—GMTC</a> B站的视频体验进化之路 - bilibili .pdf)</li><li><a href="https://www.ffmpeg.org/">FFmepg</a></li><li><a href="https://www.keycdn.com/blog/video-optimization">8 Video Optimization Tips for Faster Loading Times</a></li><li><a href="https://rigor.com/blog/optimizing-mp4-video-for-fast-streaming">Optimizing MP4 Video for Fast Streaming</a></li><li><a href="https://blog.catchpoint.com/2017/06/16/web-performance-101-video-optimization/">Web Performance 101: Video Optimization</a></li></ol><h1 id="3-重排-reflow-和重绘-repaint"><a href="#3-重排-reflow-和重绘-repaint" class="headerlink" title="3.重排(reflow)和重绘(repaint)"></a>3.重排(reflow)和重绘(repaint)</h1><h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；</p><p>2.CSS 被 CSS 解析器解析成 CSSOM 树；</p><p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p><p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p><p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af501e710ce67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。</p><p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p><h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul><li>页面初始渲染，这是开销最大的一次重排</li><li>添加/删除可见的DOM元素</li><li>改变元素位置</li><li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li><li>改变元素内容，比如文字数量，图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，比如resize事件发生时</li><li>激活CSS伪类（例如：<code>:hover</code>）</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><table><thead><tr><th>常见引起重排属性和方法</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border-width</td><td>border</td><td>position</td></tr><tr><td>overflow</td><td>font-size</td><td>vertical-align</td><td>min-height</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>clientTop</td><td>clientLeft</td></tr><tr><td>offsetWudth</td><td>offsetHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>scrollIntoView()</td><td>scrollTo()</td><td>getComputedStyle()</td><td></td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewIfNeeded()</td><td></td><td></td></tr></tbody></table><h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;&#x2F;strong&gt;BDing&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p><h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table><thead><tr><th>属性：</th><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td>background-size</td><td></td></tr></tbody></table><h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">var left &#x3D; 10;</span><br><span class="line">var top &#x3D; 10;</span><br><span class="line">el.style.left &#x3D; left + &quot;px&quot;;</span><br><span class="line">el.style.top &#x3D; top + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当top和left的值是动态计算而成时...</span><br><span class="line">&#x2F;&#x2F; better </span><br><span class="line">el.style.cssText +&#x3D; &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.className +&#x3D; &quot; className&quot;;</span><br></pre></td></tr></table></figure><h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad 强制刷新 触发四次重排+重绘</span><br><span class="line">div.style.left &#x3D; div.offsetLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; div.offsetTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; div.offsetRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; div.offsetBottom + 1 + &#39;px&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span><br><span class="line">var curLeft &#x3D; div.offsetLeft;</span><br><span class="line">var curTop &#x3D; div.offsetTop;</span><br><span class="line">var curRight &#x3D; div.offsetRight;</span><br><span class="line">var curBottom &#x3D; div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left &#x3D; curLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; curTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; curRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; curBottom + 1 + &#39;px&#39;;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 根据上面的结论</span><br><span class="line">* 将 2d transform 换成 3d</span><br><span class="line">* 就可以强制开启 GPU 加速</span><br><span class="line">* 提高动画性能</span><br><span class="line">*&#x2F;</span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(10px, 10px, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af50e460d9a23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ul><li>蓝色: 网络通信和HTML解析</li><li>黄色: JavaScript执行</li><li>紫色: 样式计算和布局，即重排</li><li>绿色: 重绘</li></ul><p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af5139b7ba71b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li><li>CSS3 就是在 GPU 发生的：Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://segmentfault.com/a/1190000017491520">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a></p><p><a href="https://csstriggers.com/">csstriggers</a></p><p><a href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/">CSS硬件加速的好与坏</a></p><h1 id="4-白屏时间"><a href="#4-白屏时间" class="headerlink" title="4.白屏时间"></a>4.白屏时间</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。</p><blockquote><p>白屏时间的长短将直接影响用户对该网站的第一印象。</p></blockquote><h2 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h2><p>当用户点开一个链接或者是直接在浏览器中输入URL开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。</p><h2 id="三、白屏是一个怎样的过程呢？"><a href="#三、白屏是一个怎样的过程呢？" class="headerlink" title="三、白屏是一个怎样的过程呢？"></a>三、白屏是一个怎样的过程呢？</h2><blockquote><p>让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！</p></blockquote><h3 id="1-DNS-Lookup"><a href="#1-DNS-Lookup" class="headerlink" title="1. DNS Lookup"></a>1. DNS Lookup</h3><blockquote><p>DNS Lookup 即浏览器从DNS服务器中进行域名查询。</p></blockquote><p>浏览器会先对页面进行<a href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>，获取到服务器的IP地址后，进而和服务器进行通信。</p><p>Tips: 通常在整个加载页面的过程中，浏览器会多次进行DNS Lookup，包括页面本身的域名查询以及在解析HTML页面时加载的JS、CSS、Image、Video等资源产生的域名查询。</p><h3 id="2-建立TCP请求连接"><a href="#2-建立TCP请求连接" class="headerlink" title="2. 建立TCP请求连接"></a>2. 建立TCP请求连接</h3><p>浏览器和服务端TCP请求建立的过程，是基于TCP/IP，该协议由网络层的IP和传输层的TCP组成。IP是每一台互联网设备在互联网中的唯一地址。</p><p>TCP通过三次握手建立连接，并提供可靠的数据传输服务。</p><h3 id="3-服务端请求处理响应"><a href="#3-服务端请求处理响应" class="headerlink" title="3. 服务端请求处理响应"></a>3. 服务端请求处理响应</h3><p>在TCP连接建立后，Web服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。</p><p>Web服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS文件、静态HTML直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。</p><blockquote><p>在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据</p></blockquote><h3 id="4-客户端下载、解析、渲染显示页面"><a href="#4-客户端下载、解析、渲染显示页面" class="headerlink" title="4. 客户端下载、解析、渲染显示页面"></a>4. 客户端下载、解析、渲染显示页面</h3><p>在服务器返回数据后，客户端浏览器接收数据，进行HTML下载、解析、渲染显示。</p><ul><li>a. 如果是Gzip包，则先解压为HTML</li><li>b. 解析HTML的头部代码，下载头部代码中的样式资源文件或脚本资源文件</li><li>c. 解析HTML代码和样式文件代码，构建HTML的DOM树以及与CSS相关的CSSOM树</li><li>d. 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树</li><li>e. 根据渲染树完成绘制过程</li></ul><p>浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。</p><p>Tips:浏览器安全解析策略对解析HTML造成的影响：</p><ul><li>当解析HTML时遇到内联JS代码，会阻塞DOM树的构建</li><li>特别悲惨的情况： 当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时！！！根据浏览器的安全解析策略，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。 一定要合理放置JS代码！！！</li></ul><h2 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h2><p>至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。</p><h3 id="1-DNS解析优化"><a href="#1-DNS解析优化" class="headerlink" title="1. DNS解析优化"></a>1. DNS解析优化</h3><p>针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。</p><ul><li>DNS缓存优化</li><li>DNS预加载策略</li><li>稳定可靠的DNS服务器</li></ul><h3 id="2-TCP网络链路优化"><a href="#2-TCP网络链路优化" class="headerlink" title="2. TCP网络链路优化"></a>2. TCP网络链路优化</h3><p>针对网络链路的优化，好像除了花钱没有什么更好的方式！</p><h3 id="3-服务端处理优化"><a href="#3-服务端处理优化" class="headerlink" title="3. 服务端处理优化"></a>3. 服务端处理优化</h3><p>服务端的处理优化，是一个非常庞大的话题，会涉及到如<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等…</p><h3 id="4-浏览器下载、解析、渲染页面优化"><a href="#4-浏览器下载、解析、渲染页面优化" class="headerlink" title="4. 浏览器下载、解析、渲染页面优化"></a>4. 浏览器下载、解析、渲染页面优化</h3><p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p><ul><li>尽可能的精简HTML的代码和结构</li><li>尽可能的优化CSS文件和结构</li><li>一定要合理的放置JS代码，尽量不要使用内联的JS代码</li></ul><h1 id="5-图片加载优化方案"><a href="#5-图片加载优化方案" class="headerlink" title="5.图片加载优化方案"></a>5.图片加载优化方案</h1><p>饿了么 App 中新零售项目主要是以图片展示为主，引导用户点击轮播广告栏或者店铺列表进入指定的商品页面，因此页面中包含了大量图片，如搜索框下面的轮播广告栏、中部的促销栏以及底部的店铺列表，这些区域中都有大量的展示图片。因此图片的加载速率直接影响页面的加载速度。下面将从图片加载存在的问题和原因、解决方案两个方面来阐述如何优化新零售图片的加载。</p><p>本文所有数据及图片都是通过 <strong>Charles</strong> 模拟 256 kbps ISDN/DSL 网络环境获取到的。在本案例中只考虑位图，因此文本中提及的图片都是指位图而非矢量图。</p><h2 id="图片加载存在的问题和原因"><a href="#图片加载存在的问题和原因" class="headerlink" title="图片加载存在的问题和原因"></a><strong>图片加载存在的问题和原因</strong></h2><p><strong>问题一</strong>：启动页面时加载过多图片</p><p><img data-src="https://pic3.zhimg.com/80/v2-f3f1170a7d72690c62f078a067b9327e_720w.jpg" alt="img"></p><p><strong>图1</strong>： 新零售图片请求瀑布图</p><p><strong>问题原因分析：</strong>如上图所示，页面启动时加载了大约 49 张图片（具体图片数量会根据后端返回数据而变化），而这些图片请求几乎是并发的，在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。上面的瀑布图中，在绿色的标记框中，我们看到不同长度的白色横柱，这些都是请求的图片资源排队等待时间。</p><p><strong>问题二</strong>：部分图片体积过大</p><p><img data-src="https://pic1.zhimg.com/80/v2-c3f2397f4515379d7741feaec49e178c_720w.jpg" alt="img"></p><p><strong>图2.</strong> 顶部轮播图中的一张图片加载图</p><p><strong>问题原因分析：</strong>如图 1，红框中是搜索框下部的轮播广告中的一张图片，通过图 2 可以看到，该图片主要耗时在 <code>Conent Download</code> 阶段。在下载阶段耗时 13.50s。而该请求的总共时间也就 13.78s。产生该问题的原因从图 1 也能看出一些端倪，该图片体积 <code>76.2KB</code>，<strong>图片体积过大</strong>，直接导致了下载图片时间过长。</p><h2 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><strong>前端解决方案</strong></h2><p><strong>针对问题一的解决方案</strong></p><p>由于新零售首页展示展示大量图片，其实在这大约 49 张图片中，大部分图片都不是首屏所需的，因此可以延迟首屏不需要的图片加载，而优先加载首屏所需图片。这儿<strong>首屏</strong>的含义是指打开新零售首页首先进入屏幕视窗内的区域范围。</p><p>判断图片是否是首屏内图片，首先想到的肯定是通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 <code>viewport</code> 内部。可能的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rect.top &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; rect.bottom &lt; <span class="built_in">window</span>.innerHeight</span><br><span class="line">    &amp;&amp; rect.left &gt; <span class="number">0</span></span><br><span class="line">    &amp;&amp; rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在项目中，我们并没有采用该方案来判断是否在首屏，其原因在于，只有当 DOM 元素插入到 DOM 树中，并且页面进行重排和重绘后，我们才能够知道该元素是否在首屏中。在项目中我们使用了 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a> 指令（新零售项目使用该指令对图片进行加载、并且将 hash 转换成 Url。项目已开源，在符合需求前提下欢迎使用），在 Vue 指令中包含两个钩子函数 <code>bind</code> 和 <code>inserted</code>。官网对这两个钩子函数进行如下解释：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li></ul><p>由上面解释可知，我们只能够在 inserted 钩子函数中才能够获取到元素的位置，并且判断其是否在首屏中。在新零售项目中，经过笔者测试，这两个钩子函数的触发时差大约是200ms，因此如果在 inserted 钩子函数内再去加载图片就会比在 bind 钩子函数中加载晚大约200ms，在 4G 网络环境下，200ms 对于很多图片来说已经足够用来加载了，因此我们最终放弃了在 inserted 钩子函数中加载首屏图片的方案。</p><p><strong>如果元素没有插入到 DOM 树中并渲染，怎么能够判断其是否在首屏中呢？</strong></p><blockquote><img v-img="{ hash: 'xxx', defer: true }"></blockquote><p>项目中使用了一种比较笨的方式来判断哪些是首屏图片，新零售页面布局是确定的，轮播广告栏下面是促销栏、再下面是店铺列表，这些组件的高度也都相对固定，因此这些组件是否在首屏中其实我们是事先知道的。因此在实际使用 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a> 指令的时候，通过传 <code>defer</code> 配置项来告诉 v-img 哪些图片需要提前加载，哪些图片等待提前加载的图片加载完毕后再加载。这样我们就能够在 bind 钩子函数中加载优先加载的图片了。比如说，轮播组件图片、促销组件图片、前两个店铺中的展示图片需要先加载，除此以外的其他图片，需等待首屏图片完全加载后再进行请求加载。实际实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [] <span class="comment">// 用来存储优先加载的图片  </span></span><br><span class="line">Vue.directive(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">        promises.push(update(el, binding, vnode))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">      <span class="keyword">if</span> (!defer) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">        promises.push(update(el, binding, vnode))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promises.length = <span class="number">0</span></span><br><span class="line">            update(el, binding, vnode)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>首先通过声明一个数组 promises 用于存储优先加载的图片，在 bind 钩子函数内部，如果 defer 配置项为 false，说明不延时加载，那么就在 bind 钩子函数内部加载该图片，且将返回的 promise 推入到 promises 数组中。在 inserted 钩子函数内，对于延迟加载的图片（defer 为 true），但是其又在首屏内，那么也有优先加载权，在 inseted 钩子函数调用时就对其加载。而对于非首屏且延迟加载的图片等待 promises 数组内部所有的图片都加载完成后才加载。当然在实际代码中还会考虑容错机制，比如上面某张图片加载失败、或者加载时间太长等。因此我们可以配置一个最大等待时间。</p><p>优化后的图片加载瀑布图如下：</p><p><img data-src="https://pic2.zhimg.com/80/v2-980599738f2adfb6822df8f503c1769d_720w.jpg" alt="img"></p><p><strong>图3</strong>. 图片按需加载的瀑布图</p><p>如上图所示，下面红框的图片不是首屏图片，因此进行了延迟加载。可以看出，其是在上面所有图片（包括上面的红框中耗时最长的那张图）加载完成之后进行加载的。这样减少了首屏加载时的网络消耗，提升了图片下载速度。</p><p><strong>优化前后对比</strong></p><p>通过上面的优化方案，在预设的网络环境下（参见文末注），分别对优化前和优化后进行了 5 次平行<code>清空缓存加载</code>，平均数据如下：</p><p><img data-src="https://pic3.zhimg.com/80/v2-d52cdac7a87683457710fa8a0175591e_720w.jpg" alt="img"></p><p>通过上面表格可以看出，<code>DOMContentLoaded</code> 和 <code>Loaded</code> 并没有多大参考价值，首屏的完整展现所需要的时间依然由加载最慢（一般都是体积最大那张图片）的图片决定，也就是上表的 <code>Max_size_image</code> 决定，上表可以看出，优化后比优化前最大体积图片的加载时间缩短了 <strong>5.74s</strong>。提速了整整 **41.41%**。加载最慢的图片加载速度的变化也很好的反应了首屏时间的变化。</p><p>当然上面的数据也不能够完全反应线上场景，毕竟测试的时间点及后端数据都有所不同。我们也不能够在同一时间点、同一网络环境下对优化前、优化后进行同时数据采集。</p><p><strong>针对问题一还有些后续的解决方案：</strong></p><ul><li>在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</li></ul><p><strong>针对问题二的解决方案</strong></p><p><strong>图片体积过大，导致下载时间过长。</strong>在保证清晰度的前提下尽量使用体积较小的图片。而一张图片的体积由两个因素决定，该图片总的像素数目和编码单位像素所需的字节数。因此一张图片的文件大小就等于图片总像素数目乘以编码单位像素所需字节数，也就是如下等式：</p><blockquote><p>FileSize = Total Number Pixels * Bytes of Encode single Pixels</p></blockquote><p>举个例子：</p><p>一张 <code>100px * 100px</code> 像素的图片，其包含该 <code>100 * 100 = 10000</code> 个像素点，而每个像素点通过 <code>RGBA</code> 颜色值进行存储，<code>R\G\B\A</code> 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：<code>10000 * 4bytes = 40000bytes = 39KB</code>。</p><p>有了上面的背景知识后，我们就知道怎么去优化一张图片了，无非就两个方向：</p><ul><li>一方面是减少单位像素所需的字节数</li><li>另一方面是减少一张图片总的像素个数</li></ul><p><strong>单位像素优化</strong>：单位像素的优化也有两个方向，一个方向是「有损」的删除一些像素数据，另一个方面是做一些「无损」的图片像素压缩。正如上面例子所说，<code>RGBA</code> 颜色值可以表示 <code>256^4</code> 种颜色，这是一个很大的数字，往往我们不需要这么多颜色值，因此我们是否可以减少色板中的颜色种类呢？这样表示单位像素的字节数就减少了。而「无损」压缩是通过一些算法，存储像素数据不变的前提下，尽量减少图片存储体积。比如一张图片中的某一个像素点和其周围的像素点很接近，比如一张蓝天的图片，因此我们可以存储两个像素点颜色值的差值（当然实际算法中可能不止考虑两个像素点也许更多），这样既保证了像素数据的「无损」，同时也减少了存储体积。不过也增加了图片解压缩的开销。</p><p>针对单位像素的优化，衍生出了不同的图片格式，<code>jpeg</code>、<code>png</code>、<code>gif</code>、<code>webp</code>。不同的图片格式都有自己的减少单位像素体积的算法。同时也有各自的优势和劣势，比如 <code>jpeg</code> 和 <code>png</code> 不支持动画效果，<code>jpeg</code> 图片体积小但是不支持透明度等。因此项目在选择图片格式上的策略就是，在满足自己需求的前提下选择体积最小的图片格式，新零售项目中已经统一使用的 <code>WebP</code> 格式，和 <code>jpeg</code> 格式相比，其体积更减少 30%，同时还支持动画和透明度。</p><p><strong>图片像素总数优化</strong>：</p><p><img data-src="https://pic2.zhimg.com/80/v2-0332bf16cf3b094fd0c311a56d4b56dd_720w.jpg" alt="img"></p><p><strong>图4</strong>：图片加载尺寸和实际渲染尺寸对比</p><p>上图是新零售类目页在 Chrome 浏览器中的 iPhone 6 模拟器加载后的轮播展示的图片之一，展示的图片是 <code>750 * 188</code> 像素，但是图片的实际尺寸为 <code>1440 * 360</code> 像素，也就是说我们根本不需要这么大的图片，大图片不仅造成了图片加载的时长增加（后面会有数据说明），同时由于图片尺寸需要缩小增加CPU的负担。</p><p>上文中已经提及，项目中我们使用的 <code>v-img</code> 指令来加载项目中的所需图片，如果我们能够根据设备的尺寸来加载不同尺寸（像素总数不同）的图片，也就是说在保证图片清晰度的前提下，尽量使用体积小的图片，问题就迎刃而解了。项目中我们使用的是七牛的图片服务，<a href="https://link.zhihu.com/?target=https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2">七牛图片服务</a>提供了图片格式转换、按尺寸裁剪等图片处理功能。只需要对 <code>v-img</code> 指令添加图片宽、高的配置，那么我们是不是可以对不同的设备加载不同尺寸的图片呢？</p><p>项目中我们使用的 <a href="https://link.zhihu.com/?target=https://github.com/amfe/lib-flexible">lib-flexible</a> 来对不同的移动端设备进行适配，<code>lib-flexible</code> 库在我们页面的html元素添加了两个属性，<code>data-dpr</code> 和 <code>style</code>。这儿我们主要会用到 style 中的 <code>font-size</code> 值，在一定的设备范围内其正好是html元素宽度的十分之一（具体原理参见：<a href="https://link.zhihu.com/?target=http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用Flexible实现手淘H5页面的终端适配</a>），也就是说我们可以通过style属性大概获取到设备的宽度。同时设计稿又是以 iPhone6 为基础进行设计的，也就是设计稿是宽度为 750px的设计图，这样在设计图中的图片大小我们也就能够转换成其他设备中所需的图片大小了。</p><p>举个例子：</p><p>设计稿中一张宽 200px 的图片，其对应的 iPhone 6 设备的宽度为 750px。我们通过 html 元素的 style 属性计算出 iPhone6 plus 的宽度为 1242px。这样也就能够计算中 iPhone6 plus 所需图片尺寸。计算如下：</p><blockquote><p>200 * 1242 / 750 = 331.2px</p></blockquote><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> viewWidth</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement</span><br><span class="line">  <span class="keyword">const</span> dataDpr = html.getAttribute(<span class="string">&#x27;data-dpr&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> ratio = dataDpr ? (dpr / dataDpr) : dpr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    viewWidth = +(html.getAttribute(<span class="string">&#x27;style&#x27;</span>).match(<span class="regexp">/(\d+)/</span>) || [])[<span class="number">1</span>]</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = html.offsetWidth</span><br><span class="line">    <span class="keyword">if</span> (w / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      viewWidth = <span class="number">540</span> * dpr / <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewWidth = w / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  viewWidth = viewWidth * ratio</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>(viewWidth) &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> viewWidth === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (size * viewWidth) / <span class="number">75</span> <span class="comment">// 75 is the 1/10 iphone6 deivce width pixel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 resize 方法用于将配置的宽、高值转换为实际所需的图片尺寸，也就是说，size 参数是 iphone 6 设计稿中的尺寸，resize 的返回值就是当前设备所需的尺寸，再把该尺寸配置到图片服务器的传参中，这样我们就能够获取到按设备裁剪后的图片了。</p><p><strong>优化前后效果对比</strong>，有了上面的基础，我们在 Chrome 中的不同的移动端模拟器上进行了实验，我们对新零售类目页中的一张体积最大的广告图片在不同设备中的加载进行了数据统计（平行三次清空缓存加载），为什么选择体积最大的图片，上文也已经说过，其决定了首屏展现所需的时间。</p><p><img data-src="https://pic4.zhimg.com/80/v2-12e8515d258f0d54dbd0dec319c867df_720w.jpg" alt="img"></p><p>上表格中，除去最后一行是未优化的加载数据，从上到下，设备屏幕尺寸逐渐变大，加载的图片尺寸也从 23.2kb增加到 65.5kb。而加载时间和下载时长也跟随着图片体积的加大而增加，下面的折线图更能够反应图片尺寸、加载时长、下载时长之间的正相关关系。TTFB（从发送请求到接收到第一个字节所需时长）却和图片大小没有明显的正相关关系，可能对于图片服务器在裁剪上述不同尺寸的图片所需时长差异不大。</p><p><img data-src="https://pic2.zhimg.com/80/v2-c93fa12974f624ba119f57c5cad88359_720w.jpg" alt="img"></p><p><strong>图5</strong>：不同设备中对同一张图片进行加载，文件大小、加载和下载时长的折线变化</p><p>由上折线图我们还能看到，对于小屏幕设备的效果尤为明显，在不优化下，iPhone5 中图片的加载需要 14.85s，而优化后，加载时长缩短到了 3.90s。加载时长整整缩短了 <strong>73.73%**。而对于大屏幕的 iPhone6 plus 也有 **26.00%</strong> 时长优化。</p><p>当然上面的数据是建立在 <code>256 kbps ISDN/DSL</code> 的网络环境下的，该低速网络环境下，图片的加载时间主要是由于下载时间决定的，因此通过优化图片体积能够达到很好的效果。在 <code>4G</code>（Charles模拟）环境下，iPhone5 中的优化效果就会有些折扣，加载时长缩短 **69.15%**。其实也很容易想到，在高速的网络环境下，TTFB 对加载时长的影响会比低速网络环境下影响要大一些。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h2><p>通过上面的研究及数据结果表明，新零售图片加载缓慢的优化策略：</p><ul><li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。</li><li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li></ul><p>本文中没有过多的讨论代码实现细节，而是把重点放在了图片加载缓慢的原因分析，以及优化前后效果对比的数据分析上，如果想看更多代码细节，请移步 <a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">vue-img</a>。</p><h1 id="6-从-URL-输入到页面展现到底发生了什么？"><a href="#6-从-URL-输入到页面展现到底发生了什么？" class="headerlink" title="6.从 URL 输入到页面展现到底发生了什么？"></a>6.从 URL 输入到页面展现到底发生了什么？</h1><p>对浏览器原理有过了解的一定不会陌生这篇神文《<a href="https://link.jianshu.com/?t=https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browsers Work</a>》中文翻译：<a href="https://link.jianshu.com/?t=https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器原理：新式网络浏览器幕后揭秘</a>。另外还有一篇 《<a href="https://link.jianshu.com/?t=http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">What really happens when you navigate to a URL</a>》。大神写的东西很长很复杂，阅读成本虽然大，但能学到东西。所以，我也试着用自己的理解去写一写，算是做个巩固。里面有很多参考，如涉及版权，侵权删！表述有误，请指正！</p><h2 id="前端为什么要研究渲染原理？"><a href="#前端为什么要研究渲染原理？" class="headerlink" title="前端为什么要研究渲染原理？"></a>前端为什么要研究渲染原理？</h2><p>像素完美（Pixel Perfection）、分辨率无关（Resolution Independent）和多平台体验一致性是设计师的追求。而访问性（Accessability）、加载性能和重构灵活性则是前端工程师必懂的技能。最重要的加载性能又与浏览器渲染机制深深挂钩，所以只有弄明白了浏览器背后的渲染机制，才能在日常的前端开发中明白如何进行性能优化。<br> 还有就是像类似：<br> <strong>从输入 URL 到页面加载完成的过程中都发生了什么事情</strong>？<br> <strong>从按下键盘到屏幕上出现字符，中间都发生了什么事情</strong>？<br> <strong>用户反应网站卡，请问都有哪些可能性，以及解决方法</strong>？<br> 这样的问题面试官都是比较喜欢问的，今天尝试来详细说一下这个过程。</p><h2 id="从输入-URL-到页面加载完成的过程中都发生了什么？"><a href="#从输入-URL-到页面加载完成的过程中都发生了什么？" class="headerlink" title="从输入 URL 到页面加载完成的过程中都发生了什么？"></a>从输入 URL 到页面加载完成的过程中都发生了什么？</h2><p><strong>简单路径线</strong>：</p><ol><li>键盘或触屏输入URL并回车确认</li><li>URL解析/DNS解析查找域名IP地址</li><li>网络连接发起HTTP请求</li><li>HTTP报文传输过程</li><li>服务器接收数据</li><li>服务器响应请求/MVC</li><li>服务器返回数据</li><li>客户端接收数据</li><li>浏览器加载/渲染页面</li><li>打印绘制输出</li></ol><p>实际上并没有这么简单，下面说说它的<strong>详细路径线</strong>：</p><h3 id="1-键盘或触屏输入URL并回车确认"><a href="#1-键盘或触屏输入URL并回车确认" class="headerlink" title="1. 键盘或触屏输入URL并回车确认"></a><strong>1. 键盘或触屏输入URL并回车确认</strong></h3><p>当然故事其实并不是从输入一个URL或抓着鼠标点击一个链接开始的，事情的开端要追溯到服务器启动监听服务的时候，在某个未知的时刻，一台机房里普普通通的服务器，加上电，启动了操作系统，随着操作系统的就绪，服务器启动了 http 服务进程，这个 http 服务的守护进程（daemon），可能是 Apache、Nginx、IIS、Lighttpd中的一个，不管怎么说，这个 http 服务进程开始定位到服务器上的 www 文件夹（网站根目录），一般是位于 /var/www ，然后启动了一些附属的模块，例如 php，或者，使用 fastcgi 方式连接到 php 的 fpm 管理进程，然后，向操作系统申请了一个 tcp 连接，然后绑定在了 80 端口，调用了 accept 函数，开始了默默的监听，监听着可能来自位于地球任何一个地方的请求，随时准备做出响应。这个时候，典型的情况下，机房里面应该还有一个数据库服务器，或许，还有一台缓存服务器，如果对于流量巨大的网站，那么动态脚本的解释器可能还有单独的物理机器来跑，如果是中小的站点，那么，上述的各色服务，甚至都可能在一台物理机上，这些服务监听之间的关系，可以通过自己搭建一次 Apache PHP MySQL 环境来了解一下，不管怎么说，他们做好了准备，静候差遣。<br> 然后是开始键盘或手机触屏输入URL，然后通过某种机制传到CPU（过程略），CPU进行内部处理（过程略），处理完后，再从CPU传到操作系统内核（过程略），然后再由操作系统GUI传到浏览器，再由浏览器到浏览器内核。这个过程因为涉及很多底层的知识，自己也只是了解皮毛，过程这里不多讲了，具体请参考我的另一篇博客《<a href="https://www.jianshu.com/p/d38a79a4f0f4">字符集历史和乱码问题</a>》和以下书籍：<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/20260928/">编码</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/4289836/">操作系统概念</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/25780703/">CPU自制入门</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/6559064/">计算机体系结构</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/6097773/">Linux内核设计与实现</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/4311450/">精通Linux设备驱动程序开发</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/7006537/">计算机体系结构：量化研究方法</a>》<br> 《<a href="https://link.jianshu.com/?t=http://book.douban.com/subject/10441748/">计算机组成与设计：硬件/软件接口</a>》</p><p>上面一步操作系统 GUI 会将输入事件传递到浏览器中，在这过程中，浏览器可能会做一些预处理，甚至已经在智能匹配所有可能的URL了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的URL，来预估所输入字符对应的网站，然后给出智能提示，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「<a href="https://link.jianshu.com/?t=http://www.baidu.com">www.baidu.com</a> 」，因此就会在输入回车前就马上开始建立 TCP 链接了。对于 Chrome这种变态的浏览器，他甚至会直接从缓存中把网页渲染出来，就是说，你还没有按下「回车」键，页面就已经出来了，再比如Chrome会在浏览器启动时预先查询10个你有可能访问的域名等等，这里面还有很多其它策略，不详细讲了。感兴趣的推荐阅读 <a href="https://link.jianshu.com/?t=http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">High Performance Networking in Chrome</a>。</p><h3 id="2-URL-解析-DNS-查询"><a href="#2-URL-解析-DNS-查询" class="headerlink" title="2. URL 解析/DNS 查询"></a><strong>2. URL 解析/DNS 查询</strong></h3><p>接着是输入 URL 「回车」后，这时浏览器会对 URL 进行检查，这里需要对URL有个回顾，请见百科《<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/url">URL</a>》，完整的URL由几个部分构成：<br> <em>协议、网络地址、资源路径、文件名、动态参数</em><br> <em>协议/模式（scheme）</em>是从该计算机获取资源的方式，一般有Http、Https、Ftp、File、Mailto、Telnet、News等协议，不同协议有不同的通讯内容格式，协议主要作用是告诉浏览器如何处理将要打开的文件；<br> <em>网络地址</em>指示该连接网络上哪一台计算机（服务器），可以是<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E5%9F%9F%E5%90%8D">域名</a>或者<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>，域名或IP地址后面有时还跟一个冒号和一个端口号；<br> <em>端口号</em>如果地址不包含端口号，根据协议的类型会确定一个默认端口号。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。一般如果你的端口号就是默认的，那么url是不需要输入端口号的，但如果你更改了默认端口号，你就必须要在url后输入新端口号才能正常访问。例如：http协议默认端口号是80。如果你输入的url是<a href="https://link.jianshu.com/?t=http://www.zhihu.com:8080/">http://www.zhihu.com:8080/</a> ，那表示不使用默认的端口号，而使用指定的端口号8080。如果使用的就是默认端口号那么输入<a href="https://link.jianshu.com/?t=http://www.zhihu.com:80">http://www.zhihu.com:80</a> 和<a href="https://link.jianshu.com/?t=http://www.zhihu.com">http://www.zhihu.com</a>是一样的。有个特殊情况有所不同，比如本地IP 127.0.0.1 其实走的是 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Localhost">loopback</a>，和网卡设备没关系。<br> <em>资源路径</em>指示从服务器上获取哪一项资源的等级结构路径，以斜线<code>/</code>分隔；<br> <em>文件名</em>一般是需要真正访问的文件，有时候，URL以斜杠“/”结尾，而隐藏了文件名，在这种情况下，URL引用路径中最后一个目录中的默认文件（通常对应于主页），这个文件常被称为 index.html 或 default.htm。<br> <em>动态参数</em>有时候路径后面会有以问号<code>?</code>开始的参数，这一般都是用来传送对服务器上的数据库进行动态询问时所需要的参数，有时候没有，很多为了seo优化，都已处理成<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E4%BC%AA%E9%9D%99%E6%80%81">伪静态</a>了。要注意区分url和<a href="https://link.jianshu.com/?t=http://www.digpage.com/route.html">路由</a>的区别。<br> <strong>URL完整格式为：协议://用户名:密码@子域名.域名.顶级域名:<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>/目录/文件名.文件后缀?参数=值#标志</strong><br> 例如：<a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/55998388/answer/166987812">https://www.zhihu.com/question/55998388/answer/166987812</a><br> 协议部分：https<br> 网络地址：<a href="https://link.jianshu.com/?t=http://www.zhihu.com">www.zhihu.com</a>（依次为 子/三级域名.二级域名.顶/一级域名）<br> 资源路径：/question/55998388/answer/166987812<br> 浏览器对 URL 进行检查时首先判断协议，如果是 http/https 就按照 Web 来处理，另外还会对 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，接下来是对网络地址进行处理，如果地址不是一个IP地址而是域名则通过DNS（域名系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。 例如：<a href="https://link.jianshu.com/?t=http://www.zhihu.com">www.zhihu.com</a>域名请求对应获得的IP是 116.211.167.187。DNS 在解析域名的时候有两种方式：<strong>递归查询和迭代查询</strong>，<br> 递归查询的流程如下：<br> 一般来说，浏览器会首先查询<strong>浏览器缓存</strong>（DNS 在各个层级都有缓存的，相应的，缓存当然有过期时间，Time to live），如果没有找到，就会检查<strong>系统缓存</strong>，检查本地硬盘的hosts文件，这个文件保存了一些以前访问过的网站的域名和IP对应的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了（注意这个地方存在安全隐患，如果有病毒把一些常用的域名，修改 hosts 文件，指向一些恶意的IP，那么浏览器也会不加判断的去连接，是的，这正是很多病毒的惯用手法）。如果本地hosts也没有找到的话，则需要再向上层找<strong>路由器缓存</strong>，路由器有自己的DNS缓存，可能就包括了查询的内容；如果还是没有，需要接着往上找，查询<strong>ISP DNS 缓存</strong>（本地名称服务器缓存，就是客户端电脑TCP/IP参数中设置的首选DNS服务器，此解析具有权威性。一般情况下你在不同的地区或者不同的网络，如电信、联通、移动的情况下，转换后的IP地址很可能是不一样的，这涉及到负载均衡，通过DNS解析域名时会将你的访问分配到不同的入口，先找附近的本地 DNS 服务器去请求解析域名，尽可能保证你所访问的入口是所有入口中较快的一个，这和<a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/CDN">CDN</a>还不一样，比如我们经常使用的114.114.114.114或Google的8.8.8.8就是本地名称服务器）。如果附近的本地DNS服务器还是没有缓存我们请求的域名记录的话，这时候会根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，则本地名称服务器再以DNS客户端的角色发送与前面一样的DNS域名查询请求转发给上一层。这里可能经过一次或者多次转发，从<strong>本地名称服务器</strong>到<strong>权威名称服务器</strong>再到<strong>顶级名称服务器</strong>最后到<strong>根名称服务器</strong>。（顺便一提，根服务器是互联网域名解析系统DNS中最高级别的域名服务器，全球一共13组，每组都只有一个主根名称服务器采用同一个IP。注意不是13个，前期是个现在已经是集群了，据说已经有上千台了，好多台用于负载均衡，备份等，全球有386台根物理服务器，被编号为A到M共13个标号。中国包括台港也持有其中5组14台辅根服务器或叫镜像也可以，386台根服务器总共只使用了13个IP，因此可以抵抗针对其所进行的分布式拒绝服务攻击DDoS。具体情况可以参看维基百科的 <a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8B%99%E5%99%A8">根域名服务器</a> 条目）所以，最终请求到了根服务器后，根服务器查询发现我们这个被请求的域名是由类似A或者B这样的服务器解析的，但是，根服务器并不会送佛送到西地找A或B之类的直接去解析，因为它没有保存全部互联网域名记录，并不直接用于名称解析，它只是负责顶级名称服务器（如.com/.cn/.net等）的相关内容。所以它会把所查询得到的被请求的DNS域名中顶级域名所对应的顶级名称服务器IP地址返回给本地名称服务器。本地名称服务器拿到地址后再向对应的顶级名称服务器发送与前面一样的DNS域名查询请求。对应的顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有则直接把对应的记录项返回给本地名称服务器，然后再由本地名称服务器返回给DNS客户端，如果没有则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的二级名称服务器（如<a href="https://link.jianshu.com/?t=http://baidu.com/qq.com/net.cn">baidu.com/qq.com/net.cn</a>等）地址。然后本地名称服务器继续按照前面介绍的方法一次次地向三级（如<a href="https://link.jianshu.com/?t=http://www.baidu.com/www.qq.com/bbs.taobao.com">www.baidu.com/www.qq.com/bbs.taobao.com</a>等）、四级名称服务器查询，直到最终的对应域名所在区域的权威名称服务器返回最终记录给本地名称服务器。同时本地名称服务器会缓存本次查询得到的记录项（每层都应该会缓存）。再层层下传，最后到了我们的DNS客户端机子，一次 DNS 解析请求就此完成。如果最终权威名称服务器都说找不到对应的域名记录，则会向本地名称服务器返回一条查询失败的DNS应答报文，这条报文最终也会由本地名称服务器返回给DNS客户端。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询的。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-7d3f7e0c5b12d23a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>DNS递归解析示例图</p><p> 所以，我们看到DNS的域名解析是递归的，递归的DNS首先会查看自己的DNS缓存，如果缓存能够命中，那么就从缓存中把IP地址返回给浏览器，如果找不到对应的域名的IP地址，那么就依此层层向上转发请求，从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP，最高达到根节点，找到或者全部找不到为止。然后把找到的这个域名对应的 nameserver 的地址拿到，再向这个 namserver 去请求域名对应的IP，最后把这个IP地址返回给浏览器，在这个<strong>递归查询</strong>的过程中，对于浏览器来说是透明的，如果DNS客户端的本地名称服务器不能解析的话，则后面的查询都会以本地名称服务器为中心，全交由本地名称服务器代替DNS客户端进行查询，DNS客户端只是发出原始的域名查询请求报文，然后就一直处于坐等状态，直到本地名称服务器最终从权威名称服务器得到了正确的IP地址查询结果并返回给它。虽然递归查询是默认的DNS查询方式，但是如果有以下情况发生的话，则会使用迭代的查询方式进行。<br> 情况一：DNS客户端的请求报文中没有申请使用递归查询，即在DNS请求报头部的RD字段没有置1。<br> 情况二：DNS客户端的请求报文中申请使用的是递归查询（也就是RD字段置1了），但在所配置的本地名称服务器上是禁用递归查询了（即在应答DNS报文头部的RA字段置0）。</p><p><strong>迭代查询的流程如下</strong>：<br> 开始也是从浏览器缓存到系统缓存到路由缓存，如果还是没找到则客户端向本机配置的本地名称服务器（在此仅以首先DNS服务器为例进行介绍，其它备用DNS服务器的解析流程完全一样）发出DNS域名查询请求。本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器就直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则向DNS客户端返回一条DNS应答报文，报文中会给出一些参考信息，如本地名称服务器上的根名称服务器地址等。DNS客户端在收到本地名称服务器的应答报文后，会根据其中的根名称服务器地址信息，向对应的根名称服务器再次发出与前面一样的DNS查询请求报文。根名称服务器在收到DNS查询请求报文后，通过查询自己的DNS数据库得到请求DNS域名中顶级域名所对应的顶级名称服务器信息，然后以一条DNS应答报文返回给DNS客户端。DNS客户端根据来自根名称服务器应答报文中的对应顶级名称服务器地址信息，向该顶级名称服务器发出与前面一样的DNS查询请求报文。顶级名称服务器在收到DNS查询请求后，先查询自己的缓存，如果有请求的DNS域名的记录项，则直接把对应的记录项返回给DNS客户端，否则通过查询后把对应域名中二级域名所对应的二级名称服务器地址信息以一条DNS应答报文返回给DNS客户端。然后DNS客户端继续按照前面介绍的方法一次次地向三级、四级名称服务器查询，直到最终的权威名称服务器返回到最终的记录。如果权威名称服务器也找不到对应的域名记录，则会向DNS客户端返回一条查询失败的DNS应答报文。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-e8a5727b9a6a0c08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>DNS迭代解析示意图</p><p> 所以，我们发现在递归查询中后面的查询工作是由本地名称服务器替代DNS客户端进行的（以“本地名称服务器”为中心），只需要本地名称服务器向DNS客户端返回最终的查询结果即可。而DNS迭代查询的所有查询工作则全部是DNS客户端自己进行（以“DNS客户端”自己为中心）。</p><p><strong>DNS递归查询和迭代查询的区别</strong>？<br> 递归查询是以本地名称服务器为中心的，是DNS客户端和服务器之间的查询活动，递归查询的过程中“查询的递交者” 一直在更替，其结果是直接告诉DNS客户端需要查询的网站目标IP地址。<br> 迭代查询则是DNS客户端自己为中心的，是各个服务器和服务器之间的查询活动，迭代查询的过程中“查询的递交者”一直没变化，其结果是间接告诉DNS客户端另一个DNS服务器的地址。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-f1a9326b8de436c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>递归和迭代查询</p><p><strong>扩展阅读：</strong><br> <a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/DNS%E5%8A%AB%E6%8C%81">什么是DNS劫持？</a><br> <a href="https://link.jianshu.com/?t=http://baike.baidu.com/item/301%E9%87%8D%E5%AE%9A%E5%90%91">什么是301重定向？</a>与<a href="https://link.jianshu.com/?t=http://www.chinaz.com/web/2013/1212/330808.shtml">301重定向设置教程</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/34784697">电脑上不了网将DNS改为114.114.114.114或8.8.8.8可以解决或加快网速的原理是什么？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/27714563">局域网 IP 和公网 IP 有何差别？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/22364736">根域名服务器的作用是什么？全球 13 组根域名服务器中有 10 组在美国，意味着什么？</a><br> <a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/20278387">递归和迭代的区别？</a></p><h3 id="3-应用层客户端发送HTTP请求"><a href="#3-应用层客户端发送HTTP请求" class="headerlink" title="3. 应用层客户端发送HTTP请求"></a><strong>3. 应用层客户端发送HTTP请求</strong></h3><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-5272cd06ebf5f4e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/832/format/webp" alt="img"></p><p>从上面的步骤中得到 IP 地址后，浏览器会开始构造一个 HTTP 请求，应用层客户端向服务器端发送的HTTP请求包括：请求报头和请求主体两个部分，其中请求报头（request header）包含了至关重要的信息，包括请求的方法（GET / POST和不常用的PUT / DELETE以及更不常用的HEAD / OPTION / TRACE，一般的浏览器只能发起 GET 或者 POST 请求）、目标url、遵循的协议（HTTP / HTTPS / FTP…），返回的信息是否需要缓存，以及客户端是否发送Cookie等信息。需要注意的是，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 文本的。</p><h3 id="4-传输层TCP传输报文"><a href="#4-传输层TCP传输报文" class="headerlink" title="4. 传输层TCP传输报文"></a><strong>4. 传输层TCP传输报文</strong></h3><p>当应用层的 HTTP 请求准备好后，浏览器会在传输层发起一条到达服务器的 TCP 连接，位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-fac6b90588bec446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt="img"></p><p> 这里需要谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段（segments），编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。为了解决 TCP 协议的性能问题，Chrome 团队提出了 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/QUIC">QUIC</a> 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回（round trip）时间，还有前向纠错码（Forward Error Correction）等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过<a href="https://link.jianshu.com/?t=chrome://net-internals/#spdy">chrome://net-internals/#spdy</a> 页面来发现。另外，浏览器对同一个域名有连接数限制，<a href="https://link.jianshu.com/?t=http://www.browserscope.org/?category=network&v=top">大部分是 6</a>，但并非将这个连接数改大后就会提升性能，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。</p><h3 id="5-网络层IP协议查询MAC地址"><a href="#5-网络层IP协议查询MAC地址" class="headerlink" title="5. 网络层IP协议查询MAC地址"></a><strong>5. 网络层IP协议查询MAC地址</strong></h3><p>IP协议的作用是把TCP分割好的各种数据包封装到IP包里面传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址才可以。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p><h3 id="6-数据到达数据链路层"><a href="#6-数据到达数据链路层" class="headerlink" title="6. 数据到达数据链路层"></a><strong>6. 数据到达数据链路层</strong></h3><p>在找到对方的MAC地址后，已被封装好的IP包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输，再通过物理层的比特流送出去。这时，客户端发送请求的阶段结束。</p><blockquote><p>这些分层的意义在于分工合作，数据链路层通过 CSMA/CD 协议保证了相邻两台主机之间的数据报文传递，而网络层的 IP 数据包通过不同子网之间的路由器的路由算法和路由转发，保证了互联网上两台遥远主机之间的点对点的通讯，不过这种传输是不可靠，于是可靠性就由传输层的 TCP 协议来保证，TCP 通过慢开始，乘法减小等手段来进行流量控制和拥塞避免，同时提供了两台遥远主机上进程到进程的通信，最终保证了 HTTP 的请求头能够被远方的服务器上正在监听的 HTTP 服务器进程收到，终于，数据包在跳与跳之间被拆了又封装，在子网与子网之间被转发了又转发，最后进入了服务器的操作系统的缓冲区，服务器的操作系统由此给正在被阻塞住的 accept 函数一个返回，将他唤醒。</p></blockquote><h3 id="7-服务器接收数据"><a href="#7-服务器接收数据" class="headerlink" title="7. 服务器接收数据"></a><strong>7. 服务器接收数据</strong></h3><p>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。</p><h3 id="8-服务器响应请求并返回相应文件"><a href="#8-服务器响应请求并返回相应文件" class="headerlink" title="8. 服务器响应请求并返回相应文件"></a><strong>8. 服务器响应请求并返回相应文件</strong></h3><p>服务接收到客户端发送的HTTP请求后，服务器上的的 http 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。http 服务器首先会查看重写规则，然后如果请求的文件是真实存在，例如一些图片，或 html、css、js 等静态文件，则会直接把这个文件返回，如果是一个动态的请求，那么会根据 url 重写模块的规则，把这个请求重写到一个 rest 风格的 url 上，然后根据动态语言的脚本，来决定调用什么类型的动态文件脚本解释器来处理这个请求。</p><p>我们以 php 语言为例来说的话，请求到达一个 php 的 mvc 框架之后，框架首先应该会初始化一些环境的参数，例如远端 ip，请求参数等等，然后根据请求的 url 送到一个路由器类里面去匹配路由，路由由上到下逐条匹配，一旦遇到 url 能够匹配的上，而且请求的方法也能够命中的话，那么请求就会由这个路由所定义的处理方法去处理。</p><p>请求进入处理函数之后，如果客户端所请求需要浏览的内容是一个动态的内容，那么处理函数会相应的从数据源里面取出数据，这个地方一般会有一个缓存，例如 memcached 来减小 db 的压力，如果引入了 orm 框架的话，那么处理函数直接向 orm 框架索要数据就可以了，由 orm 框架来决定是使用内存里面的缓存还是从 db 去取数据，一般缓存都会有一个过期的时间，而 orm 框架也会在取到数据回来之后，把数据存一份在内存缓存中的。</p><p>orm 框架负责把面向对象的请求翻译成标准的 sql 语句，然后送到后端的 db 去执行，db 这里以 mysql 为例的话，那么一条 sql 进来之后，db 本身也是有缓存的，不过 db 的缓存一般是用 sql 语言 hash 来存取的，也就是说，想要缓存能够命中，除了查询的字段和方法要一样以外，查询的参数也要完全一模一样才能够使用 db 本身的查询缓存，sql 经过查询缓存器，然后就会到达查询分析器，在这里，db 会根据被搜索的数据表的索引建立情况，和 sql 语言本身的特点，来决定使用哪一个字段的索引，值得一提的是，即使一个数据表同时在多个字段建立了索引，但是对于一条 sql 语句来说，还是只能使用一个索引，所以这里就需要分析使用哪个索引效率最高了，一般来说，sql 优化在这个点上也是很重要的一个方面。</p><p>sql 由 db 返回结果集后，再由 orm 框架把结果转换成模型对象，然后由 orm 框架进行一些逻辑处理，把准备好的数据，送到视图层的渲染引擎去渲染，渲染引擎负责模板的管理，字段的友好显示，也包括负责一些多国语言之类的任务。对于一条请求在 mvc 中的生命周期，可以参考这里，<a href="https://link.jianshu.com/?t=http://zrj.me/archives/404">临摹了一个 PHP MVC 框架</a>，在视图层把页面准备好后，再从动态脚本解释器送回到 http 服务器，由 http 服务器把这些正文加上一个响应头，封装成一个标准的 http 响应包，再通过 tcp ip 协议，送回到客户机浏览器。</p><h3 id="9-浏览器开始处理数据信息并渲染页面"><a href="#9-浏览器开始处理数据信息并渲染页面" class="headerlink" title="9.浏览器开始处理数据信息并渲染页面"></a><strong>9.浏览器开始处理数据信息并渲染页面</strong></h3><p>历经千辛万苦，我们请求的响应终于成功到达了客户端的浏览器，响应到达浏览器之后，浏览器首先会根据返回的响应报文里的一个重要信息——状态码，来做个判断。如果是 200 开头的就好办，表示请求成功，直接进入渲染流程，如果是 300 开头的就要去相应头里面找 location 域，根据这个 location 的指引，进行跳转，这里跳转需要开启一个跳转计数器，是为了避免两个或者多个页面之间形成的循环的跳转，当跳转次数过多之后，浏览器会报错，同时停止。比如：301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。如果是 400 开头或者 500 开头的状态码，浏览器也会给出一个错误页面。比如：404 not found 就表示客户端请求的资源找不到。</p><p>当浏览得到一个正确的 200 响应之后，接下来面临的一个问题就是多国语言的编码解析了，响应头是一个 ascii 的标准字符集的文本，这个还好办，但是响应的正文本质上就是一个字节流，对于这一坨字节流，浏览器要怎么去处理呢？首先浏览器会去看响应头里面指定的 encoding 域，如果有了这个东西，那么就按照指定的 encoding 去解析字符，如果没有的话，那么浏览器会使用一些比较智能的方式，去猜测和判断这一坨字节流应该使用什么字符集去解码。相关的笔记可以看这里，<a href="https://www.jianshu.com/p/d38a79a4f0f4">字符集编码</a></p><p>接下来就是构建 dom 树了，在 html 语言嵌套正常而且规范的情况下，这种 xml 标记的语言是比较容易的能够构建出一棵 dom 树出来的，当然，对于互联网上大量的不规范的页面，不同的浏览器应该有自己不同的容错去处理。构建出来的 dom 本质上还是一棵抽象的逻辑树，构建 dom 树的过程中，如果遇到了由 script 标签包起来的 js 动态脚本代码，那么会把代码送到 js 引擎里面去跑，如果遇到了 style 标签包围起来的 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 或 css 和 js等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 http 请求，去把这个文件拉取回来，值得一提的是，对于同一个域名下的下载过程来说，浏览器一般允许的并发请求是有限的，通常控制在两个左右，所以如果有很多的图片的话，一般出于优化的目的，都会把这些图片使用一台静态文件的服务器来保存起来，负责响应，从而减少主服务器的压力。</p><p>dom 树构造好了之后，就是根据 dom 树和 css 样式表来构造 render 树了，这个才是真正的用于渲染到页面上的一个一个的矩形框的树，网页渲染是浏览器最复杂、最核心的功能，对于 render 树上每一个框，需要确定他的 x y 坐标，尺寸，边框，字体，形态，等等诸多方面的东西，render 树一旦构建完成，整个页面也就准备好了，可以上菜了。需要说明的是，下载页面，构建 dom 树，构建 render 树这三个步骤，实际上并不是严格的先后顺序的，为了加快速度，提高效率，让用户不要等那么久，现在一般都并行的往前推进的，现代的浏览器都是一边下载，下载到了一点数据就开始构建 dom 树，也一边开始构建 render 树，构建了一点就显示一点出来，这样用户看起来就不用等待那么久了。</p><h3 id="10-将渲染好的页面图像显示出来，并开始响应用户的操作"><a href="#10-将渲染好的页面图像显示出来，并开始响应用户的操作" class="headerlink" title="10.将渲染好的页面图像显示出来，并开始响应用户的操作"></a><strong>10.将渲染好的页面图像显示出来，并开始响应用户的操作</strong></h3><p>这一步主要涉及显卡，内存及显示器原理等知识，不做详细解说，大概就是从内存到 LCD/LED，再由光线进入人眼的一个过程。</p><blockquote><p>以上过程简单讲主要是：从输入 URL 到浏览器接收（回车前），从浏览器接收到数据如何发送给网卡（回车后），再把接收的数据从本机网卡发送到服务器，服务器接收到数据后做了怎么的处理？服务器返回数据后浏览器又做了哪些处理？浏览器又是如何将处理好的页面展现在屏幕上的？的这么一个过程。<br> 但只是最基本的一些步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML等等，还需要考虑很多情况，比如广播、拆包解包合并包丢包重传、路由表，NAT、TCP 状态机、CDN、HTTPS 证书校验与中间人攻击检测、RSA 密钥协商、AES 加解密、浏览器解析 HTTP 的有限自动状态机、GUI 库与绘图、OpenGL 绘图、GPU 加速（OpenCL 与 CUDA）、JIT（JavaScript 会把 JavaScript 代码编译成汇编代码）、服务器的数据库 NoSQL 或 SQL 查询、主从数据库同步、服务器和浏览器的内存管理（WebKit 实现的 fastMalloc()，服务器上可能是 TCMalloc 或者 JeMalloc）、服务器上的语言解释器（可能也是 JIT）、多媒体：傅里叶变换、H.264 解码（硬件解码，硬件解码的话 GPU 的处理单元又在计算…….或软件解码）、音频解码、WebGL 绘图、浏览器的 Sandbox、服务器的 SQL 注入检查、产生的键盘中断信号处理（或者是高级层面的输入输出驱动）、网卡驱动、网络栈的 TCP FastOpen、SYN Cookie 之类众多技术……每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。即便是计算机专业的同学看了也会头大，但我保证这里面的每一个步骤都经过深思熟虑和时间的考验的，并不是谁闲的蛋疼非要搞得那么复杂，不复杂也不行啊。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出了你难以想象的努力。有兴趣的可以阅读下<br> <a href="https://link.jianshu.com/?t=http://kb.cnblogs.com/page/132716/">你刚才在淘宝上买了一件东西</a></p></blockquote><p><img data-src="https://upload-images.jianshu.io/upload_images/100954-3983d99c29c8f967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>浏览器解析渲染页面原理</p><p><a href="https://link.jianshu.com/?t=http://coolshell.cn/articles/9666.html">http://coolshell.cn/articles/9666.html</a><br><a href="https://www.jianshu.com/p/e305ace24ddf">http://www.jianshu.com/p/e305ace24ddf</a><br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000005169412">https://segmentfault.com/a/1190000005169412</a><br><a href="https://link.jianshu.com/?t=https://www.chengrang.com/how-browsers-work.html">https://www.chengrang.com/how-browsers-work.html</a><br><strong>参考资料</strong>：<br><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html">了解html页面的渲染过程</a><br><a href="https://link.jianshu.com/?t=https://leohxj.gitbooks.io/front-end-database/content/">前端工程师手册</a><br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000005169412">浏览器渲染那些事</a><br><a href="https://link.jianshu.com/?t=http://fex.baidu.com/blog/2014/05/what-happen/">手机上从输入URL到页面加载完成的过程中都发生了什么？</a><br><a href="https://link.jianshu.com/?t=https://github.com/skyline75489/what-happens-when-zh_CN">当页面渲染时，浏览器发生了什么？</a><br><a href="https://link.jianshu.com/?t=https://www.chengrang.com/how-browsers-work.html">浏览器工作原理分析与首屏加载</a><br><a href="https://link.jianshu.com/?t=https://www.youtube.com/watch?v=eeS4brbDVuU">https://www.youtube.com/watch?v=eeS4brbDVuU</a></p><h1 id="7-动画性能"><a href="#7-动画性能" class="headerlink" title="7.动画性能"></a>7.动画性能</h1><p>先总结几个要点</p><ol><li><h4 id="精简DOM，合理布局"><a href="#精简DOM，合理布局" class="headerlink" title="精简DOM，合理布局"></a>精简DOM，合理布局</h4></li><li><h4 id="使用transform代替left、top减少使用引起页面重排的属性"><a href="#使用transform代替left、top减少使用引起页面重排的属性" class="headerlink" title="使用transform代替left、top减少使用引起页面重排的属性"></a>使用transform代替left、top减少使用引起页面重排的属性</h4></li><li><h4 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h4></li><li><h4 id="尽量避免浏览器创建不必要的图形层"><a href="#尽量避免浏览器创建不必要的图形层" class="headerlink" title="尽量避免浏览器创建不必要的图形层"></a>尽量避免浏览器创建不必要的图形层</h4></li><li><h4 id="尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame"><a href="#尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame" class="headerlink" title="尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame"></a>尽量减少js动画，如需要，使用对性能友好的requestAnimationFrame</h4></li><li><h4 id="使用chrome-performance工具调试动画性能"><a href="#使用chrome-performance工具调试动画性能" class="headerlink" title="使用chrome performance工具调试动画性能"></a>使用chrome performance工具调试动画性能</h4></li></ol><p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于24镇的动画，人眼就能感受到停顿，每秒30-60帧才能比较流畅 浏览器会按照大多数显示器的刷新频率60Hz来刷新动画， 如果想达到60FPS,就意味着每一帧的任务耗时不能高于16毫秒。</p><p>通过下图我们可以了解浏览器渲染每一帧的过程</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-a41d34fd8b262bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1095/format/webp" alt="img"></p><p>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</p><p>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</p><p>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</p><p>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</p><p>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</p><p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</p><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</p><p>重排还重绘会消耗大量的CPU和GPU资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-67a605f7213dd67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt="img"></p><p>影响网页渲染的因素</p><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的DOM元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简DOM元素，合理布局。</p><p>另外Table元素的重排和重绘成本要高于div，所以我们提倡使用div+css布局，尽量避免使用table布局。</p><p>还有其他对渲染性能有影响的操作，比如：</p><ul><li>DOM元素读写分离</li><li>让进行大量动画的元素脱离文档流，减少重排开销</li><li>通过改变元素的class或csstext一次性的更改样式</li><li>缓存DOM元素的位置信息，避免不必要的属性读取</li><li>尽量使用离线DOM</li><li>使用css3 transform优化动画性能</li></ul><h3 id="使用css3-transform"><a href="#使用css3-transform" class="headerlink" title="使用css3 transform"></a>使用css3 transform</h3><p>该CSS属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改CSS 可视格式模型的坐标空间来实现的。<br> 如果该属性的值不是none，则会创建一个堆叠上下文。在这种情况下，该对象将充当position: fixed的包含块（所以position: fixed的元素将会被他覆盖）。</p><h3 id="css3-transform-的执行效率"><a href="#css3-transform-的执行效率" class="headerlink" title="css3 transform 的执行效率"></a>css3 transform 的执行效率</h3><p>我们通过一个例子来解释为什么transform的动画执行效果更佳。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>--&gt;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">transition</span>: height <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">height</span>: <span class="number">200px</span>; &#125; </span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> --&gt;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>); <span class="attribute">transition</span>: transform <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.0</span>); &#125;</span><br></pre></td></tr></table></figure><p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-2f9474dd0744d413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455/format/webp" alt="img"></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-a013fcb7fed434ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510/format/webp" alt="img"></p><p>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到GPU内存中的操作是个相对耗时的操作。</p><p>GPU 在如下方面很快：</p><ul><li>绘制位图到屏幕上</li><li>可不断的绘制相同的位图</li><li>将同一位图进行位移、旋转、缩放</li></ul><p>我们看使用了transform属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p><h3 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h3><p>页面一旦在装入并解析完成后，就会表示为许多Web开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。</p><p>在Chrome中实际上有几种不同类型的层：掌管DOM子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。</p><p>拥有单独GraphicsLayer的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。</p><p>什么渲染层会提升为合成层？Chrome在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起Chrome创建层：</p><ul><li>进行3D或者透视变换的CSS属性</li><li>使用硬件加速视频解码的<video>元素</li><li>具有3D（WebGL）上下文或者硬件加速的2D上下文的<canvas>元素</li><li>组合型插件（即Flash）</li><li>具有有CSS透明度动画或者使用动画式Webkit变换的元素</li><li>具有硬件加速的CSS滤镜的元素</li><li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li><li>同级元素中有Z索引比其小的元素，而且该Z索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li></ul><p>提升为合成层简单说来有以下几点好处</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p><p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p><p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)</p><p>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，</p><p>对于合成层占用内存的问题，这里有两个 demo 进行了验证。</p><p><a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1621708-3cdd12ef501d0d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/947/format/webp" alt="img"></p><h3 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a><strong>网页动画的渲染</strong></h3><p>有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。</p><p>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window<span class="selector-class">.requestAnimationFrame</span>(fn);</span><br></pre></td></tr></table></figure><p>**<code>\**</code>window.requestIdleCallback()<code>\**</code>**也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function"><span class="keyword">fn</span>);</span></span><br></pre></td></tr></table></figure><p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function"><span class="keyword">fn</span>, 5000);</span></span><br></pre></td></tr></table></figure><h3 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h3><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance是一个很好的选择。这里请大家参考这篇文章<a href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新Chrome Devtool Performance使用指南</a></p><h1 id="8-渲染合成层"><a href="#8-渲染合成层" class="headerlink" title="8.渲染合成层"></a>8.渲染合成层</h1><h2 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p><blockquote><ul><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染</li></ul></blockquote><p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p><blockquote><ul><li>解析html建立dom树</li><li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。</li></ul></blockquote><p>参考一张图（webkit渲染主要流程）：</p><p><img data-src="https://segmentfault.com/img/bVHJfZ?w=624&h=289" alt="图片描述"></p><p>这里先解释一下几个概念，方便大家理解：</p><p>　　DOM Tree：浏览器将HTML解析成树形的数据结构。</p><p>　　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p><p>　　Render Tree: DOM和CSSOM合并后生成Render Tree。</p><p>　　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p><p>　　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p><p>　　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p><p>　　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p><p>注意：</p><ol><li>display:none 的节点不会被加入Render Tree，而visibility: hidden<br>则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</li><li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li></ol><p>再参考一张图理解一下：</p><p><img data-src="https://segmentfault.com/img/bV7TBl?w=700&h=111" alt="图片描述"></p><p>细致分离两个环节，其他环节参考上述概念注解：</p><p><code>JavaScript</code>：JavaScript实现动画效果，DOM元素操作等。<br><code>Composite（渲染层合并）</code>：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p><p>在实际场景下，大致会出现三种常见的渲染流程（Layout和Paint步骤是可避免的，可参考上一张图的注意部分理解）：</p><p><img data-src="https://segmentfault.com/img/bV7TKK?w=580&h=381" alt="图片描述"></p><hr><h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h4><blockquote><p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p><ul><li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li><li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和GraphicsLayer(负责 RenderLayer的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给GPU的。</li><li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li><li>Chrome 使用纹理来从 GPU上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是3DCSS 的工作原理，它对于快速滚动也十分有效。</li></ul></blockquote><p>整个图：</p><p><img data-src="https://segmentfault.com/img/bV7URO?w=650&h=268" alt="图片描述"></p><p>在 Chrome 中其实有几种不同的层类型：</p><ul><li>RenderLayers 渲染层，这是负责对应 DOM 子树</li><li>GraphicsLayers 图形层，这是负责对应 RenderLayers子树。</li></ul><p>在浏览器渲染流程中提到了composite概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。</p><p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p><p>而每个GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p><h2 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><blockquote><h4 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p><ul><li>3D 或透视变换(perspective transform) CSS 属性</li><li>使用加速视频解码的 <video> 元素 拥有 3D</li><li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li><li>混合插件(如 Flash)</li><li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li><li>拥有加速 CSS 过滤器的元素</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul></blockquote><h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦renderLayer提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p><strong>注意：</strong></p><ol><li>提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU。</li><li>当需要repaint的时候可以只repaint本身，不影响其他层，但是paint之前还有style， layout,那就意味着即使合成层只是repaint了自己，但style和layout本身就很占用时间。</li><li>仅仅是transform和opacity不会引发layout 和paint，那么其他的属性不确定。</li></ol><p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p><p><strong>性能优化点：</strong></p><ol><li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少paint，我们需要把动画效果中的元素提升为合成层。 <code>提升合成层的最好方式是使用 CSS 的 will-change属性。从上一节合成层产生原因中，可以知道 will-change 设置为opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</code></li><li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li><li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。<code>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</code></li></ol><h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol><li>合成层占用内存的问题</li><li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：<code>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰合成的排序，可以有效减少chrome创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。</code> 在这篇<a href="http://div.io/topic/1348">文章</a>中的<a href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li></ol><p>用chremo打开demo页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：</p><p><img data-src="https://segmentfault.com/img/bV85wj?w=1056&h=1358" alt="图片描述"></p><p>开启 Rendering 的Layer borders后 观察点击<code>为动画元素设置z-index复选框</code>的页面提示变化：</p><p><img data-src="https://segmentfault.com/img/bV85zk?w=1056&h=1206" alt="图片描述"></p><p>上图中可以明显看出：页面中设置了一个h1标题，应用了translate3d动画，使得它被放到composited layer中渲染，然后在这个元素后面创建了2000个list。在不为h1元素设置z-index的情况下，使得本不需要提升到合成层的ul元素下的每个li元素都提升为一个单独合成层（每个li元素的黄色提示边框），最终会导致GPU资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。</p><p><img data-src="https://segmentfault.com/img/bV85Ag?w=1070&h=1200" alt="图片描述"></p><p>如上图操作选中<code>为动画元素设置z-index</code>，可以看出ul下的每个li都回归到普通渲染层，不再是合成层也就不会消耗GPU资源去渲染，从而达到了优化页面性能优化的目的。</p><p>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加z-index前后的性能差距非常明显。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。<br>关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。<br>最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！</p><p><strong>参考文章：</strong><br><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a><br><a href="https://www.html5rocks.com/zh/tutorials/speed/layers/">DOM to Screen</a><br><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">CSS GPU Animation: Doing It Right</a><br>[web优化之composite](<a href="https://github.com/hello2dj/blog/blob/master/%08web%E4%BC%98%E5%8C%96%E4%B9%8Bcomposite.md">https://github.com/hello2dj/blog/blob/master/web优化之composite.md</a>)<br><a href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a><br><a href="http://div.io/topic/1348">CSS3硬件加速也有坑</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端性能优化的相关内容，好好掌握消化，其实这一部分实用性远高于应试性，很考验各位前端仔的实战水平的&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端性能" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
    <category term="优化" scheme="https://hxy1997.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>javascript面试问题</title>
    <link href="https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-22T16:09:54.000Z</published>
    <updated>2021-03-25T12:31:58.010Z</updated>
    
    <content type="html"><![CDATA[<p>javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  <a href="https://github.com/mqyqingfeng/Blog">冴羽的博客</a> ，内容丰富，适合有一定JS基础的人进行阅读</p><span id="more"></span><h1 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h1><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个构造函数都有一个 prototype 属性 ，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 虽然写在注释里，但是你要注意：</span><br><span class="line">&#x2F;&#x2F; prototype是对象的属性</span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person2.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在Firefox或者Chrome中控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图"></a></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为同一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person &#x3D;&#x3D;&#x3D; Person.prototype.constructor); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图"></a></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图"></a></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 就是 Object.prototype 没有原型，表达了同一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 关键 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>缺点：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向Parent传参</p><h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义每个子类实例不能共享父函数，浪费内存，开销较大。不能继承父类原型。</p><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">Child.prototype.constructor &#x3D; Child;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#39;black&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class="line">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class="line">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;kevin&#39;,</span><br><span class="line">    friends: [&#39;daisy&#39;, &#39;kelly&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; createObj(person);</span><br><span class="line">var person2 &#x3D; createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name &#x3D; &#39;person1&#39;;</span><br><span class="line">console.log(person2.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#39;taylor&#39;);</span><br><span class="line">console.log(person2.friends); &#x2F;&#x2F; [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone &#x3D; Object.create(o);</span><br><span class="line">    clone.sayName &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype &#x3D; new Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键的三步</span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line">F.prototype &#x3D; Parent.prototype;</span><br><span class="line">Child.prototype &#x3D; new F();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype(child, parent) &#123;</span><br><span class="line">    var prototype &#x3D; object(parent.prototype);</span><br><span class="line">    prototype.constructor &#x3D; child;</span><br><span class="line">    child.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h1 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链"></a>3.作用域链</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>函数的作用域在函数定义的时候就决定了,这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] &#x3D; [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] &#x3D; [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope &#x3D; [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h2 id="按照步骤分析"><a href="#按照步骤分析" class="headerlink" title="按照步骤分析"></a>按照步骤分析</h2><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 &#x3D; &#39;local scope&#39;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#39;local scope&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>MDN 对闭包的定义为：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p><p>那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……</p><p>还真是这样的！</p><p>所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><p>这只是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：</p><p>ECMAScript中，从实践角度，以下函数才算是闭包：</p><p>1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p><p>2.在代码中引用了自由变量</p><p>接下来就来讲讲实践上的闭包。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><p>这里直接给出简要的执行过程：</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p>了解到这个过程，我们应该思考一个问题，那就是：</p><p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)</p><p>然而 JavaScript 却是可以的！</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext &#x3D; &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</p><p>所以，让我们再看一遍实践角度上闭包的定义：</p><ol><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol><p>在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义:</p><blockquote><p>This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p></blockquote><p>闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。</p><h2 id="必刷题"><a href="#必刷题" class="headerlink" title="必刷题"></a>必刷题</h2><p>接下来，看这道刷题必刷，面试必考的闭包题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>答案是都是 3，让我们分析一下原因：</p><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><p>data[1] 和 data[2] 是一样的道理。</p><p>所以让我们改成闭包看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; (function (i) &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟没改之前一模一样。</p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数执行上下文的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 0,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。</p><p>data[1] 和 data[2] 是一样的道理。</p><h1 id="5-变量对象"><a href="#5-变量对象" class="headerlink" title="5.变量对象"></a>5.变量对象</h1><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p><blockquote><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p></blockquote><blockquote><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p></blockquote><blockquote><p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p></blockquote><p>如果看的不是很懂的话，容我再来介绍下全局对象:</p><p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br></pre></td></tr></table></figure><p>2.全局对象是由 Object 构造函数实例化的一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this instanceof Object);</span><br></pre></td></tr></table></figure><p>3.预定义了一堆，嗯，一大堆函数和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 都能生效</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(this.Math.random());</span><br></pre></td></tr></table></figure><p>4.作为全局变量的宿主。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(this.a);</span><br></pre></td></tr></table></figure><p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(window.a);</span><br><span class="line"></span><br><span class="line">this.window.b &#x3D; 2;</span><br><span class="line">console.log(this.b);</span><br></pre></td></tr></table></figure><p>花了一个大篇幅介绍全局对象，其实就想说：</p><p>全局上下文中的变量对象就是全局对象呐！</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后让我们看几个例子：</p><p>1.第一题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; ???</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; ???</span><br></pre></td></tr></table></figure><p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p><p>第二段会打印：<code>1</code>。</p><p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p><p>第一段执行 console 的时候， AO 的值是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p><p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p><p>2.第二题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo);</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; 1;</span><br></pre></td></tr></table></figure><p>会打印函数，而不是 undefined 。</p><p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><h1 id="6-从ECMAScript规范解读this"><a href="#6-从ECMAScript规范解读this" class="headerlink" title="6.从ECMAScript规范解读this"></a>6.从ECMAScript规范解读this</h1><p> ECMAScript 5.1 规范地址：</p><p>英文版：<a href="http://es5.github.io/#x15.1">http://es5.github.io/#x15.1</a></p><p>中文版：<a href="http://yanhaijing.com/es5/#115">http://yanhaijing.com/es5/#115</a></p><p>让我们开始了解规范吧！</p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>首先是第 8 章 Types：</p><p>ECMAScript 的类型分为语言类型和规范类型。</p><p>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。</p><p>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p><p>没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p> Reference 类型。它与 this 的指向有着密切的关联。</p><p>让我们看 8.7 章 The Reference Specification Type：</p><blockquote><p>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.</p></blockquote><p>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。</p><p>抄袭尤雨溪大大的话，就是：</p><blockquote><p>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p></blockquote><p>再看接下来的这段具体介绍 Reference 的内容：</p><blockquote><p>A Reference is a resolved name binding.</p></blockquote><blockquote><p>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.</p></blockquote><blockquote><p>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).</p></blockquote><blockquote><p>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p><ul><li>base value</li><li>referenced name</li><li>strict reference</li></ul><p>可是这些到底是什么呢？</p><p>我们简单的理解的话：</p><p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p><p>referenced name 就是属性的名称。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 对应的Reference是：</span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bar对应的Reference是：</span><br><span class="line">var BarReference &#x3D; &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &#39;bar&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p><p>这两个方法很简单，简单看一看：</p><p>1.GetBase</p><blockquote><p>GetBase(V). Returns the base value component of the reference V.</p></blockquote><p>返回 reference 的 base value。</p><p>2.IsPropertyReference</p><blockquote><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p></blockquote><p>简单的理解：如果 base value 是一个对象，就返回true。</p><h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。</p><p>简单模拟 GetValue 的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) &#x2F;&#x2F; 1;</span><br></pre></td></tr></table></figure><p>GetValue 返回对象属性真正的值，但是要注意：</p><p><strong>调用 GetValue，返回的将是具体的值，而不再是一个 Reference</strong></p><p>这个很重要，这个很重要，这个很重要。</p><h2 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h2><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：</p><p>看规范 11.2.3 Function Calls：</p><p>这里讲了当函数调用的时候，如何确定 this 的取值。</p><p>只看第一步、第六步、第七步：</p><blockquote><p>1.Let <em>ref</em> be the result of evaluating MemberExpression.</p></blockquote><blockquote><p>6.If Type(<em>ref</em>) is Reference, then</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.If IsPropertyReference(ref) is true, then</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be GetBase(ref).</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.Else, the base of ref is an Environment Record</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).</span><br></pre></td></tr></table></figure><p>7.Else, Type(<em>ref</em>) is not Reference.</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a. Let thisValue be undefined.</span><br></pre></td></tr></table></figure></blockquote><p>让我们描述一下：</p><p>1.计算 MemberExpression 的结果赋值给 ref</p><p>2.判断 ref 是不是一个 Reference 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</span><br><span class="line"></span><br><span class="line">2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</span><br><span class="line"></span><br><span class="line">2.3 如果 ref 不是 Reference，那么 this 的值为 undefined</span><br></pre></td></tr></table></figure><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>让我们一步一步看：</p><ol><li>计算 MemberExpression 的结果赋值给 ref</li></ol><p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：</p><p>MemberExpression :</p><ul><li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li><li>FunctionExpression // 函数定义表达式</li><li>MemberExpression [ Expression ] // 属性访问表达式</li><li>MemberExpression . IdentifierName // 属性访问表达式</li><li>new MemberExpression Arguments // 对象创建表达式</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); &#x2F;&#x2F; MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); &#x2F;&#x2F; MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure><p>所以简单理解 MemberExpression 其实就是()左边的部分。</p><p>2.判断 ref 是不是一个 Reference 类型。</p><p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p><p>举最后一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><p>在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？</p><p>查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：</p><blockquote><p>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.</p></blockquote><p>我们得知该表达式返回了一个 Reference 类型！</p><p>根据之前的内容，我们知道该值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference &#x3D; &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &#39;bar&#39;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来按照 2.1 的判断流程走：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？</p><p>前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。</p><p>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。</p><p>这个时候我们就可以确定 this 的值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this &#x3D; GetBase(ref)，</span><br></pre></td></tr></table></figure><p>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！</p><p>唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。</p><h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><p>看示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((foo.bar)());</span><br></pre></td></tr></table></figure><p>foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator</p><p>直接看结果部分：</p><blockquote><p>Return the result of evaluating Expression. This may be of type Reference.</p></blockquote><blockquote><p>NOTE This algorithm does not apply GetValue to the result of evaluating Expression.</p></blockquote><p>实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。</p><h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h3><p>看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ):</p><p>计算的第三步：</p><blockquote><p>3.Let rval be GetValue(rref).</p></blockquote><p>因为使用了 GetValue，所以返回的值不是 Reference 类型，</p><p>按照之前讲的判断逻辑：</p><blockquote><p>2.3 如果 ref 不是Reference，那么 this 的值为 undefined</p></blockquote><p>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。</p><h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><p>看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators：</p><p>计算第二步：</p><blockquote><p>2.Let lval be GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><p>看示例5，逗号操作符，查看规范11.14 Comma Operator ( , )</p><p>计算第二步：</p><blockquote><p>2.Call GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="揭晓结果"><a href="#揭晓结果" class="headerlink" title="揭晓结果"></a>揭晓结果</h3><p>所以最后一个例子的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</p><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>最最后，忘记了一个最最普通的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure><p>MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来进行判断：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。</p><p>IsPropertyReference(ref) 的结果为 false，进入下个判断：</p><blockquote><p>2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</p></blockquote><p>base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)</p><p>查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。</p><p>所以最后 this 的值就是 undefined。</p><h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。</p><p>此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。</p><h1 id="7-立即执行函数"><a href="#7-立即执行函数" class="headerlink" title="7.立即执行函数"></a>7.立即执行函数</h1><p>可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。</p><p>除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到<strong>立即调用函数表达式</strong>进行阅读，但是我建议你读完整篇文章。</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter() &#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(++i);</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记住：&#96;counter&#96;和&#96;counter2&#96;都有他们自己的变量 &#96;i&#96;</span><br><span class="line"></span><br><span class="line">var counter &#x3D; makeCounter();</span><br><span class="line">counter();&#x2F;&#x2F;1</span><br><span class="line">counter();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">var counter2 &#x3D; makeCounter();</span><br><span class="line">counter2();&#x2F;&#x2F;1</span><br><span class="line">counter2();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">i;&#x2F;&#x2F;ReferenceError: i is not defined(它只存在于makeCounter里)</span><br></pre></td></tr></table></figure><p>在许多情况下，你可能并不需要<code>makeWhatever</code>这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。</p><h3 id="它的核心"><a href="#它的核心" class="headerlink" title="它的核心"></a>它的核心</h3><p>现在，无论你定义一个函数像这样<code>function foo()&#123;&#125;</code>或者<code>var foo = function()&#123;&#125;</code>，调用时，你都需要在后面加上一对圆括号，像这样<code>foo()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样&#96;foo()&#96;，</span><br><span class="line">&#x2F;&#x2F;因为foo相对于函数表达式&#96;function()&#123;&#x2F;* code *&#x2F;&#125;&#96;只是一个引用变量</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？</span><br><span class="line"></span><br><span class="line">function()&#123; &#x2F;* code *&#x2F;&#125;(); &#x2F;&#x2F;SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure><p>正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的<code>function</code>关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。</p><p><strong>问题1：</strong>这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数 <code>var foo = function()&#123;console.log(1)&#125;()</code>，答案是可以的。<br><strong>问题2：</strong>同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。</p><h3 id="函数，圆括号，错误"><a href="#函数，圆括号，错误" class="headerlink" title="函数，圆括号，错误"></a>函数，圆括号，错误</h3><p>有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span><br><span class="line"></span><br><span class="line">function foo()&#123; &#x2F;* code *&#x2F; &#125;();&#x2F;&#x2F;SyntaxError: Unexpected token</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line">(1);</span><br></pre></td></tr></table></figure><h2 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h2><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能<strong>包含</strong>声明。因为这点，当圆括号为了包裹函数碰上了 <code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。<strong>注意理解</strong>这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p><ul><li>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</li><li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量</span><br><span class="line"></span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;());&#x2F;&#x2F;Crockford recommends this one，括号内的表达式代表函数立即调用表达式</span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;)();&#x2F;&#x2F;But this one works just as well，括号内的表达式代表函数表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Because the point of the parens or coercing operators is to disambiguate</span><br><span class="line">&#x2F;&#x2F; between function expressions and function declarations, they can be</span><br><span class="line">&#x2F;&#x2F; omitted when the parser already expects an expression (but please see the</span><br><span class="line">&#x2F;&#x2F; &quot;important note&quot; below).</span><br><span class="line"></span><br><span class="line">var i &#x3D; function()&#123;return 10;&#125;();</span><br><span class="line">true &amp;&amp; function()&#123;&#x2F;*code*&#x2F;&#125;();</span><br><span class="line">0,function()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节</span><br><span class="line"></span><br><span class="line">!function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">~function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">-function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">+function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Here&#39;s another variation, from @kuvos - I&#39;m not sure of the performance</span><br><span class="line">&#x2F;&#x2F; implications, if any, of using the &#96;new&#96; keyword, but it works.</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;twitter.com&#x2F;kuvos&#x2F;status&#x2F;18209252090847232</span><br><span class="line"></span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;</span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;() &#x2F;&#x2F; Only need parens if passing arguments</span><br></pre></td></tr></table></figure><h3 id="关于括号的重要笔记"><a href="#关于括号的重要笔记" class="headerlink" title="关于括号的重要笔记"></a>关于括号的重要笔记</h3><p>在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。</p><p>这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。</p><p>作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误 <code>WTFError</code>!</p><h3 id="保存闭包的状态"><a href="#保存闭包的状态" class="headerlink" title="保存闭包的状态"></a>保存闭包的状态</h3><p>就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 它的运行原理可能并不像你想的那样，因为&#96;i&#96;的值从来没有被锁定。</span><br><span class="line">&#x2F;&#x2F; 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，</span><br><span class="line">&#x2F;&#x2F; 因为这是 &#96;i&#96; 此时的真实值。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(&#39;I am link #&#39; + i)</span><br><span class="line">        &#125;,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 而像下面这样改写，便可以了，因为在IIFE里，&#96;i&#96;值被锁定在了&#96;lockedInIndex&#96;里。</span><br><span class="line">&#x2F;&#x2F; 在循环结束执行时，尽管&#96;i&#96;值的数值是所有元素的总和，但每一次函数表达式被调用时，</span><br><span class="line">&#x2F;&#x2F; IIFE 里的 &#96;lockedInIndex&#96; 值都是&#96;i&#96;传给它的值,所以当链接被点击时，正确的值被弹出。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length;i++) &#123;</span><br><span class="line">    (function(lockedInIndex)&#123;</span><br><span class="line">        elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(&#39;I am link #&#39; + lockedInIndex);</span><br><span class="line">            &#125;,false)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个&#96;addEventListener&#96;。</span><br><span class="line">&#x2F;&#x2F;无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName( &#39;a&#39; );</span><br><span class="line"></span><br><span class="line">for ( var i &#x3D; 0; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[ i ].addEventListener( &#39;click&#39;, (function( lockedInIndex )&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( &#39;I am link #&#39; + lockedInIndex );</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;)( i ),false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记住，在这最后两个例子里，<code>lockedInIndex</code>可以没有任何问题的访问<code>i</code>,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。</p><p>立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。</p><h4 id="自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？"><a href="#自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？" class="headerlink" title="自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？"></a>自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？</h4><p>你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成**”Immediately-Invoked Function Expression”<strong>，或者，</strong>IIFE**，如果你喜欢缩写的话。</p><p>什么是<strong>Immediately-Invoked Function Expression</strong>呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。</p><p>我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，<strong>Immediately-Invoked Function Expression</strong>和 <strong>IIFE</strong>，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下面是个自执行函数，递归的调用自己本身</span><br><span class="line"></span><br><span class="line">function foo()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是一个自执行匿名函数。因为它没有标识符，它必须是使用&#96;arguments.callee&#96;属性来调用它自己</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;arguments.callee();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这也许算是一个自执行匿名函数，但是仅仅当&#96;foo&#96;标识符作为它的引用时，如果你将它换成用&#96;foo&#96;来调用同样可行</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有些人像这样叫&#39;self-executing anonymous function&#39;下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。</span><br><span class="line"></span><br><span class="line">(function()&#123; &#x2F;*code*&#x2F; &#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。</span><br><span class="line"></span><br><span class="line">(function foo()&#123;&#x2F;* code *&#x2F;&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IIFEs同样也可以自执行，尽管，也许他不是最有用的模式</span><br><span class="line"></span><br><span class="line">(function()&#123;arguments.callee();&#125;())</span><br><span class="line">(function foo()&#123;foo();&#125;())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; One last thing to note: this will cause an error in BlackBerry 5, because</span><br><span class="line">&#x2F;&#x2F; inside a named function expression, that name is undefined. Awesome, huh?</span><br><span class="line"></span><br><span class="line">(function foo()&#123; foo(); &#125;());</span><br></pre></td></tr></table></figure><p>希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，<strong>Immediately Invoked Function Expression</strong>，既可以是命名函数也可以匿名函数。</p><h2 id="最后：模块模式"><a href="#最后：模块模式" class="headerlink" title="最后：模块模式"></a>最后：模块模式</h2><p>当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不属性 JavaScript 里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; (function()&#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            i &#x3D; val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: function()&#123;</span><br><span class="line">            return ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">    counter.get();&#x2F;&#x2F;0</span><br><span class="line">    counter.set(3);</span><br><span class="line">    counter.increment();&#x2F;&#x2F;4</span><br><span class="line">    counter.increment();&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class="line">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure><p>模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。</p><h1 id="8-instanceof-和-typeof-的实现原理"><a href="#8-instanceof-和-typeof-的实现原理" class="headerlink" title="8.instanceof 和 typeof 的实现原理"></a>8.instanceof 和 typeof 的实现原理</h1><h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>,  <code>string</code>,  <code>object</code>,  <code>boolean</code>,  <code>function</code>, <code>undefined</code>,  <code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">typeof s &#x3D;&#x3D;&#x3D; &#39;object&#39;&#x2F;&#x2F; true</span><br><span class="line">s instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><p><code>null</code>：所有机器码均为0</p><p><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null instanceof null &#x2F;&#x2F; TypeError: Right-hand side of &#39;instanceof&#39; is not an object</span><br></pre></td></tr></table></figure><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>。</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(1) &#x2F;&#x2F; &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#39;hi&#39;) &#x2F;&#x2F; &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;a:&#39;hi&#39;&#125;) &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([1,&#39;a&#39;]) &#x2F;&#x2F; &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true) &#x2F;&#x2F; &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(() &#x3D;&gt; &#123;&#125;) &#x2F;&#x2F; &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null) &#x2F;&#x2F; &quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) &#x2F;&#x2F; &quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(Symbol(1)) &#x2F;&#x2F; &quot;[object Symbol]&quot;</span><br></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let nicole &#x3D; new person()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let programmer &#x3D; function () &#123;&#125;</span><br><span class="line">programmer.prototype &#x3D; new person()</span><br><span class="line">let nicole &#x3D; new programmer()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br><span class="line">nicole instanceof programmer &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function new_instance_of(leftVaule, rightVaule) &#123; </span><br><span class="line">    let rightProto &#x3D; rightVaule.prototype; &#x2F;&#x2F; 取右表达式的 prototype 值</span><br><span class="line">    leftVaule &#x3D; leftVaule.__proto__; &#x2F;&#x2F; 取左表达式的__proto__值</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    if (leftVaule &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftVaule &#x3D;&#x3D;&#x3D; rightProto) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule &#x3D; leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><p>看几个很有趣的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Function &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Foo &#x2F;&#x2F; false</span><br><span class="line">Foo instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Function &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p><p>关于原型继承的原理，我简单用一张图来表示</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p><ul><li><p><code>Object instanceof Object</code></p><p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Object.__proto__ &#x3D; Function.prototype;</span><br><span class="line">rightValue &#x3D; Object.prototype;</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p></li><li><p><code>Foo instanceof Foo</code></p><p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p><p>我们用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Foo</span><br><span class="line">leftValue &#x3D; Foo.__proto &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Foo.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Object.prototype &#x3D; null</span><br><span class="line">&#x2F;&#x2F; 第三次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; null</span><br><span class="line">&#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Object</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Object</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Function</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Function</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Function.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p><h1 id="9-bind实现"><a href="#9-bind实现" class="headerlink" title="9.bind实现"></a>9.bind实现</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 bind:</p><blockquote><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p></blockquote><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回了一个函数</span><br><span class="line">var bindFoo &#x3D; bar.bind(foo); </span><br><span class="line"></span><br><span class="line">bindFoo(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，来写第一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，之所以 <code>return self.apply(context)</code>，是考虑到绑定函数可能是有返回值的，依然是这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">return this.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo);</span><br><span class="line">console.log(bindFoo()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line">bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 获取bind2函数从第二个参数到最后一个参数</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个时候的arguments是指bind返回的函数传入的参数</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    this.habit &#x3D; &#39;shopping&#39;;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend &#x3D; &#39;kevin&#39;;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br><span class="line">console.log(obj.habit);</span><br><span class="line">console.log(obj.friend);</span><br><span class="line">&#x2F;&#x2F; shopping</span><br><span class="line">&#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        &#x2F;&#x2F; 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span><br><span class="line">        &#x2F;&#x2F; 以上面的是 demo 为例，如果改成 &#96;this instanceof fBound ? null : context&#96;，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span><br><span class="line">        &#x2F;&#x2F; 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span><br><span class="line">        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span><br><span class="line">    fBound.prototype &#x3D; this.prototype;</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p><h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p><p><strong>1.apply 这段代码跟 MDN 上的稍有不同</strong></p><p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, args.concat(bindArgs))</span><br></pre></td></tr></table></figure><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    bar: bar.bind(null)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p><p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p><p><strong>2.调用 bind 的不是函数咋办？</strong></p><p>不行，我们要报错！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.我要在线上用</strong></p><p>那别忘了做个兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; Function.prototype.bind || function () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然最好是用 <a href="https://github.com/es-shims/es5-shim">es5-shim</a> 啦。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试够用版"><a href="#面试够用版" class="headerlink" title="面试够用版"></a>面试够用版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function (context, ...args) &#123;</span><br><span class="line">&#x2F;&#x2F; 环境</span><br><span class="line">    context &#x3D; context || window;</span><br><span class="line">    &#x2F;&#x2F; 创建一个Symbol变量，让当前环境指向当前位置</span><br><span class="line">    const fnSymbol &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">    &#x2F;&#x2F; 配置环境</span><br><span class="line">    context[fnSymbol] &#x3D; this;</span><br><span class="line">&#x2F;&#x2F; 返回闭包函数</span><br><span class="line">    return function (..._args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 与当前参数组合</span><br><span class="line">        args &#x3D; args.concat(_args);</span><br><span class="line">&#x2F;&#x2F; 执行函数</span><br><span class="line">        context[fnSymbol](...args);</span><br><span class="line">        &#x2F;&#x2F; 避免闭包的内存泄露</span><br><span class="line">        delete context[fnSymbol];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-call和apply"><a href="#10-call和apply" class="headerlink" title="10.call和apply"></a>10.call和apply</h1><h2 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h2><p>它们的共同点是，都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p><p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p><p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p><h2 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h2><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p><h4 id="call-的写法"><a href="#call-的写法" class="headerlink" title="call 的写法"></a>call 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.call(obj,[param1[,param2[,…[,paramN]]]])</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>调用 call 的对象，必须是个函数 Function。</li><li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li><li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func (a,b,c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, 1,2,3)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.call(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure><h4 id="apply-的写法"><a href="#apply-的写法" class="headerlink" title="apply 的写法"></a>apply 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure><h4 id="什么是类数组？"><a href="#什么是类数组？" class="headerlink" title="什么是类数组？"></a>什么是类数组？</h4><p>先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。</p><p>那么，类数组是什么呢？顾名思义，就是<strong>具备与数组特征类似的对象</strong>。比如，下面的这个对象，就是一个类数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。</p><p>类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。</p><p>但是需要注意的是：<strong>类数组无法使用 forEach、splice、push 等数组原型链上的方法</strong>，毕竟它不是真正的数组。</p><h2 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h2><p>下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。</p><h4 id="call-的使用场景"><a href="#call-的使用场景" class="headerlink" title="call 的使用场景"></a>call 的使用场景</h4><p><strong>1、对象的继承</strong>。如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function superClass () &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">    this.print &#x3D; function () &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subClass () &#123;</span><br><span class="line">    superClass.call(this);</span><br><span class="line">    this.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass();</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p><p><strong>2、借用方法</strong>。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</span><br></pre></td></tr></table></figure><p>这样，domNodes 就可以应用 Array 下的所有方法了。</p><h4 id="apply-的一些妙用"><a href="#apply-的一些妙用" class="headerlink" title="apply 的一些妙用"></a>apply 的一些妙用</h4><p><strong>1、Math.max</strong>。用它来获取数组中最大的一项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let max &#x3D; Math.max.apply(null, array);</span><br></pre></td></tr></table></figure><p>同理，要获取数组中最小的一项，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let min &#x3D; Math.min.apply(null, array);</span><br></pre></td></tr></table></figure><p><strong>2、实现两个数组合并</strong>。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; [1, 2, 3];</span><br><span class="line">let arr2 &#x3D; [4, 5, 6];</span><br><span class="line"></span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h2 id="手写apply和bind"><a href="#手写apply和bind" class="headerlink" title="手写apply和bind"></a>手写apply和bind</h2><p>call的手写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">  context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply的手写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; apply</span><br><span class="line">Function.prototype.myApply &#x3D; function (context &#x3D; window, argsArr) &#123;</span><br><span class="line">  const fn &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 重点代码，利用this指向，相当于context.caller(...args)</span><br><span class="line">  context[fn](...argsArr);</span><br><span class="line">  delete context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-函数柯里化"><a href="#11-函数柯里化" class="headerlink" title="11.函数柯里化"></a>11.函数柯里化</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对柯里化 (Currying) 的定义为：</p><blockquote><p>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p></blockquote><p>翻译成中文：</p><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行 add 函数，一次传入两个参数即可</span><br><span class="line">add(1, 2) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设有一个 curry 函数可以做到柯里化</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1)(2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>我们会讲到如何写出这个 curry 函数，并且会将这个 curry 函数写的很强大，但是在编写之前，我们需要知道柯里化到底有什么用？</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示意而已</span><br><span class="line">function ajax(type, url, data) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 虽然 ajax 这个函数非常通用，但在重复调用的时候参数冗余</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test2.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test3.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用 curry</span><br><span class="line">var ajaxCurry &#x3D; curry(ajax);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求数据</span><br><span class="line">var post &#x3D; ajaxCurry(&#39;POST&#39;);</span><br><span class="line">post(&#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求来自于 www.test.com 的数据</span><br><span class="line">var postFromTest &#x3D; post(&#39;www.test.com&#39;);</span><br><span class="line">postFromTest(&quot;name&#x3D;kevin&quot;);</span><br></pre></td></tr></table></figure><p>想想 jQuery 虽然有 $.ajax 这样通用的方法，但是也有 $.get 和 $.post 的语法糖。</p><p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p><p>可是即便如此，是不是依然感觉没什么用呢？</p><p>如果我们仅仅是把参数一个一个传进去，意义可能不大，但是如果我们是把柯里化后的函数传给其他函数比如 map 呢？</p><p>举个例子：</p><p>比如我们有这样一段数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; [&#123;name: &#39;kevin&#39;&#125;, &#123;name: &#39;daisy&#39;&#125;]</span><br></pre></td></tr></table></figure><p>如果我们要获取所有的 name 值，我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; person.map(function (item) &#123;</span><br><span class="line">    return item.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过如果我们有 curry 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var prop &#x3D; curry(function (key, obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var name &#x3D; person.map(prop(&#39;name&#39;))</span><br></pre></td></tr></table></figure><p>我们为了获取 name 属性还要再编写一个 prop 函数，是不是又麻烦了些？</p><p>但是要注意，prop 函数编写一次后，以后可以多次使用，实际上代码从原本的三行精简成了一行，而且你看代码是不是更加易懂了？</p><p><code>person.map(prop(&#39;name&#39;))</code> 就好像直白的告诉你：person 对象遍历(map)获取(prop) name 属性。</p><p>是不是感觉有点意思了呢？</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>未来我们会接触到更多有关柯里化的应用，不过那是未来的事情了，现在我们该编写这个 curry 函数了。</p><p>一个经常会看到的 curry 函数的实现为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        return fn.apply(this, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry &#x3D; curry(add, 1, 2);</span><br><span class="line">addCurry() &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add, 1);</span><br><span class="line">addCurry(2) &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1, 2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。</p><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function sub_curry(fn) &#123;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(this, args.concat([].slice.call(arguments)));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length) &#123;</span><br><span class="line"></span><br><span class="line">    length &#x3D; length || fn.length;</span><br><span class="line"></span><br><span class="line">    var slice &#x3D; Array.prototype.slice;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        if (arguments.length &lt; length) &#123;</span><br><span class="line">            var combined &#x3D; [fn].concat(slice.call(arguments));</span><br><span class="line">            return curry(sub_curry.apply(this, combined), length - arguments.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们验证下这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    return [a, b, c];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>效果已经达到我们的预期，然而这个 curry 函数的实现好难理解呐……</p><p>为了让大家更好的理解这个 curry 函数，我给大家写个极简版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sub_curry(fn)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length)&#123;</span><br><span class="line">    length &#x3D; length || 4;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if (length &gt; 1) &#123;</span><br><span class="line">            return curry(sub_curry(fn), --length)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn0 &#x3D; function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0)</span><br><span class="line"></span><br><span class="line">fn1()()()() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>大家先从理解这个 curry 函数开始。</p><p>当执行 fn1() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(fn0))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return (function()&#123;</span><br><span class="line">        return fn0()</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跟 fn1()() 的分析过程一样</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()()() 时，因为此时 length &gt; 2 为 false，所以执行 fn()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0()</span><br><span class="line">&#x2F;&#x2F; 执行 fn0 函数，打印 1</span><br></pre></td></tr></table></figure><p>再回到真正的 curry 函数，我们以下面的例子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn0 &#x3D; function(a, b, c, d) &#123;</span><br><span class="line">    return [a, b, c, d];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0);</span><br><span class="line"></span><br><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;)(&quot;d&quot;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”) 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(fn0)(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(sub_curry(fn0, &quot;a&quot;, &quot;b&quot;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">&#x2F;&#x2F; 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为 fn0 后面的参数传入</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”) 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;), &quot;c&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return (function(...) &#123;return fn0(&quot;a&quot;, &quot;b&quot;, ...)&#125;)(&quot;c&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">     return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”)(“d”) 时，此时 arguments.length &lt; length 为 false ，执行 fn(arguments)，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)(&quot;d&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br></pre></td></tr></table></figure><p>函数执行结束。</p><p>所以，其实整段代码又很好理解：</p><p>sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(…)(…) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。</p><p>如果要明白 curry 函数的运行原理，大家还是要动手写一遍，尝试着分析执行步骤。</p><h2 id="更易懂的实现"><a href="#更易懂的实现" class="headerlink" title="更易懂的实现"></a>更易懂的实现</h2><p>当然了，如果你觉得还是无法理解，你可以选择下面这种实现方式，可以实现同样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">    var length &#x3D; fn.length;</span><br><span class="line"></span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line"></span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line"></span><br><span class="line">            arg, i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line"></span><br><span class="line">            _args.push(arg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>或许大家觉得这种方式更好理解，又能实现一样的效果，为什么不直接就讲这种呢？</p><p>因为想给大家介绍各种实现的方法嘛，不能因为难以理解就不给大家介绍呐~</p><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>curry 函数写到这里其实已经很完善了，但是注意这个函数的传参顺序必须是从左到右，根据形参的顺序依次传入，如果我不想根据这个顺序传呢？</p><p>我们可以创建一个占位符，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, _, &quot;c&quot;)(&quot;b&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>我们直接看第三版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function curry(fn, args, holes) &#123;</span><br><span class="line">    length &#x3D; fn.length;</span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line">    holes &#x3D; holes || [];</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line">            _holes &#x3D; holes.slice(0),</span><br><span class="line">            argsLen &#x3D; args.length,</span><br><span class="line">            holesLen &#x3D; holes.length,</span><br><span class="line">            arg, i, index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标</span><br><span class="line">            if (arg &#x3D;&#x3D;&#x3D; _ &amp;&amp; holesLen) &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index &gt; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                    _holes.push(argsLen - 1 + index - holesLen)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1)(_) 这种情况</span><br><span class="line">            else if (arg &#x3D;&#x3D;&#x3D; _) &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">                _holes.push(argsLen + i);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(_, 2)(1) 这种情况</span><br><span class="line">            else if (holesLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(_, 3)</span><br><span class="line">                if (index &gt;&#x3D; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(1) 用参数 1 替换占位符</span><br><span class="line">                else &#123;</span><br><span class="line">                    _args.splice(_holes[index], 1, arg);</span><br><span class="line">                    _holes.splice(index, 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_holes.length || _args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args, _holes);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c, d, e) &#123;</span><br><span class="line">    console.log([a, b, c, d, e]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证 输出全部都是 [1, 2, 3, 4, 5]</span><br><span class="line">fn(1, 2, 3, 4, 5);</span><br><span class="line">fn(_, 2, 3, 4, 5)(1);</span><br><span class="line">fn(1, _, 3, 4, 5)(2);</span><br><span class="line">fn(1, _, 3)(_, 4)(2)(5);</span><br><span class="line">fn(1, _, _, 4)(_, 3)(2)(5);</span><br><span class="line">fn(_, 2)(_, _, 4)(1)(3)(5)</span><br></pre></td></tr></table></figure><h2 id="面试够用版-1"><a href="#面试够用版-1" class="headerlink" title="面试够用版"></a>面试够用版</h2><p>就是第二版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        if (newArgs.length &lt; fn.length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="12-V8引擎的垃圾回收"><a href="#12-V8引擎的垃圾回收" class="headerlink" title="12.V8引擎的垃圾回收"></a>12.V8引擎的垃圾回收</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>作为目前最流行的JavaScript引擎，V8引擎从出现的那一刻起便广泛受到人们的关注，我们知道，JavaScript可以高效地运行在浏览器和Nodejs这两大宿主环境中，也是因为背后有强大的V8引擎在为其保驾护航，甚至成就了Chrome在浏览器中的霸主地位。不得不说，V8引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的<code>Full-codegen</code>和<code>Crankshaft</code>编译器升级为<code>Ignition</code>解释器和<code>TurboFan</code>编译器的强强组合，到隐藏类，内联缓存和<code>HotSpot</code>热点代码收集等一系列强有力的优化策略，V8引擎正在努力降低整体的内存占用和提升到更高的运行性能。</p><p>本篇主要是从V8引擎的垃圾回收机制入手，讲解一下在JavaScript代码执行的整个生命周期中V8引擎是采取怎样的垃圾回收策略来减少内存占比的，当然这部分的知识并不太影响我们写代码的流程，毕竟在一般情况下我们很少会遇到浏览器端出现内存溢出而导致程序崩溃的情况，但是至少我们对这方面有一定的了解之后，能增强我们在写代码过程中对减少内存占用，避免内存泄漏的主观意识，也许能够帮助你写出更加健壮和对V8引擎更加友好的代码。本文也是笔者在查阅资料巩固复习的过程中慢慢总结和整理出来的，若文中有错误的地方，还请指正。</p><h3 id="1、为何需要垃圾回收"><a href="#1、为何需要垃圾回收" class="headerlink" title="1、为何需要垃圾回收"></a>1、为何需要垃圾回收</h3><p>我们知道，在V8引擎逐行执行JavaScript代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。</p><blockquote><p>这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。</p></blockquote><p>但是JavaScript作为一门高级编程语言，并不像C语言或C++语言中需要手动地申请分配和释放内存，V8引擎已经帮我们自动进行了内存的分配和管理，好让我们有更多的精力去专注于业务层面的复杂逻辑，这对于我们前端开发人员来说是一项福利，但是随之带来的问题也是显而易见的，那就是由于不用去手动管理内存，导致写代码的过程中不够严谨从而容易引发内存泄漏(毕竟这是别人对你的好，你没有付出过，又怎能体会得到？)。</p><h3 id="2、V8引擎的内存限制"><a href="#2、V8引擎的内存限制" class="headerlink" title="2、V8引擎的内存限制"></a>2、V8引擎的内存限制</h3><p>虽然V8引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但V8引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8引擎在<code>64</code>位系统下最多只能使用约<code>1.4GB</code>的内存，在<code>32</code>位系统下最多只能使用约<code>0.7GB</code>的内存，在这样的限制下，必然会导致在node中无法直接操作大内存对象，比如将一个<code>2GB</code>大小的文件全部读入内存进行字符串分析处理，即使物理内存高达<code>32GB</code>也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？这个要回到V8引擎的设计之初，起初只是作为浏览器端JavaScript的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：</p><ul><li><code>JS单线程机制</code>：作为浏览器的脚本语言，JS的主要用途是与用户交互以及操作DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。试想如果JS是多线程的，一个线程在删除DOM元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。既然JS是单线程的，那么也就意味着在V8执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行JS逻辑。因此，由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</li></ul><blockquote><p>虽然JS是单线程的，但是为了能够充分利用操作系统的多核CPU计算能力，在HTML5中引入了新的Web Worker标准，其作用就是为JS创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker在后台运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被Worker线程负担，主线程(通常负责UI交互)就会很流畅，不会被阻塞或者拖慢。Web Worker不是JS的一部分，而是通过JS访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的API，例如操作DOM，因此这个新标准并没有改变JS单线程的本质。</p></blockquote><ul><li><code>垃圾回收机制</code>：垃圾回收本身也是一件非常耗时的操作，假设V8的堆内存为<code>1.5G</code>，那么V8做一次小的垃圾回收需要50ms以上，而做一次非增量式回收甚至需要1s以上，可见其耗时之久，而在这1s的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。</li></ul><p>基于以上两点，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景。但是在node端，涉及到的<code>I/O</code>操作可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，V8为我们提供了可配置项来让我们手动地调整内存大小，但是需要在node初始化的时候进行配置，我们可以通过如下方式来手动设置。</p><p>我们尝试在node命令行中输入以下命令：</p><blockquote><p>笔者本地安装的node版本为<code>v10.14.2</code>，可通过<code>node -v</code>查看本地node的版本号，不同版本可能会导致下面的命令会有所差异。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该命令可以用来查看node中可用的V8引擎的选项及其含义</span><br><span class="line">node --v8-options</span><br></pre></td></tr></table></figure><p>然后我们会在命令行窗口中看到大量关于V8的选项，这里我们暂且只关注图中红色选框中的几个选项：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edeb6f141feaac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最小值，单位MB</span><br><span class="line">node --min-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最大值，单位MB</span><br><span class="line">node --max-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置老生代内存最大值，单位MB</span><br><span class="line">node --max-old-space-size&#x3D;2048 xxx.js</span><br></pre></td></tr></table></figure><p>通过以上方法便可以手动放宽V8引擎所使用的内存限制，同时node也为我们提供了<code>process.memoryUsage()</code>方法来让我们可以查看当前node进程所占用的实际内存大小。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edf18bb16af64d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在上图中，包含的几个字段的含义分别如下所示，单位均为字节：</p><ul><li><code>heapTotal</code>：表示V8当前申请到的堆内存总大小。</li><li><code>heapUsed</code>：表示当前内存使用量。</li><li><code>external</code>：表示V8内部的C++对象所占用的内存。</li><li><code>rss(resident set size)</code>：表示驻留集大小，是给这个node进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的JavaScript源代码存于代码段内存。使用Worker线程时，<code>rss</code>将会是一个对整个进程有效的值，而其他字段则只针对当前线程。</li></ul><blockquote><p>在JS中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过V8的限制为止。</p></blockquote><h3 id="3、V8的垃圾回收策略"><a href="#3、V8的垃圾回收策略" class="headerlink" title="3、V8的垃圾回收策略"></a>3、V8的垃圾回收策略</h3><p>V8的垃圾回收策略主要是基于<code>分代式垃圾回收机制</code>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h4 id="3-1-V8的内存结构"><a href="#3-1-V8的内存结构" class="headerlink" title="3.1 V8的内存结构"></a>3.1 V8的内存结构</h4><p>在V8引擎的堆结构组成中，其实除了<code>新生代</code>和<code>老生代</code>外，还包含其他几个部分，但是垃圾回收的过程主要出现在新生代和老生代，所以对于其他的部分我们没必要做太多的深入，有兴趣的小伙伴儿可以查阅下相关资料，V8的内存结构主要由以下几个部分组成：</p><ul><li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li><li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li><li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li><li><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li><li><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</li></ul><p>内存结构图如下所示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee12280b78399d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态，为什么会划分为两个部分呢，在下一小节我们会讲到。</p><h4 id="3-2-新生代"><a href="#3-2-新生代" class="headerlink" title="3.2 新生代"></a>3.2 新生代</h4><p>在V8引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个<code>semispace(半空间)</code>构成的，内存最大值在<code>64</code>位系统和<code>32</code>位系统上分别为<code>32MB</code>和<code>16MB</code>，在新生代的垃圾回收过程中主要采用了<code>Scavenge</code>算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><blockquote><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p></blockquote><p>基于以上算法，我们可以画出如下的流程图：</p><ul><li>假设我们在<code>From</code>空间中分配了三个对象A、B、C</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee172cf1a23c9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象A已经没有其他引用，则表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17a2fda2c461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，因此会被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17decd1d9ed2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>接下来将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1819dd9f5999?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>此时<code>From</code>空间中的内存已经清空，开始和<code>To</code>空间完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18439a76a3eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程在执行第二个任务时，在<code>From</code>空间中分配了一个新对象D</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1874b4c441d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>任务执行完毕后再次进入垃圾回收，发现对象D已经没有其他引用，表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18969e114bc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，再次被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18cd2bff353c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>再次将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18f4a21c517e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>From</code>空间和<code>To</code>空间继续完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee191560b716c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通过以上的流程图，我们可以很清楚地看到，<code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h4 id="3-3-对象晋升"><a href="#3-3-对象晋升" class="headerlink" title="3.3 对象晋升"></a>3.3 对象晋升</h4><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><p>默认情况下，我们创建的对象都会分配在<code>From</code>空间中，当进行垃圾回收时，在将对象从<code>From</code>空间复制到<code>To</code>空间之前，会先检查该对象的内存地址来判断是否已经经历过一次<code>Scavenge</code>算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到<code>To</code>空间，可以用以下的流程图来表示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c5634e61f9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如果对象没有经历过<code>Scavenge</code>算法，会被复制到<code>To</code>空间，但是如果此时<code>To</code>空间的内存占比已经超过<code>25%</code>，则该对象依旧会被转移到老生代，如下图所示:</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c90fedad146?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>之所以有<code>25%</code>的内存限制是因为<code>To</code>空间在经历过一次<code>Scavenge</code>算法后会和<code>From</code>空间完成角色互换，会变为<code>From</code>空间，后续的内存分配都是在<code>From</code>空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p><h4 id="3-4-老生代"><a href="#3-4-老生代" class="headerlink" title="3.4 老生代"></a>3.4 老生代</h4><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>来进行管理。</p><p>在早前我们可能听说过一种算法叫做<code>引用计数</code>，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建了两个对象obj1和obj2，其中obj2作为obj1的属性被obj1引用，因此不会被垃圾回收</span><br><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">    obj2: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj3并将obj1赋值给obj3，让两个对象指向同一个内存地址</span><br><span class="line">let obj3 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj1重新赋值，此时原来obj1指向的对象现在只由obj3来表示</span><br><span class="line">obj1 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj4并将obj3.obj2赋值给obj4</span><br><span class="line">&#x2F;&#x2F; 此时obj2所指向的对象有两个引用：一个是作为obj3的属性，另一个是变量obj4</span><br><span class="line">let obj4 &#x3D; obj3.obj2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj3重新赋值，此时本可以对obj3指向的对象进行回收，但是因为obj3.obj2被obj4所引用，因此依旧不能被回收</span><br><span class="line">obj3 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此时obj3.obj2已经没有指向它的引用，因此obj3指向的对象在此时可以被回收</span><br><span class="line">obj4 &#x3D; null;</span><br></pre></td></tr></table></figure><p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到<code>循环引用</code>的场景，就会出现问题，我们看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let a &#x3D; &#123;&#125;;</span><br><span class="line">    let b &#x3D; &#123;&#125;;</span><br><span class="line">    a.a1 &#x3D; b;</span><br><span class="line">    b.b1 &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这个例子中我们将对象<code>a</code>的<code>a1</code>属性指向对象<code>b</code>，将对象<code>b</code>的<code>b1</code>属性指向对象<code>a</code>，形成两个对象相互引用，在<code>foo</code>函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量<code>a</code>和<code>b</code>本应该可以被回收，但是因为采用了<code>引用计数</code>的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。</p><p>因此为了避免循环引用导致的内存泄漏问题，截至2012年所有的现代浏览器均放弃了这种算法，转而采用新的<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>算法。在上面循环引用的例子中，因为变量<code>a</code>和变量<code>b</code>无法从<code>window</code>全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p><p><code>Mark-Sweep(标记清除)</code>分为<code>标记</code>和<code>清除</code>两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。<code>Mark-Sweep</code>算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p><ul><li>垃圾回收器会在内部构建一个<code>根列表</code>，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，<code>window</code>全局对象可以看成一个根节点。</li><li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li><li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li></ul><blockquote><p>以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee468e85a1084d?imageslim" alt="img"></p><p>但是<code>Mark-Sweep</code>算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示：</p><ul><li>假设在老生代中有A、B、C、D四个对象</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee47d9f933bfc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>标记</code>阶段，将对象A和对象C标记为活动的</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee486ece5fda42?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>整理</code>阶段，将活动的对象往堆内存的一端移动</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee48f23fe98d7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>清除</code>阶段，将活动对象左侧的内存全部回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee490a8b9bf0af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>至此就完成了一次老生代垃圾回收的全部过程，我们在前文中说过，由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为<code>全停顿(stop-the-world)</code>。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p><p>因此，为了减少垃圾回收带来的停顿时间，V8引擎又引入了<code>Incremental Marking(增量标记)</code>的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像<code>React</code>框架中的<code>Fiber</code>架构，只有在浏览器的空闲时间才会去遍历<code>Fiber Tree</code>执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<code>延迟清理(lazy sweeping)</code>和<code>增量式整理(incremental compaction)</code>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入<code>并行标记</code>和<code>并行清理</code>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h3 id="4、如何避免内存泄漏"><a href="#4、如何避免内存泄漏" class="headerlink" title="4、如何避免内存泄漏"></a>4、如何避免内存泄漏</h3><p>在我们写代码的过程中，基本上都不太会关注写出怎样的代码才能有效地避免内存泄漏，或者说浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏问题，但是我们还是有必要了解一下常见的几种避免内存泄漏的方式，毕竟在面试过程中也是经常考察的要点。</p><h4 id="4-1-尽可能少地创建全局变量"><a href="#4-1-尽可能少地创建全局变量" class="headerlink" title="4.1 尽可能少地创建全局变量"></a>4.1 尽可能少地创建全局变量</h4><p>在ES5中以<code>var</code>声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到<code>window</code>全局对象上，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1; &#x2F;&#x2F; 等价于 window.a &#x3D; 1;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    window.a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>foo</code>函数中创建了一个变量<code>a</code>但是忘记使用<code>var</code>来声明，此时会意想不到地创建一个全局变量并挂载到window对象上，另外还有一种比较隐蔽的方式来创建全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">foo(); &#x2F;&#x2F; 相当于 window.foo()</span><br></pre></td></tr></table></figure><p>当<code>foo</code>函数在调用时，它所指向的运行上下文环境为<code>window</code>全局对象，因此函数中的<code>this</code>指向的其实是<code>window</code>，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为<code>window</code>对象可以作为根节点，在<code>window</code>上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为<code>null</code>从而触发回收机制。</p><h4 id="4-2-手动清除定时器"><a href="#4-2-手动清除定时器" class="headerlink" title="4.2 手动清除定时器"></a>4.2 手动清除定时器</h4><p>在我们的应用中经常会有使用<code>setTimeout</code>或者<code>setInterval</code>等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [];</span><br><span class="line">const foo &#x3D; function() &#123;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; 100000;i++) &#123;</span><br><span class="line">        numbers.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">window.setInterval(foo, 1000);</span><br></pre></td></tr></table></figure><p>在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的<code>numbers</code>变量也不会被垃圾回收，最终导致<code>numbers</code>数组长度无限递增，从而引发内存泄漏。</p><h4 id="4-3-少用闭包"><a href="#4-3-少用闭包" class="headerlink" title="4.3 少用闭包"></a>4.3 少用闭包</h4><p>闭包是JS中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let local &#x3D; 123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bar &#x3D; foo();</span><br><span class="line">console.log(bar()); &#x2F;&#x2F; -&gt; 123</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>foo</code>函数执行完毕后会返回一个匿名函数，该函数内部引用了<code>foo</code>函数中的局部变量<code>local</code>，并且通过变量<code>bar</code>来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在<code>foo</code>函数的外部作用域中访问到它的局部变量<code>local</code>。一般情况下，当<code>foo</code>函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致<code>local</code>变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。</p><h4 id="4-4-清除DOM引用"><a href="#4-4-清除DOM引用" class="headerlink" title="4.4 清除DOM引用"></a>4.4 清除DOM引用</h4><p>以往我们在操作DOM元素时，为了避免多次获取DOM元素，我们会将DOM元素存储在一个数据字典中，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;button&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们想调用<code>removeButton</code>方法来清除<code>button</code>元素，但是由于在<code>elements</code>字典中存在对<code>button</code>元素的引用，所以即使我们通过<code>removeChild</code>方法移除了<code>button</code>元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对<code>button</code>元素的引用才会被垃圾回收。</p><h4 id="4-5-弱引用"><a href="#4-5-弱引用" class="headerlink" title="4.5 弱引用"></a>4.5 弱引用</h4><p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在ES6中为我们新增了两个有效的数据结构<code>WeakMap</code>和<code>WeakSet</code>，就是为了解决内存泄漏的问题而诞生的。其表示<code>弱引用</code>，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心<code>WeakMap</code>中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在node中演示一下过程(参考阮一峰ES6标准入门中的示例，自己手动实现了一遍)。</p><p>首先打开node命令行，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --expose-gc &#x2F;&#x2F; --expose-gc 表示允许手动执行垃圾回收机制</span><br></pre></td></tr></table></figure><p>然后我们执行下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收保证内存数据准确</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前占用的内存，主要关心heapUsed字段，大小约为4.4MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 21626880,</span><br><span class="line">  heapTotal: 7585792,</span><br><span class="line">  heapUsed: 4708440,</span><br><span class="line">  external: 8710 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个WeakMap</span><br><span class="line">&gt; let wm &#x3D; new WeakMap();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个数组并赋值给变量key</span><br><span class="line">&gt; let key &#x3D; new Array(1000000);</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将WeakMap的键名指向该数组</span><br><span class="line">&#x2F;&#x2F; 此时该数组存在两个引用，一个是key，一个是WeakMap的键名</span><br><span class="line">&#x2F;&#x2F; 注意WeakMap是弱引用</span><br><span class="line">&gt; wm.set(key, 1);</span><br><span class="line">WeakMap &#123; [items unknown] &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次查看内存占用大小，heapUsed已经增加到约12MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 30232576,</span><br><span class="line">  heapTotal: 17694720,</span><br><span class="line">  heapUsed: 13068464,</span><br><span class="line">  external: 8688 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动清除变量key对数组的引用</span><br><span class="line">&#x2F;&#x2F; 注意这里并没有清除WeakMap中键名对数组的引用</span><br><span class="line">&gt; key &#x3D; null;</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次执行垃圾回收</span><br><span class="line">&gt; global.gc()</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看内存占用大小，发现heapUsed已经回到了之前的大小(这里约为4.8M，原来为4.4M，稍微有些浮动)</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 22110208,</span><br><span class="line">  heapTotal: 9158656,</span><br><span class="line">  heapUsed: 5089752,</span><br><span class="line">  external: 8698 &#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们发现虽然我们没有手动清除<code>WeakMap</code>中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>本文中主要讲解了一下V8引擎的垃圾回收机制，并分别从新生代和老生代讲述了不同分代中的垃圾回收策略以及对应的回收算法，之后列出了几种常见的避免内存泄漏的方式来帮助我们写出更加优雅的代码。如果你已经了解过垃圾回收相关的内容，那么这篇文章可以帮助你简单复习加深印象，如果没有了解过，那么笔者也希望这篇文章能够帮助到你了解一些代码层面之外的底层知识点，由于V8引擎的源码是用C++实现的，所以笔者也就没有做这方面的深入了，有兴趣的小伙伴儿可以自行探究，文中有错误的地方，还希望能够在评论区指正。</p><h1 id="13-浮点数精度"><a href="#13-浮点数精度" class="headerlink" title="13.浮点数精度"></a>13.浮点数精度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。</p><p>在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。</p><h2 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h2><p>我们来看下 1020 用十进制的表示：</p><blockquote><p>1020 = <strong>1</strong> * 10^3 + <strong>0</strong> * 10^2 + <strong>2</strong> * 10^1 + <strong>0</strong> * 10^0</p></blockquote><p>所以 1020 用十进制表示就是 1020……(哈哈)</p><p>如果 1020 用二进制来表示呢？</p><blockquote><p>1020 = <strong>1</strong> * 2^9 + <strong>1</strong> * 2^8 + <strong>1</strong> * 2^7 + <strong>1</strong> * 2^6 + <strong>1</strong> * 2^5 + <strong>1</strong> * 2^4 + <strong>1</strong> * 2^3 + <strong>1</strong> * 2^2 + <strong>0</strong> * 2^1 + <strong>0</strong> * 2^0</p></blockquote><p>所以 1020 的二进制为 <code>1111111100</code></p><p>那如果是 0.75 用二进制表示呢？同理应该是：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p></blockquote><p>因为使用的是二进制，这里的 abcd……的值的要么是 0 要么是 1。</p><p>那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4…</p></blockquote><p>两边同时乘以 2</p><blockquote><p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3… (所以 a = 1)</p></blockquote><p>剩下的：</p><blockquote><p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3…</p></blockquote><p>再同时乘以 2</p><blockquote><p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3… (所以 b = 1)</p></blockquote><p>所以 0.75 用二进制表示就是 0.ab，也就是 0.11</p><p>然而不是所有的数都像 0.75 这么好算，我们来算下 0.1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.1 &#x3D; a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...</span><br><span class="line"></span><br><span class="line">0 + 0.2 &#x3D; a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a &#x3D; 0)</span><br><span class="line">0 + 0.4 &#x3D; b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d &#x3D; 1)</span><br><span class="line">1 + 0.2 &#x3D; e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e &#x3D; 1)</span><br><span class="line">0 + 0.4 &#x3D; f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h &#x3D; 1)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……</p><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><p>虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式。</p><p>这个标准认为，一个浮点数 (Value) 可以这样表示：</p><blockquote><p>Value = sign * exponent * fraction</p></blockquote><p>看起来很抽象的样子，简单理解就是科学计数法……</p><p>比如 -1020，用科学计数法表示就是:</p><blockquote><p>-1 * 10^3 * 1.02</p></blockquote><p>sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02</p><p>对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：</p><p>可以表示为：</p><blockquote><p>1 * 2^-4 * 1.1001100110011……</p></blockquote><p>其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……</p><p>而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：</p><blockquote><p>V = (-1)^S * (1 + Fraction) * 2^E</p></blockquote><p>(如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了)</p><p>我们来一点点看：</p><p><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。</p><p>再看 <code>(1 + Fraction)</code>，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。</p><p>最后再看 <code>2^E</code></p><p>如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？</p><p>我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。</p><p>所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。</p><p>所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：</p><p><a href="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067"><img data-src="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067" alt="IEEE754"></a></p><p>在这个标准下：</p><p>我们会用 1 位存储 S，0 表示正数，1 表示负数。</p><p>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。</p><p>用 52 位存储 Fraction。</p><p>举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……</p><p>对应 64 个字节位的完整表示就是：</p><blockquote><p>0 01111111011 1001100110011001100110011001100110011001100110011010</p></blockquote><p>同理, 0.2 表示的完整表示是：</p><blockquote><p>0 01111111100 1001100110011001100110011001100110011001100110011010</p></blockquote><p>所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。</p><h2 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h2><p>关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。</p><p>首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 <code>1.1001100110011…… * 2^-4</code>，阶码是 -4，而 0.2 就是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 <code>0.11001100110011…… * 2^-3</code></p><p>接下来是尾数计算:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0.1100110011001100110011001100110011001100110011001101</span><br><span class="line">+ 1.1001100110011001100110011001100110011001100110011010</span><br><span class="line">————————————————————————————————————————————————————————</span><br><span class="line"> 10.0110011001100110011001100110011001100110011001100111</span><br></pre></td></tr></table></figure><p>我们得到结果为 <code>10.0110011001100110011001100110011001100110011001100111 * 2^-3</code></p><p>将这个结果处理一下，即结果规格化，变成 <code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code></p><p>括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。</p><p>再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0011001100110011001100110011001100110011001100110100 * 2^-2</span><br></pre></td></tr></table></figure><p>本来还有一个溢出判断，因为这里不涉及，就不讲了。</p><p>所以最终的结果存成 64 位就是</p><blockquote><p>0 01111111101 0011001100110011001100110011001100110011001100110100</p></blockquote><p>将它转换为10进制数就得到 <code>0.30000000000000004440892098500626</code></p><p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 十进制转二进制</span><br><span class="line">parseFloat(0.1).toString(2);</span><br><span class="line">&#x3D;&gt; &quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二进制转十进制</span><br><span class="line">parseInt(1100100,2)</span><br><span class="line">&#x3D;&gt; 100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定的精度返回该数值对象的字符串表示</span><br><span class="line">(0.1 + 0.2).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.300000000000000044409&quot;</span><br><span class="line">(0.3).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.299999999999999988898&quot;</span><br></pre></td></tr></table></figure><h1 id="14-new"><a href="#14-new" class="headerlink" title="14.new"></a>14.new</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 new:</p><blockquote><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p></blockquote><p>也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Otaku 御宅族，简称宅</span><br><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为缺乏锻炼的缘故，身体强度让人担忧</span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到，实例 person 可以：</p><ol><li>访问到 Otaku 构造函数里的属性</li><li>访问到 Otaku.prototype 中的属性</li></ol><p>接下来，我们可以尝试着模拟一下了。</p><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Otaku () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 new</span><br><span class="line">var person &#x3D; new Otaku(……);</span><br><span class="line">&#x2F;&#x2F; 使用 objectFactory</span><br><span class="line">var person &#x3D; objectFactory(Otaku, ……)</span><br></pre></td></tr></table></figure><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>分析：</p><p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。</p><p>在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 <strong>proto</strong> 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。</p><p>现在，我们可以尝试着写第一版了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">&#x2F;&#x2F; 新建对象</span><br><span class="line">    var obj &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 移除参数首个</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    &#x2F;&#x2F; 实例的 __proto__ 属性会指向构造函数的 prototype</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    &#x2F;&#x2F; 调用对象</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这一版中，我们：</p><ol><li>用new Object() 的方式新建了一个对象 obj</li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数</li><li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li><li>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</li><li>返回 obj</li></ol><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">https://github.com/mqyqingfeng/Blog/issues/16</a>)</p><p>复制以下的代码，到浏览器中，我们可以做一下测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; objectFactory(Otaku, &#39;Kevin&#39;, &#39;18&#39;)</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><h2 id="返回值效果实现"><a href="#返回值效果实现" class="headerlink" title="返回值效果实现"></a>返回值效果实现</h2><p>接下来我们再来看一种情况，假如构造函数有返回值，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        habit: &#39;Games&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p><p>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？</p><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#39;handsome boy&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p><p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p><p>再来看第二版的代码，也是最后一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版的代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    var ret &#x3D; Constructor.apply(obj, arguments);</span><br><span class="line">    return typeof ret &#x3D;&#x3D;&#x3D; &#39;object&#39; ? ret : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="15-Event-Loop（事件循环）机制"><a href="#15-Event-Loop（事件循环）机制" class="headerlink" title="15.Event Loop（事件循环）机制"></a>15.Event Loop（事件循环）机制</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p><p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p><p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><p>话说回来，前面提到javascript的另一个特点是“非阻塞”，那么javascript引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p><p><em>注：虽然nodejs中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</em></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a><strong>浏览器环境下js引擎的事件循环机制</strong></h2><h2 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a><strong>1.执行栈与事件队列</strong></h2><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p><p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p><p>下面这个图片非常直观的展示了这个过程，其中的global就是初次运行脚本时向执行栈中加入的代码：</p><p><img data-src="https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.jpg" alt="img"></p><p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p><p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p><p>这里还有一张图来展示这个过程：</p><p><img data-src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg" alt="img"></p><p>图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。</p><h2 id="2-macro-task与micro-task"><a href="#2-macro-task与micro-task" class="headerlink" title="2.macro task与micro task"></a><strong>2.macro task与micro task</strong></h2><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li><code>setInterval()</code></li><li><code>setTimeout()</code></li></ul><p>以下事件属于微任务</p><ul><li><code>new Promise()</code></li><li><code>new MutaionObserver()</code></li></ul><p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><p>我们只需记住<strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p><p>这样就能解释下面这段代码的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 </span><br></pre></td></tr></table></figure><h2 id="node环境下的事件循环机制"><a href="#node环境下的事件循环机制" class="headerlink" title="node环境下的事件循环机制"></a><strong>node环境下的事件循环机制</strong></h2><h2 id="1-与浏览器环境有何不同"><a href="#1-与浏览器环境有何不同" class="headerlink" title="1.与浏览器环境有何不同?"></a><strong>1.与浏览器环境有何不同?</strong></h2><p>在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</p><h2 id="2-事件循环模型"><a href="#2-事件循环模型" class="headerlink" title="2.事件循环模型"></a><strong>2.事件循环模型</strong></h2><p>下面是一个libuv引擎中的事件循环的模型:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><em>注：模型中的每一个方块代表事件循环的一个阶段</em></p><p>这个模型是node官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自与看看原文。</p><h2 id="3-事件循环各阶段详解"><a href="#3-事件循环各阶段详解" class="headerlink" title="3.事件循环各阶段详解"></a><strong>3.事件循环各阶段详解</strong></h2><p>从上面这个模型中，我们可以大致分析出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p><p>这些阶段大致的功能如下：</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和<code>setImmediate()</code>的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li><li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种close事件的回调。</li></ul><p>下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段：</p><h2 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a><strong>poll阶段</strong></h2><p>当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。</p><p>值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。</p><h2 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a><strong>check阶段</strong></h2><p>check阶段专门用来执行<code>setImmediate()</code>方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。</p><h2 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a><strong>close阶段</strong></h2><p>当一个socket连接或者一个handle被突然关闭时（例如调用了<code>socket.destroy()</code>方法），close事件会被发送到这个阶段执行回调。否则事件会用<code>process.nextTick（）</code>方法发送出去。</p><h2 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a><strong>timer阶段</strong></h2><p>这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。</p><h2 id="I-O-callback阶段"><a href="#I-O-callback阶段" class="headerlink" title="I/O callback阶段"></a><strong>I/O callback阶段</strong></h2><p>如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。</p><h2 id="4-process-nextTick-setTimeout与setImmediate的区别与使用场景"><a href="#4-process-nextTick-setTimeout与setImmediate的区别与使用场景" class="headerlink" title="4.process.nextTick,setTimeout与setImmediate的区别与使用场景"></a><strong>4.process.nextTick,setTimeout与setImmediate的区别与使用场景</strong></h2><p>在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate</p><p>这三者间存在着一些非常不同的区别：</p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><strong>process.nextTick()</strong></h2><p>尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用<code>process.nextTick()</code>方法会导致node进入一个死循环。。直到内存泄漏。</p><p>那么合适使用这个方法比较合适呢？下面有一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p><h2 id="setTimeout-和setImmediate"><a href="#setTimeout-和setImmediate" class="headerlink" title="setTimeout()和setImmediate()"></a><strong>setTimeout()和setImmediate()</strong></h2><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p><p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。</p><p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p><p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;immediate&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>答案永远是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。</p><p><strong>尾声</strong></p><p>javascrit的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p><h1 id="16-Promise-原理"><a href="#16-Promise-原理" class="headerlink" title="16.Promise 原理"></a>16.Promise 原理</h1><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        reject(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">&#125;,(data1)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;result2&#39;,data1)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result3&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3 undefined</span><br></pre></td></tr></table></figure><p>显然这里输出了不同的 data。由此可以看出几点：</p><ol><li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li><li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li><li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li></ol><p>基于以上几点，我们先写个基于 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123; &#x2F;&#x2F;桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span><br><span class="line">                onFulfilled, </span><br><span class="line">                resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            if(!callback.onFulfilled)&#123;</span><br><span class="line">                callback.resolve(value)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const ret &#x3D; callback.onFulfilled(value) &#x2F;&#x2F;处理回调</span><br><span class="line">            callback.resolve(ret) &#x2F;&#x2F;处理下一个 promise 的resolve</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0) &#x2F;&#x2F;基于 PromiseA+ 规范</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fulfiledFn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fulfiledFn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p><p>但是如果仅仅是例子中的情况，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    console.log(&#39;result3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3</span><br></pre></td></tr></table></figure><p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#123; test: 1 &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result1&#39;, data)</span><br><span class="line">  &#x2F;&#x2F;dosomething</span><br><span class="line">  return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">  return new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;基于第一个 Promise 模型，执行后的输出</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 Promise &#123;then: ƒ&#125;</span><br></pre></td></tr></table></figure><p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个模型，再测试我们的例子，就得到了正确的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F; result2 &#123; test: 2 &#125;</span><br></pre></td></tr></table></figure><p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p><p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p><p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p><p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p><table><thead><tr><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>P1</td><td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td></tr><tr><td>P2 (P1 调用 then 时产生)</td><td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td></tr><tr><td>P3 (P2 调用 then 时产生)</td><td>[]</td></tr><tr><td>P4 (执行c1中产生[调用 test ])</td><td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td></tr><tr><td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td><td>[]</td></tr></tbody></table><p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p><p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p><p>以上就是链式调用的原理了。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p><p>完整代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">        const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">        if(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(error)&#123;</span><br><span class="line"></span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; error</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    then.call(error,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;rejected&#39;;</span><br><span class="line">            value &#x3D; error</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p><p>handle代码改造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handle(callback)&#123;</span><br><span class="line">    if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        callbacks.push(callback)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">    if(!cb)&#123;</span><br><span class="line">        next(value)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        callback.reject(e);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).catch((ex) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;error&#39;, ex)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finally方法"><a href="#Finally方法" class="headerlink" title="Finally方法"></a>Finally方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    this.finally &#x3D; function (onDone)&#123;</span><br><span class="line">        this.then(onDone,onDone)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">Promise.reject(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">new Promise((resolve,reject) &#x3D;&gt; reject(&#123;name:&#39;winty&#39;&#125;))</span><br></pre></td></tr></table></figure><p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p><ul><li>无参数 [直接返回一个resolved状态的 Promise 对象]</li><li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li><li>一个Promise实例 [直接返回当前实例]</li><li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li></ul><p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.resolve &#x3D; function (value)&#123;</span><br><span class="line">        if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; else if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">            let then &#x3D; value.then;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">                then(resolve);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (value) &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve(value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Promise(fn)&#123; </span><br><span class="line">     ...</span><br><span class="line">     this.reject &#x3D; function (value)&#123;</span><br><span class="line">         return new Promise(function(resolve, reject) &#123;</span><br><span class="line">reject(value);</span><br><span class="line">&#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.all &#x3D; function (arr)&#123;</span><br><span class="line">        var args &#x3D; Array.prototype.slice.call(arr);</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        &#x2F;&#x2F; 长度为0返回结果</span><br><span class="line">            if(args.length &#x3D;&#x3D;&#x3D; 0) return resolve([]);</span><br><span class="line">            &#x2F;&#x2F; 剩余参数数组长度</span><br><span class="line">            var remaining &#x3D; args.length;</span><br><span class="line">&#x2F;&#x2F; 参数和值</span><br><span class="line">            function res(i, val) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">                        var then &#x3D; val.then;</span><br><span class="line">                        &#x2F;&#x2F; 进行参数分析</span><br><span class="line">                        if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                            then.call(val, function(val) &#123;</span><br><span class="line">                                res(i, val);</span><br><span class="line">                            &#125;, reject);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    args[i] &#x3D; val;</span><br><span class="line">                    if(--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        resolve(args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(ex) &#123;</span><br><span class="line">                    reject(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 遍历数组中的每个元素</span><br><span class="line">            for(var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                res(i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.race &#x3D; function(values) &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            for(var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://promisesaplus.com/">PromiseA+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li><li><a href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30分钟，让你彻底明白Promise原理</a></li></ul><h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  let state &#x3D; &#39;pending&#39;</span><br><span class="line">  let value &#x3D; null</span><br><span class="line">  const callbacks &#x3D; []</span><br><span class="line"></span><br><span class="line">  this.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.catch &#x3D; function (onError) &#123;</span><br><span class="line">    return this.then(null, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.finally &#x3D; function (onDone) &#123;</span><br><span class="line">    this.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">      return value</span><br><span class="line">    &#125; if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const &#123; then &#125; &#x3D; value</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; if (value) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.reject &#x3D; function (value) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.all &#x3D; function (arr) &#123;</span><br><span class="line">    const args &#x3D; Array.prototype.slice.call(arr)</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      if (args.length &#x3D;&#x3D;&#x3D; 0) return resolve([])</span><br><span class="line">      let remaining &#x3D; args.length</span><br><span class="line"></span><br><span class="line">      function res(i, val) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">            const &#123; then &#125; &#x3D; val</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">              then.call(val, (val) &#x3D;&gt; &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] &#x3D; val</span><br><span class="line">          if (--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.race &#x3D; function (values) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      for (let i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handle(callback) &#123;</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    if (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let ret;</span><br><span class="line">    try &#123;</span><br><span class="line">     ret &#x3D; cb(value)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  function resolve(newValue) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; newValue</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">          &#x2F;&#x2F; 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;fulfilled&#39;</span><br><span class="line">      value &#x3D; newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(error) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; error</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;rejected&#39;</span><br><span class="line">      value &#x3D; error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function handelCb() &#123;</span><br><span class="line">    while (callbacks.length) &#123;</span><br><span class="line">      const fn &#x3D; callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; catch(ex) &#123;</span><br><span class="line">reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-Generators原理"><a href="#17-Generators原理" class="headerlink" title="17.Generators原理"></a>17.Generators原理</h1><p>随着 Javascript 语言的发展，ES6 规范为我们带来了许多新的内容，其中生成器 Generators 是一项重要的特性。利用这一特性，我们可以简化迭代器的创建，更加令人兴奋的，是 Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。</p><p>本重点探讨 Generators 运行机制及在 ES5 的实现原理。</p><h2 id="1-Generators-简单介绍"><a href="#1-Generators-简单介绍" class="headerlink" title="1.Generators 简单介绍"></a><strong>1.Generators 简单介绍</strong></h2><p>一个简单的 Generator 函数示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter=example();</span><br><span class="line">iter.next();<span class="comment">//&#123;value:1，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:2，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:3，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:undefined，done:true&#125;</span></span><br></pre></td></tr></table></figure><p>​    上述代码中定义了一个生成器函数，当调用生成器函数 example() 时，并非立即执行该函数，而是返回一个生成器对象。每当调用生成器对象的.next() 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身。当抵达生成器函数的末尾时，返回结果中 done 的值为 true，value 的值为 undefined。我们将上述 example() 函数称之为生成器函数，与普通函数相比二者有如下区别</p><ul><li>普通函数使用 function 声明，生成器函数用 function*声明</li><li>普通函数使用 return 返回值，生成器函数使用 yield 返回值</li><li>普通函数是 run to completion 模式，即普通函数开始执行后，会一直执行到该函数所有语句完成，在此期间别的代码语句是不会被执行的；生成器函数是 run-pause-run 模式，即生成器函数可以在函数运行中被暂停一次或多次，并且在后面再恢复执行，在暂停期间允许其他代码语句被执行</li></ul><h2 id="2-Generators-in-C"><a href="#2-Generators-in-C" class="headerlink" title="2.Generators in C#"></a><strong>2.Generators in C#</strong></h2><p>生成器不是一个新的概念，我最初接触这一概念是在学习使用 C#时。C#从 2.0 版本便引入了 yield 关键字，使得我们可以更简单的创建枚举数和可枚举类型。不同的是 C#中未将其命名为生成器 Generators，而将其称之为迭代器。</p><p>本文不会介绍 C#中可枚举类 IEnumerable 和枚举数 IEnumerator 内容，如需了解推荐阅读《C#4.0 图解教程》相关章节。</p><p>2.1 C#迭代器介绍</p><p>让我们先看一个示例，下面方法声明实现了一个产生和返回枚举数的迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerable &lt;int&gt; Example()</span><br><span class="line">&#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义与 ES6 Generators 定义很接近，定义中声明返回了一个 int 类型的泛型可枚举类型，方法体内通过 yield return 语句返回值并将自身暂停执行。</p><p>使用迭代器来创建可枚举类型的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class YieldClass</span><br><span class="line">&#123;</span><br><span class="line">    public IEnumerable&lt;int&gt; Example()&#x2F;&#x2F;迭代器</span><br><span class="line">    &#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">YieldClass yc&#x3D;new YieldClass ();</span><br><span class="line">foreach(var a in yc.Example())</span><br><span class="line">Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会产生如下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>2.2 C#迭代器原理</p><p>在.Net 中，yield 并不是.Net runtime 的特性，而是一个语法糖，代码编译时，这一语法糖会被 C#编译器编译成简单的 IL 代码。</p><p>继续研究上述示例，通过 Reflector 反编译工具可以看到，编译器为我们生成了一个带有如下声明的内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[CompilerGenerated]</span><br><span class="line">private sealed class YieldEnumerator : </span><br><span class="line">   IEnumerable&lt;object&gt;, IEnumerator&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Fields字段</span><br><span class="line">    private int state;</span><br><span class="line">    private int current;</span><br><span class="line">    public YieldClass owner;</span><br><span class="line">    private int initialThreadId;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Methods方法</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    public YieldEnumerator(int state);</span><br><span class="line">    private bool MoveNext();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator&lt;int&gt; IEnumerable&lt;int&gt;.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    void IEnumerator.Reset();</span><br><span class="line">    void IDisposable.Dispose();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Properties属性</span><br><span class="line">    object IEnumerator&lt;object&gt;.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line"> </span><br><span class="line">    object IEnumerator.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始的 Example() 方法仅返回一个 YieldEnumerator 的实例，并将初始状态-2 传递给它自身和其引用者，每一个迭代器保存一个状态指示</p><ul><li>-2：初始化为可迭代类 Enumerable</li><li>-1: 迭代结束</li><li>0: 初始化为迭代器 Enumerator</li><li>1-n: 原始 Example() 方法中的 yield return 索引值</li></ul><p>Example() 方法中代码被转换为 YieldingEnumerator.MoveNext()，在我们的示例中转换后代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool MoveNext()</span><br><span class="line">&#123;</span><br><span class="line">    switch (state)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 1;</span><br><span class="line">            state &#x3D; 1;</span><br><span class="line">            return true;</span><br><span class="line">        case 1:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 2;</span><br><span class="line">            state &#x3D; 2;</span><br><span class="line">            return true;</span><br><span class="line">        case 2:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 3;</span><br><span class="line">            state &#x3D; 3;</span><br><span class="line">            return true;</span><br><span class="line">        case 3:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述的代码转换，编译器为我们生成了一个状态机，正是基于这一状态机模型，实现了 yield 关键字的特性。</p><p>迭代器状态机模型可如下图所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png" alt="statemachine"></a></p><ul><li>Before 为迭代器初始状态</li><li>Running 为调用 MoveNext 后进入这个状态。在这个状态，枚举数检测并设置下一项的位置。遇到 yield return、yield break 或者迭代结束时，退出该状态</li><li>Suspended 为状态机等待下次调用 MoveNext 的状态</li><li>After 为迭代结束的状态</li></ul><p><strong>3.Generators in Javascript</strong></p><p>通过阅读上文，我们了解了 Generator 在 C#中的使用，并且通过查看编译器生成的 IL 代码，得知编译器会生成一个内部类来保存上下文信息，然后将 yield return 表达式转换成 switch case，通过状态机模式实现 yield 关键字的特性。</p><p>3.1 Javascript Generators 原理浅析</p><p>yield 关键字在 Javascript 中如何实现呢？</p><p>首先，生成器不是线程。支持线程的语言中，多段不同的代码可以在同一时候运行，这经常会导致资源竞争，使用得当会有不错的性能提升。生成器则完全不同，Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。</p><p>既然生成器并非由引擎从底层提供额外的支持，我们可以沿用上文在 C#中对 yield 特性的原理探究的经验，将生成器视为一个语法糖，用一个辅助工具将生成器函数转换为普通的 Javascript 代码，在经过转换的代码中，有两个关键点，一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。</p><p>3.2 How Generators work in ES5</p><p><a href="https://facebook.github.io/regenerator/">Regenerator</a> 工具已经实现了上述思路，借助 Regenerator 工具，我们已经可以在原生 ES5 中使用生成器函数，本节我们来分析 Regenerator 实现方式以深入理解 Generators 运行原理。</p><p>通过<a href="http://babeljs.io/repl/">这个在线地址</a>可以方便的查看经过转换后的代码，仍然以文章初始为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* example() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">var iter&#x3D;example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>经过转换后为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var marked0$0 &#x3D; [example].map(regeneratorRuntime.mark);</span><br><span class="line">function example() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function example$(context$1$0) &#123;</span><br><span class="line">    while (1) switch (context$1$0.prev &#x3D; context$1$0.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        context$1$0.next &#x3D; 2;</span><br><span class="line">        return 1;</span><br><span class="line"> </span><br><span class="line">      case 2:</span><br><span class="line">        context$1$0.next &#x3D; 4;</span><br><span class="line">        return 2;</span><br><span class="line"> </span><br><span class="line">      case 4:</span><br><span class="line">        context$1$0.next &#x3D; 6;</span><br><span class="line">        return 3;</span><br><span class="line"> </span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return context$1$0.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, marked0$0[0], this);</span><br><span class="line">&#125;</span><br><span class="line">var iter &#x3D; example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>从转换后的代码中可以看到，与 C#编译器对 yield return 表达式的转换相似，Regenerator 将生成器函数中的 yield 表达式重写为 switch case，同时，在每个 case 中使用 context$1$0 来保存函数当前的上下文状态。</p><p>switch case 之外，迭代器函数 example 被 regeneratorRuntime.mark 包装，返回一个被 regeneratorRuntime.wrap 包装的迭代器对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  if (Object.setPrototypeOf) &#123;</span><br><span class="line">    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  &#125;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 mark 包装，将 example 包装成如下对象</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png" alt="example"></a></p><p>当调用生成器函数 example() 时，返回一个被 wrap 函数包装后的迭代器对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runtime.wrap&#x3D;function (innerFn, outerFn, self, tryLocsList) &#123;</span><br><span class="line">  &#x2F;&#x2F; If outerFn provided, then outerFn.prototype instanceof Generator.</span><br><span class="line">  var generator &#x3D; Object.create((outerFn || Generator).prototype);</span><br><span class="line">  var context &#x3D; new Context(tryLocsList || []);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; The ._invoke method unifies the implementations of the .next,</span><br><span class="line">  &#x2F;&#x2F; .throw, and .return methods.</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"> </span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的迭代器对象如下所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png" alt="iter"></a></p><p>当调用迭代器对象 iter.next() 方法时，因为有如下代码，所以会执行_invoke 方法，而根据前面 wrap 方法代码可知，最终是调用了迭代器对象的 makeInvokeMethod (innerFn, self, context); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">  [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">    prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">      return this._invoke(method, arg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 方法内容较多，这里选取部分分析。首先，我们发现生成器将自身状态初始化为“Suspended Start”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function makeInvokeMethod(innerFn, self, context) &#123;</span><br><span class="line">  var state &#x3D; GenStateSuspendedStart;</span><br><span class="line"> </span><br><span class="line">  return function invoke(method, arg) &#123;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 返回 invoke 函数，当我们执行.next 方法时，实际调用的是 invoke 方法中的下面语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br></pre></td></tr></table></figure><p>这里 tryCatch 方法中 fn 为经过转换后的 example$方法，arg 为上下文对象 context, 因为 invoke 函数内部对 context 的引用形成闭包引用，所以 context 上下文得以在迭代期间一直保持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tryCatch(fn, obj, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    return &#123; type: &quot;throw&quot;, arg: err &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryCatch 方法会实际调用 example$方法，进入转换后的 switch case, 执行代码逻辑。如果得到的结果是一个普通类型的值，我们将它包装成一个可迭代对象格式，并且更新生成器状态至 GenStateCompleted 或者 GenStateSuspendedYield</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br><span class="line">        if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">          &#x2F;&#x2F; If an exception is thrown from innerFn, we leave state &#x3D;&#x3D;&#x3D;</span><br><span class="line">          &#x2F;&#x2F; GenStateExecuting and loop back for another invocation.</span><br><span class="line">          state &#x3D; context.done</span><br><span class="line">            ? GenStateCompleted</span><br><span class="line">            : GenStateSuspendedYield;</span><br><span class="line"> </span><br><span class="line">          var info &#x3D; &#123;</span><br><span class="line">            value: record.arg,</span><br><span class="line">            done: context.done</span><br><span class="line">          &#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><p>通过对 Regenerator 转换后的生成器代码及工具源码分析，我们探究了生成器的运行原理。Regenerator 通过工具函数将生成器函数包装，为其添加如 next/return 等方法。同时也对返回的生成器对象进行包装，使得对 next 等方法的调用，最终进入由 switch case 组成的状态机模型中。除此之外，利用闭包技巧，保存生成器函数上下文信息。</p><p>上述过程与 C#中 yield 关键字的实现原理基本一致，都采用了编译转换思路，运用状态机模型，同时保存函数上下文信息，最终实现了新的 yield 关键字带来的新的语言特性。</p><p>参考文章</p><p>1.<a href="https://davidwalsh.name/es6-generators">ES6 Generators:Complete Series 系列文章</a></p><p>\2. <a href="http://www.infoq.com/cn/articles/es6-in-depth-generators">深入浅出 ES6 Generators</a></p><p>3.<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">《深入掌握 ECMAScript 6 异步编程》系列文章</a></p><p>4.<a href="http://x-team.com/2015/04/generators-work/">ES6 Generators:How do they work?</a></p><p>5.<a href="https://startbigthinksmall.wordpress.com/2008/06/09/behind-the-scenes-of-the-c-yield-keyword/">Behind the scenes of the C# yield keyword</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  &lt;a href=&quot;https://github.com/mqyqingfeng/Blog&quot;&gt;冴羽的博客&lt;/a&gt; ，内容丰富，适合有一定JS基础的人进行阅读&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Promise async Generator实现原理解析</title>
    <link href="https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2021-03-10T13:10:17.214Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://juejin.im/post/6844904096525189128">https://juejin.im/post/6844904096525189128</a> </p><p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：</p><ol><li><p><code>Promise</code>的实现原理</p></li><li><p><code>async/await</code>的实现原理</p></li><li><p><code>Generator</code>的实现原理</p></li></ol><span id="more"></span><h1 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h1><p>在成文过程中，笔者查阅了很多讲解Promise实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段Promise规范翻译，有的在Promise基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p><p>回归正题，文章开头我们先点一下Promise为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个Promise：</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Promise实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入resolve, reject函数参数</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>观察这个例子，我们分析Promise的调用流程：</p><ul><li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个executor回调</li><li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li><li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li><li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li></ul><p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在Promise里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出Promise的大致形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// then收集的执行成功的回调队列</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// then收集的执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 从成功队列里取出回调依次执行</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// 一秒后输出result</span></span><br></pre></td></tr></table></figure><p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在then方法的回调里取得异步操作的返回值，但我们这个Promise离最终实现还有很长的距离，下面我们来一步步补充这个Promise：</p><h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版Promise，但我们会看到很多文章和我们写的不一样，他们的Promise实现中还引入了各种状态控制，这是由于ES6的Promise实现需要遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对Promise的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p><blockquote><ol><li>Promise本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li><li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/2/26/161d2454e68ff07b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>根据规范，我们补充一下Promise的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">            <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._resolveQueue.length) &#123;    </span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-then的链式调用"><a href="#3-then的链式调用" class="headerlink" title="3. then的链式调用"></a>3. then的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是Promise实现的重点和难点，我们先来看一下then是如何链式调用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(2)</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">     &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">        return 3</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们思考一下如何实现这种链式调用：</p><ol><li>显然<code>.then()</code>需要返回一个Promise，这样才能找到then方法，所以我们会把then方法的返回值包装成Promise。</li><li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li><li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间return了一个Promise，但执行顺序仍要保证是1-&gt;2-&gt;3。我们要等待当前Promise状态变更后，再执行下一个then收集的回调，这就要求我们对then的返回值分类讨论</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法改进</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                <span class="comment">//这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span></span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reject同理</span></span><br><span class="line">        <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能测试一下链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p><ol><li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是function，那么我们应该忽略它。如果没有忽略，当then()回调不为function时将会抛出异常，导致链式调用中断</li><li><strong>处理状态为resolve/reject的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把then()回调push进resolve/reject的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行then回调：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span>? reason.message:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">            <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">            <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">            <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了then的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor是异步任务</strong>的前提上的，如果executor是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve的执行跑到then之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个setTimeout，让它异步执行。</p><blockquote><p>这里插一句，有关这个setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实Promise的默认实现是放进了微任务队列，我们的实现（包括大多数Promise手动实现和polyfill的转化）都是使用setTimeout放入了宏任务队列（当然我们也可以用MutationObserver模拟微任务）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">        this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">        this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">        this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">        let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">                &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">                while(this._resolveQueue.length) &#123;    </span><br><span class="line">                    const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 实现同resolve</span><br><span class="line">        let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">                while(this._rejectQueue.length) &#123;</span><br><span class="line">                    const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">    then(resolveFn, rejectFn) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">        typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">        typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">        throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">        &#125; : null</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return一个新的promise</span><br><span class="line">        return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">        const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">                let x &#x3D; resolveFn(value)</span><br><span class="line">                &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">                x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; reject同理</span><br><span class="line">            const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; rejectFn(error)</span><br><span class="line">                    x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (this._status) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">                case PENDING:</span><br><span class="line">                    this._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    this._rejectQueue.push(rejectedFn)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">                case FULFILLED:</span><br><span class="line">                    fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">                    break;</span><br><span class="line">                case REJECTED:</span><br><span class="line">                    rejectedFn(this._value)</span><br><span class="line">                    break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下这个Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)          <span class="comment">//同步executor测试</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>          <span class="comment">//链式调用测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then()             <span class="comment">//值穿透测试</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">3</span>)      <span class="comment">//返回Promise测试</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;reject测试&#x27;</span>)   <span class="comment">//reject测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// Error: reject测试</span></span><br></pre></td></tr></table></figure><p>到这里，我们已经实现了Promise的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote><p><code>finally()方法</code>返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">        value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">        reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变Promise状态，在finally()没有返回reject态Promise或throw错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对Promise的理解，大家可以在各个交流群里直接@我）</p><blockquote><p>参考资料：<a href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p></blockquote><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote><p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    result[i] = val</span><br><span class="line">                    <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                    <span class="keyword">if</span>(index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                value =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._value = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> FULFILLED:</span><br><span class="line">                    fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                    rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            value =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">            reason =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> result = []</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    val =&gt; &#123;</span><br><span class="line">                        index++</span><br><span class="line">                        result[i] = val</span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的race方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒150多行的代码，到这里，我们终于可以给Promise的实现做一个结尾了。我们从一个最简单的Promise使用实例开始，通过对调用流程的分析，根据观察者模式实现了Promise的大致骨架，然后依据Promise/A+规范填充代码，重点实现了then 的链式调用，最后完成了Promise的静态/实例方法。其实Promise实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多Promise细节，因而很难写出一个符合规范的Promise实现，源码的实现过程，其实也是对Promise使用细节重新学习的过程。</p><h1 id="async-await实现"><a href="#async-await实现" class="headerlink" title="async/await实现"></a>async/await实现</h1><p>虽然前边花了这么多篇幅讲Promise的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下async/await的使用意义。 在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p><blockquote><p>设想一个这样的场景，异步任务a-&gt;b-&gt;c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b不往下执行到c，那么也不是很方便控制</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(a)</span><br><span class="line">    .then(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是如果通过async/await来实现这个场景，可读性和流程控制都会方便不少。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(a);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(b);</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要如何实现一个async/await呢，首先我们要知道，<strong>async/await实际上是对Generator（生成器）的封装</strong>，是一个语法糖。由于Generator出现不久就被async/await取代了，很多同学对Generator比较陌生，因此我们先来看看Generator的用法：</p><blockquote><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();  <span class="comment">// 获取迭代器</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>也可以通过给<code>next()</code>传参, 让yield具有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 输出test1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>)  <span class="comment">// 输出test2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>)  <span class="comment">// 输出test3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(<span class="string">&#x27;test1&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test2&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们看到Generator的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用next()就能自动执行下一步</li><li><code>async</code>函数返回值是Promise对象，而Generator返回的是生成器对象</li><li><code>await</code>能够返回Promise的resolve/reject的值</li></ul><p><strong>我们对async/await的实现，其实也就是对应以上三点封装Generator</strong></p><h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">        gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出1 2 3</span></span><br></pre></td></tr></table></figure><p>我们也可以通过给<code>gen.next()</code>传值的方式，让yield能返回resolve的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(val)</span></span><br><span class="line">    gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(val)</span></span><br><span class="line">        gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(val)</span></span><br><span class="line">            gen.next(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen()                     <span class="comment">// 由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;             <span class="comment">// 封装一个方法, 递归执行g.next()</span></span><br><span class="line">        <span class="keyword">var</span> res = g.next(val)           <span class="comment">// 获取迭代器对象，并返回resolve的值</span></span><br><span class="line">        <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">// 递归终止条件</span></span><br><span class="line">            res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">// Promise的then方法是实现自动迭代的前提</span></span><br><span class="line">            _next(val)                    <span class="comment">// 等待Promise完成就自动执行下一个next，并传入resolve的值</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    _next()  <span class="comment">//第一次执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们之前的例子，我们就能这样执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure><p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成<code>_next()</code>，每次Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入<code>gen.next()</code>，使得yield得以返回Promise的resolve的值</p><blockquote><p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接<code>thunk函数</code>，thunk函数不是一个新东西，所谓thunk函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰Thunk 函数的含义和用法</a>，无论是Promise还是thunk函数，其核心都是通过<strong>传入回调</strong>的方式来实现Generator的自动执行。thunk函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p></blockquote><h2 id="2-返回Promise-amp-异常处理"><a href="#2-返回Promise-amp-异常处理" class="headerlink" title="2.返回Promise &amp; 异常处理"></a>2.返回Promise &amp; 异常处理</h2><p>虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：</p><ol><li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li><li><strong>缺少错误处理</strong>：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的try-catch捕获到</li><li><strong>返回值是Promise</strong>：<code>async/await</code>的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise</li></ol><p>我们改造一下run方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把返回值包装成promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> res = g.next(val) </span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err); </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(res.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// res.value包装为promise，以兼容yield后面跟基本类型的情况</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(res.value).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    _next(val);</span><br><span class="line">                &#125;, </span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 抛出错误</span></span><br><span class="line">                    g.throw(err)</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        _next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)) </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = run(myGenerator)     <span class="comment">// result是一个Promise</span></span><br><span class="line"><span class="comment">// 输出 1 2 error</span></span><br></pre></td></tr></table></figure><p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下babel对async/await的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于我们的run()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> gen = fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于我们的_next()</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;next&#x27;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;throw&#x27;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">            _next(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">        <span class="keyword">var</span> value = info.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(value).then(_next, _throw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)                          <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道await到底是如何暂停执行的，有关await暂停执行的秘密，我们还要到Generator的实现中去寻找答案</p><h1 id="Generator实现"><a href="#Generator实现" class="headerlink" title="Generator实现"></a>Generator实现</h1><p>我们从一个简单的Generator使用实例开始，一步步探究Generator的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> gen = foo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br></pre></td></tr></table></figure><p>我们可以在<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel官网</a>上在线转化这段代码，看看ES5环境下是如何实现Generator的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _marked =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">foo$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    _context.next = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    _context.next = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    _context.next = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> _context.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = foo();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br></pre></td></tr></table></figure><p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自facebook的 regenerator 模块，完整代码在<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个runtime有700多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p><blockquote><p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p></blockquote><h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下runtime里mark()方法的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line">runtime.mark = <span class="function"><span class="keyword">function</span>(<span class="params">genFun</span>) </span>&#123;</span><br><span class="line">    genFun.__proto__ = GeneratorFunctionPrototype;</span><br><span class="line">    genFun.prototype = <span class="built_in">Object</span>.create(Gp);</span><br><span class="line">    <span class="keyword">return</span> genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在runtime里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p><h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面babel转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看wrap方法的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">innerFn, outerFn, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = <span class="built_in">Object</span>.create(outerFn.prototype);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> Context([]);</span><br><span class="line">    generator._invoke = makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrap方法先是创建了一个generator，并继承<code>outerFn.prototype</code>；然后new了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后return了generator。<strong>其实wrap()相当于是给generator增加了一个_invoke方法</strong></p><p>这段代码肯定让人产生很多疑问，outerFn.prototype是什么，Context又是什么，makeInvokeMethod又做了哪些操作。下面我们就来一一解答：</p><blockquote><p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p></blockquote><p>这个我们结合一下上面的代码就能知道</p><blockquote><p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ContinueSentinel = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    method: <span class="string">&quot;next&quot;</span>,</span><br><span class="line">    next: <span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    abrupt: <span class="function"><span class="keyword">function</span>(<span class="params">type, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> record = &#123;&#125;;</span><br><span class="line">        record.type = type;</span><br><span class="line">        record.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.complete(record);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span>(<span class="params">record, afterLoc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (record.type === <span class="string">&quot;return&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rval = <span class="built_in">this</span>.arg = record.arg;</span><br><span class="line">            <span class="built_in">this</span>.method = <span class="string">&quot;return&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ContinueSentinel;</span><br><span class="line">    &#125;,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>makeInvokeMethod<code>的定义如下，它return了一个</code>invoke方法<code>，invoke用于判断当前状态和执行下一步，其实就是我们调用的</code>next()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInvokeMethod</span>(<span class="params">innerFn, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态置为start</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">method, arg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已完成</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">&quot;completed&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.method = method;</span><br><span class="line">        context.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            state = <span class="string">&quot;executing&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> record = &#123;</span><br><span class="line">                type: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                arg: innerFn.call(self, context)    <span class="comment">// 执行下一步,并获取状态(其实就是switch里边return的值)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.type === <span class="string">&quot;normal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否已经执行完成</span></span><br><span class="line">                state = context.done ? <span class="string">&quot;completed&quot;</span> : <span class="string">&quot;yield&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ContinueSentinel其实是一个空对象,record.arg === &#123;&#125;则跳过return进入下一个循环</span></span><br><span class="line">                <span class="comment">// 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span></span><br><span class="line">                <span class="keyword">if</span> (record.arg === ContinueSentinel) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// next()的返回值</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: record.arg,</span><br><span class="line">                    done: context.done</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在runtime对于next()的定义中，next()其实就return了_invoke方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for defining the .next, .throw, and .return methods of the</span></span><br><span class="line"><span class="comment">// Iterator interface in terms of a single ._invoke method.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineIteratorMethods</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">    [<span class="string">&quot;next&quot;</span>, <span class="string">&quot;throw&quot;</span>, <span class="string">&quot;return&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">        prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._invoke(method, arg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure><h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的Generator，然后再回过头看源码，会得到更清晰的认识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.next = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                _context.next = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                _context.next = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版context  </span></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    next:<span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span> <span class="title">stop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.done = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版invoke</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            value = context.done ? <span class="literal">undefined</span>: gen$(context)</span><br><span class="line">            done = context.done</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试使用</span></span><br><span class="line"><span class="keyword">var</span> g = gen() </span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result1&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result2&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result3&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码并不难理解，我们分析一下调用流程：</p><ol><li>我们定义的<code>function*</code>生成器函数被转化为以上代码</li><li>转化后的代码分为三大块：<ul><li><code>gen$(_context)</code>由yield分割生成器函数代码而来</li><li><code>context对象</code>用于储存函数执行上下文</li><li><code>invoke()方法</code>定义next()，用于执行gen$(_context)来跳到下一步</li></ul></li><li>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果</li><li>当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></li></ol><p>从中我们可以看出，<strong>Generator实现的核心在于<code>上下文的保存</code>，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p><h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关Promise、async/await、Generator的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近9千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对await挂起机制的好奇，后来，从一个 “await是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p><p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在Generator机制上给予的解惑~</p><blockquote><p>前端技匠：<a href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a><br> 神三元：<a href="https://juejin.im/post/6844903702457925640">我如何实现Promise</a><br> winty：<a href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a><br> 冴羽：<a href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator   编译成了什么样子</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自 &lt;a href=&quot;https://juejin.im/post/6844904096525189128&quot;&gt;https://juejin.im/post/6844904096525189128&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;笔者刚接触&lt;code&gt;async/await&lt;/code&gt;时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Promise" scheme="https://hxy1997.xyz/tags/Promise/"/>
    
    <category term="async" scheme="https://hxy1997.xyz/tags/async/"/>
    
    <category term="Generator" scheme="https://hxy1997.xyz/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>JS基础</title>
    <link href="https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/"/>
    <id>https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-26T09:14:39.000Z</published>
    <updated>2020-10-26T13:44:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。</p><span id="more"></span><h2 id="1-如何在ES5环境下实现let"><a href="#1-如何在ES5环境下实现let" class="headerlink" title="1. 如何在ES5环境下实现let"></a>1. 如何在ES5环境下实现let</h2><blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageslim" alt="img"></p><p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数（闭包）来模拟块级作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  for(var i &#x3D; 0; i &lt; 5; i ++)&#123;</span><br><span class="line">    console.log(i)  &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(i)      &#x2F;&#x2F; Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p><ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li><li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li><li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li><li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ul><p>babel的转化，其实只实现了第2、3、5点</p><h2 id="2-如何在ES5环境下实现const"><a href="#2-如何在ES5环境下实现const" class="headerlink" title="2. 如何在ES5环境下实现const"></a>2. 如何在ES5环境下实现const</h2><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p><blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">obj</td><td align="center">要在其上定义属性的对象</td></tr><tr><td align="center">prop</td><td align="center">要定义或修改的属性的名称</td></tr><tr><td align="center">descriptor</td><td align="center">将被定义或修改的属性描述符</td></tr></tbody></table><table><thead><tr><th align="center">属性描述符</th><th align="left">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">value</td><td align="left">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">get</td><td align="left">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">set</td><td align="left">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td><td align="center">undefined</td></tr><tr><td align="center">writable</td><td align="left">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td><td align="center">false</td></tr><tr><td align="center">enumerable</td><td align="left">enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td><td align="center">false</td></tr><tr><td align="center">Configurable</td><td align="left">configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td><td align="center">false</td></tr></tbody></table><p>对于const不可修改的特性，我们通过设置writable属性来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var __const &#x3D; function __const (data, value) &#123;</span><br><span class="line">    window.data &#x3D; value &#x2F;&#x2F; 把要定义的data挂载到window下，并赋值value</span><br><span class="line">    Object.defineProperty(window, data, &#123; &#x2F;&#x2F; 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: false,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">        return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (data) &#123;</span><br><span class="line">            if (data !&#x3D;&#x3D; value) &#123; &#x2F;&#x2F; 当要对当前属性进行赋值时，则抛出错误！</span><br><span class="line">            throw new TypeError(&#39;Assignment to constant variable.&#39;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">_const(&#39;obj&#39;, &#123;a: 1&#125;)   &#x2F;&#x2F; 定义obj</span><br><span class="line">obj.b &#x3D; 2               &#x2F;&#x2F; 可以正常给obj的属性赋值</span><br><span class="line">obj &#x3D; &#123;&#125;                &#x2F;&#x2F; 无法赋值新对象 报错</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://juejin.im/post/6844903848008482824">如何在 ES5 环境下实现一个const ？</a></p><h2 id="3-模拟实现call"><a href="#3-模拟实现call" class="headerlink" title="3. 模拟实现call"></a>3. 模拟实现call</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call() 方法&#96;使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</span><br><span class="line"> 语法：&#96;function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></blockquote><p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行当前函数</span></span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟实现apply"><a href="#4-模拟实现apply" class="headerlink" title="4. 模拟实现apply"></a>4. 模拟实现apply</h2><blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br> 语法：func.apply(thisArg, [argsArray])</p></blockquote><p><code>apply()</code>和<code>call()</code>类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-模拟实现bind"><a href="#5-模拟实现bind" class="headerlink" title="5. 模拟实现bind"></a>5. 模拟实现bind</h2><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br> 语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><p>从用法上看，似乎给call/apply包一层function就实现了bind()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function(context &#x3D; window, ...args) &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">    this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但我们忽略了三点：</p><ol><li><p>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</p></li><li><p>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</p></li><li><p>没有保留原函数在原型链上的属性和方法</p></li></ol><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-手写一个防抖函数-debounce"><a href="#6-手写一个防抖函数-debounce" class="headerlink" title="6. 手写一个防抖函数(debounce)"></a>6. 手写一个防抖函数(debounce)</h2><p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p><blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function debounce (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存一个定时器id</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">    &#x2F;&#x2F; 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">    &#x2F;&#x2F; 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-手写一个节流函数-throttle"><a href="#7-手写一个节流函数-throttle" class="headerlink" title="7. 手写一个节流函数(throttle)"></a>7. 手写一个节流函数(throttle)</h2><blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle(func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if (!lastTime) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                lastTime &#x3D; null</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; 0;</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前时间</span><br><span class="line">        let now &#x3D; +new Date()</span><br><span class="line">        &#x2F;&#x2F; 将当前时间和上一次执行函数时间对比</span><br><span class="line">        &#x2F;&#x2F; 如果差值大于设置的等待时间就执行函数</span><br><span class="line">        if (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime &#x3D; now</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8. 数组扁平化"></a>8. 数组扁平化</h2><blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>这样的一维数组呢：</p></blockquote><p><strong>1.直接调用ES6的flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">arr.flat(Infinity)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>2.序列化后正则</strong></p><p>把所有<code>[</code>和<code>]</code>去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">const str &#x3D; &#96;[$&#123;JSON.stringify(arr).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;)&#125;]&#96;</span><br><span class="line">JSON.parse(str)   &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>3.递归</strong><br> 对于树状结构的数据，最直接的处理方式就是递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr) &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>4.reduce()递归</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; &#123;</span><br><span class="line">    return prev.concat(cur instanceof Array ? flat(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>5.迭代+展开运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]</span><br><span class="line">&#x2F;&#x2F; 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并</span><br><span class="line">let arr &#x3D; [1, [1,2], [1,2,3,[4,4,4]]]</span><br><span class="line">while (arr.some(Array.isArray)) &#123;</span><br><span class="line">  arr &#x3D; [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3, 4, 4, 4]</span><br></pre></td></tr></table></figure><h2 id="9-手写一个Promise"><a href="#9-手写一个Promise" class="headerlink" title="9. 手写一个Promise"></a>9. 手写一个Promise</h2><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现一个符合规范的Promise篇幅比较长，建议阅读文章：<a href="https://juejin.im/post/6844904096525189128">异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-24T16:02:39.000Z</published>
    <updated>2020-10-26T06:17:51.766Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。</p><span id="more"></span><h1 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h1><h2 id="1-1-本地安装hexo"><a href="#1-1-本地安装hexo" class="headerlink" title="1.1.本地安装hexo"></a>1.1.本地安装hexo</h2><p>首先保证你电脑上有node环境，这个不懂的可以自定百度。</p><p>控制台输入node -v出现版本号说明安装成功。</p><p>有了node就可以安装hexo了，控制台输入如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure><p>同样控制台输入hexo -v出现版本号说明安装成功。</p><p>然后开始初始化项目，控制台输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>生成的目录：</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules：是依赖包</span><br><span class="line">public：存放的是生成的页面</span><br><span class="line">scaffolds：命令生成文章等的模板</span><br><span class="line">source：用命令创建的各种文章</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml：整个博客的配置</span><br><span class="line">db.json：source解析所得到的</span><br><span class="line">package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-本地运行"><a href="#1-2-本地运行" class="headerlink" title="1.2.本地运行"></a>1.2.本地运行</h2><p>首先在本地跑起来你的代码</p><p>控制台安装hexo-server</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-server</span><br></pre></td></tr></table></figure><p>然后运行 hexo-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<a href="http://localhost:4000/">http://localhost:4000</a>  就可以看到你本定运行的页面了</p><p>这时你可以在本地调试一下你的blog。</p><h2 id="1-3-github配置"><a href="#1-3-github配置" class="headerlink" title="1.3.github配置"></a>1.3.github配置</h2><p>首先要创建一个github账号</p><p>并配置好ssh</p><p>这些不懂的可以自行百度。</p><p>创建一个repo，名称为yourname.github.io, 其中 yourname 是你的github名称，按照这个规则创建github page才会生效。</p><p>修改_config.yml中的git配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:  https:<span class="comment">//github.com/yourname/yourname.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="1-4-部署上传"><a href="#1-4-部署上传" class="headerlink" title="1.4.部署上传"></a>1.4.部署上传</h2><p>在本地安装上传工具</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>依次执行如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean     //删除上次打包</span><br><span class="line">hexo generate   //打包</span><br><span class="line">hexo deploy    /上传</span><br></pre></td></tr></table></figure><p>这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。</p><p>在浏览器中输入 <a href="https://yourname.github.io/">https://yourname.github.io/</a> 就可以看到你的个人博客了！</p><h2 id="1-5-README-md配置"><a href="#1-5-README-md配置" class="headerlink" title="1.5 README.md配置"></a>1.5 README.md配置</h2><p>1.首先在source文件夹下建立一个README.md</p><p>2.修改_config.yml</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><h1 id="二、绑定二人域名"><a href="#二、绑定二人域名" class="headerlink" title="二、绑定二人域名"></a>二、绑定二人域名</h1><h2 id="2-1购买一个域名"><a href="#2-1购买一个域名" class="headerlink" title="2.1购买一个域名"></a>2.1购买一个域名</h2><p>这里我选择的是阿里云，挑选一个自己喜欢的域名购买。</p><h2 id="2-2域名解析"><a href="#2-2域名解析" class="headerlink" title="2.2域名解析"></a>2.2域名解析</h2><p>进入控制台添加域名解析。</p><p>按照如下规则添加两条记录。</p><p>解析好的域名404，说明域名解析没有问题，接下来进入github进行配置</p><h2 id="2-3-hexo配置"><a href="#2-3-hexo配置" class="headerlink" title="2.3 hexo配置"></a>2.3 hexo配置</h2><p>在本地的博客目录中找到source文件夹。</p><p>新建一个没有后缀名的文件CNAME</p><p>在文件中添加你的域名，如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisq.xyz</span><br></pre></td></tr></table></figure><p>保存后重新生成，并提交你的博客。</p><h2 id="2-4-github配置"><a href="#2-4-github配置" class="headerlink" title="2.4 github配置"></a>2.4 github配置</h2><p>在github中找到你的博客仓库。</p><p>点击<code>Setting</code></p><p>找到<code>Custom domain</code></p><p>输入你的域名点击save</p><p>然后你就可以在浏览器用你的域名愉快的访问啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Github" scheme="https://hxy1997.xyz/tags/Github/"/>
    
    <category term="博客" scheme="https://hxy1997.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://hxy1997.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vue电商管理后台项目</title>
    <link href="https://hxy1997.xyz/2020/10/21/Vue%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hxy1997.xyz/2020/10/21/Vue%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-10-21T04:02:39.000Z</published>
    <updated>2021-03-18T08:17:22.971Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Vue搭建的电商管理后台项目，手把手地指引新人每一步的过程，项目调用了别人提供的后端接口。笔记我是重新梳理了一遍，只有动手做才能发现自己踩过的坑，加以改进。为了方便，我最终选择将自己学习搭建的Vue电商项目托管至Gitee Pages和GitHub Pages，实现项目的正式上线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目(Gitee Pages)</a>和<a href="https://hxy1997.xyz/vue_shops/">Vue电商项目(GitHub Pages)</a>，其中GitHub Pages采用的是我自己在阿里云配置的域名，所以和博客是同一个域名。</p><span id="more"></span><h1 id="1-电商业务概述"><a href="#1-电商业务概述" class="headerlink" title="1.电商业务概述"></a>1.电商业务概述</h1><p>客户使用的业务服务：PC端，小程序，移动web，移动app<br>管理员使用的业务服务：PC后台管理端。<br>PC后台管理端的功能：管理用户账号（登录，退出，用户管理，权限管理），商品管理（商品分类，分类参数，商品信息，订单），数据统计<br>电商后台管理系统采用前后端分离的开发模式<br>前端项目是基于Vue的SPA（单页应用程序）项目</p><p>前端技术栈:Vue,Vue-Router,Element-UI,Axios,Echarts<br>后端技术栈：Node.js,Express,Jwt(模拟session),Mysql,Sequelize(操作数据库的框架)</p><h1 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2.项目初始化"></a>2.项目初始化</h1><h2 id="2-1-安装Vue脚手架"><a href="#2-1-安装Vue脚手架" class="headerlink" title="2.1 安装Vue脚手架"></a>2.1 安装Vue脚手架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue&#x2F;cli -g</span><br></pre></td></tr></table></figure><h2 id="2-2-通过脚手架创建项目"><a href="#2-2-通过脚手架创建项目" class="headerlink" title="2.2 通过脚手架创建项目"></a>2.2 通过脚手架创建项目</h2><p>可视化操作 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><h2 id="2-3-配置路由"><a href="#2-3-配置路由" class="headerlink" title="2.3 配置路由"></a>2.3 配置路由</h2><h2 id="2-4-配置Element-UI-在插件中安装，搜索vue-cli-plugin-element"><a href="#2-4-配置Element-UI-在插件中安装，搜索vue-cli-plugin-element" class="headerlink" title="2.4 配置Element-UI:在插件中安装，搜索vue-cli-plugin-element"></a>2.4 配置Element-UI:在插件中安装，搜索vue-cli-plugin-element</h2><h2 id="2-5-配置Axios：在依赖中安装-搜索axios-运行依赖"><a href="#2-5-配置Axios：在依赖中安装-搜索axios-运行依赖" class="headerlink" title="2.5 配置Axios：在依赖中安装,搜索axios(运行依赖)"></a>2.5 配置Axios：在依赖中安装,搜索axios(运行依赖)</h2><h2 id="2-6-初始化git仓库"><a href="#2-6-初始化git仓库" class="headerlink" title="2.6 初始化git仓库"></a>2.6 初始化git仓库</h2><h2 id="2-7-将本地项目托管到github或者码云中"><a href="#2-7-将本地项目托管到github或者码云中" class="headerlink" title="2.7 将本地项目托管到github或者码云中"></a>2.7 将本地项目托管到github或者码云中</h2><h1 id="3-码云相关操作"><a href="#3-码云相关操作" class="headerlink" title="3.码云相关操作"></a>3.码云相关操作</h1><h2 id="3-1-注册登录码云账号"><a href="#3-1-注册登录码云账号" class="headerlink" title="3.1 注册登录码云账号"></a>3.1 注册登录码云账号</h2><p><img data-src="images/%E6%B3%A8%E5%86%8C%E7%A0%81%E4%BA%91.jpg"></p><h2 id="3-2-安装git"><a href="#3-2-安装git" class="headerlink" title="3.2 安装git"></a>3.2 安装git</h2><p>​    在Windows上使用Git，可以从Git官网直接下载安装程序进行安装。<br>​    测试命令：git –version</p><h2 id="3-3-点击网站右上角“登录”，登录码云，并进行账号设置"><a href="#3-3-点击网站右上角“登录”，登录码云，并进行账号设置" class="headerlink" title="3.3 点击网站右上角“登录”，登录码云，并进行账号设置"></a>3.3 点击网站右上角“登录”，登录码云，并进行账号设置</h2><p><img data-src="images/%E7%A0%81%E4%BA%91%E7%82%B9%E5%87%BB%E8%AE%BE%E7%BD%AE.jpg"></p><h2 id="3-4-在本地创建公钥："><a href="#3-4-在本地创建公钥：" class="headerlink" title="3.4 在本地创建公钥："></a>3.4 在本地创建公钥：</h2><p>在终端运行：ssh-keygen -t rsa -C “<a href="mailto:&#x78;&#120;&#x78;&#x40;&#x78;&#x78;&#120;&#46;&#x63;&#111;&#x6d;">&#x78;&#120;&#x78;&#x40;&#x78;&#x78;&#120;&#46;&#x63;&#111;&#x6d;</a>“<br><img data-src="images/%E5%88%9B%E5%BB%BA%E5%85%AC%E9%92%A5.jpg"></p><h2 id="3-5-找到公钥地址："><a href="#3-5-找到公钥地址：" class="headerlink" title="3.5 找到公钥地址："></a>3.5 找到公钥地址：</h2><p>Your identification has been saved in /c/Users/My/.ssh/id_rsa.<br>Your public key has been saved in /c/Users/My/.ssh/id_rsa.pub.<br>当我们创建公钥完毕之后，请注意打印出来的信息“Your public key has been saved in”<br>/c/Users/My/.ssh/id_rsa.pub : c盘下面的Users下面的My下面的.ssh下面的id_rsa.pub就是我们创建好的公钥了</p><p>E.打开id_rsa.pub文件，复制文件中的所有代码，点击码云中的SSH公钥，将生成的公钥复制到公钥中<br><img data-src="images/pub%E6%96%87%E4%BB%B6.jpg"></p><p><img data-src="images/ssh%E5%85%AC%E9%92%A5.jpg"></p><h2 id="3-6-测试公钥：打开终端，输入命令"><a href="#3-6-测试公钥：打开终端，输入命令" class="headerlink" title="3.6 测试公钥：打开终端，输入命令"></a>3.6 测试公钥：打开终端，输入命令</h2><p>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#x65;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#x65;&#x65;&#46;&#x63;&#x6f;&#x6d;</a><br><img data-src="images/success.jpg"></p><h2 id="3-7-将本地代码托管到码云中"><a href="#3-7-将本地代码托管到码云中" class="headerlink" title="3.7 将本地代码托管到码云中"></a>3.7 将本地代码托管到码云中</h2><p>点击码云右上角的+号-&gt;新建仓库<br><img data-src="images/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.jpg"><br><img data-src="images/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%932.jpg"></p><h2 id="3-8-进行git配置："><a href="#3-8-进行git配置：" class="headerlink" title="3.8 进行git配置："></a>3.8 进行git配置：</h2><p><img data-src="images/config.jpg"><br>打开项目所在位置的终端，进行git仓库关联<br><img data-src="images/%E9%A1%B9%E7%9B%AE%E7%BB%88%E7%AB%AF%E6%89%A7%E8%A1%8C%E5%85%B3%E8%81%94.jpg"></p><h1 id="4-配置后台项目"><a href="#4-配置后台项目" class="headerlink" title="4.配置后台项目"></a>4.配置后台项目</h1><h2 id="4-1-安装phpStudy并导入mysql数据库数据"><a href="#4-1-安装phpStudy并导入mysql数据库数据" class="headerlink" title="4.1 安装phpStudy并导入mysql数据库数据"></a>4.1 安装phpStudy并导入mysql数据库数据</h2><p><img data-src="images/phpStudy.jpg"></p><p><img data-src="images/mysql.jpg"></p><h2 id="4-2-安装nodeJS，配置后台项目-从终端打开后台项目vue-api-server"><a href="#4-2-安装nodeJS，配置后台项目-从终端打开后台项目vue-api-server" class="headerlink" title="4.2 安装nodeJS，配置后台项目,从终端打开后台项目vue_api_server"></a>4.2 安装nodeJS，配置后台项目,从终端打开后台项目vue_api_server</h2><p>然后在终端中输入命令安装项目依赖包：npm install</p><h2 id="4-3-使用postman测试api接口"><a href="#4-3-使用postman测试api接口" class="headerlink" title="4.3 使用postman测试api接口"></a>4.3 使用postman测试api接口</h2><p><img data-src="images/postman.jpg"></p><h1 id="5-实现登录功能"><a href="#5-实现登录功能" class="headerlink" title="5.实现登录功能"></a>5.实现登录功能</h1><h2 id="5-1-登录状态保持"><a href="#5-1-登录状态保持" class="headerlink" title="5.1 登录状态保持"></a>5.1 登录状态保持</h2><p>如果服务器和客户端是同源，建议可以使用cookie或者session来保持登录状态<br>如果客户端和服务器跨域了，建议使用token进行维持登录状态。</p><h2 id="5-2-登录逻辑："><a href="#5-2-登录逻辑：" class="headerlink" title="5.2 登录逻辑："></a>5.2 登录逻辑：</h2><p>在登录页面输入账号和密码进行登录，将数据发送给服务器<br>服务器返回登录的结果，登录成功则返回数据中带有token<br>客户端得到token并进行保存，后续的请求都需要将此token发送给服务器，服务器会验证token以保证用户身份。</p><h2 id="5-3-添加新分支login，在login分支中开发当前项目vue-shop："><a href="#5-3-添加新分支login，在login分支中开发当前项目vue-shop：" class="headerlink" title="5.3 添加新分支login，在login分支中开发当前项目vue_shop："></a>5.3 添加新分支login，在login分支中开发当前项目vue_shop：</h2><p>打开vue_shop终端，使用git status确定当前项目状态。<br>确定当前工作目录是干净的之后，创建一个分支进行开发，开发完毕之后将其合并到master<br>git checkout -b login<br>然后查看新创建的分支：git branch<br>确定我们正在使用login分支进行开发<br><img data-src="images/branch.jpg"></p><p>然后执行vue ui命令打开ui界面，然后运行serve，运行app查看当前项目效果<br><img data-src="images/ui%E7%95%8C%E9%9D%A2%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE.jpg"></p><p>发现现在是一个默认页面，我们需要进行更改，打开项目的src目录，点击main.js文件（入口文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p>再打开App.vue(根组件)，将根组件的内容进行操作梳理(template中留下根节点，script中留下默认导出，去掉组件，style中去掉所有样式)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>再打开router.js(路由)，将routes数组中的路由规则清除，然后将views删除，将components中的helloworld.vue删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    </span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在components文件夹中新建Login.vue组件,添加template，script，style标签,style标签中的scoped可以防止组件之间的样式冲突，没有scoped则样式是全局的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;login_container&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.login_container &#123;</span><br><span class="line">  background-color: #2b5b6b;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>在router.js中导入组件并设置规则<br>在App.vue中添加路由占位符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;login&#39; &#125;,</span><br><span class="line">    &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们给Login.vue中的内容添加样式的时候，会报错“缺少less-loader”，需要配置less加载器（开发依赖），安装less(开发依赖)<br><img data-src="images/less.jpg"><br>然后需要添加公共样式，在assets文件夹下面添加css文件夹，创建global.css文件,添加全局样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 全局样式表 *&#x2F;</span><br><span class="line">html,body,#app&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.js中导入global.css，使得全局样式生效 import “./assets/css/global.css”<br>然后Login.vue中的根元素也需要设置撑满全屏（height:100%）<br>最终Login.vue文件中的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;login_container&quot;&gt;</span><br><span class="line">        &lt;!-- 登录盒子  --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;login_box&quot;&gt;</span><br><span class="line">            &lt;!-- 头像 --&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;avatar_box&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;!-- 登录表单 --&gt;</span><br><span class="line">            &lt;el-form :model&#x3D;&quot;loginForm&quot; ref&#x3D;&quot;LoginFormRef&quot; :rules&#x3D;&quot;loginFormRules&quot; label-width&#x3D;&quot;0px&quot; class&#x3D;&quot;login_form&quot;&gt;</span><br><span class="line">                &lt;!-- 用户名 --&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">                    &lt;el-input v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-user&quot; &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt; </span><br><span class="line">                &lt;!-- 密码 --&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">                    &lt;el-input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-3702mima&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt; </span><br><span class="line">                &lt;!-- 按钮 --&gt;</span><br><span class="line">                &lt;el-form-item class&#x3D;&quot;btns&quot;&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;login&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;resetLoginForm&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt; </span><br><span class="line">            &lt;&#x2F;el-form&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 数据绑定</span><br><span class="line">      loginForm: &#123;</span><br><span class="line">        username: &#39;admin&#39;,</span><br><span class="line">        password: &#39;123456&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 表单验证规则</span><br><span class="line">      loginFormRules: &#123;</span><br><span class="line">        username: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入登录名&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            min: 3,</span><br><span class="line">            max: 10,</span><br><span class="line">            message: &#39;登录名长度在 3 到 10 个字符&#39;,</span><br><span class="line">            trigger: &#39;blur&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        password: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            min: 6,</span><br><span class="line">            max: 15,</span><br><span class="line">            message: &#39;密码长度在 6 到 15 个字符&#39;,</span><br><span class="line">            trigger: &#39;blur&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 添加行为，</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加表单重置方法</span><br><span class="line">    resetLoginForm() &#123;</span><br><span class="line">      &#x2F;&#x2F; this&#x3D;&gt;当前组件对象，其中的属性$refs包含了设置的表单ref</span><br><span class="line">      &#x2F;&#x2F; console.log(this)</span><br><span class="line">      this.$refs.LoginFormRef.resetFields()</span><br><span class="line">    &#125;,</span><br><span class="line">    login() &#123;</span><br><span class="line">      &#x2F;&#x2F; 点击登录的时候先调用validate方法验证表单内容是否有误</span><br><span class="line">      this.$refs.LoginFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.loginFormRules)</span><br><span class="line">        &#x2F;&#x2F; 如果valid参数为true则验证通过</span><br><span class="line">        if (!valid) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送请求进行登录</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.post(&#39;login&#39;, this.loginForm)</span><br><span class="line">        &#x2F;&#x2F;   console.log(res);</span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;登录失败:&#39; + res.meta.msg) &#x2F;&#x2F;console.log(&quot;登录失败:&quot;+res.meta.msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$message.success(&#39;登录成功&#39;)</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F; 保存token</span><br><span class="line">        window.sessionStorage.setItem(&#39;token&#39;, res.data.token)</span><br><span class="line">        &#x2F;&#x2F; 导航至&#x2F;home</span><br><span class="line">        this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.login_container &#123;</span><br><span class="line">  background-color: #2b5b6b;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.login_box &#123;</span><br><span class="line">  width: 450px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  background: #fff;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  .avatar_box &#123;</span><br><span class="line">    height: 130px;</span><br><span class="line">    width: 130px;</span><br><span class="line">    border: 1px solid #eee;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    box-shadow: 0 0 10px #ddd;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    img &#123;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      background-color: #eee;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.login_form &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.btns &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中我们有用到一些未导入的内容，需要进行进一步处理：</p><h3 id="5-3-1-添加element-ui的表单组件"><a href="#5-3-1-添加element-ui的表单组件" class="headerlink" title="5.3.1 添加element-ui的表单组件"></a>5.3.1 添加element-ui的表单组件</h3><p>在plugins文件夹中打开element.js文件，进行elementui的按需导入<br>import Vue from ‘vue’<br>import { Button } from ‘element-ui’<br>import { Form, FormItem } from ‘element-ui’<br>import { Input } from ‘element-ui’</p><p>Vue.use(Button)<br>Vue.use(Form)<br>Vue.use(FormItem)<br>Vue.use(Input)</p><h3 id="5-3-2-添加第三方字体"><a href="#5-3-2-添加第三方字体" class="headerlink" title="5.3.2 添加第三方字体"></a>5.3.2 添加第三方字体</h3><p>复制素材中的fonts文件夹到assets中,在入口文件main.js中导入import ‘./assets/fonts/iconfont.css’<br>然后直接在 <el-input prefix-icon="iconfont icon-3702mima"></el-input><br>接着添加登录盒子</p><h3 id="5-3-3-添加表单验证的步骤"><a href="#5-3-3-添加表单验证的步骤" class="headerlink" title="5.3.3 添加表单验证的步骤"></a>5.3.3 添加表单验证的步骤</h3><h4 id="1-给添加属性-rules-”rules”，rules是一堆验证规则，定义在script、中"><a href="#1-给添加属性-rules-”rules”，rules是一堆验证规则，定义在script、中" class="headerlink" title="1).给添加属性:rules=”rules”，rules是一堆验证规则，定义在script、中"></a>1).给<el-form>添加属性:rules=”rules”，rules是一堆验证规则，定义在script、中</h4><h4 id="2-在script中添加rules：export-default-data-return-……-rules"><a href="#2-在script中添加rules：export-default-data-return-……-rules" class="headerlink" title="2).在script中添加rules：export default{ data(){return{……, rules: {"></a>2).在script中添加rules：export default{ data(){return{……, rules: {</h4><p>​          name: [<br>​            { required: true, message: ‘请输入活动名称’, trigger: ‘blur’ },<br>​            { min: 3, max: 5, message: ‘长度在 3 到 5 个字符’, trigger: ‘blur’ }<br>​          ],<br>​          region: [<br>​            { required: true, message: ‘请选择活动区域’, trigger: ‘change’ }<br>​          ]<br>}……</p><h4 id="3-通过的prop属性设置验证规则"><a href="#3-通过的prop属性设置验证规则" class="headerlink" title="3).通过的prop属性设置验证规则"></a>3).通过<el-form-item>的prop属性设置验证规则<el-form-item label="活动名称" prop="name"></h4><h4 id="4-导入axios以发送ajax请求"><a href="#4-导入axios以发送ajax请求" class="headerlink" title="4.导入axios以发送ajax请求"></a>4.导入axios以发送ajax请求</h4><p>打开main.js，import axios from ‘axios’;<br>设置请求的根路径：axios.defaults.baseURL = ‘<a href="http://127.0.0.1:8888/api/private/v1/&#39;">http://127.0.0.1:8888/api/private/v1/&#39;</a>;<br>挂载axios：Vue.prototype.$http = axios;</p><h4 id="5-配置弹窗提示："><a href="#5-配置弹窗提示：" class="headerlink" title="5.配置弹窗提示："></a>5.配置弹窗提示：</h4><p>在plugins文件夹中打开element.js文件，进行elementui的按需导入<br>import {Message} from ‘element-ui’<br>进行全局挂载：Vue.prototype.$message = Message;<br>在login.vue组件中编写弹窗代码：this.$message.error(‘登录失败’)</p><h2 id="5-4-登录成功之后的操作"><a href="#5-4-登录成功之后的操作" class="headerlink" title="5.4 登录成功之后的操作"></a>5.4 登录成功之后的操作</h2><h3 id="5-4-1-登录成功之后，需要将后台返回的token保存到sessionStorage中"><a href="#5-4-1-登录成功之后，需要将后台返回的token保存到sessionStorage中" class="headerlink" title="5.4.1 登录成功之后，需要将后台返回的token保存到sessionStorage中"></a>5.4.1 登录成功之后，需要将后台返回的token保存到sessionStorage中</h3><p>操作完毕之后，需要跳转到/home</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">login() &#123;</span><br><span class="line">      &#x2F;&#x2F;点击登录的时候先调用validate方法验证表单内容是否有误</span><br><span class="line">      this.$refs.LoginFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.loginFormRules)</span><br><span class="line">        &#x2F;&#x2F;如果valid参数为true则验证通过</span><br><span class="line">        if (!valid) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送请求进行登录</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.post(&#39;login&#39;, this.loginForm)</span><br><span class="line">        &#x2F;&#x2F;   console.log(res);</span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;登录失败:&#39; + res.meta.msg) &#x2F;&#x2F; console.log(&quot;登录失败:&quot;+res.meta.msg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$message.success(&#39;登录成功&#39;)</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F; 保存token</span><br><span class="line">        window.sessionStorage.setItem(&#39;token&#39;, res.data.token)</span><br><span class="line">        &#x2F;&#x2F; 导航至&#x2F;home</span><br><span class="line">        this.$router.push(&#39;&#x2F;home&#39;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加一个组件Home.vue，并为之添加规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        this is home</span><br><span class="line">        &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;logout&quot;&gt; 退出 &lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line">      window.sessionStorage.clear()</span><br><span class="line">      this.$router.push(&#39;&#x2F;login&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&#39;less&#39; scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>添加路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;login&#39; &#125;,</span><br><span class="line">    &#123; path: &#39;&#x2F;login&#39;, component: Login &#125;,</span><br><span class="line">    &#123; path: &#39;&#x2F;home&#39;, component: Home &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>添加路由守卫<br>如果用户没有登录，不能访问/home,如果用户通过url地址直接访问，则强制跳转到登录页面<br>打开router.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import Login from &#39;.&#x2F;components&#x2F;Login.vue&#39;</span><br><span class="line">import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">const router &#x3D; new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path:&#39;&#x2F;&#39;, redirect:&#39;&#x2F;login&#39;&#125;,</span><br><span class="line">    &#123; path:&#39;&#x2F;login&#39; , component:Login &#125;,</span><br><span class="line">    &#123; path:&#39;&#x2F;home&#39; , component:Home&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 挂载路由导航守卫,to表示将要访问的路径，from表示从哪里来，next是下一个要做的操作</span><br><span class="line">router.beforeEach((to, from, next)&#x3D;&gt;&#123; </span><br><span class="line">  if(to.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;)</span><br><span class="line">    return next();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;获取token</span><br><span class="line">  const tokenStr &#x3D; window.sessionStorage.getItem(&#39;token&#39;);</span><br><span class="line"></span><br><span class="line">  if(!tokenStr)</span><br><span class="line">    return next(&#39;&#x2F;login&#39;);</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router </span><br></pre></td></tr></table></figure><p>实现退出功能<br>在Home组件中添加一个退出功能按钮,给退出按钮添加点击事件，添加事件处理代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        logout()&#123;</span><br><span class="line">            window.sessionStorage.clear();</span><br><span class="line">            this.$router.push(&#39;&#x2F;login&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-处理ESLint警告"><a href="#5-5-处理ESLint警告" class="headerlink" title="5.5 处理ESLint警告"></a>5.5 处理ESLint警告</h2><p>打开脚手架面板，查看警告信息<br>[图片]<br>默认情况下，ESLint和vscode格式化工具有冲突，需要添加配置文件解决冲突。<br>在项目根目录添加 .prettierrc 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;semi&quot;:false,</span><br><span class="line">    &quot;singleQuote&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开.eslintrc.js文件，禁用对 space-before-function-paren 的检查:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#39;no-console&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">  &#39;no-debugger&#39;: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,</span><br><span class="line">  &#39;space-before-function-paren&#39; : 0</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="5-6-合并按需导入的element-ui"><a href="#5-6-合并按需导入的element-ui" class="headerlink" title="5.6 合并按需导入的element-ui"></a>5.6 合并按需导入的element-ui</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123; Button, Form, FormItem, Input, Message &#125; from &#39;element-ui&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Form)</span><br><span class="line">Vue.use(FormItem)</span><br><span class="line">Vue.use(Input)</span><br><span class="line">&#x2F;&#x2F; 进行全局挂载：</span><br><span class="line">Vue.prototype.$message &#x3D; Message</span><br></pre></td></tr></table></figure><h2 id="5-7-将代码提交到码云"><a href="#5-7-将代码提交到码云" class="headerlink" title="5.7 将代码提交到码云"></a>5.7 将代码提交到码云</h2><p>新建一个项目终端,输入命令‘git status’查看修改过的与新增的文件内容<br>将所有文件添加到暂存区：git add .<br>将所有代码提交到本地仓库：git commit -m “添加登录功能以及/home的基本结构”<br>查看分支： git branch  发现所有代码都被提交到了login分支<br>将login分支代码合并到master主分支，先切换到master：git checkout master<br>在master分支进行代码合并：git merge login<br>将本地的master推送到远端的码云：git push</p><p>(推送本地的子分支到码云，先切换到子分支：git checkout 分支名<br>然后推送到码云：git push -u origin 远端分支名)</p><h1 id="6-后台首页布局"><a href="#6-后台首页布局" class="headerlink" title="6.后台首页布局"></a>6.后台首页布局</h1><h2 id="6-1-git-操作"><a href="#6-1-git-操作" class="headerlink" title="6.1 git 操作"></a>6.1 git 操作</h2><p>创建一个分支进行开发，开发完毕之后将其合并到master<br>git checkout -b home<br>然后查看新创建的分支：git branch<br>确定我们正在使用home分支进行开发<br>然后推送到码云：git push -u origin home</p><h2 id="6-2-首页整体布局"><a href="#6-2-首页整体布局" class="headerlink" title="6.2 首页整体布局"></a>6.2 首页整体布局</h2><p>打开Home.vue组件，进行布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-container class&#x3D;&quot;home-container&quot;&gt;</span><br><span class="line">  &lt;!-- 头部区域 --&gt;</span><br><span class="line">  &lt;el-header&gt;Header&lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;logout&quot;&gt; 退出 &lt;&#x2F;el-button&gt;&lt;&#x2F;el-header&gt;</span><br><span class="line">  &lt;!-- 页面主体区域 --&gt;</span><br><span class="line">  &lt;el-container&gt;</span><br><span class="line">    &lt;!-- 侧边栏 --&gt;</span><br><span class="line">    &lt;el-aside width&#x3D;&quot;200px&quot;&gt;Aside&lt;&#x2F;el-aside&gt;</span><br><span class="line">    &lt;!-- 主体结构 --&gt;</span><br><span class="line">    &lt;el-main&gt;Main&lt;&#x2F;el-main&gt;</span><br><span class="line">  &lt;&#x2F;el-container&gt;</span><br><span class="line">&lt;&#x2F;el-container&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，跟element-ui组件同名的类名可以帮助我们快速的给对应的组件添加样式，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.home-container &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.el-header&#123;</span><br><span class="line">  background-color:#373D41;</span><br><span class="line">&#125;</span><br><span class="line">.el-aside&#123;</span><br><span class="line">  background-color:#333744;</span><br><span class="line">&#125;</span><br><span class="line">.el-main&#123;</span><br><span class="line">  background-color:#eaedf1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-顶部布局，侧边栏布局"><a href="#6-3-顶部布局，侧边栏布局" class="headerlink" title="6.3 顶部布局，侧边栏布局"></a>6.3 顶部布局，侧边栏布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-container class&#x3D;&quot;home-container&quot;&gt;</span><br><span class="line">      &lt;!-- 头部区域 --&gt;</span><br><span class="line">      &lt;el-header&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;!-- 黑马logo --&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;heima.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">          &lt;!-- 顶部标题 --&gt;</span><br><span class="line">          &lt;span&gt;电商后台管理系统&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;logout&quot;&gt; 退出 &lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-header&gt;</span><br><span class="line">      &lt;!-- 页面主体区域 --&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;!-- 侧边栏 --&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;!-- 侧边栏菜单 --&gt;</span><br><span class="line">          &lt;el-menu</span><br><span class="line">            background-color&#x3D;&quot;#333744&quot;</span><br><span class="line">            text-color&#x3D;&quot;#fff&quot;</span><br><span class="line">            active-text-color&#x3D;&quot;#ffd04b&quot;&gt;</span><br><span class="line">            &lt;!-- 一级菜单 --&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;!-- 一级菜单模板 --&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">                &lt;!-- 图标 --&gt;</span><br><span class="line">                &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                &lt;!-- 文本 --&gt;</span><br><span class="line">                &lt;span&gt;导航一&lt;&#x2F;span&gt;</span><br><span class="line">              &lt;&#x2F;template&gt;</span><br><span class="line">              &lt;!-- 二级子菜单 --&gt;</span><br><span class="line">              &lt;el-menu-item index&#x3D;&quot;1-4-1&quot;&gt;</span><br><span class="line">                &lt;!-- 二级菜单模板 --&gt;</span><br><span class="line">                &lt;template slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">                  &lt;!-- 图标 --&gt;</span><br><span class="line">                  &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                  &lt;!-- 文本 --&gt;</span><br><span class="line">                  &lt;span&gt;子菜单一&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;&#x2F;template&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            </span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line">        &lt;!-- 主体结构 --&gt;</span><br><span class="line">        &lt;el-main&gt;Main&lt;&#x2F;el-main&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;el-container&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="6-4-axios请求拦截器"><a href="#6-4-axios请求拦截器" class="headerlink" title="6.4 axios请求拦截器"></a>6.4 axios请求拦截器</h2><p>后台除了登录接口之外，都需要token权限验证，我们可以通过添加axios请求拦截器来添加token，以保证拥有获取数据的权限<br>在main.js中添加代码，在将axios挂载到vue原型之前添加下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span><br><span class="line">axios.interceptors.request.use(config&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; 为请求头对象，添加token验证的Authorization字段</span><br><span class="line">  config.headers.Authorization &#x3D; window.sessionStorage.getItem(&quot;token&quot;)</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-5-请求侧边栏数据"><a href="#6-5-请求侧边栏数据" class="headerlink" title="6.5 请求侧边栏数据"></a>6.5 请求侧边栏数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 左侧菜单数据</span><br><span class="line">      menuList: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在created阶段请求左侧菜单数据</span><br><span class="line">    this.getMenuList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout() &#123;</span><br><span class="line">      window.sessionStorage.clear()</span><br><span class="line">      this.$router.push(&#39;&#x2F;login&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    async getMenuList() &#123;</span><br><span class="line">      &#x2F;&#x2F; 发送请求获取左侧菜单数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;menus&#39;)</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(res.meta.msg)</span><br><span class="line"></span><br><span class="line">      this.menuList &#x3D; res.data</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>通过v-for双重循环渲染左侧菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu</span><br><span class="line">  background-color&#x3D;&quot;#333744&quot;</span><br><span class="line">  text-color&#x3D;&quot;#fff&quot;</span><br><span class="line">  active-text-color&#x3D;&quot;#ffd04b&quot;&gt;</span><br><span class="line">  &lt;!-- 一级菜单 --&gt;</span><br><span class="line">  &lt;el-submenu :index&#x3D;&quot;item.id+&#39;&#39;&quot; v-for&#x3D;&quot;item in menuList&quot; :key&#x3D;&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;!-- 一级菜单模板 --&gt;</span><br><span class="line">    &lt;template slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">      &lt;!-- 图标 --&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;!-- 文本 --&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item.authName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;!-- 二级子菜单 --&gt;</span><br><span class="line">    &lt;el-menu-item :index&#x3D;&quot;subItem.id+&#39;&#39;&quot; v-for&#x3D;&quot;subItem in item.children&quot; :key&#x3D;&quot;subItem.id&quot;&gt;</span><br><span class="line">      &lt;!-- 二级菜单模板 --&gt;</span><br><span class="line">      &lt;template slot&#x3D;&quot;title&quot;&gt;</span><br><span class="line">        &lt;!-- 图标 --&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;!-- 文本 --&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;subItem.authName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">  &lt;&#x2F;el-submenu&gt;</span><br><span class="line">&lt;&#x2F;el-menu&gt;</span><br></pre></td></tr></table></figure><h2 id="6-6-设置激活子菜单样式"><a href="#6-6-设置激活子菜单样式" class="headerlink" title="6.6 设置激活子菜单样式"></a>6.6 设置激活子菜单样式</h2><p>通过更改el-menu的active-text-color属性可以设置侧边栏菜单中点击的激活项的文字颜色<br>通过更改菜单项模板（template）中的i标签的类名，可以将左侧菜单栏的图标进行设置，我们需要在项目中使用第三方字体图标<br>在数据中添加一个iconsObj：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iconsObj: &#123;</span><br><span class="line">    <span class="string">&#x27;125&#x27;</span>:<span class="string">&#x27;iconfont icon-user&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;103&#x27;</span>:<span class="string">&#x27;iconfont icon-tijikongjian&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;101&#x27;</span>:<span class="string">&#x27;iconfont icon-shangpin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;102&#x27;</span>:<span class="string">&#x27;iconfont icon-danju&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;145&#x27;</span>:<span class="string">&#x27;iconfont icon-baobiao&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将图标类名进行数据绑定，绑定iconsObj中的数据：</p><p>为了保持左侧菜单每次只能打开一个，显示其中的子菜单，我们可以在el-menu中添加一个属性unique-opened<br>或者也可以数据绑定进行设置(此时true认为是一个bool值，而不是字符串) :unique-opened=”true”</p><h2 id="6-7-制作侧边菜单栏的伸缩功能"><a href="#6-7-制作侧边菜单栏的伸缩功能" class="headerlink" title="6.7 制作侧边菜单栏的伸缩功能"></a>6.7 制作侧边菜单栏的伸缩功能</h2><p>在菜单栏上方添加一个div</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 侧边栏,宽度根据是否折叠进行设置 --&gt;</span><br><span class="line">&lt;el-aside :width&#x3D;&quot;isCollapse ? &#39;64px&#39;:&#39;200px&#39;&quot;&gt;</span><br><span class="line">  &lt;!-- 伸缩侧边栏按钮 --&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;toggle-button&quot; @click&#x3D;&quot;toggleCollapse&quot;&gt;|||&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- 侧边栏菜单，:collapse&#x3D;&quot;isCollapse&quot;（设置折叠菜单为绑定的 isCollapse 值），:collapse-transition&#x3D;&quot;false&quot;（关闭默认的折叠动画） --&gt;</span><br><span class="line">  &lt;el-menu</span><br><span class="line">  :collapse&#x3D;&quot;isCollapse&quot;</span><br><span class="line">  :collapse-transition&#x3D;&quot;false&quot;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>然后给div添加样式，给div添加事件，实现伸缩：</p><div class="toggle-button" @click="this.isCollapse ? '64px':'200px'">|||</div><h2 id="6-8-在后台首页添加子级路由"><a href="#6-8-在后台首页添加子级路由" class="headerlink" title="6.8 在后台首页添加子级路由"></a>6.8 在后台首页添加子级路由</h2><p>新增子级路由组件Welcome.vue<br>在router.js中导入子级路由组件，并设置路由规则以及子级路由的默认重定向<br>打开Home.vue，在main的主体结构中添加一个路由占位符</p><p>制作好了Welcome子级路由之后，我们需要将所有的侧边栏二级菜单都改造成子级路由链接<br>我们只需要将el-menu的router属性设置为true就可以了，此时当我们点击二级菜单的时候，就会根据菜单的index<br>属性进行路由跳转,如: /110,<br>使用index id来作为跳转的路径不合适，我们可以重新绑定index的值为  :index=”‘/‘+subItem.path”</p><h1 id="7-完成用户列表开发"><a href="#7-完成用户列表开发" class="headerlink" title="7.完成用户列表开发"></a>7.完成用户列表开发</h1><h2 id="7-1-完成用户列表主体区域"><a href="#7-1-完成用户列表主体区域" class="headerlink" title="7.1 完成用户列表主体区域"></a>7.1 完成用户列表主体区域</h2><p>新建用户列表组件  user/Users.vue<br>在router.js中导入子级路由组件Users.vue，并设置路由规则</p><p>当点击二级菜单的时候，被点击的二级子菜单并没有高亮，我们需要正在被使用的功能高亮显示<br>我们可以通过设置el-menu的default-active属性来设置当前激活菜单的index<br>但是default-active属性也不能写死，固定为某个菜单值<br>所以我们可以先给所有的二级菜单添加点击事件,并将path值作为方法的参数<br>@click=”saveNavState(‘/‘+subItem.path)”<br>在saveNavState方法中将path保存到sessionStorage中<br>saveNavState( path ){<br>  //点击二级菜单的时候保存被点击的二级菜单信息<br>  window.sessionStorage.setItem(“activePath”,path);<br>  this.activePath = path;<br>}<br>然后在数据中添加一个activePath绑定数据，并将el-menu的default-active属性设置为activePath<br>最后在created中将sessionStorage中的数据赋值给activePath<br>this.activePath = window.sessionStorage.getItem(“activePath”)</p><h2 id="7-2-绘制用户列表基本结构"><a href="#7-2-绘制用户列表基本结构" class="headerlink" title="7.2 绘制用户列表基本结构"></a>7.2 绘制用户列表基本结构</h2><h3 id="7-2-1-使用element-ui面包屑组件完成顶部导航路径"><a href="#7-2-1-使用element-ui面包屑组件完成顶部导航路径" class="headerlink" title="7.2.1 使用element-ui面包屑组件完成顶部导航路径"></a>7.2.1 使用element-ui面包屑组件完成顶部导航路径</h3><p>复制面包屑代码，在element.js中导入组件Breadcrumb,BreadcrumbItem</p><h3 id="7-2-2-使用element-ui卡片组件完成主体表格"><a href="#7-2-2-使用element-ui卡片组件完成主体表格" class="headerlink" title="7.2.2 使用element-ui卡片组件完成主体表格"></a>7.2.2 使用element-ui卡片组件完成主体表格</h3><p>复制卡片组件代码，在element.js中导入组件Card，再使用element-ui输入框完成搜索框及搜索按钮，<br>此时我们需要使用栅格布局来划分结构(复制卡片组件代码，在element.js中导入组件Row，Col)，然后再使用el-button制作添加用户按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h3&gt;用户列表组件&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">    &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">        &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;el-breadcrumb-item&gt;用户管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;el-breadcrumb-item&gt;用户列表&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">    &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">    &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">    &lt;el-card&gt;</span><br><span class="line">        &lt;!-- 搜索与添加区域 --&gt;</span><br><span class="line">        &lt;el-row :gutter&#x3D;&quot;20&quot;&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;7&quot;&gt;</span><br><span class="line">                &lt;el-input placeholder&#x3D;&quot;请输入内容&quot;&gt;</span><br><span class="line">                    &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-input&gt; </span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;4&quot;&gt;</span><br><span class="line">                &lt;el-button type&#x3D;&quot;primary&quot;&gt;添加用户&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">        &lt;&#x2F;el-row&gt; </span><br><span class="line">    &lt;&#x2F;el-card&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="7-3-请求用户列表数据"><a href="#7-3-请求用户列表数据" class="headerlink" title="7.3 请求用户列表数据"></a>7.3 请求用户列表数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F;获取查询用户信息的参数</span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        query: &#39;&#39;,</span><br><span class="line">        pagenum: 1,</span><br><span class="line">        pagesize: 2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;保存请求回来的用户列表数据</span><br><span class="line">      userList:[],</span><br><span class="line">      total:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getUserList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getUserList() &#123;</span><br><span class="line">      &#x2F;&#x2F;发送请求获取用户列表数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;users&#39;, &#123;</span><br><span class="line">        params: this.queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line">      &#x2F;&#x2F;如果返回状态为异常状态则报错并返回</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;获取用户列表失败&#39;)</span><br><span class="line">      &#x2F;&#x2F;如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">      this.userList &#x3D; res.data.users;</span><br><span class="line">      this.total &#x3D; res.data.total;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="7-4-将用户列表数据展示"><a href="#7-4-将用户列表数据展示" class="headerlink" title="7.4 将用户列表数据展示"></a>7.4 将用户列表数据展示</h2><p>使用表格来展示用户列表数据，使用element-ui表格组件完成列表展示数据(复制表格代码，在element.js中导入组件Table,TableColumn)<br>在渲染展示状态时，会使用作用域插槽获取每一行的数据<br>再使用switch开关组件展示状态信息(复制开关组件代码，在element.js中导入组件Switch)<br>而渲染操作列时，也是使用作用域插槽来进行渲染的，<br>在操作列中包含了修改，删除，分配角色按钮，当我们把鼠标放到分配角色按钮上时<br>希望能有一些文字提示，此时我们需要使用文字提示组件(复制文字提示组件代码，在element.js中导入组件Tooltip),将分配角色按钮包含<br>代码结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用户列表(表格)区域 --&gt;</span><br><span class="line">&lt;el-table :data&#x3D;&quot;userList&quot; border stripe&gt;</span><br><span class="line">    &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;姓名&quot; prop&#x3D;&quot;username&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;邮箱&quot; prop&#x3D;&quot;email&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;电话&quot; prop&#x3D;&quot;mobile&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;角色&quot; prop&#x3D;&quot;role_name&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;状态&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">            &lt;el-switch v-model&#x3D;&quot;scope.row.mg_state&quot;&gt;&lt;&#x2F;el-switch&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;180px&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">            &lt;!-- 修改 --&gt;</span><br><span class="line">            &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot; size&#x3D;&#39;mini&#39;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;!-- 删除 --&gt;</span><br><span class="line">            &lt;el-button type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; size&#x3D;&#39;mini&#39;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;!-- 分配角色 --&gt;</span><br><span class="line">            &lt;el-tooltip class&#x3D;&quot;item&quot; effect&#x3D;&quot;dark&quot; content&#x3D;&quot;分配角色&quot; placement&#x3D;&quot;top&quot; :enterable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">                &lt;el-button type&#x3D;&quot;warning&quot; icon&#x3D;&quot;el-icon-setting&quot; size&#x3D;&#39;mini&#39;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;el-tooltip&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br></pre></td></tr></table></figure><h2 id="7-5-实现用户列表分页"><a href="#7-5-实现用户列表分页" class="headerlink" title="7.5 实现用户列表分页"></a>7.5 实现用户列表分页</h2><h3 id="7-5-1使用表格来展示用户列表数据"><a href="#7-5-1使用表格来展示用户列表数据" class="headerlink" title="7.5.1使用表格来展示用户列表数据"></a>7.5.1使用表格来展示用户列表数据</h3><p>可以使用分页组件完成列表分页展示数据(复制分页组件代码，在element.js中导入组件Pagination)</p><h3 id="7-5-2-更改组件中的绑定数据"><a href="#7-5-2-更改组件中的绑定数据" class="headerlink" title="7.5.2 更改组件中的绑定数据"></a>7.5.2 更改组件中的绑定数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分页导航区域 </span><br><span class="line">@size-change(pagesize改变时触发) </span><br><span class="line">@current-change(页码发生改变时触发)</span><br><span class="line">:current-page(设置当前页码)</span><br><span class="line">:page-size(设置每页的数据条数)</span><br><span class="line">:total(设置总页数) --&gt;</span><br><span class="line">            &lt;el-pagination @size-change&#x3D;&quot;handleSizeChange&quot; @current-change&#x3D;&quot;handleCurrentChange&quot; :current-page&#x3D;&quot;queryInfo.pagenum&quot; :page-sizes&#x3D;&quot;[1, 2, 5, 10]&quot; :page-size&#x3D;&quot;queryInfo.pagesize&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; :total&#x3D;&quot;total&quot;&gt;</span><br><span class="line">            &lt;&#x2F;el-pagination&gt;</span><br></pre></td></tr></table></figure><h3 id="7-5-3-添加两个事件的事件处理函数-size-change，-current-change"><a href="#7-5-3-添加两个事件的事件处理函数-size-change，-current-change" class="headerlink" title="7.5.3 添加两个事件的事件处理函数@size-change，@current-change"></a>7.5.3 添加两个事件的事件处理函数@size-change，@current-change</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handleSizeChange(newSize) &#123;</span><br><span class="line">  &#x2F;&#x2F;pagesize改变时触发，当pagesize发生改变的时候，我们应该</span><br><span class="line">  &#x2F;&#x2F;以最新的pagesize来请求数据并展示数据</span><br><span class="line">  &#x2F;&#x2F;   console.log(newSize)</span><br><span class="line">  this.queryInfo.pagesize &#x3D; newSize;</span><br><span class="line">  &#x2F;&#x2F;重新按照pagesize发送请求，请求最新的数据</span><br><span class="line">  this.getUserList();  </span><br><span class="line">&#125;,</span><br><span class="line">handleCurrentChange( current ) &#123;</span><br><span class="line">  &#x2F;&#x2F;页码发生改变时触发当current发生改变的时候，我们应该</span><br><span class="line">  &#x2F;&#x2F;以最新的current页码来请求数据并展示数据</span><br><span class="line">  &#x2F;&#x2F;   console.log(current)</span><br><span class="line">  this.queryInfo.pagenum &#x3D; current;</span><br><span class="line">  &#x2F;&#x2F;重新按照pagenum发送请求，请求最新的数据</span><br><span class="line">  this.getUserList();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-实现更新用户状态"><a href="#7-6-实现更新用户状态" class="headerlink" title="7.6 实现更新用户状态"></a>7.6 实现更新用户状态</h2><p>当用户点击列表中的switch组件时，用户的状态应该跟随发生改变。</p><h3 id="7-6-1-首先监听用户点击switch组件的事件，并将作用域插槽的数据当做事件参数进行传递"><a href="#7-6-1-首先监听用户点击switch组件的事件，并将作用域插槽的数据当做事件参数进行传递" class="headerlink" title="7.6.1 首先监听用户点击switch组件的事件，并将作用域插槽的数据当做事件参数进行传递"></a>7.6.1 首先监听用户点击switch组件的事件，并将作用域插槽的数据当做事件参数进行传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-switch v-model&#x3D;&quot;scope.row.mg_state&quot; @change&#x3D;&quot;userStateChanged(scope.row)&quot;&gt;&lt;&#x2F;el-switch&gt;</span><br></pre></td></tr></table></figure><h3 id="7-6-2-在事件中发送请求完成状态的更改"><a href="#7-6-2-在事件中发送请求完成状态的更改" class="headerlink" title="7.6.2 在事件中发送请求完成状态的更改"></a>7.6.2 在事件中发送请求完成状态的更改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async userStateChanged(row) &#123;</span><br><span class="line">  &#x2F;&#x2F;发送请求进行状态修改</span><br><span class="line">  const &#123; data: res &#125; &#x3D; await this.$http.put(</span><br><span class="line">    &#96;users&#x2F;$&#123;row.id&#125;&#x2F;state&#x2F;$&#123;row.mg_state&#125;&#96;</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F;如果返回状态为异常状态则报错并返回</span><br><span class="line">  if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    row.mg_state &#x3D; !row.mg_state</span><br><span class="line">    return this.$message.error(&#39;修改状态失败&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this.$message.success(&#39;更新状态成功&#39;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="7-7-实现搜索功能"><a href="#7-7-实现搜索功能" class="headerlink" title="7.7 实现搜索功能"></a>7.7 实现搜索功能</h2><p>添加数据绑定，添加搜索按钮的点击事件(当用户点击搜索按钮的时候，调用getUserList方法根据文本框内容重新请求用户列表数据)<br>当我们在输入框中输入内容并点击搜索之后，会按照搜索关键字搜索，我们希望能够提供一个X删除搜索关键字并重新获取所有的用户列表数据，只需要给文本框添加clearable属性并添加clear事件，在clear事件中重新请求数据即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-col :span&#x3D;&quot;7&quot;&gt;</span><br><span class="line">    &lt;el-input placeholder&#x3D;&quot;请输入内容&quot; v-model&#x3D;&quot;queryInfo.query&quot; clearable @clear&#x3D;&quot;getUserList&quot;&gt;</span><br><span class="line">        &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot; @click&#x3D;&quot;getUserList&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;el-input&gt;</span><br><span class="line">&lt;&#x2F;el-col&gt;</span><br></pre></td></tr></table></figure><h2 id="7-8-实现添加用户"><a href="#7-8-实现添加用户" class="headerlink" title="7.8 实现添加用户"></a>7.8 实现添加用户</h2><h3 id="7-8-1-当我们点击添加用户按钮的时候，弹出一个对话框来实现添加用户的功能，首先我们需要复制对话框组件的代码并在element-js文件中引入Dialog组件"><a href="#7-8-1-当我们点击添加用户按钮的时候，弹出一个对话框来实现添加用户的功能，首先我们需要复制对话框组件的代码并在element-js文件中引入Dialog组件" class="headerlink" title="7.8.1 当我们点击添加用户按钮的时候，弹出一个对话框来实现添加用户的功能，首先我们需要复制对话框组件的代码并在element.js文件中引入Dialog组件"></a>7.8.1 当我们点击添加用户按钮的时候，弹出一个对话框来实现添加用户的功能，首先我们需要复制对话框组件的代码并在element.js文件中引入Dialog组件</h3><h3 id="7-8-2-接下来我们要为“添加用户”按钮添加点击事件，在事件中将addDialogVisible设置为true，即显示对话框"><a href="#7-8-2-接下来我们要为“添加用户”按钮添加点击事件，在事件中将addDialogVisible设置为true，即显示对话框" class="headerlink" title="7.8.2 接下来我们要为“添加用户”按钮添加点击事件，在事件中将addDialogVisible设置为true，即显示对话框"></a>7.8.2 接下来我们要为“添加用户”按钮添加点击事件，在事件中将addDialogVisible设置为true，即显示对话框</h3><h3 id="7-8-3-更改Dialog组件中的内容"><a href="#7-8-3-更改Dialog组件中的内容" class="headerlink" title="7.8.3 更改Dialog组件中的内容"></a>7.8.3 更改Dialog组件中的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对话框组件  :visible.sync(设置是否显示对话框) width(设置对话框的宽度)</span><br><span class="line">:before-close(在对话框关闭前触发的事件) --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;添加用户&quot; :visible.sync&#x3D;&quot;addDialogVisible&quot; width&#x3D;&quot;50%&quot;&gt;</span><br><span class="line">    &lt;!-- 对话框主体区域 --&gt;</span><br><span class="line">    &lt;el-form :model&#x3D;&quot;addForm&quot; :rules&#x3D;&quot;addFormRules&quot; ref&#x3D;&quot;addFormRef&quot; label-width&#x3D;&quot;70px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;addForm.username&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;addForm.password&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;邮箱&quot; prop&#x3D;&quot;email&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;addForm.email&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;电话&quot; prop&#x3D;&quot;mobile&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;addForm.mobile&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">    &lt;!-- 对话框底部区域 --&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;addDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addDialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><h3 id="7-8-4-添加数据绑定和校验规则："><a href="#7-8-4-添加数据绑定和校验规则：" class="headerlink" title="7.8.4 添加数据绑定和校验规则："></a>7.8.4 添加数据绑定和校验规则：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  &#x2F;&#x2F;验证邮箱的规则</span><br><span class="line">  var checkEmail &#x3D; (rule, value, cb) &#x3D;&gt; &#123;</span><br><span class="line">    const regEmail &#x3D; &#x2F;^\w+@\w+(\.\w+)+$&#x2F;</span><br><span class="line">    if (regEmail.test(value)) &#123;</span><br><span class="line">      return cb()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回一个错误提示</span><br><span class="line">    cb(new Error(&#39;请输入合法的邮箱&#39;))</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;验证手机号码的规则</span><br><span class="line">  var checkMobile &#x3D; (rule, value, cb) &#x3D;&gt; &#123;</span><br><span class="line">    const regMobile &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;</span><br><span class="line">    if (regMobile.test(value)) &#123;</span><br><span class="line">      return cb()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回一个错误提示</span><br><span class="line">    cb(new Error(&#39;请输入合法的手机号码&#39;))</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    &#x2F;&#x2F;获取查询用户信息的参数</span><br><span class="line">    queryInfo: &#123;</span><br><span class="line">      &#x2F;&#x2F; 查询的条件</span><br><span class="line">      query: &#39;&#39;,</span><br><span class="line">      &#x2F;&#x2F; 当前的页数，即页码</span><br><span class="line">      pagenum: 1,</span><br><span class="line">      &#x2F;&#x2F; 每页显示的数据条数</span><br><span class="line">      pagesize: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;保存请求回来的用户列表数据</span><br><span class="line">    userList: [],</span><br><span class="line">    total: 0,</span><br><span class="line">    &#x2F;&#x2F;是否显示添加用户弹出窗</span><br><span class="line">    addDialogVisible: false,</span><br><span class="line">    &#x2F;&#x2F; 添加用户的表单数据</span><br><span class="line">    addForm: &#123;</span><br><span class="line">      username: &#39;&#39;,</span><br><span class="line">      password: &#39;&#39;,</span><br><span class="line">      email: &#39;&#39;,</span><br><span class="line">      mobile: &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 添加表单的验证规则对象</span><br><span class="line">    addFormRules: &#123;</span><br><span class="line">      username: [</span><br><span class="line">        &#123; required: true, message: &#39;请输入用户名称&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          min: 3,</span><br><span class="line">          max: 10,</span><br><span class="line">          message: &#39;用户名在3~10个字符之间&#39;,</span><br><span class="line">          trigger: &#39;blur&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      password: [</span><br><span class="line">        &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          min: 6,</span><br><span class="line">          max: 15,</span><br><span class="line">          message: &#39;用户名在6~15个字符之间&#39;,</span><br><span class="line">          trigger: &#39;blur&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      email: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入邮箱&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">          &#123; validator:checkEmail, message: &#39;邮箱格式不正确，请重新输入&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">      ],</span><br><span class="line">      mobile: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入手机号码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">          &#123; validator:checkMobile, message: &#39;手机号码不正确，请重新输入&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-8-5当关闭对话框时，重置表单"><a href="#7-8-5当关闭对话框时，重置表单" class="headerlink" title="7.8.5当关闭对话框时，重置表单"></a>7.8.5当关闭对话框时，重置表单</h3><p>给el-dialog添加@close事件，在事件中添加重置表单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ....</span><br><span class="line">  addDialogClosed()&#123;</span><br><span class="line">      &#x2F;&#x2F;对话框关闭之后，重置表达</span><br><span class="line">      this.$refs.addFormRef.resetFields();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-8-6-点击对话框中的确定按钮，发送请求完成添加用户的操作"><a href="#7-8-6-点击对话框中的确定按钮，发送请求完成添加用户的操作" class="headerlink" title="7.8.6 点击对话框中的确定按钮，发送请求完成添加用户的操作"></a>7.8.6 点击对话框中的确定按钮，发送请求完成添加用户的操作</h3><p>首先给确定按钮添加点击事件，在点击事件中完成业务逻辑代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ....</span><br><span class="line">  addUser()&#123;</span><br><span class="line">      &#x2F;&#x2F;点击确定按钮，添加新用户</span><br><span class="line">      &#x2F;&#x2F;调用validate进行表单验证</span><br><span class="line">      this.$refs.addFormRef.validate( async valid &#x3D;&gt; &#123;</span><br><span class="line">          if(!valid) return this.$message.error(&quot;请填写完整用户信息&quot;);</span><br><span class="line">          &#x2F;&#x2F;发送请求完成添加用户的操作</span><br><span class="line">          const &#123;data:res&#125; &#x3D; await this.$http.post(&quot;users&quot;,this.addForm)</span><br><span class="line">          &#x2F;&#x2F;判断如果添加失败，就做提示</span><br><span class="line">          if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">              return this.$message.error(&#39;添加用户失败&#39;)</span><br><span class="line">          &#x2F;&#x2F;添加成功的提示</span><br><span class="line">          this.$message.success(&quot;添加用户成功&quot;)</span><br><span class="line">          &#x2F;&#x2F;关闭对话框</span><br><span class="line">          this.addDialogVisible &#x3D; false</span><br><span class="line">          &#x2F;&#x2F;重新请求最新的数据</span><br><span class="line">          this.getUserList()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-9-推送代码"><a href="#7-9-推送代码" class="headerlink" title="7.9 推送代码"></a>7.9 推送代码</h2><p>新建一个项目终端,输入命令‘git status’查看修改过的与新增的文件内容<br>将所有文件添加到暂存区：git add .<br>将所有代码提交到本地仓库：git commit -m “添加用户列表页”<br>查看分支： git branch  发现所有代码都被提交到了home分支<br>将login分支代码合并到master主分支，先切换到master：git checkout master<br>在master分支进行代码合并：git merge home<br>将本地的master推送到远端的码云：git push</p><p>(推送本地的子分支到码云，先切换到子分支：git checkout 分支名<br>然后推送到码云：git push -u origin 远端分支名)</p><p>创建user子分支，并将代码推送到码云</p><h1 id="8-完成用户信息的修改与删除"><a href="#8-完成用户信息的修改与删除" class="headerlink" title="8.完成用户信息的修改与删除"></a>8.完成用户信息的修改与删除</h1><h2 id="8-1-git操作"><a href="#8-1-git操作" class="headerlink" title="8.1 git操作"></a>8.1 git操作</h2><p>创建user子分支：git checkout -b user</p><p> 将本地的user分支推送到码云：git push -u origin user</p><h2 id="8-2-修改用户信息"><a href="#8-2-修改用户信息" class="headerlink" title="8.2 修改用户信息"></a>8.2 修改用户信息</h2><h3 id="8-2-1-为用户列表中的修改按钮绑定点击事件"><a href="#8-2-1-为用户列表中的修改按钮绑定点击事件" class="headerlink" title="8.2.1 为用户列表中的修改按钮绑定点击事件"></a>8.2.1 为用户列表中的修改按钮绑定点击事件</h3><h3 id="8-2-2-在页面中添加修改用户对话框，并修改对话框的属性"><a href="#8-2-2-在页面中添加修改用户对话框，并修改对话框的属性" class="headerlink" title="8.2.2 在页面中添加修改用户对话框，并修改对话框的属性"></a>8.2.2 在页面中添加修改用户对话框，并修改对话框的属性</h3><h3 id="8-2-3-根据id查询需要修改的用户数据"><a href="#8-2-3-根据id查询需要修改的用户数据" class="headerlink" title="8.2.3 根据id查询需要修改的用户数据"></a>8.2.3 根据id查询需要修改的用户数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;展示编辑用户的对话框</span><br><span class="line">async showEditDialog(id) &#123;</span><br><span class="line">    &#x2F;&#x2F;发送请求根据id获取用户信息</span><br><span class="line">    const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;users&#x2F;&#39; + id)</span><br><span class="line">    &#x2F;&#x2F;判断如果添加失败，就做提示</span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(&#39;获取用户信息失败&#39;)</span><br><span class="line">    &#x2F;&#x2F;将获取到的数据保存到数据editForm中</span><br><span class="line">    this.editForm &#x3D; res.data</span><br><span class="line">    &#x2F;&#x2F; 显示弹出窗</span><br><span class="line">    this.editDialogVisible &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-4-在弹出窗中添加修改用户信息的表单并做响应的数据绑定以及数据验证"><a href="#8-2-4-在弹出窗中添加修改用户信息的表单并做响应的数据绑定以及数据验证" class="headerlink" title="8.2.4 在弹出窗中添加修改用户信息的表单并做响应的数据绑定以及数据验证"></a>8.2.4 在弹出窗中添加修改用户信息的表单并做响应的数据绑定以及数据验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对话框主体区域 --&gt;</span><br><span class="line">&lt;el-form :model&#x3D;&quot;editForm&quot; :rules&#x3D;&quot;editFormRules&quot; ref&#x3D;&quot;editFormRef&quot; label-width&#x3D;&quot;70px&quot;&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;用户名&quot;&gt;</span><br><span class="line">        &lt;el-input v-model&#x3D;&quot;editForm.username&quot; disabled&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;邮箱&quot; prop&#x3D;&quot;email&quot;&gt;</span><br><span class="line">        &lt;el-input v-model&#x3D;&quot;editForm.email&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;电话&quot; prop&#x3D;&quot;mobile&quot;&gt;</span><br><span class="line">        &lt;el-input v-model&#x3D;&quot;editForm.mobile&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-form&gt;</span><br></pre></td></tr></table></figure><p>数据绑定以及验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;控制修改用户对话框的显示与否</span><br><span class="line">editDialogVisible: false,</span><br><span class="line">&#x2F;&#x2F;修改用户的表单数据</span><br><span class="line">editForm: &#123;</span><br><span class="line">    username: &#39;&#39;,</span><br><span class="line">    email: &#39;&#39;,</span><br><span class="line">    mobile: &#39;&#39;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;修改表单的验证规则对象</span><br><span class="line">editFormRules: &#123;</span><br><span class="line">    email: [</span><br><span class="line">        &#123; required: true, message: &#39;请输入邮箱&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        validator: checkEmail,</span><br><span class="line">        message: &#39;邮箱格式不正确，请重新输入&#39;,</span><br><span class="line">        trigger: &#39;blur&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    mobile: [</span><br><span class="line">        &#123; required: true, message: &#39;请输入手机号码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        validator: checkMobile,</span><br><span class="line">        message: &#39;手机号码不正确，请重新输入&#39;,</span><br><span class="line">        trigger: &#39;blur&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-监听对话框关闭事件，在对话框关闭之后，重置表单"><a href="#8-2-5-监听对话框关闭事件，在对话框关闭之后，重置表单" class="headerlink" title="8.2.5 监听对话框关闭事件，在对话框关闭之后，重置表单"></a>8.2.5 监听对话框关闭事件，在对话框关闭之后，重置表单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog title&#x3D;&quot;修改用户&quot; :visible.sync&#x3D;&quot;editDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;editDialogClosed&quot;&gt;</span><br><span class="line"></span><br><span class="line">editDialogClosed()&#123;</span><br><span class="line">    &#x2F;&#x2F;对话框关闭之后，重置表达</span><br><span class="line">    this.$refs.editFormRef.resetFields()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-6-在用户点击确定按钮的时候，验证数据成功之后发送请求完成修改"><a href="#8-2-6-在用户点击确定按钮的时候，验证数据成功之后发送请求完成修改" class="headerlink" title="8.2.6 在用户点击确定按钮的时候，验证数据成功之后发送请求完成修改"></a>8.2.6 在用户点击确定按钮的时候，验证数据成功之后发送请求完成修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">editUser() &#123;</span><br><span class="line">    &#x2F;&#x2F;用户点击修改表单中的确定按钮之后，验证表单数据</span><br><span class="line">    this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if (!valid) return this.$message.error(&#39;请填写完整用户信息&#39;)</span><br><span class="line">        &#x2F;&#x2F;发送请求完成修改用户的操作</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.put(</span><br><span class="line">            &#39;users&#x2F;&#39; + this.editForm.id,</span><br><span class="line">            this.editForm</span><br><span class="line">        )</span><br><span class="line">        &#x2F;&#x2F;判断如果修改失败，就做提示</span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(&#39;修改用户失败&#39;)</span><br><span class="line">        &#x2F;&#x2F;修改成功的提示</span><br><span class="line">        this.$message.success(&#39;修改用户成功&#39;)</span><br><span class="line">        &#x2F;&#x2F;关闭对话框</span><br><span class="line">        this.editDialogVisible &#x3D; false</span><br><span class="line">        &#x2F;&#x2F;重新请求最新的数据</span><br><span class="line">        this.getUserList()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-删除用户"><a href="#8-3-删除用户" class="headerlink" title="8.3 删除用户"></a>8.3 删除用户</h2><p>在点击删除按钮的时候，我们应该跳出提示信息框，让用户确认要进行删除操作。<br>如果想要使用确认取消提示框，我们需要先将提示信息框挂载到vue中。</p><h3 id="8-3-1-导入MessageBox组件，并将MessageBox组件挂载到实例。"><a href="#8-3-1-导入MessageBox组件，并将MessageBox组件挂载到实例。" class="headerlink" title="8.3.1 导入MessageBox组件，并将MessageBox组件挂载到实例。"></a>8.3.1 导入MessageBox组件，并将MessageBox组件挂载到实例。</h3><p>Vue.prototype.$confirm = MessageBox.confirm</p><h3 id="8-3-2-给用户列表中的删除按钮添加事件，并在事件处理函数中弹出确定取消窗-最后再根据id发送删除用户的请求"><a href="#8-3-2-给用户列表中的删除按钮添加事件，并在事件处理函数中弹出确定取消窗-最后再根据id发送删除用户的请求" class="headerlink" title="8.3.2 给用户列表中的删除按钮添加事件，并在事件处理函数中弹出确定取消窗,最后再根据id发送删除用户的请求"></a>8.3.2 给用户列表中的删除按钮添加事件，并在事件处理函数中弹出确定取消窗,最后再根据id发送删除用户的请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">async removeUserById(id)&#123;</span><br><span class="line">    &#x2F;&#x2F;弹出确定取消框，是否删除用户</span><br><span class="line">    const confirmResult &#x3D; await this.$confirm(&#39;请问是否要永久删除该用户&#39;,&#39;删除提示&#39;,&#123;</span><br><span class="line">        confirmButtonText:&#39;确认删除&#39;,</span><br><span class="line">        cancelButtonText:&#39;取消&#39;,</span><br><span class="line">        type:&#39;warning&#39;</span><br><span class="line">    &#125;).catch(err&#x3D;&gt;err)</span><br><span class="line">    &#x2F;&#x2F;如果用户点击确认，则confirmResult 为&#39;confirm&#39;</span><br><span class="line">    &#x2F;&#x2F;如果用户点击取消, 则confirmResult获取的就是catch的错误消息&#39;cancel&#39;</span><br><span class="line">    if(confirmResult !&#x3D; &quot;confirm&quot;)&#123;</span><br><span class="line">        return this.$message.info(&quot;已经取消删除&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;发送请求根据id完成删除操作</span><br><span class="line">    const &#123;data:res&#125; &#x3D; await this.$http.delete(&#39;users&#x2F;&#39;+id)</span><br><span class="line">    &#x2F;&#x2F;判断如果删除失败，就做提示</span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(&#39;删除用户失败&#39;)</span><br><span class="line">    &#x2F;&#x2F;修改成功的提示</span><br><span class="line">    this.$message.success(&#39;删除用户成功&#39;)</span><br><span class="line">    &#x2F;&#x2F;重新请求最新的数据</span><br><span class="line">    this.getUserList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-推送代码"><a href="#8-4-推送代码" class="headerlink" title="8.4 推送代码"></a>8.4 推送代码</h2><p>将代码添加到暂存区：git add .</p><p>将代码提交并注释： git commit -m ‘添加完成用户列表功能’</p><p>将本地的user分支推送到码云： git push</p><p>将user分支代码合并到master，切换到master ：  git checkout master<br>合并user：git merge user</p><p>将本地master分支的代码推送到码云：git push</p><h1 id="9-权限功能开发"><a href="#9-权限功能开发" class="headerlink" title="9.权限功能开发"></a>9.权限功能开发</h1><h2 id="9-1-git-操作"><a href="#9-1-git-操作" class="headerlink" title="9.1 git 操作"></a>9.1 git 操作</h2><p>创建rights子分支: git checkout -b rights<br>将本地的rights分支推送到码云: git push -u origin rights</p><h2 id="9-2-权限列表"><a href="#9-2-权限列表" class="headerlink" title="9.2 权限列表"></a>9.2 权限列表</h2><h3 id="9-2-1-添加权限列表路由"><a href="#9-2-1-添加权限列表路由" class="headerlink" title="9.2.1 添加权限列表路由"></a>9.2.1 添加权限列表路由</h3><p>创建权限管理组件（Rights.vue），并在router.js添加对应的路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Rights from &#39;.&#x2F;components&#x2F;power&#x2F;Rights.vue&#39;</span><br><span class="line">......</span><br><span class="line">      path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">        &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">        &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">        &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;</span><br><span class="line">      ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="9-2-2-添加面包屑导航"><a href="#9-2-2-添加面包屑导航" class="headerlink" title="9.2.2 添加面包屑导航"></a>9.2.2 添加面包屑导航</h3><p>在Rights.vue中添加面包屑组件展示导航路径</p><h3 id="9-2-3-显示数据"><a href="#9-2-3-显示数据" class="headerlink" title="9.2.3 显示数据"></a>9.2.3 显示数据</h3><p>在data中添加一个rightsList数据，在methods中提供一个getRightsList方法发送请求获取权限列表数据，在created中调用这个方法获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table :data&#x3D;&quot;rightsList&quot; stripe&gt;</span><br><span class="line">    &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;权限名称&quot; prop&#x3D;&quot;authName&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;路径&quot; prop&#x3D;&quot;path&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;权限等级&quot; prop&#x3D;&quot;level&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt; </span><br><span class="line">            &lt;el-tag v-if&#x3D;&quot;scope.row.level &#x3D;&#x3D;&#x3D; 0&quot;&gt;一级权限&lt;&#x2F;el-tag&gt;</span><br><span class="line">            &lt;el-tag v-if&#x3D;&quot;scope.row.level &#x3D;&#x3D;&#x3D; 1&quot; type&#x3D;&quot;success&quot;&gt;二级权限&lt;&#x2F;el-tag&gt;</span><br><span class="line">            &lt;el-tag v-if&#x3D;&quot;scope.row.level &#x3D;&#x3D;&#x3D; 2&quot; type&#x3D;&quot;warning&quot;&gt;三级权限&lt;&#x2F;el-tag&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x2F;&#x2F;列表形式的权限</span><br><span class="line">            rightsList:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.getRightsList();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        async getRightsList()&#123;</span><br><span class="line">            const &#123;data:res&#125; &#x3D; await this.$http.get(&#39;rights&#x2F;list&#39;)</span><br><span class="line">            &#x2F;&#x2F;如果返回状态为异常状态则报错并返回</span><br><span class="line">            if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">                return this.$message.error(&#39;获取权限列表失败&#39;)</span><br><span class="line">            &#x2F;&#x2F;如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">            this.rightsList &#x3D; res.data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="9-3-角色列表"><a href="#9-3-角色列表" class="headerlink" title="9.3 角色列表"></a>9.3 角色列表</h2><h3 id="9-3-1-添加角色列表路由"><a href="#9-3-1-添加角色列表路由" class="headerlink" title="9.3.1 添加角色列表路由"></a>9.3.1 添加角色列表路由</h3><p>添加角色列表子组件（power/Roles.vue），并添加对应的规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">        &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">        &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">        &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">        &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure><h3 id="9-3-2-添加面包屑导航"><a href="#9-3-2-添加面包屑导航" class="headerlink" title="9.3.2 添加面包屑导航"></a>9.3.2 添加面包屑导航</h3><p>在Roles.vue中添加面包屑组件展示导航路径</p><h3 id="9-3-3-显示数据"><a href="#9-3-3-显示数据" class="headerlink" title="9.3.3 显示数据"></a>9.3.3 显示数据</h3><p>在data中添加一个roleList数据，在methods中提供一个getRoleList方法发送请求获取权限列表数据，在created中调用这个方法获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 角色列表区域 --&gt;</span><br><span class="line">&lt;!-- row-key&#x3D;&quot;id&quot; 是2019年3月提供的新特性，</span><br><span class="line">if there&#39;s nested data, rowKey is required.</span><br><span class="line">如果这是一个嵌套的数据，rowkey 是必须添加的属性 --&gt;</span><br><span class="line">&lt;el-table row-key&#x3D;&quot;id&quot; :data&#x3D;&quot;roleList&quot; border&gt;</span><br><span class="line">    &lt;!-- 添加展开列 --&gt;</span><br><span class="line">    &lt;el-table-column type&#x3D;&quot;expand&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;角色名称&quot; prop&#x3D;&quot;roleName&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;角色描述&quot; prop&#x3D;&quot;roleDesc&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;300px&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt; </span><br><span class="line">            &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;warning&quot; icon&#x3D;&quot;el-icon-setting&quot;&gt;分配权限&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            roleList:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,created()&#123;</span><br><span class="line">        this.getRoleList();</span><br><span class="line">    &#125;,methods:&#123;</span><br><span class="line">        async getRoleList()&#123;</span><br><span class="line">            const &#123;data:res&#125; &#x3D; await this.$http.get(&#39;roles&#39;)</span><br><span class="line">            &#x2F;&#x2F;如果返回状态为异常状态则报错并返回</span><br><span class="line">            &#x2F;&#x2F; if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">            &#x2F;&#x2F;     return this.$message.error(&#39;获取角色列表失败&#39;)</span><br><span class="line">            &#x2F;&#x2F; &#x2F;&#x2F;如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">            &#x2F;&#x2F; this.roleList &#x3D; res.data</span><br><span class="line">            console.log(res.data)</span><br><span class="line">            this.roleList &#x3D; res.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="9-3-4-添加角色，删除角色，编辑角色"><a href="#9-3-4-添加角色，删除角色，编辑角色" class="headerlink" title="9.3.4 添加角色，删除角色，编辑角色"></a>9.3.4 添加角色，删除角色，编辑角色</h3><p>完成添加角色，删除角色，编辑角色三个按钮的对应功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addRoleDialogVisible &#x3D; true&quot;&gt;添加角色&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">     &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot; @click&#x3D;&quot;showEditDialog(scope.row.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">     &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeRoleById(scope.row.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">     &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;warning&quot; icon&#x3D;&quot;el-icon-setting&quot; @click&#x3D;&quot;showSetRightDialog(scope.row)&quot;&gt;分配权限&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>完成添加角色，编辑角色2个对话框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加角色的对话框--&gt;</span><br><span class="line">    &lt;el-dialog title&#x3D;&quot;添加角色&quot; width&#x3D;&quot;50%&quot; :visible.sync&#x3D;&quot;addRoleDialogVisible&quot; :close-on-click-modal&#x3D;&quot;false&quot; @close&#x3D;&quot;addRoleDialogClosed&quot;&gt;</span><br><span class="line">      &lt;!--内容主体--&gt;</span><br><span class="line">      &lt;el-form :model&#x3D;&quot;addRoleForm&quot; :rules&#x3D;&quot;addRoleFormRules&quot; ref&#x3D;&quot;addRoleFormRef&quot; label-width&#x3D;&quot;80px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;角色名称&quot; prop&#x3D;&quot;roleName&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;addRoleForm.roleName&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;角色描述&quot; prop&#x3D;&quot;roleDesc&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;addRoleForm.roleDesc&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;!--底部--&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;addRoleDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addRole&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--修改角色的对话框--&gt;</span><br><span class="line">    &lt;el-dialog title&#x3D;&quot;修改角色&quot; width&#x3D;&quot;50%&quot; :visible.sync&#x3D;&quot;editRoleDialogVisible&quot; :close-on-click-modal&#x3D;&quot;false&quot; @close&#x3D;&quot;editRoleDialogClosed&quot;&gt;</span><br><span class="line">      &lt;!--内容主体--&gt;</span><br><span class="line">      &lt;el-form :model&#x3D;&quot;editRoleForm&quot; :rules&#x3D;&quot;editRoleFormRules&quot; ref&#x3D;&quot;editRoleFormRef&quot; label-width&#x3D;&quot;80px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;角色名称&quot; prop&#x3D;&quot;roleName&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;editRoleForm.roleName&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;角色描述&quot; prop&#x3D;&quot;roleDesc&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;editRoleForm.roleDesc&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;!--底部--&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;editRoleDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;editRole&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><p>实现3个功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 添加角色对话框的显示状态</span><br><span class="line">      addRoleDialogVisible: false,</span><br><span class="line">      &#x2F;&#x2F; 修改角色对话框的显示状态</span><br><span class="line">      editRoleDialogVisible: false,</span><br><span class="line">      &#x2F;&#x2F; 添加角色的表单数据</span><br><span class="line">      addRoleForm: &#123;</span><br><span class="line">        roleName: &#39;&#39;,</span><br><span class="line">        roleDesc: &#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 添加角色表单的验证规则对象</span><br><span class="line">      addRoleFormRules: &#123;</span><br><span class="line">        roleName: [&#123; required: true, message: &#39;请输入角色名称&#39;, trigger: &#39;blur&#39; &#125;],</span><br><span class="line">        roleDesc: [&#123; required: true, message: &#39;请输入角色描述&#39;, trigger: &#39;blur&#39; &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 修改角色的表单数据</span><br><span class="line">      editRoleForm: &#123;</span><br><span class="line">        roleName: &#39;&#39;,</span><br><span class="line">        roleDesc: &#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 修改角色表单的验证规则对象</span><br><span class="line">      editRoleFormRules: &#123;</span><br><span class="line">        roleName: [&#123; required: true, message: &#39;请输入角色名称&#39;, trigger: &#39;blur&#39; &#125;],</span><br><span class="line">        roleDesc: [&#123; required: true, message: &#39;请输入角色描述&#39;, trigger: &#39;blur&#39; &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加角色对话框的关闭事件</span><br><span class="line">    addRoleDialogClosed() &#123;</span><br><span class="line">      this.$refs.addRoleFormRef.resetFields()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 确认添加角色</span><br><span class="line">    addRole() &#123;</span><br><span class="line">      this.$refs.addRoleFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if (!valid) &#123;</span><br><span class="line">          return this.$message.error(&#39;请填写必要的角色信息!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发起请求添加角色</span><br><span class="line">        &#x2F;&#x2F; 商品的名称必须是唯一的</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.post(&#39;roles&#39;, this.addRoleForm)</span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 201) &#123;</span><br><span class="line">          return this.$message.error(&#39;添加角色失败!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.getRolesList()</span><br><span class="line">        this.$message.success(&#39;添加角色成功!&#39;)</span><br><span class="line">        this.addRoleDialogVisible &#x3D; false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 展示编辑角色的对话框</span><br><span class="line">    async showEditDialog(id) &#123;</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#96;roles&#x2F;$&#123;id&#125;&#96;)</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;查询角色信息失败！&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.editRoleForm &#x3D; res.data</span><br><span class="line">      &#x2F;&#x2F; console.log(this.editRoleForm)</span><br><span class="line">      this.editRoleDialogVisible &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 修改角色对话框的关闭事件</span><br><span class="line">    editRoleDialogClosed() &#123;</span><br><span class="line">      this.$refs.editRoleFormRef.resetFields()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 确认修改角色</span><br><span class="line">    editRole() &#123;</span><br><span class="line">      this.$refs.editRoleFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if (!valid) return</span><br><span class="line">        &#x2F;&#x2F; console.log(this.editRoleForm.roleId)</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.put(&#96;roles&#x2F;$&#123;this.editRoleForm.roleId&#125;&#96;, this.editRoleForm)</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;编辑角色失败!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.getRolesList()</span><br><span class="line">        this.$message.success(&#39;编辑角色成功!&#39;)</span><br><span class="line">        &#x2F;&#x2F; 隐藏对话框</span><br><span class="line">        this.editRoleDialogVisible &#x3D; false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 根据id删除对应的角色</span><br><span class="line">    async removeRoleById(id) &#123;</span><br><span class="line">      const confirmResult &#x3D; await this.$confirm(&#39;此操作将永久删除该角色, 是否继续?&#39;, &#39;提示&#39;, &#123;</span><br><span class="line">        confirmButtonText: &#39;确定&#39;,</span><br><span class="line">        cancelButtonText: &#39;取消&#39;,</span><br><span class="line">        type: &#39;warning&#39;</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; err)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果用户确认删除，则返回值为字符串 confirm</span><br><span class="line">      &#x2F;&#x2F; 如果用户取消了删除，则返回值为字符串 cancel</span><br><span class="line">      &#x2F;&#x2F; console.log(confirmResult)</span><br><span class="line">      if (confirmResult !&#x3D;&#x3D; &#39;confirm&#39;) &#123;</span><br><span class="line">        return this.$message.info(&#39;已取消删除&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.delete(&#96;roles&#x2F;$&#123;id&#125;&#96;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;删除角色失败！&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.$message.success(&#39;删除角色成功！&#39;)</span><br><span class="line">      this.getRolesList()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="9-3-5-生成权限列表"><a href="#9-3-5-生成权限列表" class="headerlink" title="9.3.5 生成权限列表"></a>9.3.5 生成权限列表</h3><p>使用三重嵌套for循环生成权限下拉列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加展开列 --&gt;</span><br><span class="line">&lt;el-table-column type&#x3D;&quot;expand&quot;&gt;</span><br><span class="line">    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">        &lt;el-row :class&#x3D;&quot;[&#39;bdbottom&#39;,i1&#x3D;&#x3D;&#x3D;0?&#39;bdtop&#39;:&#39;&#39;]&quot; v-for&#x3D;&quot;(item1,i1) in scope.row.children&quot; :key&#x3D;&quot;item1.id&quot;&gt;</span><br><span class="line">            &lt;!-- 渲染一级权限 --&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;5&quot;&gt;</span><br><span class="line">                &lt;el-tag&gt;</span><br><span class="line">                    &#123;&#123;item1.authName&#125;&#125;</span><br><span class="line">                &lt;&#x2F;el-tag&gt;</span><br><span class="line">                &lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;!-- 渲染二，三级权限 --&gt;</span><br><span class="line">            &lt;el-col :span&#x3D;&quot;19&quot;&gt;</span><br><span class="line">                &lt;!-- 通过for循环嵌套渲染二级权限  --&gt;</span><br><span class="line">                &lt;el-row :class&#x3D;&quot;[i2&#x3D;&#x3D;&#x3D;0?&#39;&#39;:&#39;bdtop&#39; ]&quot; v-for&#x3D;&quot;(item2,i2) in item1.children&quot; :key&#x3D;&quot;item2.id&quot;&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;6&quot;&gt;</span><br><span class="line">                        &lt;el-tag type&#x3D;&quot;success&quot;&gt;&#123;&#123;item2.authName&#125;&#125;&lt;&#x2F;el-tag&gt;</span><br><span class="line">                        &lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">                    &lt;&#x2F;el-col&gt;</span><br><span class="line">                    &lt;el-col :span&#x3D;&quot;18&quot;&gt;</span><br><span class="line">                        &lt;el-tag type&#x3D;&quot;warning&quot; v-for&#x3D;&quot;(item3) in item2.children&quot; :key&#x3D;&quot;item3.id&quot;&gt;</span><br><span class="line">                            &#123;&#123;item3.authName&#125;&#125;</span><br><span class="line">                        &lt;&#x2F;el-tag&gt;</span><br><span class="line">                    &lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;&#x2F;el-row&gt;</span><br><span class="line">            &lt;&#x2F;el-col&gt;</span><br><span class="line">        &lt;&#x2F;el-row&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure><h3 id="9-3-6-美化样式"><a href="#9-3-6-美化样式" class="headerlink" title="9.3.6 美化样式"></a>9.3.6 美化样式</h3><p>通过设置global.css中的#app样式min-width:1366px 解决三级权限换行的问题<br>，通过给一级权限el-row添加display:flex,align-items:center的方式解决一级权限垂直居中的问题，二级权限也类似添加，因为需要给多个内容添加，可以将这个样式设置为一个.vcenter{display:flex;align-items:center}</p><h3 id="9-3-7-添加权限删除功能"><a href="#9-3-7-添加权限删除功能" class="headerlink" title="9.3.7 添加权限删除功能"></a>9.3.7 添加权限删除功能</h3><p>给每一个权限的el-tag添加closable属性，是的权限右侧出现“X”图标<br>再给el-tag添加绑定close事件处理函数removeRightById(scope.row,item1.id)<br>removeRightById(scope.row,item2.id)<br>removeRightById(scope.row,item3.id)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">async removeRightById(role,rightId)&#123;</span><br><span class="line">    &#x2F;&#x2F; 弹窗提示用户是否要删除</span><br><span class="line">    const confirmResult &#x3D; await this.$confirm(&#39;请问是否要删除该权限&#39;,&#39;删除提示&#39;,&#123;</span><br><span class="line">        confirmButtonText:&#39;确认删除&#39;,</span><br><span class="line">        cancelButtonText:&#39;取消&#39;,</span><br><span class="line">        type:&#39;warning&#39;</span><br><span class="line">    &#125;).catch(err&#x3D;&gt;err)</span><br><span class="line">    &#x2F;&#x2F; 如果用户点击确认，则confirmResult 为&#39;confirm&#39;</span><br><span class="line">    &#x2F;&#x2F; 如果用户点击取消, 则confirmResult获取的就是catch的错误消息&#39;cancel&#39;</span><br><span class="line">    if(confirmResult !&#x3D; &quot;confirm&quot;)&#123;</span><br><span class="line">        return this.$message.info(&quot;已经取消删除&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用户点击了确定表示真的要删除</span><br><span class="line">    &#x2F;&#x2F; 当发送delete请求之后，返回的数据就是最新的角色权限信息</span><br><span class="line">    const &#123;data:res&#125; &#x3D; await this.$http.delete(&#96;roles&#x2F;$&#123;role.id&#125;&#x2F;rights&#x2F;$&#123;rightId&#125;&#96;)</span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;删除角色权限失败&#39;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 无需再重新加载所有权限</span><br><span class="line">    &#x2F;&#x2F;只需要对现有的角色权限进行更新即可</span><br><span class="line">    role.children &#x3D; res.data</span><br><span class="line">    &#x2F;&#x2F; this.getRoleList();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-8-完成权限分配功能"><a href="#9-3-8-完成权限分配功能" class="headerlink" title="9.3.8 完成权限分配功能"></a>9.3.8 完成权限分配功能</h3><p>先给分配权限按钮添加事件<br>&lt;el-button size=”mini” type=”warning” icon=”el-icon-setting” @click=”showSetRightDialog”&gt;分配权限</el-button><br>在showSetRightDialog函数中请求权限树数据并显示对话框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async showSetRightDialog() &#123;</span><br><span class="line">    &#x2F;&#x2F;当点击分配权限按钮时，展示对应的对话框</span><br><span class="line">    this.setRightDialogVisible &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;获取所有权限的数据</span><br><span class="line">    const &#123;data:res&#125; &#x3D; await this.$http.get(&#39;rights&#x2F;tree&#39;)</span><br><span class="line">    &#x2F;&#x2F;如果返回状态为异常状态则报错并返回</span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;获取权限树失败&#39;)</span><br><span class="line">    &#x2F;&#x2F;如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">    this.rightsList &#x3D; res.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加分配权限对话框，并添加绑定数据setRightDialogVisible</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分配权限对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;分配权限&quot; :visible.sync&#x3D;&quot;setRightDialogVisible&quot; width&#x3D;&quot;50%&quot;&gt;</span><br><span class="line">    &lt;span&gt;这是一段信息&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;setRightDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;setRightDialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><h3 id="9-3-9-完成树形结构弹窗"><a href="#9-3-9-完成树形结构弹窗" class="headerlink" title="9.3.9 完成树形结构弹窗"></a>9.3.9 完成树形结构弹窗</h3><p>在element.js中引入Tree，注册Tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分配权限对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;分配权限&quot; :visible.sync&#x3D;&quot;setRightDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;setRightDialogClose&quot;&gt;</span><br><span class="line">    &lt;!-- 树形组件</span><br><span class="line">    show-checkbox:显示复选框</span><br><span class="line">    node-key:设置选中节点对应的值</span><br><span class="line">    default-expand-all:是否默认展开所有节点</span><br><span class="line">    :default-checked-keys 设置默认选中项的数组</span><br><span class="line">    ref:设置引用 --&gt;</span><br><span class="line">    &lt;el-tree :data&#x3D;&quot;rightsList&quot; :props&#x3D;&quot;treeProps&quot; show-checkbox node-key&#x3D;&quot;id&quot; default-expand-all :default-checked-keys&#x3D;&quot;defKeys&quot; ref&#x3D;&quot;treeRef&quot;&gt;&lt;&#x2F;el-tree&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;setRightDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;allotRights&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 角色列表数据</span><br><span class="line">      roleList: [],</span><br><span class="line">      &#x2F;&#x2F; 控制分配权限对话框的显示</span><br><span class="line">      setRightDialogVisible: false,</span><br><span class="line">      &#x2F;&#x2F; 权限树数据</span><br><span class="line">      rightsList: [],</span><br><span class="line">      &#x2F;&#x2F; 树形控件的属性绑定对象</span><br><span class="line">      treeProps: &#123;</span><br><span class="line">        &#x2F;&#x2F;通过label设置树形节点文本展示authName</span><br><span class="line">        label: &#39;authName&#39;,</span><br><span class="line">        &#x2F;&#x2F;设置通过children属性展示子节点信息</span><br><span class="line">        children: &#39;children&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 设置树形控件中默认选中的内容</span><br><span class="line">      defKeys: [],</span><br><span class="line">      &#x2F;&#x2F; 保存正在操作的角色id</span><br><span class="line">      roleId:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getRoleList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getRoleList() &#123;</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;roles&#39;)</span><br><span class="line">      &#x2F;&#x2F; 如果返回状态为异常状态则报错并返回</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;获取角色列表失败&#39;)</span><br><span class="line">      &#x2F;&#x2F; 如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">      &#x2F;&#x2F; this.roleList &#x3D; res.data</span><br><span class="line">      console.log(res.data)</span><br><span class="line">      this.roleList &#x3D; res.data</span><br><span class="line">    &#125;,</span><br><span class="line">    async removeRightById(role, rightId) &#123;</span><br><span class="line">      &#x2F;&#x2F; 弹窗提示用户是否要删除</span><br><span class="line">      const confirmResult &#x3D; await this.$confirm(</span><br><span class="line">        &#39;请问是否要删除该权限&#39;,</span><br><span class="line">        &#39;删除提示&#39;,</span><br><span class="line">        &#123;</span><br><span class="line">          confirmButtonText: &#39;确认删除&#39;,</span><br><span class="line">          cancelButtonText: &#39;取消&#39;,</span><br><span class="line">          type: &#39;warning&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      ).catch(err &#x3D;&gt; err)</span><br><span class="line">      &#x2F;&#x2F; 如果用户点击确认，则confirmResult 为&#39;confirm&#39;</span><br><span class="line">      &#x2F;&#x2F; 如果用户点击取消, 则confirmResult获取的就是catch的错误消息&#39;cancel&#39;</span><br><span class="line">      if (confirmResult !&#x3D; &#39;confirm&#39;) &#123;</span><br><span class="line">        return this.$message.info(&#39;已经取消删除&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 用户点击了确定表示真的要删除</span><br><span class="line">      &#x2F;&#x2F; 当发送delete请求之后，返回的数据就是最新的角色权限信息</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.delete(</span><br><span class="line">        &#96;roles&#x2F;$&#123;role.id&#125;&#x2F;rights&#x2F;$&#123;rightId&#125;&#96;</span><br><span class="line">      )</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;删除角色权限失败&#39;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 无需再重新加载所有权限</span><br><span class="line">      &#x2F;&#x2F; 只需要对现有的角色权限进行更新即可</span><br><span class="line">      role.children &#x3D; res.data</span><br><span class="line">      &#x2F;&#x2F; this.getRoleList();</span><br><span class="line">    &#125;,</span><br><span class="line">    async showSetRightDialog(role) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将role.id保存起来以供保存权限时使用</span><br><span class="line">      this.roleId &#x3D; role.id;  </span><br><span class="line">      &#x2F;&#x2F; 获取所有权限的数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;rights&#x2F;tree&#39;)</span><br><span class="line">      &#x2F;&#x2F; 如果返回状态为异常状态则报错并返回</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(&#39;获取权限树失败&#39;)</span><br><span class="line">      &#x2F;&#x2F; 如果返回状态正常，将请求的数据保存在data中</span><br><span class="line">      this.rightsList &#x3D; res.data</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 调用getLeafKeys进行递归，将三级权限添加到数组中</span><br><span class="line">      this.getLeafKeys(role, this.defKeys)</span><br><span class="line">      &#x2F;&#x2F; 当点击分配权限按钮时，展示对应的对话框</span><br><span class="line">      this.setRightDialogVisible &#x3D; true</span><br><span class="line">      console.log(this.defKeys)</span><br><span class="line">    &#125;,</span><br><span class="line">    getLeafKeys(node, arr) &#123;</span><br><span class="line">      &#x2F;&#x2F; 该函数会获取到当前角色的所有三级权限id并添加到defKeys中</span><br><span class="line">      &#x2F;&#x2F; 如果当前节点不包含children属性，则表示node为三级权限</span><br><span class="line">      if (!node.children) &#123;</span><br><span class="line">        return arr.push(node.id)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 递归调用</span><br><span class="line">      node.children.forEach(item &#x3D;&gt; this.getLeafKeys(item, arr))</span><br><span class="line">    &#125;,</span><br><span class="line">    setRightDialogClose() &#123;</span><br><span class="line">      &#x2F;&#x2F; 当用户关闭树形权限对话框的时候，清除掉所有选中状态</span><br><span class="line">      this.defKeys &#x3D; []</span><br><span class="line">    &#125;,</span><br><span class="line">    async allotRights() &#123;</span><br><span class="line">      &#x2F;&#x2F; 当用户在树形权限对话框中点击确定，将用户选择的</span><br><span class="line">      &#x2F;&#x2F; 权限发送请求进行更新</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 获取所有选中及半选的内容</span><br><span class="line">      const keys &#x3D; [</span><br><span class="line">        ...this.$refs.treeRef.getCheckedKeys(),</span><br><span class="line">        ...this.$refs.treeRef.getHalfCheckedKeys()</span><br><span class="line">      ]</span><br><span class="line">      &#x2F;&#x2F; 将数组转换为 , 拼接的字符串</span><br><span class="line">      const idStr &#x3D; keys.join(&#39;,&#39;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 发送请求完成更新</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.post(</span><br><span class="line">        &#96;roles&#x2F;$&#123;this.roleId&#125;&#x2F;rights&#96;,</span><br><span class="line">        &#123; rids:idStr &#125;</span><br><span class="line">      )</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;分配权限失败&#39;)</span><br><span class="line"></span><br><span class="line">      this.$message.success(&quot;分配权限成功&quot;)</span><br><span class="line">      this.getRoleList();</span><br><span class="line">      &#x2F;&#x2F; 关闭对话框</span><br><span class="line">      this.setRightDialogVisible &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="9-4-分配角色"><a href="#9-4-分配角色" class="headerlink" title="9.4 分配角色"></a>9.4 分配角色</h2><p>打开Users.vue，完成分配角色的功能</p><h3 id="9-4-1-添加分配角色对话框"><a href="#9-4-1-添加分配角色对话框" class="headerlink" title="9.4.1 添加分配角色对话框"></a>9.4.1 添加分配角色对话框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分配角色对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;分配角色&quot; :visible.sync&#x3D;&quot;setRoleDialogVisible&quot; width&#x3D;&quot;50%&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;当前的用户:&#123;&#123;userInfo.username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;当前的角色:&#123;&#123;userInfo.role_name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;分配新角色:&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;setRoleDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;setRoleDialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><h3 id="9-4-2-给分配角色按钮添加点击事件，点击之后弹出一个对话框进行角色分配"><a href="#9-4-2-给分配角色按钮添加点击事件，点击之后弹出一个对话框进行角色分配" class="headerlink" title="9.4.2 给分配角色按钮添加点击事件，点击之后弹出一个对话框进行角色分配"></a>9.4.2 给分配角色按钮添加点击事件，点击之后弹出一个对话框进行角色分配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分配角色 --&gt;</span><br><span class="line">&lt;el-tooltip class&#x3D;&quot;item&quot; effect&#x3D;&quot;dark&quot; content&#x3D;&quot;分配角色&quot; placement&#x3D;&quot;top&quot; :enterable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;warning&quot; icon&#x3D;&quot;el-icon-setting&quot; size&#x3D;&#39;mini&#39; @click&#x3D;&quot;setRole(scope.row)&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-tooltip&gt;</span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F;控制显示分配角色对话框</span><br><span class="line">    setRoleDialogVisible:false,</span><br><span class="line">    &#x2F;&#x2F;保存正在操作的那个用户信息</span><br><span class="line">    userInfo:&#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F;保存所有的角色信息</span><br><span class="line">    rolesList:[],</span><br><span class="line">    &#x2F;&#x2F;保存用户选中的角色id</span><br><span class="line">    selectedRoleId:&#39;&#39;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    ......</span><br><span class="line">    async setRole( userInfo )&#123;</span><br><span class="line">      &#x2F;&#x2F;保存起来以供后续使用</span><br><span class="line">      this.userInfo &#x3D; userInfo;</span><br><span class="line">      &#x2F;&#x2F;获取所有的角色信息，以备下拉列表使用</span><br><span class="line">      &#x2F;&#x2F;发送请求根据id完成删除操作</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;roles&#39;)</span><br><span class="line">      &#x2F;&#x2F;判断如果删除失败，就做提示</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) return this.$message.error(&#39;获取角色列表失败&#39;)</span><br><span class="line">      </span><br><span class="line">      this.rolesList &#x3D; res.data;</span><br><span class="line">      &#x2F;&#x2F;展示分配角色对话框</span><br><span class="line">      this.setRoleDialogVisible &#x3D; true;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-3-在element-js中引入Select，Option，注册Select，Option"><a href="#9-4-3-在element-js中引入Select，Option，注册Select，Option" class="headerlink" title="9.4.3 在element.js中引入Select，Option，注册Select，Option"></a>9.4.3 在element.js中引入Select，Option，注册Select，Option</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 角色选择下拉框</span><br><span class="line">v-model：设置用户选中角色之后的id绑定数据</span><br><span class="line">--&gt;</span><br><span class="line">&lt;el-select v-model&#x3D;&quot;selectedRoleId&quot; placeholder&#x3D;&quot;请选择角色&quot;&gt;</span><br><span class="line">&lt;!-- :label 显示文本，:value 选中值 --&gt;</span><br><span class="line">&lt;el-option v-for&#x3D;&quot;item in rolesList&quot; :key&#x3D;&quot;item.id&quot; :label&#x3D;&quot;item.roleName&quot; :value&#x3D;&quot;item.id&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-option&gt;</span><br><span class="line">&lt;&#x2F;el-select&gt;</span><br></pre></td></tr></table></figure><h3 id="9-4-4-当用户点击对话框中的确定之后，完成分配角色的操作"><a href="#9-4-4-当用户点击对话框中的确定之后，完成分配角色的操作" class="headerlink" title="9.4.4 当用户点击对话框中的确定之后，完成分配角色的操作"></a>9.4.4 当用户点击对话框中的确定之后，完成分配角色的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分配角色对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;分配角色&quot; :visible.sync&#x3D;&quot;setRoleDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;setRoleDialogClosed&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;当前的用户:&#123;&#123;userInfo.username&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;当前的角色:&#123;&#123;userInfo.role_name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;分配新角色:</span><br><span class="line">        &lt;!-- 角色选择下拉框</span><br><span class="line">        v-model：设置用户选中角色之后的id绑定数据</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;el-select v-model&#x3D;&quot;selectedRoleId&quot; placeholder&#x3D;&quot;请选择角色&quot;&gt;</span><br><span class="line">        &lt;!-- :label 显示文本，:value 选中值 --&gt;</span><br><span class="line">        &lt;el-option v-for&#x3D;&quot;item in rolesList&quot; :key&#x3D;&quot;item.id&quot; :label&#x3D;&quot;item.roleName&quot; :value&#x3D;&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;&#x2F;el-option&gt;</span><br><span class="line">        &lt;&#x2F;el-select&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;setRoleDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveRoleInfo&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">    .......</span><br><span class="line">    async saveRoleInfo()&#123;</span><br><span class="line">      &#x2F;&#x2F;当用户点击确定按钮之后</span><br><span class="line">      &#x2F;&#x2F;判断用户是否选择了需要分配的角色</span><br><span class="line">      if(!this.selectedRoleId)&#123;</span><br><span class="line">        return this.$message.error(&#39;请选择需要分配的角色&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;发送请求完成分配角色的操作</span><br><span class="line">      const &#123;data:res&#125; &#x3D; await this.$http.put(&#96;users&#x2F;$&#123;this.userInfo.id&#125;&#x2F;role&#96;,&#123;rid:this.selectedRoleId&#125;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;判断如果删除失败，就做提示</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200)</span><br><span class="line">        return this.$message.error(&#39;分配角色失败&#39;)</span><br><span class="line"></span><br><span class="line">      this.$message.success(&#39;分配角色成功&#39;)</span><br><span class="line">      this.getUserList();</span><br><span class="line">      &#x2F;&#x2F;关闭对话框</span><br><span class="line">      this.setRoleDialogVisible &#x3D; false</span><br><span class="line">    &#125;,</span><br><span class="line">    setRoleDialogClosed()&#123;</span><br><span class="line">      &#x2F;&#x2F;当关闭对话框的时候，重置下拉框中的内容</span><br><span class="line">      this.selectedRoleId &#x3D; &#39;&#39;</span><br><span class="line">      this.userInfo &#x3D; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-5-将代码推送到码云"><a href="#9-5-将代码推送到码云" class="headerlink" title="9.5 将代码推送到码云"></a>9.5 将代码推送到码云</h2><p>将代码推送到暂存区:git add .</p><p>将代码提交到仓库:git commit -m ‘完成了权限功能开发’</p><p>将rights分支代码推送到码云:git push</p><p>将代码合并到master :git checkout master<br>git merge rights</p><p>将master代码推送到码云:git push</p><h1 id="10-商品分类"><a href="#10-商品分类" class="headerlink" title="10.商品分类"></a>10.商品分类</h1><h2 id="10-1-新建分支goods-cate"><a href="#10-1-新建分支goods-cate" class="headerlink" title="10.1 新建分支goods_cate"></a>10.1 新建分支goods_cate</h2><p>新建分支goods_cate并推送到码云<br>git checkout -b goods_cate<br>git push -u origin goods_cate</p><h2 id="10-2-创建子级路由"><a href="#10-2-创建子级路由" class="headerlink" title="10.2 创建子级路由"></a>10.2 创建子级路由</h2><p>创建categories子级路由组件并设置路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Cate from &#39;.&#x2F;components&#x2F;goods&#x2F;Cate.vue&#39;</span><br><span class="line"></span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">    &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">    &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="10-3-添加组件基本布局"><a href="#10-3-添加组件基本布局" class="headerlink" title="10.3 添加组件基本布局"></a>10.3 添加组件基本布局</h2><p>在Cate.vue组件中添加面包屑导航以及卡片视图中的添加分类按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品分类&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;!-- 添加分类按钮区域 --&gt;</span><br><span class="line">            &lt;el-row&gt;</span><br><span class="line">                &lt;el-col&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot;&gt;添加分类&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;&#x2F;el-row&gt;</span><br><span class="line">            &lt;!-- 分类表格  --&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 分页 --&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="10-4-请求分类数据"><a href="#10-4-请求分类数据" class="headerlink" title="10.4 请求分类数据"></a>10.4 请求分类数据</h2><p>请求分类数据并将数据保存在data中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 商品分类数据列表</span><br><span class="line">      cateList: [],</span><br><span class="line">      &#x2F;&#x2F; 查询分类数据的条件</span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        type: 3,</span><br><span class="line">        pagenum: 1,</span><br><span class="line">        pagesize: 5</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 保存总数据条数</span><br><span class="line">      total: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getCateList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getCateList() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取商品分类数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;categories&#39;, &#123;</span><br><span class="line">        params: queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取商品列表数据失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 将数据列表赋值给cateList</span><br><span class="line">      this.cateList &#x3D; res.data.result</span><br><span class="line">      &#x2F;&#x2F; 保存总数据条数</span><br><span class="line">      this.total &#x3D; res.data.total</span><br><span class="line">      &#x2F;&#x2F; console.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="10-5-使用插件展示数据"><a href="#10-5-使用插件展示数据" class="headerlink" title="10.5 使用插件展示数据"></a>10.5 使用插件展示数据</h2><p>使用第三方插件vue-table-with-tree-grid展示分类数据</p><h3 id="10-5-1-在vue-控制台中点击依赖-gt-安装依赖-gt-运行依赖-gt-输入vue-table-with-tree-gird-gt-点击安装"><a href="#10-5-1-在vue-控制台中点击依赖-gt-安装依赖-gt-运行依赖-gt-输入vue-table-with-tree-gird-gt-点击安装" class="headerlink" title="10.5.1 在vue 控制台中点击依赖-&gt;安装依赖-&gt;运行依赖-&gt;输入vue-table-with-tree-gird-&gt;点击安装"></a>10.5.1 在vue 控制台中点击依赖-&gt;安装依赖-&gt;运行依赖-&gt;输入vue-table-with-tree-gird-&gt;点击安装</h3><h3 id="10-5-2-打开main-js，导入vue-table-with-tree-grid"><a href="#10-5-2-打开main-js，导入vue-table-with-tree-grid" class="headerlink" title="10.5.2 打开main.js，导入vue-table-with-tree-grid"></a>10.5.2 打开main.js，导入vue-table-with-tree-grid</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TreeTable <span class="keyword">from</span> <span class="string">&#x27;vue-table-with-tree-grid&#x27;</span></span><br><span class="line">    .....</span><br><span class="line">    Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 全局注册组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;tree-table&#x27;</span>, TreeTable)</span><br></pre></td></tr></table></figure><h3 id="10-5-3-使用组件展示分类数据"><a href="#10-5-3-使用组件展示分类数据" class="headerlink" title="10.5.3 使用组件展示分类数据"></a>10.5.3 使用组件展示分类数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分类表格</span><br><span class="line">:data(设置数据源) :columns(设置表格中列配置信息) :selection-type(是否有复选框)</span><br><span class="line">:expand-type(是否展开数据) show-index(是否设置索引列) index-text(设置索引列头)</span><br><span class="line">border(是否添加纵向边框) :show-row-hover(是否鼠标悬停高亮) --&gt;</span><br><span class="line">&lt;tree-table :data&#x3D;&quot;cateList&quot; :columns&#x3D;&quot;columns&quot; :selection-type&#x3D;&quot;false&quot;</span><br><span class="line">:expand-type&#x3D;&quot;false&quot; show-index index-text&#x3D;&quot;#&quot; border :show-row-hover&#x3D;&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;tree-table&gt;</span><br><span class="line"></span><br><span class="line">在数据中添加columns:</span><br><span class="line">columns: [</span><br><span class="line">    &#123;label:&#39;分类名称&#39;,prop:&#39;cat_name&#39;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="10-6-自定义数据列"><a href="#10-6-自定义数据列" class="headerlink" title="10.6 自定义数据列"></a>10.6 自定义数据列</h2><p>使用vue-table-with-tree-grid定义模板列并添加自定义列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先在columns中添加一个列</span><br><span class="line">columns: [</span><br><span class="line">    &#123;label:&#39;分类名称&#39;,prop:&#39;cat_name&#39;&#125;,</span><br><span class="line">    &#x2F;&#x2F; type:&#39;template&#39;(将该列设置为模板列)，template:&#39;isok&#39;(设置该列模板的名称为isok)</span><br><span class="line">    &#123;label:&#39;是否有效&#39;,prop:&#39;&#39;,type:&#39;template&#39;,template:&#39;isok&#39;&#125;,</span><br><span class="line">    &#123;label:&#39;排序&#39;,prop:&#39;&#39;,type:&#39;template&#39;,template:&#39;order&#39;&#125;,</span><br><span class="line">    &#123;label:&#39;操作&#39;,prop:&#39;&#39;,type:&#39;template&#39;,template:&#39;opt&#39;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&lt;!-- 是否有效区域， 设置对应的模板列： slot&#x3D;&quot;isok&quot;(与columns中设置的template一致) --&gt;</span><br><span class="line">&lt;template slot&#x3D;&quot;isok&quot; slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-success&quot; v-if&#x3D;&quot;scope.row.cat_deleted &#x3D;&#x3D;&#x3D; false&quot; style&#x3D;&quot;color:lightgreen&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;el-icon-error&quot; v-else style&#x3D;&quot;color:red&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;!-- 排序 --&gt;</span><br><span class="line">&lt;template slot&#x3D;&quot;order&quot; slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">  &lt;el-tag size&#x3D;&quot;mini&quot; v-if&#x3D;&quot;scope.row.cat_level&#x3D;&#x3D;&#x3D;0&quot;&gt;一级&lt;&#x2F;el-tag&gt;</span><br><span class="line">  &lt;el-tag size&#x3D;&quot;mini&quot; type&#x3D;&quot;success&quot; v-else-if&#x3D;&quot;scope.row.cat_level&#x3D;&#x3D;&#x3D;1&quot;&gt;二级&lt;&#x2F;el-tag&gt;</span><br><span class="line">  &lt;el-tag size&#x3D;&quot;mini&quot; type&#x3D;&quot;warning&quot; v-else&gt;三级&lt;&#x2F;el-tag&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 操作 --&gt;</span><br><span class="line">&lt;template slot&#x3D;&quot;opt&quot; slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">  &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;删除&lt;&#x2F;el-button&gt; </span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="10-7-完成分页功能"><a href="#10-7-完成分页功能" class="headerlink" title="10.7 完成分页功能"></a>10.7 完成分页功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分页 --&gt;</span><br><span class="line">&lt;el-pagination @size-change&#x3D;&quot;handleSizeChange&quot; @current-change&#x3D;&quot;handleCurrentChange&quot; :current-page&#x3D;&quot;queryInfo.pagenum&quot; :page-sizes&#x3D;&quot;[3, 5, 10, 15]&quot; :page-size&#x3D;&quot;queryInfo.pagesize&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; :total&#x3D;&quot;total&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-pagination&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加对应的事件函数</span><br><span class="line">methods:&#123;</span><br><span class="line">  .......</span><br><span class="line">  handleSizeChange(newSize)&#123;</span><br><span class="line">    &#x2F;&#x2F; 当pagesize发生改变时触发</span><br><span class="line">    this.queryInfo.pagesize &#x3D; newSize;</span><br><span class="line">    this.getCateList();</span><br><span class="line">  &#125;,</span><br><span class="line">  handleCurrentChange(newPage)&#123;</span><br><span class="line">    &#x2F;&#x2F; 当pagenum发生改变时触发</span><br><span class="line">    this.queryInfo.pagenum &#x3D; newPage;</span><br><span class="line">    this.getCateList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-8-完成添加分类"><a href="#10-8-完成添加分类" class="headerlink" title="10.8 完成添加分类"></a>10.8 完成添加分类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&lt;!-- 添加分类按钮区域 --&gt;</span><br><span class="line">&lt;el-row&gt;</span><br><span class="line">  &lt;el-col&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;showAddCateDialog&quot;&gt;添加分类&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;el-col&gt;</span><br><span class="line">&lt;&#x2F;el-row&gt;</span><br><span class="line">......</span><br><span class="line">&lt;!-- 添加分类对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;添加分类&quot; :visible.sync&#x3D;&quot;addCateDialogVisible&quot; width&#x3D;&quot;50%&quot;  @close&#x3D;&quot;addCateDialogClosed&quot;&gt;</span><br><span class="line">  &lt;!-- 添加分类表单 --&gt;</span><br><span class="line">  &lt;el-form :model&#x3D;&quot;addCateForm&quot; :rules&#x3D;&quot;addCateFormRules&quot; ref&#x3D;&quot;addCateFormRuleForm&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;分类名称&quot; prop&#x3D;&quot;cat_name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model&#x3D;&quot;addCateForm.cat_name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;el-form-item label&#x3D;&quot;父级分类&quot; prop&#x3D;&quot;cat_pid&quot;&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;&#x2F;el-form&gt;</span><br><span class="line">  &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;addCateDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addCate&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用来显示或隐藏添加分类对话框</span><br><span class="line">addCateDialogVisible: false,</span><br><span class="line">&#x2F;&#x2F; 添加分类的表单数据对象</span><br><span class="line">addCateForm:&#123;</span><br><span class="line">  &#x2F;&#x2F; 分类名称</span><br><span class="line">  cat_name:&#39;&#39;,</span><br><span class="line">  &#x2F;&#x2F; 添加分类的父级id，0则表示父级为0.添加一级分类</span><br><span class="line">  cat_pid:0,</span><br><span class="line">  &#x2F;&#x2F; 添加分类的等级，0则表示添加一级分类</span><br><span class="line">  cat_level:0</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 添加分类校验规则</span><br><span class="line">addCateFormRules:&#123;</span><br><span class="line">  &#x2F;&#x2F; 验证规则</span><br><span class="line">  cat_name:[ &#123;required:true , message:&#39;请输入分类名称&#39;,trigger:&#39;blur&#39;&#125; ]</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 保存1,2级父级分类的列表</span><br><span class="line">parentCateList:[]</span><br><span class="line">.......</span><br><span class="line">showAddCateDialog() &#123;</span><br><span class="line">  &#x2F;&#x2F; 调用getParentCateList获取分类列表</span><br><span class="line">  this.getParentCateList()</span><br><span class="line">  &#x2F;&#x2F; 显示添加分类对话框</span><br><span class="line">  this.addCateDialogVisible &#x3D; true</span><br><span class="line">&#125;,</span><br><span class="line">async getParentCateList()&#123;</span><br><span class="line">  &#x2F;&#x2F; 获取父级分类数据列表</span><br><span class="line">  const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;categories&#39;, &#123;</span><br><span class="line">    params: &#123;type:2&#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    return this.$message.error(&#39;获取商品分类列表数据失败&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  this.parentCateList &#x3D; res.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加级联菜单显示父级分类<br>先导入Cascader组件，并注册<br>然后添加使用级联菜单组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form-item label&#x3D;&quot;父级分类&quot; prop&#x3D;&quot;cat_pid&quot;&gt;</span><br><span class="line">  &lt;!-- expandTrigger&#x3D;&#39;hover&#39;(鼠标悬停触发级联) v-model(设置级联菜单绑定数据) :options(指定级联菜单数据源)  :props(用来配置数据显示的规则) </span><br><span class="line">  clearable(提供“X”号完成删除文本功能) change-on-select(是否可以选中任意一级的菜单) --&gt;</span><br><span class="line">  &lt;el-cascader expandTrigger&#x3D;&#39;hover&#39; v-model&#x3D;&quot;selectedKeys&quot; :options&#x3D;&quot;parentCateList&quot; :props&#x3D;&quot;cascaderProps&quot; @change&#x3D;&quot;parentCateChange&quot; clearable change-on-select&gt;&lt;&#x2F;el-cascader&gt;</span><br><span class="line">&lt;&#x2F;el-form-item&gt;</span><br><span class="line"></span><br><span class="line">添加数据</span><br><span class="line">&#x2F;&#x2F; 配置级联菜单中数据如何展示</span><br><span class="line">cascaderProps:&#123;</span><br><span class="line">  value:&#39;cat_id&#39;,</span><br><span class="line">  label:&#39;cat_name&#39;,</span><br><span class="line">  children:&#39;children&#39;,</span><br><span class="line">  expandTrigger:&#39;hover&#39;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;绑定用户选择的分类值</span><br><span class="line">selectedKeys:[]</span><br><span class="line">.....</span><br><span class="line">methods:&#123;</span><br><span class="line">  .....</span><br><span class="line">  parentCateChange()&#123;</span><br><span class="line">    &#x2F;&#x2F; 级联菜单中选择项发生变化时触发</span><br><span class="line">    console.log(this.selectedKeys)</span><br><span class="line">    &#x2F;&#x2F; 如果用户选择了父级分类</span><br><span class="line">    if (this.selectedKeys.length &gt; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 则将数组中的最后一项设置为父级分类</span><br><span class="line">      this.addCateForm.cat_pid &#x3D; this.selectedKeys[this.selectedKeys.length - 1]</span><br><span class="line">      &#x2F;&#x2F; level也要跟着发生变化</span><br><span class="line">      this.addCateForm.cat_level &#x3D; this.selectedKeys.length</span><br><span class="line">      return</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.addCateForm.cat_pid &#x3D; 0</span><br><span class="line">      this.addCateForm.cat_level &#x3D; 0</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  addCateDialogClosed() &#123;</span><br><span class="line">    &#x2F;&#x2F;当关闭添加分类对话框时，重置表单</span><br><span class="line">    this.$refs.addCateFormRef.resetFields()</span><br><span class="line">    this.selectedKeys &#x3D; [];</span><br><span class="line">    this.addCateForm.cat_pid &#x3D; 0</span><br><span class="line">    this.addCateForm.cat_level &#x3D; 0</span><br><span class="line">  &#125;,</span><br><span class="line">  addCate() &#123;</span><br><span class="line">    &#x2F;&#x2F;点击确定，完成添加分类</span><br><span class="line">    console.log(this.addCateForm)</span><br><span class="line">    this.$refs.addCateFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">      if (!valid) return</span><br><span class="line">      &#x2F;&#x2F;发送请求完成添加分类</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.post(</span><br><span class="line">        &#39;categories&#39;,</span><br><span class="line">        this.addCateForm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 201) &#123;</span><br><span class="line">        return this.$message.error(&#39;添加分类失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.$message.success(&#39;添加分类成功&#39;)</span><br><span class="line">      this.getCateList()</span><br><span class="line">      this.addCateDialogVisible &#x3D; false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-9-完成编辑和删除功能"><a href="#10-9-完成编辑和删除功能" class="headerlink" title="10.9 完成编辑和删除功能"></a>10.9 完成编辑和删除功能</h2><p>在编辑和删除按钮上增加功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 操作 --&gt;</span><br><span class="line">      &lt;template slot&#x3D;&quot;opt&quot; slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;showEditCateDialog(scope.row.cat_id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; size&#x3D;&quot;mini&quot; @click&#x3D;&quot;removeCateById(scope.row.cat_id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>完成编辑按钮的对话框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 编辑分类的对话框 --&gt;</span><br><span class="line">   &lt;el-dialog title&#x3D;&quot;编辑分类&quot; :visible.sync&#x3D;&quot;editCateDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;editCateDialogClosed&quot;&gt;</span><br><span class="line">     &lt;!-- 编辑分类的表单 --&gt;</span><br><span class="line">     &lt;el-form :model&#x3D;&quot;editCateForm&quot; :rules&#x3D;&quot;editCateFormRules&quot; ref&#x3D;&quot;editCateFormRef&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">       &lt;el-form-item label&#x3D;&quot;分类名称：&quot; prop&#x3D;&quot;cat_name&quot;&gt;</span><br><span class="line">         &lt;el-input v-model&#x3D;&quot;editCateForm.cat_name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">       &lt;&#x2F;el-form-item&gt;</span><br><span class="line">     &lt;&#x2F;el-form&gt;</span><br><span class="line">     &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">       &lt;el-button @click&#x3D;&quot;editCateDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">       &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;editCate&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">     &lt;&#x2F;span&gt;</span><br><span class="line">   &lt;&#x2F;el-dialog&gt;</span><br></pre></td></tr></table></figure><p>在script完成对应的参数和函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      editCateDialogVisible: false,</span><br><span class="line">      &#x2F;&#x2F; 添加分类的表单数据对象</span><br><span class="line">      editCateForm: &#123;</span><br><span class="line">        &#x2F;&#x2F; 将要修改的分类id</span><br><span class="line">        cat_id: 0,</span><br><span class="line">        &#x2F;&#x2F; 将要修改的分类名称</span><br><span class="line">        cat_name: &#39;&#39;,</span><br><span class="line">        &#x2F;&#x2F; 父级分类的Id</span><br><span class="line">        cat_pid: 0,</span><br><span class="line">        &#x2F;&#x2F; 分类的等级，默认要修改的是1级分类</span><br><span class="line">        cat_level: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 添加分类表单的验证规则对象</span><br><span class="line">      editCateFormRules: &#123;</span><br><span class="line">        cat_name: [&#123; required: true, message: &#39;请输入分类名称&#39;, trigger: &#39;blur&#39; &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据Id删除对应的用户信息</span><br><span class="line">    async removeCateById(catId) &#123;</span><br><span class="line">      &#x2F;&#x2F; 弹框询问用户是否删除数据</span><br><span class="line">      const confirmResult &#x3D; await this.$confirm(&#39;此操作将永久删除该商品, 是否继续?&#39;, &#39;提示&#39;, &#123;</span><br><span class="line">        confirmButtonText: &#39;确定&#39;,</span><br><span class="line">        cancelButtonText: &#39;取消&#39;,</span><br><span class="line">        type: &#39;warning&#39;</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; err)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果用户确认删除，则返回值为字符串 confirm</span><br><span class="line">      &#x2F;&#x2F; 如果用户取消了删除，则返回值为字符串 cancel</span><br><span class="line">      &#x2F;&#x2F; console.log(confirmResult)</span><br><span class="line">      if (confirmResult !&#x3D;&#x3D; &#39;confirm&#39;) &#123;</span><br><span class="line">        return this.$message.info(&#39;已取消删除&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.delete(&#39;categories&#x2F;&#39; + catId)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;删除商品失败！&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.$message.success(&#39;删除商品成功！&#39;)</span><br><span class="line">      this.getCateList()</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 展示编辑商品的对话框</span><br><span class="line">    async showEditCateDialog(id) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先获取父级分类的数据列表</span><br><span class="line">      this.getParentCateList()</span><br><span class="line">      &#x2F;&#x2F; console.log(id)</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;categories&#x2F;&#39; + id)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;查询商品信息失败！&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.editCateForm &#x3D; res.data</span><br><span class="line">      this.editCateDialogVisible &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 点击按钮，编辑分类</span><br><span class="line">    editCate() &#123;</span><br><span class="line">      this.$refs.editCateFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if (!valid) return</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.put(&#39;categories&#x2F;&#39; + this.editCateForm.cat_id, this.editCateForm)</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;编辑分类失败!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$message.success(&#39;编辑分类成功!&#39;)</span><br><span class="line">        this.getCateList()</span><br><span class="line">        this.editCateDialogVisible &#x3D; false</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 监听对话框的关闭事件，重置表单数据</span><br><span class="line">    editCateDialogClosed() &#123;</span><br><span class="line">      this.$refs.editCateFormRef.resetFields()</span><br><span class="line">      this.selectedKeys &#x3D; []</span><br><span class="line">      this.editCateForm.cat_level &#x3D; 0</span><br><span class="line">      this.editCateForm.cat_pid &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="10-10-推送代码"><a href="#10-10-推送代码" class="headerlink" title="10.10 推送代码"></a>10.10 推送代码</h2><p>制作完添加分类之后，将代码提交到仓库，推送到码云,将goods_cate分支合并到master<br>git add .<br>git commit -m ‘完成商品分类’<br>git push<br>git checkout master<br>git merge goods_cate</p><h1 id="11-参数管理"><a href="#11-参数管理" class="headerlink" title="11.参数管理"></a>11.参数管理</h1><h2 id="11-1-新建分支goods-params"><a href="#11-1-新建分支goods-params" class="headerlink" title="11.1 新建分支goods_params"></a>11.1 新建分支goods_params</h2><p>只允许给三级分类内容设置参数，参数分为动态参数和静态参数属性</p><p>新建分支 goods_params并推送到码云<br>git checkout -b  goods_params<br>git push -u origin  goods_params</p><h2 id="11-2-添加子级组件"><a href="#11-2-添加子级组件" class="headerlink" title="11.2 添加子级组件"></a>11.2 添加子级组件</h2><p>添加Params.vue子组件，并在router.js中引入该组件并设置路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Params from &#39;.&#x2F;components&#x2F;goods&#x2F;Params.vue&#39;</span><br><span class="line">......</span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">  &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;params&quot;, component: Params  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="11-3-完成组件基本布局"><a href="#11-3-完成组件基本布局" class="headerlink" title="11.3 完成组件基本布局"></a>11.3 完成组件基本布局</h2><p>完成Params.vue组件的基本布局<br>其中警告提示信息使用了el-alert，在element.js引入该组件并注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;分类参数&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;分类参数&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;!-- 警告区域 :closable&#x3D;&quot;false&quot;(是否展示“X”号) show-icon(显示图标) --&gt;</span><br><span class="line">            &lt;el-alert title&#x3D;&quot;注意：只允许为第三级分类设置相关参数&quot; type&#x3D;&quot;warning&quot; :closable&#x3D;&quot;false&quot; show-icon&gt;</span><br><span class="line">            &lt;&#x2F;el-alert&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 选择商品分类区域 --&gt;</span><br><span class="line">            &lt;el-row class&#x3D;&quot;cat_opt&quot;&gt;</span><br><span class="line">                &lt;el-col&gt;</span><br><span class="line">                    &lt;span&gt;选择商品分类：&lt;&#x2F;span&gt;</span><br><span class="line">                    &lt;!-- 选择商品分类的级联选择框 --&gt;</span><br><span class="line">                &lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;el-col&gt;&lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;&#x2F;el-row&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="11-4-完成级联选择框"><a href="#11-4-完成级联选择框" class="headerlink" title="11.4 完成级联选择框"></a>11.4 完成级联选择框</h2><p>完成商品分类级联选择框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 选择商品分类区域 --&gt;</span><br><span class="line">&lt;el-row class&#x3D;&quot;cat_opt&quot;&gt;</span><br><span class="line">    &lt;el-col&gt;</span><br><span class="line">        &lt;span&gt;选择商品分类：&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;!-- 选择商品分类的级联选择框 --&gt;</span><br><span class="line">        &lt;el-cascader expandTrigger&#x3D;&#39;hover&#39; v-model&#x3D;&quot;selectedCateKeys&quot; :options&#x3D;&quot;cateList&quot; :props&#x3D;&quot;cateProps&quot; @change&#x3D;&quot;handleChange&quot; clearable&gt;&lt;&#x2F;el-cascader&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;el-col&gt;&lt;&#x2F;el-col&gt;</span><br><span class="line">&lt;&#x2F;el-row&gt;</span><br><span class="line">......</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 分类列表</span><br><span class="line">        cateList:[],</span><br><span class="line">        &#x2F;&#x2F; 用户在级联下拉菜单中选中的分类id</span><br><span class="line">        selectedCateKeys:[],</span><br><span class="line">        &#x2F;&#x2F; 配置级联菜单中数据如何展示</span><br><span class="line">        cateProps: &#123;</span><br><span class="line">            value: &#39;cat_id&#39;,</span><br><span class="line">            label: &#39;cat_name&#39;,</span><br><span class="line">            children: &#39;children&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">      this.getCateList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      async getCateList()&#123;</span><br><span class="line">        &#x2F;&#x2F; 获取所有的商品分类列表</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;categories&#39;)</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">            return this.$message.error(&#39;获取分类数据失败&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将数据列表赋值给cateList</span><br><span class="line">        this.cateList &#x3D; res.data</span><br><span class="line">        &#x2F;&#x2F; 保存总数据条数</span><br><span class="line">        &#x2F;&#x2F; this.total &#x3D; res.data.total</span><br><span class="line">        &#x2F;&#x2F; console.log(res.data);</span><br><span class="line">      &#125;,</span><br><span class="line">      handleChange()&#123;</span><br><span class="line">        &#x2F;&#x2F; 当用户在级联菜单中选择内容改变时触发</span><br><span class="line">        console.log(this.selectedCateKeys);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="11-5-展示参数"><a href="#11-5-展示参数" class="headerlink" title="11.5 展示参数"></a>11.5 展示参数</h2><p>展示动态参数数据以及静态属性数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- tab页签区域 --&gt;</span><br><span class="line">&lt;el-tabs v-model&#x3D;&quot;activeName&quot; @tab-click&#x3D;&quot;handleTabClick&quot;&gt;</span><br><span class="line">  &lt;!-- 添加动态参数的面板 将标签页改为many --&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;动态参数&quot; name&#x3D;&quot;many&quot;&gt;</span><br><span class="line">    &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; :disabled&#x3D;&quot;isButtonDisabled&quot;&gt;添加参数&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;!-- 动态参数表格 --&gt;</span><br><span class="line">    &lt;el-table :data&#x3D;&quot;manyTableData&quot; border stripe&gt;</span><br><span class="line">      &lt;!-- 展开行 --&gt;</span><br><span class="line">      &lt;el-table-column type&#x3D;&quot;expand&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;!-- 索引列 --&gt;</span><br><span class="line">      &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;参数名称&quot; prop&#x3D;&quot;attr_name&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">          &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line">  &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">  &lt;!-- 添加静态属性的面板 将标签页改为only --&gt;</span><br><span class="line">  &lt;el-tab-pane label&#x3D;&quot;静态属性&quot; name&#x3D;&quot;only&quot;&gt;</span><br><span class="line">    &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; :disabled&#x3D;&quot;isButtonDisabled&quot;&gt;添加属性&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;!-- 静态属性表格 --&gt;</span><br><span class="line">    &lt;el-table :data&#x3D;&quot;onlyTableData&quot; border stripe&gt;</span><br><span class="line">      &lt;!-- 展开行 --&gt;</span><br><span class="line">      &lt;el-table-column type&#x3D;&quot;expand&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;!-- 索引列 --&gt;</span><br><span class="line">      &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;属性名称&quot; prop&#x3D;&quot;attr_name&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column label&#x3D;&quot;操作&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">          &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑&lt;&#x2F;el-button&gt;</span><br><span class="line">          &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line">  &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#x2F;&#x2F;tab页签激活显示的页签项</span><br><span class="line">      activeName: &#39;many&#39;,</span><br><span class="line">      &#x2F;&#x2F;用来保存动态参数数据</span><br><span class="line">      manyTableData: [],</span><br><span class="line">      &#x2F;&#x2F;用来保存静态属性数据</span><br><span class="line">      onlyTableData: []  </span><br><span class="line">    &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    .......</span><br><span class="line">    async handleChange() &#123;</span><br><span class="line">      &#x2F;&#x2F;当用户在级联菜单中选择内容改变时触发</span><br><span class="line">      console.log(this.selectedCateKeys)</span><br><span class="line">      &#x2F;&#x2F;发送请求，根据用户选择的三级分类和面板获取参数数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(</span><br><span class="line">        &#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#96;,</span><br><span class="line">        &#123; params: &#123; sel: this.activeName &#125; &#125;</span><br><span class="line">      )</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取参数列表数据失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      console.log(res.data)</span><br><span class="line">      if (this.activeName &#x3D;&#x3D;&#x3D; &#39;many&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取的是动态参数</span><br><span class="line">        this.manyTableData &#x3D; res.data</span><br><span class="line">      &#125; else if (this.activeName &#x3D;&#x3D;&#x3D; &#39;only&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取的是静态属性</span><br><span class="line">        this.onlyTableData &#x3D; res.data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleTabClick() &#123;</span><br><span class="line">      console.log(this.activeName)</span><br><span class="line">      this.handleChange()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F;添加计算属性用来获取按钮禁用与否</span><br><span class="line">    isButtonDisabled() &#123;</span><br><span class="line">      return this.selectedCateKeys.length !&#x3D;&#x3D; 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;获取选中的三级分类id</span><br><span class="line">    cateId() &#123;</span><br><span class="line">      if (this.selectedCateKeys.length &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return this.selectedCateKeys[this.selectedCateKeys.length - 1]</span><br><span class="line">      &#125;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="11-6-添加参数"><a href="#11-6-添加参数" class="headerlink" title="11.6 添加参数"></a>11.6 添加参数</h2><p>完成添加参数或属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加参数或属性对话框 --&gt;</span><br><span class="line">&lt;el-dialog :title&#x3D;&quot;&#39;添加&#39;+titleText&quot; :visible.sync&#x3D;&quot;addDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;addDialogClosed&quot;&gt;</span><br><span class="line">  &lt;!-- 添加表单 --&gt;</span><br><span class="line">  &lt;el-form :model&#x3D;&quot;addForm&quot; :rules&#x3D;&quot;addFormRules&quot; ref&#x3D;&quot;addFormRef&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">    &lt;el-form-item :label&#x3D;&quot;titleText&quot; prop&#x3D;&quot;attr_name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model&#x3D;&quot;addForm.attr_name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;&#x2F;el-form&gt;</span><br><span class="line">  &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;addDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addParams&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      .......</span><br><span class="line">      &#x2F;&#x2F; 控制添加参数.属性对话框的显示或隐藏</span><br><span class="line">      addDialogVisible: false,</span><br><span class="line">      &#x2F;&#x2F; 添加参数的表单数据对象</span><br><span class="line">      addForm: &#123;</span><br><span class="line">        attr_name: &#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 添加表单验证规则</span><br><span class="line">      addFormRules: &#123;</span><br><span class="line">        attr_name: [&#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    .......</span><br><span class="line">    addParams() &#123;</span><br><span class="line">      &#x2F;&#x2F; 当用户点击对话框中的确定时，校验表单</span><br><span class="line">      this.$refs.addFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 校验不通过，return</span><br><span class="line">        if (!valid) return</span><br><span class="line">        &#x2F;&#x2F; 校验通过，发送请求完成添加参数或者属性</span><br><span class="line">        const &#123; data: res &#125; &#x3D; this.$http.post(&#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#96;,</span><br><span class="line">          &#123; </span><br><span class="line">            attr_name: this.addForm.attr_name, </span><br><span class="line">            attr_sel: this.activeName,</span><br><span class="line">            attr_vals: &quot;a,b,c&quot; </span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        console.log(res)</span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 201) &#123;</span><br><span class="line">          return this.$message.error(&#39;添加&#39; + this.titleText + &#39;数据失败&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.$message.success(&#39;添加&#39; + this.titleText + &#39;数据成功&#39;)</span><br><span class="line">        this.addDialogVisible &#x3D; false</span><br><span class="line">        this.getCateList()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="11-7-编辑参数"><a href="#11-7-编辑参数" class="headerlink" title="11.7 编辑参数"></a>11.7 编辑参数</h2><p>完成编辑参数或属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 修改参数或属性对话框 --&gt;</span><br><span class="line">&lt;el-dialog :title&#x3D;&quot;&#39;修改&#39;+titleText&quot; :visible.sync&#x3D;&quot;editDialogVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;editDialogClosed&quot;&gt;</span><br><span class="line">  &lt;!-- 添加表单 --&gt;</span><br><span class="line">  &lt;el-form :model&#x3D;&quot;editForm&quot; :rules&#x3D;&quot;editFormRules&quot; ref&#x3D;&quot;editFormRef&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">    &lt;el-form-item :label&#x3D;&quot;titleText&quot; prop&#x3D;&quot;attr_name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model&#x3D;&quot;editForm.attr_name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;&#x2F;el-form-item&gt;</span><br><span class="line">  &lt;&#x2F;el-form&gt;</span><br><span class="line">  &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;editDialogVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;editParams&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      .......</span><br><span class="line">      &#x2F;&#x2F;控制修改参数.属性对话框的显示或隐藏</span><br><span class="line">      editDialogVisible:false,</span><br><span class="line">      &#x2F;&#x2F;修改参数.属性对话框中的表单</span><br><span class="line">      editForm:&#123;</span><br><span class="line">        attr_name:&#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;修改表单的验证规则</span><br><span class="line">      editFormRules:&#123;</span><br><span class="line">        attr_name:[</span><br><span class="line">          &#123; required: true, message: &#39;请输入名称&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    .......</span><br><span class="line">    async showEditDialog(attr_id)&#123;</span><br><span class="line">      &#x2F;&#x2F;发起请求获取需要修改的那个参数数据</span><br><span class="line">      const &#123;data:res&#125; &#x3D; await this.$http.get(&#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#x2F;$&#123;attr_id&#125;&#96;,</span><br><span class="line">      &#123;params:&#123; attr_sel:this.activeName &#125;&#125;)</span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取参数数据失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      this.editForm &#x3D; res.data;</span><br><span class="line">      &#x2F;&#x2F;显示修改参数.属性对话框</span><br><span class="line">      this.editDialogVisible &#x3D; true;</span><br><span class="line">    &#125;,</span><br><span class="line">    editDialogClosed()&#123;</span><br><span class="line">      &#x2F;&#x2F;当关闭修改参数.属性对话框时</span><br><span class="line">      this.$refs.editFormRef.resetFields()</span><br><span class="line">    &#125;,</span><br><span class="line">    editParams()&#123;</span><br><span class="line">      &#x2F;&#x2F;验证表单</span><br><span class="line">      this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if(!valid) return;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送请求完成修改</span><br><span class="line">        const &#123;data:res&#125; &#x3D; await this.$http.put(&#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#x2F;$&#123;this.editForm.attr_id&#125;&#96;,</span><br><span class="line">        &#123;attr_name:this.editForm.attr_name,attr_sel:this.activeName&#125;)</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;获取参数数据失败&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.$message.success(&#39;修改&#39; + this.titleText + &#39;数据成功&#39;)</span><br><span class="line">        this.editDialogVisible &#x3D; false</span><br><span class="line">        this.handleChange();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="11-8-删除参数"><a href="#11-8-删除参数" class="headerlink" title="11.8 删除参数"></a>11.8 删除参数</h2><p>删除参数或属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">给两个删除按钮添加事件</span><br><span class="line">&lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeParams(scope.row.attr_id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeParams(scope.row.attr_id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">添加对应的事件处理函数</span><br><span class="line">async removeParams(attr_id)&#123;</span><br><span class="line">  &#x2F;&#x2F;根据id删除对应的参数或属性</span><br><span class="line">  &#x2F;&#x2F;弹窗提示用户是否要删除</span><br><span class="line">  const confirmResult &#x3D; await this.$confirm(</span><br><span class="line">    &#39;请问是否要删除该&#39;+this.titleText,</span><br><span class="line">    &#39;删除提示&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      confirmButtonText: &#39;确认删除&#39;,</span><br><span class="line">      cancelButtonText: &#39;取消&#39;,</span><br><span class="line">      type: &#39;warning&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ).catch(err &#x3D;&gt; err)</span><br><span class="line">  &#x2F;&#x2F;如果用户点击确认，则confirmResult 为&#39;confirm&#39;</span><br><span class="line">  &#x2F;&#x2F;如果用户点击取消, 则confirmResult获取的就是catch的错误消息&#39;cancel&#39;</span><br><span class="line">  if (confirmResult !&#x3D; &#39;confirm&#39;) &#123;</span><br><span class="line">    return this.$message.info(&#39;已经取消删除&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;没有取消就是要删除，发送请求完成删除</span><br><span class="line">      const &#123;data:res&#125; &#x3D; await  this.$http.delete(&#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#x2F;$&#123;attr_id&#125;&#96;)</span><br><span class="line"></span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    return this.$message.error(&#39;删除参数数据失败&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.$message.success(&#39;删除&#39; + this.titleText + &#39;数据成功&#39;)</span><br><span class="line">    this.handleChange()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-9-展示动态参数可选项"><a href="#11-9-展示动态参数可选项" class="headerlink" title="11.9 展示动态参数可选项"></a>11.9 展示动态参数可选项</h2><p>动态参数可选项展示及操作<br>在获取动态参数的方法中进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将获取到的数据中的attr_vals字符串转换为数组</span><br><span class="line">res.data.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">  item.attr_vals &#x3D; item.attr_vals ? item.attr_vals.split(&#39; &#39;) : []</span><br><span class="line">  &#x2F;&#x2F;添加一个bool值控制文本框的显示或者隐藏</span><br><span class="line">  item.inputVisible &#x3D; false</span><br><span class="line">  &#x2F;&#x2F;添加一个inputValue保存文本框值</span><br><span class="line">  item.inputValue &#x3D; &#39;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后再修改展开行中的代码，生成el-tag和文本框以及添加按钮</span><br><span class="line">&lt;!-- 展开行 --&gt;</span><br><span class="line">&lt;el-table-column type&#x3D;&quot;expand&quot;&gt;</span><br><span class="line">  &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">    &lt;!-- 循环生成的el-tag --&gt;</span><br><span class="line">    &lt;el-tag v-for&#x3D;&quot;(item,i) in scope.row.attr_vals&quot; :key&#x3D;&quot;i&quot; closable&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;el-tag&gt;</span><br><span class="line">    &lt;!-- 输入框 --&gt;</span><br><span class="line">    &lt;el-input class&#x3D;&quot;input-new-tag&quot; v-if&#x3D;&quot;scope.row.inputVisible&quot; v-model&#x3D;&quot;scope.row.inputValue&quot; ref&#x3D;&quot;saveTagInput&quot; size&#x3D;&quot;small&quot; @keyup.enter.native&#x3D;&quot;handleInputConfirm(scope.row)&quot; @blur&#x3D;&quot;handleInputConfirm(scope.row)&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;!-- 添加按钮 --&gt;</span><br><span class="line">    &lt;el-button v-else class&#x3D;&quot;button-new-tag&quot; size&#x3D;&quot;small&quot; @click&#x3D;&quot;showInput(scope.row)&quot;&gt;+ New Tag&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最后对应文本框的事件和按钮的事件添加处理函数</span><br><span class="line">handleInputConfirm(row)&#123;</span><br><span class="line">  &#x2F;&#x2F;当用户在文本框中按下enter键或者焦点离开时都会触发执行</span><br><span class="line">  &#x2F;&#x2F;判断用户在文本框中输入的内容是否合法</span><br><span class="line">  if(row.inputValue.trim().length&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">    row.inputValue &#x3D; &#39;&#39;</span><br><span class="line">    row.inputVisible &#x3D; false</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; row.inputVisible &#x3D; false</span><br><span class="line">  &#x2F;&#x2F;如果用户输入了真实合法的数据，需要保存起来</span><br><span class="line">&#125;,</span><br><span class="line">showInput(row)&#123;</span><br><span class="line">  &#x2F;&#x2F;用户点击添加按钮时触发</span><br><span class="line">  row.inputVisible &#x3D; true</span><br><span class="line">  &#x2F;&#x2F;$nextTick:在页面上元素被重新渲染之后，调用回调函数的代码</span><br><span class="line">  this.$nextTick(_&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;让文本框自动获得焦点</span><br><span class="line">    this.$refs.saveTagInput.$refs.input.focus()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-10-添加-删除可选项"><a href="#11-10-添加-删除可选项" class="headerlink" title="11.10 添加/删除可选项"></a>11.10 添加/删除可选项</h2><p>添加/删除动态参数可选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">给el-tag添加删除事件</span><br><span class="line">&lt;el-tag v-for&#x3D;&quot;(item,i) in scope.row.attr_vals&quot; :key&#x3D;&quot;i&quot; closable @close&#x3D;&quot;handleClose(i,scope.row)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;el-tag&gt;</span><br><span class="line"></span><br><span class="line">在methods中添加新增，删除事件处理函数</span><br><span class="line">handleInputConfirm(row)&#123;</span><br><span class="line">  &#x2F;&#x2F;当用户在文本框中按下enter键或者焦点离开时都会触发执行</span><br><span class="line">  &#x2F;&#x2F;判断用户在文本框中输入的内容是否合法</span><br><span class="line">  if(row.inputValue.trim().length&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">    row.inputValue &#x3D; &#39;&#39;</span><br><span class="line">    row.inputVisible &#x3D; false</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; row.inputVisible &#x3D; false</span><br><span class="line">  &#x2F;&#x2F;如果用户输入了真实合法的数据，需要保存起来</span><br><span class="line">  row.attr_vals.push(row.inputValue.trim())</span><br><span class="line">  row.inputValue &#x3D; &#39;&#39;</span><br><span class="line">  row.inputVisible &#x3D; false</span><br><span class="line"></span><br><span class="line">  this.saveAttrVals(row)</span><br><span class="line">&#125;,</span><br><span class="line">handleClose(index,row)&#123;</span><br><span class="line">  &#x2F;&#x2F;删除对应索引的参数可选项</span><br><span class="line">  row.attr_vals.splice(index,1)</span><br><span class="line">  &#x2F;&#x2F;调用函数，完成保存可选项的操作</span><br><span class="line">  this.saveAttrVals(row)</span><br><span class="line">&#125;,</span><br><span class="line">async saveAttrVals(row)&#123;</span><br><span class="line">  &#x2F;&#x2F;封装函数，完成保存可选项的操作</span><br><span class="line">  &#x2F;&#x2F;发起请求，保存参数细项</span><br><span class="line">  const &#123;data:res&#125; &#x3D; await this.$http.put(&#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#x2F;$&#123;row.attr_id&#125;&#96;,</span><br><span class="line">  &#123;attr_name:row.attr_name,attr_sel:row.attr_sel,attr_vals:row.attr_vals.join(&#39; &#39;)&#125;)</span><br><span class="line"></span><br><span class="line">  if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    return this.$message.error(&#39;修改参数项失败&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.$message.success(&#39;修改参数项成功&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：当用户在级联选择框中选中了非三级分类时，需要清空表格中数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async handleChange() &#123;</span><br><span class="line">      &#x2F;&#x2F;如果用户选择的不是三级分类</span><br><span class="line">      if(this.selectedCateKeys.length !&#x3D;&#x3D; 3)&#123;</span><br><span class="line">        this.selectedCateKeys &#x3D; []</span><br><span class="line">        this.manyTableData &#x3D; []</span><br><span class="line">        this.onlyTableData &#x3D; []</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure><p>补充2：当完成了动态参数可选项的功能之后，我们也需要一样的方式完成静态属性可选项的功能。</p><p>此时我们只需要将动态参数可选项中的展开行复制到静态属性的表格中即可</p><h2 id="11-11-推送代码到码云"><a href="#11-11-推送代码到码云" class="headerlink" title="11.11 推送代码到码云"></a>11.11 推送代码到码云</h2><p>添加到暂存求： git add .<br>提交到本地仓库：  git commit -m ‘完成了分类参数开发’<br>推送到码云：  git push<br>切换到master ： git checkout master<br>合并到master ： git merge goods_params</p><p>推送到码云：  git push</p><h1 id="12-商品列表"><a href="#12-商品列表" class="headerlink" title="12.商品列表"></a>12.商品列表</h1><h2 id="12-1-创建子分支goods-list"><a href="#12-1-创建子分支goods-list" class="headerlink" title="12.1 创建子分支goods_list"></a>12.1 创建子分支goods_list</h2><p>git checkout -b goods_list<br>推送至码云 git push -u origin goods_list</p><h2 id="12-2-制作商品列表基本结构"><a href="#12-2-制作商品列表基本结构" class="headerlink" title="12.2 制作商品列表基本结构"></a>12.2 制作商品列表基本结构</h2><p>添加子级路由组件以及对应的规则,并设置组件的基本机构<br>打开router.js,添加下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import GoodList from &#39;.&#x2F;components&#x2F;goods&#x2F;List.vue&#39;</span><br><span class="line"></span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">  &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;params&quot;, component: Params  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&quot;, component: GoodList  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>打开List.vue组件，添加下列代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;商品列表&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品列表&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;el-row :gutter&#x3D;&quot;20&quot;&gt;</span><br><span class="line">                &lt;el-col :span&#x3D;&quot;8&quot;&gt;</span><br><span class="line">                    &lt;el-input placeholder&#x3D;&quot;请输入内容&quot;&gt;</span><br><span class="line">                        &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-col&gt;</span><br><span class="line">                &lt;el-col :span&#x3D;&quot;4&quot;&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot;&gt;添加商品&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;&#x2F;el-row&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="12-3-数据展示"><a href="#12-3-数据展示" class="headerlink" title="12.3 数据展示"></a>12.3 数据展示</h2><p>添加数据表格展示数据以及分页功能的实现,搜索功能的实现<br>在main.js中添加过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建过滤器将秒数过滤为年月日，时分秒</span><br><span class="line">Vue.filter(&#39;dateFormat&#39;,function(originVal)&#123;</span><br><span class="line">  const dt &#x3D; new Date(originVal)</span><br><span class="line">  const y &#x3D; dt.getFullYear()</span><br><span class="line">  const m &#x3D; (dt.getMonth()+1+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const d &#x3D; (dt.getDate()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">  const hh &#x3D; (dt.getHours()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const mm &#x3D; (dt.getMinutes()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const ss &#x3D; (dt.getSeconds()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">  return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">&lt;el-card&gt;</span><br><span class="line">    &lt;!-- 搜索栏 --&gt;</span><br><span class="line">    &lt;el-row :gutter&#x3D;&quot;20&quot;&gt;</span><br><span class="line">        &lt;el-col :span&#x3D;&quot;8&quot;&gt;</span><br><span class="line">            &lt;el-input placeholder&#x3D;&quot;请输入内容&quot; v-model&#x3D;&quot;queryInfo.query&quot; clearable @clear&#x3D;&quot;getGoodsList&quot;&gt;</span><br><span class="line">                &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot; @click&#x3D;&quot;getGoodsList&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-col&gt;</span><br><span class="line">        &lt;el-col :span&#x3D;&quot;4&quot;&gt;</span><br><span class="line">            &lt;el-button type&#x3D;&quot;primary&quot;&gt;添加商品&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;&#x2F;el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 表格区域 --&gt;</span><br><span class="line">    &lt;el-table :data&#x3D;&quot;goodsList&quot; border stripe&gt;</span><br><span class="line">        &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;商品名称&quot; prop&#x3D;&quot;goods_name&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;商品价格(元)&quot; prop&#x3D;&quot;goods_price&quot; width&#x3D;&quot;95px&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;商品重量&quot; prop&#x3D;&quot;goods_weight&quot; width&#x3D;&quot;95px&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;创建时间&quot; prop&#x3D;&quot;add_time&quot; width&#x3D;&quot;140px&quot;&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                &#123;&#123;scope.row.add_time | dateFormat&#125;&#125;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;125px&quot;&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 分页 --&gt;</span><br><span class="line">    &lt;el-pagination @size-change&#x3D;&quot;handleSizeChange&quot; @current-change&#x3D;&quot;handleCurrentChange&quot; :current-page&#x3D;&quot;queryInfo.pagenum&quot; :page-sizes&#x3D;&quot;[3, 5, 10, 15]&quot; :page-size&#x3D;&quot;queryInfo.pagesize&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; :total&#x3D;&quot;total&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-pagination&gt;</span><br><span class="line">&lt;&#x2F;el-card&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绑定数据以及添加方法</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 查询参数</span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        query: &#39;&#39;,</span><br><span class="line">        pagenum: 1,</span><br><span class="line">        pagesize: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 保存商品列表信息</span><br><span class="line">      goodsList: [],</span><br><span class="line">      &#x2F;&#x2F; 总数据条数</span><br><span class="line">      total: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getGoodsList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getGoodsList() &#123;</span><br><span class="line">      &#x2F;&#x2F; 根据分页获取对应的商品列表</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;goods&#39;, &#123;</span><br><span class="line">        params: this.queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取商品列表失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(res.data)</span><br><span class="line">      this.$message.success(&#39;获取商品列表成功&#39;)</span><br><span class="line">      this.goodsList &#x3D; res.data.goods</span><br><span class="line">      this.total &#x3D; res.data.total</span><br><span class="line">    &#125;,</span><br><span class="line">    handleSizeChange(newSize)&#123;</span><br><span class="line">        &#x2F;&#x2F; 当页号发生改变时，更改pagesize，重新请求</span><br><span class="line">        this.queryInfo.pagesize &#x3D; newSize</span><br><span class="line">        this.getGoodsList();</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCurrentChange(newPage)&#123;</span><br><span class="line">        &#x2F;&#x2F; 当页码发生改变时，更改pagesize，重新请求</span><br><span class="line">        this.queryInfo.pagenum &#x3D; newPage</span><br><span class="line">        this.getGoodsList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="12-4-实现删除商品"><a href="#12-4-实现删除商品" class="headerlink" title="12.4 实现删除商品"></a>12.4 实现删除商品</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 绑定按钮点击事件</span><br><span class="line">&lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeGoods(scope.row.goods_id)&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件函数代码编写</span><br><span class="line">async removeGoods(goods_id) &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据id删除对应的参数或属性</span><br><span class="line">  &#x2F;&#x2F; 弹窗提示用户是否要删除</span><br><span class="line">  const confirmResult &#x3D; await this.$confirm(</span><br><span class="line">    &#39;请问是否要删除该商品&#39;,</span><br><span class="line">    &#39;删除提示&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">      confirmButtonText: &#39;确认删除&#39;,</span><br><span class="line">      cancelButtonText: &#39;取消&#39;,</span><br><span class="line">      type: &#39;warning&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ).catch(err &#x3D;&gt; err)</span><br><span class="line">  &#x2F;&#x2F; 如果用户点击确认，则confirmResult 为&#39;confirm&#39;</span><br><span class="line">  &#x2F;&#x2F; 如果用户点击取消, 则confirmResult获取的就是catch的错误消息&#39;cancel&#39;</span><br><span class="line">  if (confirmResult !&#x3D; &#39;confirm&#39;) &#123;</span><br><span class="line">    return this.$message.info(&#39;已经取消删除&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 没有取消就是要删除，发送请求完成删除</span><br><span class="line">  const &#123;data:res&#125; &#x3D; await this.$http.delete(&#96;goods&#x2F;$&#123;goods_id&#125;&#96;)</span><br><span class="line"></span><br><span class="line">  if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    return this.$message.error(&#39;删除商品失败&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.$message.success(&#39;删除商品成功&#39;)</span><br><span class="line">  this.getGoodsList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-5-实现添加商品"><a href="#12-5-实现添加商品" class="headerlink" title="12.5 实现添加商品"></a>12.5 实现添加商品</h2><h3 id="12-5-1-添加编程式导航"><a href="#12-5-1-添加编程式导航" class="headerlink" title="12.5.1 添加编程式导航"></a>12.5.1 添加编程式导航</h3><p>在List.vue中添加编程式导航，并创建添加商品路由组件及规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在List.vue中添加编程式导航</span><br><span class="line">&lt;el-col :span&#x3D;&quot;4&quot;&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;goAddPage&quot;&gt;添加商品&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-col&gt;</span><br><span class="line"></span><br><span class="line">goAddPage()&#123;</span><br><span class="line">    this.$router.push(&#39;&#x2F;goods&#x2F;add&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在router.js中引入goods/Add.vue,并添加路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import GoodAdd from &#39;.&#x2F;components&#x2F;goods&#x2F;Add.vue&#39;</span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">  &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;params&quot;, component: Params  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&quot;, component: GoodList  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&#x2F;add&quot;, component: GoodAdd  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="12-5-2-布局Add-vue组件"><a href="#12-5-2-布局Add-vue组件" class="headerlink" title="12.5.2 布局Add.vue组件"></a>12.5.2 布局Add.vue组件</h3><p>布局过程中需要使用Steps组件，在element.js中引入并注册该组件，并在global.css中给组件设置全局样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Steps,Step&#125; from &#39;element-ui&#39;</span><br><span class="line">Vue.use(Step)</span><br><span class="line">Vue.use(Steps)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;global.css</span><br><span class="line">.el-steps&#123;</span><br><span class="line">    margin:15px 0;</span><br><span class="line">&#125;</span><br><span class="line">.el-step__title&#123;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在Add.vue中进行页面布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;添加商品&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;商品管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;添加商品&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;!-- 消息提示 --&gt;</span><br><span class="line">            &lt;el-alert title&#x3D;&quot;添加商品信息&quot; type&#x3D;&quot;info&quot; center show-icon :closable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;&#x2F;el-alert&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 步骤条组件 --&gt;</span><br><span class="line">            &lt;!-- align-center(居中效果) --&gt;</span><br><span class="line">            &lt;el-steps :space&#x3D;&quot;200&quot; :active&#x3D;&quot;activeIndex - 0&quot; finish-status&#x3D;&quot;success&quot; align-center&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;基本信息&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;商品参数&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;商品属性&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;商品图片&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;商品内容&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">                &lt;el-step title&#x3D;&quot;完成&quot;&gt;&lt;&#x2F;el-step&gt;</span><br><span class="line">            &lt;&#x2F;el-steps&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- tab栏区域:el-tab-pane必须是el-tabs的子节点</span><br><span class="line">            :tab-position&#x3D;&quot;&#39;left&#39;&quot;(设置tab栏为左右结构tab栏) --&gt;</span><br><span class="line">            &lt;!-- 表单：label-position&#x3D;&quot;top&quot;(设置label在文本框上方) --&gt;</span><br><span class="line">            &lt;el-form :model&#x3D;&quot;addForm&quot; :rules&#x3D;&quot;addFormRules&quot; ref&#x3D;&quot;addFormRef&quot; label-width&#x3D;&quot;100px&quot; label-position&#x3D;&quot;top&quot;&gt;</span><br><span class="line">                &lt;el-tabs v-model&#x3D;&quot;activeIndex&quot; :tab-position&#x3D;&quot;&#39;left&#39;&quot;&gt;</span><br><span class="line">                    &lt;el-tab-pane label&#x3D;&quot;基本信息&quot; name&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                        &lt;el-form-item label&#x3D;&quot;商品名称&quot; prop&#x3D;&quot;goods_name&quot;&gt;</span><br><span class="line">                            &lt;el-input v-model&#x3D;&quot;addForm.goods_name&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item label&#x3D;&quot;商品价格&quot; prop&#x3D;&quot;goods_price&quot;&gt;</span><br><span class="line">                            &lt;el-input v-model&#x3D;&quot;addForm.goods_price&quot; type&#x3D;&quot;number&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item label&#x3D;&quot;商品重量&quot; prop&#x3D;&quot;goods_weight&quot;&gt;</span><br><span class="line">                            &lt;el-input v-model&#x3D;&quot;addForm.goods_weight&quot; type&#x3D;&quot;number&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item label&#x3D;&quot;商品数量&quot; prop&#x3D;&quot;goods_number&quot;&gt;</span><br><span class="line">                            &lt;el-input v-model&#x3D;&quot;addForm.goods_number&quot; type&#x3D;&quot;number&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                        &lt;el-form-item label&#x3D;&quot;商品分类&quot; prop&#x3D;&quot;goods_cat&quot;&gt;</span><br><span class="line">                            &lt;!-- 选择商品分类的级联选择框 --&gt;</span><br><span class="line">                            &lt;el-cascader expandTrigger&#x3D;&#39;hover&#39; v-model&#x3D;&quot;addForm.goods_cat&quot; :options&#x3D;&quot;cateList&quot; :props&#x3D;&quot;cateProps&quot; @change&#x3D;&quot;handleChange&quot; clearable&gt;&lt;&#x2F;el-cascader&gt;</span><br><span class="line">                        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                    &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">                    &lt;el-tab-pane label&#x3D;&quot;商品参数&quot; name&#x3D;&quot;1&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">                    &lt;el-tab-pane label&#x3D;&quot;商品属性&quot; name&#x3D;&quot;2&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">                    &lt;el-tab-pane label&#x3D;&quot;商品图片&quot; name&#x3D;&quot;3&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">                    &lt;el-tab-pane label&#x3D;&quot;商品内容&quot; name&#x3D;&quot;4&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">                &lt;&#x2F;el-tabs&gt;</span><br><span class="line">            &lt;&#x2F;el-form&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F;保存步骤条激活项索引</span><br><span class="line">      activeIndex: &#39;0&#39;,</span><br><span class="line">      &#x2F;&#x2F;添加商品的表单数据对象</span><br><span class="line">      addForm: &#123;</span><br><span class="line">        goods_name: &#39;&#39;,</span><br><span class="line">        goods_price: 0,</span><br><span class="line">        goods_weight: 0,</span><br><span class="line">        goods_number: 0,</span><br><span class="line">        goods_cat:[]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;验证规则</span><br><span class="line">      addFormRules: &#123;</span><br><span class="line">        goods_name: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入商品名称&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ],</span><br><span class="line">        goods_price: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入商品价格&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ],</span><br><span class="line">        goods_weight: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入商品重量&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ],</span><br><span class="line">        goods_number: [</span><br><span class="line">          &#123; required: true, message: &#39;请输入商品数量&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ],</span><br><span class="line">        goods_cat: [</span><br><span class="line">          &#123; required: true, message: &#39;请选择商品分类&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;用来保存分类数据</span><br><span class="line">      cateList: [],</span><br><span class="line">      &#x2F;&#x2F;配置级联菜单中数据如何展示</span><br><span class="line">      cateProps: &#123;</span><br><span class="line">        value: &#39;cat_id&#39;,</span><br><span class="line">        label: &#39;cat_name&#39;,</span><br><span class="line">        children: &#39;children&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getCateList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getCateList() &#123;</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;categories&#39;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取商品分类数据失败&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      this.cateList &#x3D; res.data</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange()&#123;</span><br><span class="line">      &#x2F;&#x2F;如果用户选择的不是三级分类,该次选择无效，因为必须选择三级分类</span><br><span class="line">      if(this.addForm.goods_cat.length !&#x3D;&#x3D; 3)&#123;</span><br><span class="line">        this.addForm.goods_cat &#x3D; []</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="12-5-3-添加tab栏切换验证"><a href="#12-5-3-添加tab栏切换验证" class="headerlink" title="12.5.3 添加tab栏切换验证"></a>12.5.3 添加tab栏切换验证</h3><p>也就是说不输入某些内容，无法切换到别的tab栏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;首先给tabs添加tab切换前事件</span><br><span class="line">&lt;el-tabs v-model&#x3D;&quot;activeIndex&quot; :tab-position&#x3D;&quot;&#39;left&#39;&quot; :before-leave&#x3D;&quot;beforeTabLeave&quot;&gt;</span><br><span class="line">......</span><br><span class="line">&lt;&#x2F;el-tabs&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;再到methods编写事件函数beforeTabLeave</span><br><span class="line">beforeTabLeave(activeName,oldActiveName)&#123;</span><br><span class="line">  &#x2F;&#x2F;在tab栏切换之前触发，两个形参为切换前，后的tab栏name</span><br><span class="line">  if(oldActiveName &#x3D;&#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">      &#x2F;&#x2F;在第一个标签页的时候</span><br><span class="line">      if(this.addForm.goods_cat.length !&#x3D;&#x3D; 3)&#123;</span><br><span class="line">          this.$message.error(&#39;请选择商品的分类&#39;)</span><br><span class="line">          return false</span><br><span class="line">      &#125;else if(this.addForm.goods_name.trim() &#x3D;&#x3D;&#x3D; &#39;&#39;)&#123;</span><br><span class="line">          this.$message.error(&#39;请输入商品名称&#39;)</span><br><span class="line">          return false</span><br><span class="line">      &#125;else if(this.addForm.goods_price.trim() &#x3D;&#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">          this.$message.error(&#39;请输入商品价格&#39;)</span><br><span class="line">          return false</span><br><span class="line">      &#125;else if(this.addForm.goods_weight.trim() &#x3D;&#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">          this.$message.error(&#39;请输入商品重量&#39;)</span><br><span class="line">          return false</span><br><span class="line">      &#125;else if(this.addForm.goods_number.trim() &#x3D;&#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">          this.$message.error(&#39;请输入商品数量&#39;)</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-4-展示信息"><a href="#12-5-4-展示信息" class="headerlink" title="12.5.4 展示信息"></a>12.5.4 展示信息</h3><p>展示商品参数信息,商品属性信息<br>在商品参数信息展示中使用的el-checkbox,el-checkbox-group组件，打开element.js引入组件并注册组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在用户点击tab栏时触发事件</span><br><span class="line">&lt;el-tabs v-model&#x3D;&quot;activeIndex&quot; :tab-position&#x3D;&quot;&#39;left&#39;&quot; :before-leave&#x3D;&quot;beforeTabLeave&quot; @tab-click&#x3D;&quot;tabClicked&quot;&gt;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在参数信息，商品属性面板中添加循环生成结构的代码</span><br><span class="line">&lt;el-tab-pane label&#x3D;&quot;商品参数&quot; name&#x3D;&quot;1&quot;&gt;</span><br><span class="line">  &lt;!-- 渲染表单item项 --&gt;</span><br><span class="line">  &lt;el-form-item :label&#x3D;&quot;item.attr_name&quot; :key&#x3D;&quot;item.attr_id&quot; v-for&#x3D;&quot;item in manyTableData&quot;&gt;</span><br><span class="line">      &lt;!-- 使用数组渲染复选框组 --&gt;</span><br><span class="line">      &lt;el-checkbox-group v-model&#x3D;&quot;item.attr_vals&quot;&gt;</span><br><span class="line">          &lt;el-checkbox border :label&#x3D;&quot;val&quot; v-for&#x3D;&quot;(val,i) in item.attr_vals&quot; :key&#x3D;&quot;i&quot;&gt;&lt;&#x2F;el-checkbox&gt;</span><br><span class="line">      &lt;&#x2F;el-checkbox-group&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&lt;el-tab-pane label&#x3D;&quot;商品属性&quot; name&#x3D;&quot;2&quot;&gt;</span><br><span class="line">  &lt;!-- 循环生成静态属性 --&gt;</span><br><span class="line">  &lt;el-form-item :label&#x3D;&quot;item.attr_name&quot; v-for&#x3D;&quot;item in onlyTableData&quot; :key&#x3D;&quot;item.attr_id&quot;&gt;</span><br><span class="line">      &lt;el-input v-model&#x3D;&quot;item.attr_vals&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">  &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在data数据中添加保存动态参数和静态属性的数组</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#x2F;&#x2F;动态参数列表</span><br><span class="line">      manyTableData: [],</span><br><span class="line">      &#x2F;&#x2F;静态属性列表</span><br><span class="line">      onlyTableData:[]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    .......</span><br><span class="line">    async tabClicked() &#123;</span><br><span class="line">      &#x2F;&#x2F;当用户点击切换tab栏时触发</span><br><span class="line">      if (this.activeIndex &#x3D;&#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送请求获取动态参数</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.get(</span><br><span class="line">          &#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#96;,</span><br><span class="line">          &#123; params: &#123; sel: &#39;many&#39; &#125; &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;获取动态参数列表失败&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将attr_vals字符串转换为数组</span><br><span class="line">        res.data.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">          item.attr_vals &#x3D;</span><br><span class="line">            item.attr_vals.length &#x3D;&#x3D;&#x3D; 0 ? [] : item.attr_vals.split(&#39; &#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.manyTableData &#x3D; res.data</span><br><span class="line">      &#125; else if (this.activeIndex &#x3D;&#x3D;&#x3D; &#39;2&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F;发送请求获取静态属性</span><br><span class="line">        const &#123; data: res &#125; &#x3D; await this.$http.get(</span><br><span class="line">          &#96;categories&#x2F;$&#123;this.cateId&#125;&#x2F;attributes&#96;,</span><br><span class="line">          &#123; params: &#123; sel: &#39;only&#39; &#125; &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          return this.$message.error(&#39;获取静态属性列表失败&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.onlyTableData &#x3D; res.data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;添加 计算属性获取三级分类</span><br><span class="line">  computed: &#123;</span><br><span class="line">    cateId() &#123;</span><br><span class="line">      if (this.addForm.goods_cat.length &#x3D;&#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return this.addForm.goods_cat[2]</span><br><span class="line">      &#125;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-5-完成图片上传"><a href="#12-5-5-完成图片上传" class="headerlink" title="12.5.5 完成图片上传"></a>12.5.5 完成图片上传</h3><p>使用upload组件完成图片上传<br>在element.js中引入upload组件，并注册<br>因为upload组件进行图片上传的时候并不是使用axios发送请求<br>所以，我们需要手动为上传图片的请求添加token，即为upload组件添加headers属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在页面中添加upload组件，并设置对应的事件和属性</span><br><span class="line">&lt;el-tab-pane label&#x3D;&quot;商品图片&quot; name&#x3D;&quot;3&quot;&gt;</span><br><span class="line">  &lt;!-- 商品图片上传</span><br><span class="line">  action:指定图片上传api接口</span><br><span class="line">  :on-preview ： 当点击图片时会触发该事件进行预览操作,处理图片预览</span><br><span class="line">  :on-remove : 当用户点击图片右上角的X号时触发执行</span><br><span class="line">  :on-success：当用户点击上传图片并成功上传时触发</span><br><span class="line">  list-type ：设置预览图片的方式</span><br><span class="line">  :headers ：设置上传图片的请求头 --&gt;</span><br><span class="line">  &lt;el-upload :action&#x3D;&quot;uploadURL&quot; :on-preview&#x3D;&quot;handlePreview&quot; :on-remove&#x3D;&quot;handleRemove&quot; :on-success&#x3D;&quot;handleSuccess&quot; list-type&#x3D;&quot;picture&quot; :headers&#x3D;&quot;headerObj&quot;&gt;</span><br><span class="line">    &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;el-upload&gt;</span><br><span class="line">&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line">&#x2F;&#x2F;在el-card卡片视图下面添加对话框用来预览图片</span><br><span class="line">&lt;!-- 预览图片对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;图片预览&quot; :visible.sync&#x3D;&quot;previewVisible&quot; width&#x3D;&quot;50%&quot;&gt;</span><br><span class="line">  &lt;img :src&#x3D;&quot;previewPath&quot; class&#x3D;&quot;previewImg&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在data中添加数据</span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F;添加商品的表单数据对象</span><br><span class="line">    addForm: &#123;</span><br><span class="line">      goods_name: &#39;&#39;,</span><br><span class="line">      goods_price: 0,</span><br><span class="line">      goods_weight: 0,</span><br><span class="line">      goods_number: 0,</span><br><span class="line">      goods_cat: [],</span><br><span class="line">      &#x2F;&#x2F;上传图片数组</span><br><span class="line">      pics: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F;上传图片的url地址</span><br><span class="line">    uploadURL: &#39;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;api&#x2F;private&#x2F;v1&#x2F;upload&#39;,</span><br><span class="line">    &#x2F;&#x2F;图片上传组件的headers请求头对象</span><br><span class="line">    headerObj: &#123; Authorization: window.sessionStorage.getItem(&#39;token&#39;) &#125;,</span><br><span class="line">    &#x2F;&#x2F;保存预览图片的url地址</span><br><span class="line">    previewPath: &#39;&#39;,</span><br><span class="line">    &#x2F;&#x2F;控制预览图片对话框的显示和隐藏</span><br><span class="line">    previewVisible:false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;在methods中添加事件处理函数</span><br><span class="line">methods:&#123;</span><br><span class="line">  .......</span><br><span class="line">  handlePreview(file) &#123;</span><br><span class="line">    &#x2F;&#x2F;当用户点击图片进行预览时执行，处理图片预览</span><br><span class="line">    &#x2F;&#x2F;形参file就是用户预览的那个文件</span><br><span class="line">    this.previewPath &#x3D; file.response.data.url</span><br><span class="line">    &#x2F;&#x2F;显示预览图片对话框</span><br><span class="line">    this.previewVisible &#x3D; true</span><br><span class="line">  &#125;,</span><br><span class="line">  handleRemove(file) &#123;</span><br><span class="line">    &#x2F;&#x2F;当用户点击X号删除时执行</span><br><span class="line">    &#x2F;&#x2F;形参file就是用户点击删除的文件</span><br><span class="line">    &#x2F;&#x2F;获取用户点击删除的那个图片的临时路径</span><br><span class="line">    const filePath &#x3D; file.response.data.tmp_path</span><br><span class="line">    &#x2F;&#x2F;使用findIndex来查找符合条件的索引</span><br><span class="line">    const index &#x3D; this.addForm.pics.findIndex(item &#x3D;&gt; item.pic &#x3D;&#x3D;&#x3D; filePath)</span><br><span class="line">    &#x2F;&#x2F;移除索引对应的图片</span><br><span class="line">    this.addForm.pics.splice(index, 1)</span><br><span class="line">  &#125;,</span><br><span class="line">  handleSuccess(response) &#123;</span><br><span class="line">    &#x2F;&#x2F;当上传成功时触发执行</span><br><span class="line">    &#x2F;&#x2F;形参response就是上传成功之后服务器返回的结果</span><br><span class="line">    &#x2F;&#x2F;将服务器返回的临时路径保存到addForm表单的pics数组中</span><br><span class="line">    this.addForm.pics.push(&#123; pic: response.data.tmp_path &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-6-使用富文本插件"><a href="#12-5-6-使用富文本插件" class="headerlink" title="12.5.6 使用富文本插件"></a>12.5.6 使用富文本插件</h3><p>想要使用富文本插件vue-quill-editor，就必须先从依赖安装该插件<br>引入并注册vue-quill-editor，打开main.js，编写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;导入vue-quill-editor（富文本编辑器）</span><br><span class="line">import VueQuillEditor from &#39;vue-quill-editor&#39;</span><br><span class="line">&#x2F;&#x2F;导入vue-quill-editor的样式</span><br><span class="line">import &#39;quill&#x2F;dist&#x2F;quill.core.css&#39;</span><br><span class="line">import &#39;quill&#x2F;dist&#x2F;quill.snow.css&#39;</span><br><span class="line">import &#39;quill&#x2F;dist&#x2F;quill.bubble.css&#39;</span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F;全局注册组件</span><br><span class="line">Vue.component(&#39;tree-table&#39;, TreeTable)</span><br><span class="line">&#x2F;&#x2F;全局注册富文本组件</span><br><span class="line">Vue.use(VueQuillEditor)</span><br></pre></td></tr></table></figure><p>使用富文本插件vue-quill-editor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 富文本编辑器组件 --&gt;</span><br><span class="line">&lt;el-tab-pane label&#x3D;&quot;商品内容&quot; name&#x3D;&quot;4&quot;&gt;</span><br><span class="line">  &lt;!-- 富文本编辑器组件 --&gt;</span><br><span class="line">  &lt;quill-editor v-model&#x3D;&quot;addForm.goods_introduce&quot;&gt;&lt;&#x2F;quill-editor&gt;</span><br><span class="line">  &lt;!-- 添加商品按钮 --&gt;</span><br><span class="line">  &lt;el-button type&#x3D;&quot;primary&quot; class&#x3D;&quot;btnAdd&quot;&gt;添加商品&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-tab-pane&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在数据中添加goods_introduce</span><br><span class="line">&#x2F;&#x2F;添加商品的表单数据对象</span><br><span class="line">addForm: &#123;</span><br><span class="line">  goods_name: &#39;&#39;,</span><br><span class="line">  goods_price: 0,</span><br><span class="line">  goods_weight: 0,</span><br><span class="line">  goods_number: 0,</span><br><span class="line">  goods_cat: [],</span><br><span class="line">  &#x2F;&#x2F;上传图片数组</span><br><span class="line">  pics: [],</span><br><span class="line">  &#x2F;&#x2F;商品的详情介绍</span><br><span class="line">  goods_introduce:&#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在global.css样式中添加富文本编辑器的最小高度</span><br><span class="line">.ql-editor&#123;</span><br><span class="line">    min-height: 300px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;给添加商品按钮添加间距</span><br><span class="line">.btnAdd&#123;</span><br><span class="line">  margin-top:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-添加商品"><a href="#12-6-添加商品" class="headerlink" title="12.6 添加商品"></a>12.6 添加商品</h2><p>完成添加商品的操作<br>在添加商品之前，为了避免goods_cat数组转换字符串之后导致级联选择器报错<br>我们需要打开vue控制条，点击依赖，安装lodash，把addForm进行深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;打开Add.vue，导入lodash</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;官方推荐将lodash导入为_</span><br><span class="line">import _ from &#39;lodash&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给添加商品按钮绑定点击事件</span><br><span class="line">&lt;!-- 添加商品按钮 --&gt;</span><br><span class="line">&lt;el-button type&#x3D;&quot;primary&quot; class&#x3D;&quot;btnAdd&quot; @click&#x3D;&quot;add&quot;&gt;添加商品&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F;编写点击事件完成商品添加</span><br><span class="line">add()&#123;</span><br><span class="line">  this.$refs.addFormRef.validate(async valid&#x3D;&gt;&#123;</span><br><span class="line">    if(!valid) return this.$message.error(&quot;请填写必要的表单项!&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将addForm进行深拷贝，避免goods_cat数组转换字符串之后导致级联选择器报错</span><br><span class="line">    const form &#x3D; _.cloneDeep(this.addForm)</span><br><span class="line">    &#x2F;&#x2F;将goods_cat从数组转换为&quot;1,2,3&quot;字符串形式</span><br><span class="line">    form.goods_cat &#x3D; form.goods_cat.join(&quot;,&quot;)</span><br><span class="line">    &#x2F;&#x2F;处理attrs数组，数组中需要包含商品的动态参数和静态属性</span><br><span class="line">    &#x2F;&#x2F;将manyTableData（动态参数）处理添加到attrs</span><br><span class="line">    this.manyTableData.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">      form.attrs.push(&#123; attr_id:item.attr_id, attr_value:item.attr_vals.join(&quot; &quot;) &#125;) </span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;将onlyTableData（静态属性）处理添加到attrs</span><br><span class="line">    this.onlyTableData.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">      form.attrs.push(&#123; attr_id:item.attr_id, attr_value:item.attr_vals &#125;) </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送请求完成商品的添加,商品名称必须是唯一的</span><br><span class="line">    const &#123;data:res&#125; &#x3D; await this.$http.post(&#39;goods&#39;,form)</span><br><span class="line">    if(res.meta.status !&#x3D;&#x3D; 201)&#123;</span><br><span class="line">      return this.$message.error(&#39;添加商品失败&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.$message.success(&#39;添加商品成功&#39;)</span><br><span class="line">    &#x2F;&#x2F;编程式导航跳转到商品列表</span><br><span class="line">    this.$router.push(&#39;&#x2F;goods&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="12-7-推送代码"><a href="#12-7-推送代码" class="headerlink" title="12.7 推送代码"></a>12.7 推送代码</h2><p>推送goods_list分支到码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成商品功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将goods_list分支代码合并到master: git merge goods_list<br>将master推送到码云：  git push</p><h1 id="13-订单列表"><a href="#13-订单列表" class="headerlink" title="13.订单列表"></a>13.订单列表</h1><h2 id="13-1-创建分支"><a href="#13-1-创建分支" class="headerlink" title="13.1 创建分支"></a>13.1 创建分支</h2><p>创建order子分支并推送到码云<br>创建order子分支: git checkout -b order<br>将order分支推送到码云： git push -u origin order</p><h2 id="13-2-创建路由"><a href="#13-2-创建路由" class="headerlink" title="13.2 创建路由"></a>13.2 创建路由</h2><p>创建订单列表路由组件并添加路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在components中新建order文件夹，新建Order.vue组件，组件中添加代码如下</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;订单列表&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;订单管理&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;订单列表&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;!-- 搜索栏 --&gt;</span><br><span class="line">            &lt;el-row :gutter&#x3D;&quot;20&quot;&gt;</span><br><span class="line">                &lt;el-col :span&#x3D;&quot;8&quot;&gt;</span><br><span class="line">                    &lt;el-input placeholder&#x3D;&quot;请输入内容&quot; v-model&#x3D;&quot;queryInfo.query&quot; clearable&gt;</span><br><span class="line">                        &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot; &gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-col&gt;</span><br><span class="line">            &lt;&#x2F;el-row&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询条件</span><br><span class="line">        queryInfo:&#123;</span><br><span class="line">            query:&#39;&#39;,</span><br><span class="line">            pagenum:1,</span><br><span class="line">            pagesize:10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打开router.js导入Order.vue并添加规则</span><br><span class="line">import Order from &#39;.&#x2F;components&#x2F;order&#x2F;Order.vue&#39;</span><br><span class="line"></span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">  &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;params&quot;, component: Params  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&quot;, component: GoodList  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&#x2F;add&quot;, component: GoodAdd  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;orders&quot;, component: Order  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="13-3-实现数据展示及分页"><a href="#13-3-实现数据展示及分页" class="headerlink" title="13.3 实现数据展示及分页"></a>13.3 实现数据展示及分页</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">&lt;el-card&gt;</span><br><span class="line">    &lt;!-- 搜索栏 --&gt;</span><br><span class="line">    &lt;el-row :gutter&#x3D;&quot;20&quot;&gt;</span><br><span class="line">        &lt;el-col :span&#x3D;&quot;8&quot;&gt;</span><br><span class="line">            &lt;el-input placeholder&#x3D;&quot;请输入内容&quot; v-model&#x3D;&quot;queryInfo.query&quot; clearable&gt;</span><br><span class="line">                &lt;el-button slot&#x3D;&quot;append&quot; icon&#x3D;&quot;el-icon-search&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-col&gt;</span><br><span class="line">    &lt;&#x2F;el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 订单表格 --&gt;</span><br><span class="line">    &lt;el-table :data&#x3D;&quot;orderList&quot; border stripe&gt;</span><br><span class="line">        &lt;el-table-column type&#x3D;&quot;index&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;订单编号&quot; prop&#x3D;&quot;order_number&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;订单价格&quot; prop&#x3D;&quot;order_price&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;是否付款&quot; prop&#x3D;&quot;pay_status&quot;&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-tag type&#x3D;&quot;success&quot; v-if&#x3D;&quot;scope.row.pay_status &#x3D;&#x3D;&#x3D; &#39;1&#39;&quot;&gt;已付款&lt;&#x2F;el-tag&gt;</span><br><span class="line">                &lt;el-tag type&#x3D;&quot;danger&quot; v-else&gt;未付款&lt;&#x2F;el-tag&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;是否发货&quot; prop&#x3D;&quot;is_send&quot;&gt;&lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;下单时间&quot; prop&#x3D;&quot;create_time&quot;&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                &#123;&#123;scope.row.create_time | dateFormat&#125;&#125;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">        &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;125px&quot;&gt;</span><br><span class="line">            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;success&quot; icon&#x3D;&quot;el-icon-location&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">        &lt;&#x2F;el-table-column&gt;</span><br><span class="line">    &lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 分页 --&gt;</span><br><span class="line">    &lt;el-pagination @size-change&#x3D;&quot;handleSizeChange&quot; @current-change&#x3D;&quot;handleCurrentChange&quot; :current-page&#x3D;&quot;queryInfo.pagenum&quot; :page-sizes&#x3D;&quot;[3, 5, 10, 15]&quot; :page-size&#x3D;&quot;queryInfo.pagesize&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; :total&#x3D;&quot;total&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-pagination&gt;</span><br><span class="line">&lt;&#x2F;el-card&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 查询条件</span><br><span class="line">      queryInfo: &#123;</span><br><span class="line">        query: &#39;&#39;,</span><br><span class="line">        pagenum: 1,</span><br><span class="line">        pagesize: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 订单列表数据</span><br><span class="line">      orderList: [],</span><br><span class="line">      &#x2F;&#x2F; 数据总条数</span><br><span class="line">      total: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getOrderList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async getOrderList() &#123;</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;orders&#39;, &#123;</span><br><span class="line">        params: this.queryInfo</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取订单列表数据失败!&#39;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.total &#x3D; res.data.total</span><br><span class="line">      this.orderList &#x3D; res.data.goods</span><br><span class="line">    &#125;,</span><br><span class="line">    handleSizeChange(newSize)&#123;</span><br><span class="line">        this.queryInfo.pagesize &#x3D; newSize</span><br><span class="line">        this.getOrderList()</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCurrentChange(newPage)&#123;</span><br><span class="line">        this.queryInfo.pagenum &#x3D; newPage</span><br><span class="line">        this.getOrderList()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="13-4-制作省市区县联动"><a href="#13-4-制作省市区县联动" class="headerlink" title="13.4 制作省市区县联动"></a>13.4 制作省市区县联动</h2><p>打开今天的资料，找到素材文件夹，复制citydata.js文件到components/order文件夹中<br>然后导入citydata.js文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import cityData from &quot;.&#x2F;citydata.js&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给修改地址按钮添加点击事件</span><br><span class="line">&lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-edit&quot; @click&#x3D;&quot;showEditAddress&quot;&gt;&lt;&#x2F;el-button&gt;</span><br><span class="line">&#x2F;&#x2F; 添加修改地址对话框,在卡片视图下方添加</span><br><span class="line">&lt;!-- 修改地址对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;修改收货地址&quot; :visible.sync&#x3D;&quot;addressVisible&quot; width&#x3D;&quot;50%&quot; @close&#x3D;&quot;addressDialogClosed&quot;&gt;</span><br><span class="line">    &lt;!-- 添加表单 --&gt;</span><br><span class="line">    &lt;el-form :model&#x3D;&quot;addressForm&quot; :rules&#x3D;&quot;addressFormRules&quot; ref&#x3D;&quot;addressFormRef&quot; label-width&#x3D;&quot;100px&quot;&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;省市区县&quot; prop&#x3D;&quot;address1&quot;&gt;</span><br><span class="line">            &lt;el-cascader :options&#x3D;&quot;cityData&quot; v-model&#x3D;&quot;addressForm.address1&quot;&gt;&lt;&#x2F;el-cascader&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;详细地址&quot; prop&#x3D;&quot;address2&quot;&gt;</span><br><span class="line">            &lt;el-input v-model&#x3D;&quot;addressForm.address2&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line">    &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;addressVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addressVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; js部分的代码</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cityData from &quot;.&#x2F;citydata.js&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#x2F;&#x2F; 控制修改地址对话框的显示和隐藏</span><br><span class="line">      addressVisible:false,</span><br><span class="line">      &#x2F;&#x2F; 修改收货地址的表单</span><br><span class="line">      addressForm:&#123;</span><br><span class="line">          address1:[],</span><br><span class="line">          address2:&#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      addressFormRules:&#123;</span><br><span class="line">          address1:[&#123; required: true, message: &#39;请选择省市区县&#39;, trigger: &#39;blur&#39; &#125;],</span><br><span class="line">          address2:[&#123; required: true, message: &#39;请输入详细地址&#39;, trigger: &#39;blur&#39; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 将导入的cityData数据保存起来</span><br><span class="line">      cityData:cityData</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    ......</span><br><span class="line">    showEditAddress() &#123;</span><br><span class="line">      &#x2F;&#x2F; 当用户点击修改收货地址按钮时触发</span><br><span class="line">      this.addressVisible &#x3D; true;</span><br><span class="line">    &#125;,</span><br><span class="line">    addressDialogClosed()&#123;</span><br><span class="line">        this.$refs.addressFormRef.resetFields()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.el-cascader&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="13-5-制作物流进度对话框"><a href="#13-5-制作物流进度对话框" class="headerlink" title="13.5 制作物流进度对话框"></a>13.5 制作物流进度对话框</h2><p>因为我们使用的是element-ui中提供的Timeline组件，所以需要导入并注册组件<br>打开element.js,编写代码会进行导入和注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Timeline,TimelineItem</span><br><span class="line">&#125; from &#39;element-ui&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Timeline)</span><br><span class="line">Vue.use(TimelineItem)</span><br></pre></td></tr></table></figure><p>打开Order.vue文件，添加代码实现物流进度对话框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 物流信息进度对话框 --&gt;</span><br><span class="line">&lt;el-dialog title&#x3D;&quot;物流进度&quot; :visible.sync&#x3D;&quot;progressVisible&quot; width&#x3D;&quot;50%&quot;&gt;</span><br><span class="line">    &lt;!-- 时间线组件  --&gt;</span><br><span class="line">    &lt;el-timeline&gt;</span><br><span class="line">        &lt;el-timeline-item v-for&#x3D;&quot;(activity, index) in progressInfo&quot; </span><br><span class="line">        :key&#x3D;&quot;index&quot; :timestamp&#x3D;&quot;activity.time&quot;&gt;</span><br><span class="line">            &#123;&#123;activity.context&#125;&#125;</span><br><span class="line">        &lt;&#x2F;el-timeline-item&gt;</span><br><span class="line">    &lt;&#x2F;el-timeline&gt;</span><br><span class="line">&lt;&#x2F;el-dialog&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cityData from &#39;.&#x2F;citydata.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#x2F;&#x2F;控制物流进度对话框的显示和隐藏</span><br><span class="line">      progressVisible: false,</span><br><span class="line">      &#x2F;&#x2F;保存物流信息</span><br><span class="line">      progressInfo: []</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,methods: &#123;</span><br><span class="line">    ......</span><br><span class="line">    async showProgress() &#123;</span><br><span class="line">      &#x2F;&#x2F;发送请求获取物流数据</span><br><span class="line">      const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;&#x2F;kuaidi&#x2F;804909574412544580&#39;)</span><br><span class="line"></span><br><span class="line">      if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        return this.$message.error(&#39;获取物流进度失败!&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">      this.progressInfo &#x3D; res.data</span><br><span class="line">      &#x2F;&#x2F;显示对话框</span><br><span class="line">      this.progressVisible &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="13-6-推送代码"><a href="#13-6-推送代码" class="headerlink" title="13.6 推送代码"></a>13.6 推送代码</h2><p>将order分支代码推送至码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成订单列表功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将goods_list分支代码合并到master: git merge order<br>将master推送到码云：  git push</p><h1 id="14-数据统计"><a href="#14-数据统计" class="headerlink" title="14.数据统计"></a>14.数据统计</h1><h2 id="14-1-创建分支"><a href="#14-1-创建分支" class="headerlink" title="14.1 创建分支"></a>14.1 创建分支</h2><p>创建report子分支并推送到码云<br>创建report子分支: git checkout -b report<br>将report分支推送到码云： git push -u origin report</p><h2 id="14-2-创建路由"><a href="#14-2-创建路由" class="headerlink" title="14.2 创建路由"></a>14.2 创建路由</h2><p>创建数据统计路由组件并添加路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在components中新建report文件夹，新建Report.vue组件，组件中添加代码如下</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;数据报表&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;数据统计&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;数据报表&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;&lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,created()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,methods:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>打开router.js，导入Report.vue并设置路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Report from &#39;.&#x2F;components&#x2F;report&#x2F;Report.vue&#39;</span><br><span class="line">path: &#39;&#x2F;home&#39;, component: Home, redirect: &#39;&#x2F;welcome&#39;, children: [</span><br><span class="line">  &#123; path: &quot;&#x2F;welcome&quot;, component: Welcome &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;users&quot;, component: Users &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;rights&quot;, component: Rights &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;roles&quot;, component: Roles  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;categories&quot;, component: Cate  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;params&quot;, component: Params  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&quot;, component: GoodList  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;goods&#x2F;add&quot;, component: GoodAdd  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;orders&quot;, component: Order  &#125;,</span><br><span class="line">  &#123; path: &quot;&#x2F;reports&quot;, component: Report  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="14-3-导入ECharts并使用"><a href="#14-3-导入ECharts并使用" class="headerlink" title="14.3 导入ECharts并使用"></a>14.3 导入ECharts并使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;数据报表&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;!-- 面包屑导航 --&gt;</span><br><span class="line">        &lt;el-breadcrumb separator&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">            &lt;el-breadcrumb-item :to&#x3D;&quot;&#123; path: &#39;&#x2F;home&#39; &#125;&quot;&gt;首页&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;数据统计&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">            &lt;el-breadcrumb-item&gt;数据报表&lt;&#x2F;el-breadcrumb-item&gt;</span><br><span class="line">        &lt;&#x2F;el-breadcrumb&gt;</span><br><span class="line">        &lt;!-- 卡片视图区域 --&gt;</span><br><span class="line">        &lt;el-card&gt;</span><br><span class="line">            &lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width:750px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;导入echarts</span><br><span class="line">import echarts from &#39;echarts&#39;</span><br><span class="line">&#x2F;&#x2F;导入lodash</span><br><span class="line">import _ from &#39;lodash&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F;需要跟请求的折线图数据合并的options</span><br><span class="line">      options: &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: &#39;用户来源&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: &#39;axis&#39;,</span><br><span class="line">          axisPointer: &#123;</span><br><span class="line">            type: &#39;cross&#39;,</span><br><span class="line">            label: &#123;</span><br><span class="line">              backgroundColor: &#39;#E9EEF3&#39;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">          left: &#39;3%&#39;,</span><br><span class="line">          right: &#39;4%&#39;,</span><br><span class="line">          bottom: &#39;3%&#39;,</span><br><span class="line">          containLabel: true</span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            boundaryGap: false</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        yAxis: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: &#39;value&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  async mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在页面dom元素加载完毕之后执行的钩子函数mounted</span><br><span class="line">    &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例</span><br><span class="line">    var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;))</span><br><span class="line">    &#x2F;&#x2F;准备数据和配置项</span><br><span class="line">    &#x2F;&#x2F;发送请求获取折线图数据</span><br><span class="line">    const &#123; data: res &#125; &#x3D; await this.$http.get(&#39;reports&#x2F;type&#x2F;1&#39;)</span><br><span class="line"></span><br><span class="line">    if (res.meta.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">      return this.$message.error(&#39;获取折线图数据失败&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;合并res.data和this.options</span><br><span class="line">    const result &#x3D; _.merge(res.data,this.options)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用获取的数据展示图表</span><br><span class="line">    myChart.setOption(result)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="14-4-推送代码"><a href="#14-4-推送代码" class="headerlink" title="14.4 推送代码"></a>14.4 推送代码</h2><p>推送report分支到码云<br>将代码添加到暂存区：  git add .<br>将代码提交到本地仓库： git commit -m “完成数据报表功能开发”<br>将代码推送到码云：  git push<br>切换到master主分支： git checkout master<br>将report分支代码合并到master: git merge report<br>将master推送到码云：  git push</p><h1 id="15-项目优化"><a href="#15-项目优化" class="headerlink" title="15.项目优化"></a>15.项目优化</h1><h2 id="15-1-添加进度条"><a href="#15-1-添加进度条" class="headerlink" title="15.1 添加进度条"></a>15.1 添加进度条</h2><p>给项目添加进度条效果，先打开项目控制台，打开依赖，安装nprogress<br>打开main.js，编写如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入进度条插件</span><br><span class="line">import NProgress from &#39;nprogress&#39;</span><br><span class="line">&#x2F;&#x2F; 导入进度条样式</span><br><span class="line">import &#39;nprogress&#x2F;nprogress.css&#39;</span><br><span class="line">.....</span><br><span class="line">&#x2F;&#x2F; 请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span><br><span class="line">axios.interceptors.request.use(config &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 当进入request拦截器，表示发送了请求，我们就开启进度条</span><br><span class="line">  NProgress.start()</span><br><span class="line">  &#x2F;&#x2F; 为请求头对象，添加token验证的Authorization字段</span><br><span class="line">  config.headers.Authorization &#x3D; window.sessionStorage.getItem(&quot;token&quot;)</span><br><span class="line">  &#x2F;&#x2F; 必须返回config</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 在response拦截器中，隐藏进度条</span><br><span class="line">axios.interceptors.response.use(config &#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; 当进入response拦截器，表示请求已经结束，我们就结束进度条</span><br><span class="line">  NProgress.done()</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="15-2-根据报错修改代码"><a href="#15-2-根据报错修改代码" class="headerlink" title="15.2 根据报错修改代码"></a>15.2 根据报错修改代码</h2><p>根据ESLint的警告提示更改对应的代码<br>在.prettierrc文件中更改设置”printWidth”:200,  将每行代码的文字数量更改为200</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;semi&quot;:false,</span><br><span class="line">    &quot;singleQuote&quot;:true,</span><br><span class="line">    &quot;printWidth&quot;:200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-3-执行build"><a href="#15-3-执行build" class="headerlink" title="15.3 执行build"></a>15.3 执行build</h2><p>安装一个插件（babel-plugin-transform-remove-console）在项目build阶段移除所有的console信息<br>打开项目控制台，点击依赖-&gt;开发依赖，输入babel-plugin-transform-remove-console，安装<br>打开babel.config.js，编辑代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 项目发布阶段需要用到的babel插件</span><br><span class="line">const productPlugins &#x3D; []</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是开发还是发布阶段</span><br><span class="line">if(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;)&#123;</span><br><span class="line">  &#x2F;&#x2F; 发布阶段</span><br><span class="line">  productPlugins.push(&quot;transform-remove-console&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@vue&#x2F;app&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...productPlugins</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-生成打包报告"><a href="#15-4-生成打包报告" class="headerlink" title="15.4 生成打包报告"></a>15.4 生成打包报告</h2><p>A.命令行形式生成打包报告<br>vue-cli-service build –report<br>B.在vue控制台生成打包报告<br>点击“任务”=&gt;“build”=&gt;“运行”<br>运行完毕之后点击右侧“分析”，“控制台”面板查看报告</p><h2 id="15-5-修改webpack的默认配置"><a href="#15-5-修改webpack的默认配置" class="headerlink" title="15.5 修改webpack的默认配置"></a>15.5 修改webpack的默认配置</h2><p>默认情况下，vue-cli 3.0生成的项目，隐藏了webpack配置项，如果我们需要配置webpack<br>需要通过vue.config.js来配置。<br>在项目根目录中创建vue.config.js文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack:config&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 发布模式</span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            &#x2F;&#x2F; entry找到默认的打包入口，调用clear则是删除默认的打包入口</span><br><span class="line">            &#x2F;&#x2F; add添加新的打包入口</span><br><span class="line">            config.entry(&#39;app&#39;).clear().add(&#39;.&#x2F;src&#x2F;main-prod.js&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 开发模式</span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            config.entry(&#39;app&#39;).clear().add(&#39;.&#x2F;src&#x2F;main-dev.js&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：<br>chainWebpack可以通过链式编程的形式，修改webpack配置<br>configureWebpack可以通过操作对象的形式，修改webpack配置</p><h2 id="15-6-加载外部CDN"><a href="#15-6-加载外部CDN" class="headerlink" title="15.6 加载外部CDN"></a>15.6 加载外部CDN</h2><p>默认情况下，依赖项的所有第三方包都会被打包到js/chunk-vendors.<strong>**</strong>.js文件中，导致该js文件过大<br>那么我们可以通过externals排除这些包，使它们不被打包到js/chunk-vendors.<strong>**</strong>.js文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack:config&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 发布模式</span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            &#x2F;&#x2F; entry找到默认的打包入口，调用clear则是删除默认的打包入口</span><br><span class="line">            &#x2F;&#x2F; add添加新的打包入口</span><br><span class="line">            config.entry(&#39;app&#39;).clear().add(&#39;.&#x2F;src&#x2F;main-prod.js&#39;)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 使用externals设置排除项</span><br><span class="line">            config.set(&#39;externals&#39;,&#123;</span><br><span class="line">                vue:&#39;Vue&#39;,</span><br><span class="line">                &#39;vue-router&#39;:&#39;VueRouter&#39;,</span><br><span class="line">                axios:&#39;axios&#39;,</span><br><span class="line">                lodash:&#39;_&#39;,</span><br><span class="line">                echarts:&#39;echarts&#39;,</span><br><span class="line">                nprogress:&#39;NProgress&#39;,</span><br><span class="line">                &#39;vue-quill-editor&#39;:&#39;VueQuillEditor&#39;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 开发模式</span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            config.entry(&#39;app&#39;).clear().add(&#39;.&#x2F;src&#x2F;main-dev.js&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好排除之后，为了使我们可以使用vue，axios等内容，我们需要加载外部CDN的形式解决引入依赖项。<br>打开开发入口文件main-prod.js,删除掉默认的引入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">&#x2F;&#x2F; 导入字体图标</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;fonts&#x2F;iconfont.css&#39;</span><br><span class="line">&#x2F;&#x2F; 导入全局样式</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;css&#x2F;global.css&#39;</span><br><span class="line">&#x2F;&#x2F; 导入第三方组件vue-table-with-tree-grid</span><br><span class="line">import TreeTable from &#39;vue-table-with-tree-grid&#39;</span><br><span class="line">&#x2F;&#x2F; 导入进度条插件</span><br><span class="line">import NProgress from &#39;nprogress&#39;</span><br><span class="line">&#x2F;&#x2F; 导入进度条样式</span><br><span class="line">&#x2F;&#x2F; import &#39;nprogress&#x2F;nprogress.css&#39;</span><br><span class="line">&#x2F;&#x2F; 导入axios</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">&#x2F;&#x2F; 导入vue-quill-editor（富文本编辑器）</span><br><span class="line">import VueQuillEditor from &#39;vue-quill-editor&#39;</span><br><span class="line">&#x2F;&#x2F; 导入vue-quill-editor的样式</span><br><span class="line">&#x2F;&#x2F; import &#39;quill&#x2F;dist&#x2F;quill.core.css&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;quill&#x2F;dist&#x2F;quill.snow.css&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;quill&#x2F;dist&#x2F;quill.bubble.css&#39;</span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;api&#x2F;private&#x2F;v1&#x2F;&#39;</span><br><span class="line">&#x2F;&#x2F;请求在到达服务器之前，先会调用use中的这个回调函数来添加请求头信息</span><br><span class="line">axios.interceptors.request.use(config &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;当进入request拦截器，表示发送了请求，我们就开启进度条</span><br><span class="line">  NProgress.start()</span><br><span class="line">  &#x2F;&#x2F;为请求头对象，添加token验证的Authorization字段</span><br><span class="line">  config.headers.Authorization &#x3D; window.sessionStorage.getItem(&quot;token&quot;)</span><br><span class="line">  &#x2F;&#x2F;必须返回config</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;在response拦截器中，隐藏进度条</span><br><span class="line">axios.interceptors.response.use(config &#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;当进入response拦截器，表示请求已经结束，我们就结束进度条</span><br><span class="line">  NProgress.done()</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br><span class="line">Vue.prototype.$http &#x3D; axios</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局注册组件</span><br><span class="line">Vue.component(&#39;tree-table&#39;, TreeTable)</span><br><span class="line">&#x2F;&#x2F; 全局注册富文本组件</span><br><span class="line">Vue.use(VueQuillEditor)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建过滤器将秒数过滤为年月日，时分秒</span><br><span class="line">Vue.filter(&#39;dateFormat&#39;,function(originVal)&#123;</span><br><span class="line">  const dt &#x3D; new Date(originVal)</span><br><span class="line">  const y &#x3D; dt.getFullYear()</span><br><span class="line">  const m &#x3D; (dt.getMonth()+1+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const d &#x3D; (dt.getDate()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">  const hh &#x3D; (dt.getHours()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const mm &#x3D; (dt.getMinutes()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line">  const ss &#x3D; (dt.getSeconds()+&#39;&#39;).padStart(2,&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">  return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><p>然后打开public/index.html添加外部cdn引入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&lt;%&#x3D; BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;电商后台管理系统&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- nprogress 的样式表文件 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;nprogress&#x2F;0.2.0&#x2F;nprogress.min.css&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 富文本编辑器 的样式表文件 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;quill&#x2F;1.3.4&#x2F;quill.core.min.css&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;quill&#x2F;1.3.4&#x2F;quill.snow.min.css&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;quill&#x2F;1.3.4&#x2F;quill.bubble.min.css&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- element-ui 的样式表文件 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;element-ui&#x2F;2.8.2&#x2F;theme-chalk&#x2F;index.css&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;vue&#x2F;2.5.22&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;vue-router&#x2F;3.0.1&#x2F;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;axios&#x2F;0.18.0&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;lodash.js&#x2F;4.17.11&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;echarts&#x2F;4.1.0&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;nprogress&#x2F;0.2.0&#x2F;nprogress.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;!-- 富文本编辑器的 js 文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;quill&#x2F;1.3.4&#x2F;quill.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue-quill-editor@3.0.4&#x2F;dist&#x2F;vue-quill-editor.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- element-ui 的 js 文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;element-ui&#x2F;2.8.2&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;</span><br><span class="line">      &lt;strong&gt;We&#39;re sorry but vue_shop doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;&#x2F;strong&gt;</span><br><span class="line">    &lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="15-7-定制首页内容"><a href="#15-7-定制首页内容" class="headerlink" title="15.7 定制首页内容"></a>15.7 定制首页内容</h2><p>开发环境的首页和发布环境的首页展示内容的形式有所不同<br>如开发环境中使用的是import加载第三方包，而发布环境则是使用CDN，那么首页也需根据环境不同来进行不同的实现<br>我们可以通过插件的方式来定制首页内容，打开vue.config.js，编写代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    chainWebpack:config&#x3D;&gt;&#123;</span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 使用插件</span><br><span class="line">            config.plugin(&#39;html&#39;).tap(args&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F; 添加参数isProd</span><br><span class="line">                args[0].isProd &#x3D; true</span><br><span class="line">                return args</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        config.when(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;,config&#x3D;&gt;&#123;</span><br><span class="line">            config.entry(&#39;app&#39;).clear().add(&#39;.&#x2F;src&#x2F;main-dev.js&#39;)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 使用插件</span><br><span class="line">            config.plugin(&#39;html&#39;).tap(args&#x3D;&gt;&#123;</span><br><span class="line">                &#x2F;&#x2F; 添加参数isProd</span><br><span class="line">                args[0].isProd &#x3D; false</span><br><span class="line">                return args</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在public/index.html中使用插件判断是否为发布环境并定制首页内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&lt;%&#x3D; BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%&#x3D; htmlWebpackPlugin.options.isProd ? &#39;&#39; : &#39;dev - &#39; %&gt;电商后台管理系统&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% if(htmlWebpackPlugin.options.isProd)&#123; %&gt;</span><br><span class="line">    &lt;!-- nprogress 的样式表文件 --&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;nprogress&#x2F;0.2.0&#x2F;nprogress.min.css&quot; &#x2F;&gt;</span><br><span class="line">    ........</span><br><span class="line">    &lt;!-- element-ui 的 js 文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;element-ui&#x2F;2.8.2&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  .......</span><br></pre></td></tr></table></figure><h2 id="15-8-路由懒加载"><a href="#15-8-路由懒加载" class="headerlink" title="15.8 路由懒加载"></a>15.8 路由懒加载</h2><p>当路由被访问时才加载对应的路由文件，就是路由懒加载。<br>路由懒加载实现步骤：<br>1.安装 @babel/plugin-syntax-dynamic-import<br>打开vue控制台，点击依赖-&gt;安装依赖-&gt;开发依赖-&gt;搜索@babel/plugin-syntax-dynamic-import<br>点击安装。</p><p>2.在babel.config.js中声明该插件，打开babel.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 项目发布阶段需要用到的babel插件</span><br><span class="line">const productPlugins &#x3D; []</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是开发还是发布阶段</span><br><span class="line">if(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;)&#123;</span><br><span class="line">  &#x2F;&#x2F; 发布阶段</span><br><span class="line">  productPlugins.push(&quot;transform-remove-console&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@vue&#x2F;app&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;element-ui&quot;,</span><br><span class="line">        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...productPlugins,</span><br><span class="line">    &#x2F;&#x2F; 配置路由懒加载插件</span><br><span class="line">    &quot;@babel&#x2F;plugin-syntax-dynamic-import&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.将路由更改为按需加载的形式，打开router.js，更改引入组件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">const Login &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;login_home_welcome&quot; *&#x2F; &#39;.&#x2F;components&#x2F;Login.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Login from &#39;.&#x2F;components&#x2F;Login.vue&#39;</span><br><span class="line">const Home &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;login_home_welcome&quot; *&#x2F; &#39;.&#x2F;components&#x2F;Home.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Home from &#39;.&#x2F;components&#x2F;Home.vue&#39;</span><br><span class="line">const Welcome &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;login_home_welcome&quot; *&#x2F; &#39;.&#x2F;components&#x2F;Welcome.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Welcome from &#39;.&#x2F;components&#x2F;Welcome.vue&#39;</span><br><span class="line">const Users &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;user&quot; *&#x2F; &#39;.&#x2F;components&#x2F;user&#x2F;Users.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Users from &#39;.&#x2F;components&#x2F;user&#x2F;Users.vue&#39;</span><br><span class="line">const Rights &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;power&quot; *&#x2F; &#39;.&#x2F;components&#x2F;power&#x2F;Rights.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Rights from &#39;.&#x2F;components&#x2F;power&#x2F;Rights.vue&#39;</span><br><span class="line">const Roles &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;power&quot; *&#x2F; &#39;.&#x2F;components&#x2F;power&#x2F;Roles.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Roles from &#39;.&#x2F;components&#x2F;power&#x2F;Roles.vue&#39;</span><br><span class="line">const Cate &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;goods&quot; *&#x2F; &#39;.&#x2F;components&#x2F;goods&#x2F;Cate.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Cate from &#39;.&#x2F;components&#x2F;goods&#x2F;Cate.vue&#39;</span><br><span class="line">const Params &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;goods&quot; *&#x2F; &#39;.&#x2F;components&#x2F;goods&#x2F;Params.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Params from &#39;.&#x2F;components&#x2F;goods&#x2F;Params.vue&#39;</span><br><span class="line">const GoodList &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;goods&quot; *&#x2F; &#39;.&#x2F;components&#x2F;goods&#x2F;List.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import GoodList from &#39;.&#x2F;components&#x2F;goods&#x2F;List.vue&#39;</span><br><span class="line">const GoodAdd &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;goods&quot; *&#x2F; &#39;.&#x2F;components&#x2F;goods&#x2F;Add.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import GoodAdd from &#39;.&#x2F;components&#x2F;goods&#x2F;Add.vue&#39;</span><br><span class="line">const Order &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;order&quot; *&#x2F; &#39;.&#x2F;components&#x2F;order&#x2F;Order.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Order from &#39;.&#x2F;components&#x2F;order&#x2F;Order.vue&#39;</span><br><span class="line">const Report &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName:&quot;report&quot; *&#x2F; &#39;.&#x2F;components&#x2F;report&#x2F;Report.vue&#39;)</span><br><span class="line">&#x2F;&#x2F; import Report from &#39;.&#x2F;components&#x2F;report&#x2F;Report.vue&#39;</span><br></pre></td></tr></table></figure><h1 id="16-项目上线"><a href="#16-项目上线" class="headerlink" title="16.项目上线"></a>16.项目上线</h1><h2 id="16-1-通过node创建服务器"><a href="#16-1-通过node创建服务器" class="headerlink" title="16.1 通过node创建服务器"></a>16.1 通过node创建服务器</h2><p>在vue_shop同级创建一个文件夹vue_shop_server存放node服务器<br>使用终端打开vue_shop_server文件夹，输入命令 npm init -y<br>初始化包之后，输入命令 npm i express -S<br>打开vue_shop目录，复制dist文件夹，粘贴到vue_shop_server中<br>在vue_shop_server文件夹中创建app.js文件,编写代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use(express.static(&#39;.&#x2F;dist&#39;))</span><br><span class="line"></span><br><span class="line">app.listen(8998,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;server running at http:&#x2F;&#x2F;127.0.0.1:8998&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后再次在终端中输入  node app.js</p><h2 id="16-2-开启gzip压缩"><a href="#16-2-开启gzip压缩" class="headerlink" title="16.2 开启gzip压缩"></a>16.2 开启gzip压缩</h2><p>打开vue_shop_server文件夹的终端，输入命令：npm i compression -D<br>打开app.js,编写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const compression &#x3D; require(&#39;compression&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use(compression())</span><br><span class="line">app.use(express.static(&#39;.&#x2F;dist&#39;))</span><br><span class="line"></span><br><span class="line">app.listen(8998,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;server running at http:&#x2F;&#x2F;127.0.0.1:8998&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="16-3-配置https服务"><a href="#16-3-配置https服务" class="headerlink" title="16.3 配置https服务"></a>16.3 配置https服务</h2><p>配置https服务一般是后台进行处理，前端开发人员了解即可。<br>首先，需要申请SSL证书，进入<a href="https://freessl.cn官网/">https://freessl.cn官网</a><br>在后台导入证书，打开今天资料/素材，复制素材中的两个文件到vue_shop_server中<br>打开app.js文件，编写代码导入证书，并开启https服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line">const compression &#x3D; require(&#39;compression&#39;)</span><br><span class="line">const https &#x3D; require(&#39;https&#39;)</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line">&#x2F;&#x2F;创建配置对象设置公钥和私钥</span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">    cert:fs.readFileSync(&#39;.&#x2F;full_chain.pem&#39;),</span><br><span class="line">    key:fs.readFileSync(&#39;.&#x2F;private.key&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(compression())</span><br><span class="line">app.use(express.static(&#39;.&#x2F;dist&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.listen(8998,()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;     console.log(&quot;server running at http:&#x2F;&#x2F;127.0.0.1:8998&quot;)</span><br><span class="line">&#x2F;&#x2F; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动https服务</span><br><span class="line">https.createServer(options,app).listen(443)</span><br></pre></td></tr></table></figure><p>注意：因为我们使用的证书有问题，所以无法正常使用https服务</p><h2 id="16-4-使用pm2管理应用"><a href="#16-4-使用pm2管理应用" class="headerlink" title="16.4 使用pm2管理应用"></a>16.4 使用pm2管理应用</h2><p>打开vue_shop_server文件夹的终端，输入命令：npm i pm2 -g<br>使用pm2启动项目，在终端中输入命令：pm2 start app.js –name 自定义名称<br>查看项目列表命令：pm2 ls<br>重启项目：pm2 restart 自定义名称<br>停止项目：pm2 stop 自定义名称<br>删除项目：pm2 delete 自定义名称</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 Vue搭建的电商管理后台项目，手把手地指引新人每一步的过程，项目调用了别人提供的后端接口。笔记我是重新梳理了一遍，只有动手做才能发现自己踩过的坑，加以改进。为了方便，我最终选择将自己学习搭建的Vue电商项目托管至Gitee Pages和GitHub Pages，实现项目的正式上线 &lt;a href=&quot;https://hxy1997.gitee.io/vue_shops/&quot;&gt;Vue电商项目(Gitee Pages)&lt;/a&gt;和&lt;a href=&quot;https://hxy1997.xyz/vue_shops/&quot;&gt;Vue电商项目(GitHub Pages)&lt;/a&gt;，其中GitHub Pages采用的是我自己在阿里云配置的域名，所以和博客是同一个域名。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://hxy1997.xyz/tags/Vue/"/>
    
    <category term="实战" scheme="https://hxy1997.xyz/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="电商管理后台" scheme="https://hxy1997.xyz/tags/%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-25T06:02:29.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><h2 id="1-为什么要学习设计模式？"><a href="#1-为什么要学习设计模式？" class="headerlink" title="1.为什么要学习设计模式？"></a>1.为什么要学习设计模式？</h2><p>在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。</p><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="2-什么是设计模式。"><a href="#2-什么是设计模式。" class="headerlink" title="2.什么是设计模式。"></a>2.什么是设计模式。</h2><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p><p>设计模式主要是为了解决对象的生成和整合问题。</p><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p><h2 id="3-设计模式的发展历史"><a href="#3-设计模式的发展历史" class="headerlink" title="3.设计模式的发展历史"></a>3.设计模式的发展历史</h2><p>设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。</p><p>四人帮把这本书分成两部分：</p><p>第一部分解释面向对象编程的优缺点。</p><p>第二部分是关于 23 个经典设计模式的演变。</p><p>自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。</p><h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.设计模式分类"></a>4.设计模式分类</h2><p>根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p>接下来将概述属于这三种类型的 23 种设计模式的主要概念。</p><span id="more"></span><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="this、new、bind、call、apply"><a href="#this、new、bind、call、apply" class="headerlink" title="this、new、bind、call、apply"></a>this、new、bind、call、apply</h2><h3 id="1-this-指向的类型"><a href="#1-this-指向的类型" class="headerlink" title="1. this 指向的类型"></a><strong>1. this 指向的类型</strong></h3><h4 id="this-在函数的指向有以下几种场景："><a href="#this-在函数的指向有以下几种场景：" class="headerlink" title="this 在函数的指向有以下几种场景："></a><strong>this 在函数的指向有以下几种场景：</strong></h4><ul><li>作为构造函数被 new 调用；</li><li>作为对象的方法使用；</li><li>作为函数直接调用；</li><li>被 <code>call</code>、<code>apply</code>、<code>bind</code> 调用；</li><li>箭头函数中的 <code>this</code>；</li></ul><h4 id="1-1-new-绑定"><a href="#1-1-new-绑定" class="headerlink" title="1.1 new 绑定"></a><strong>1.1 new 绑定</strong></h4><blockquote><p>函数如果作为构造函数使用 <code>new</code> 调用时， <code>this</code> 绑定的是新创建的构造函数的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()       <span class="comment">// 输出: Foo 实例，this 就是 bar</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上使用 <code>new</code> 调用构造函数时，会依次执行下面的操作：</p></blockquote><ul><li>创建一个新对象；</li><li>构造函数的 <code>prototype</code> 被赋值给这个新对象的 <code>__proto__</code>；</li><li>将新对象赋给当前的 <code>this</code>；</li><li>执行构造函数；</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象，如果返回的不是对象将被忽略；</li></ul><h4 id="1-2-显式绑定"><a href="#1-2-显式绑定" class="headerlink" title="1.2 显式绑定"></a><strong>1.2 显式绑定</strong></h4><blockquote><p>通过 <code>call</code>、<code>apply</code>、<code>bind</code> 我们可以修改函数绑定的 <code>this</code>，使其成为我们指定的对象。通过这些方法的第一个参数我们可以显式地绑定 <code>this</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">category, name, price</span>) </span>&#123;</span><br><span class="line">    foo.call(<span class="built_in">this</span>, name, price)       <span class="comment">// call 方式调用</span></span><br><span class="line">    <span class="comment">// foo.apply(this, [name, price])    // apply 方式调用</span></span><br><span class="line">    <span class="built_in">this</span>.category = category</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Food(<span class="string">&#x27;食品&#x27;</span>, <span class="string">&#x27;汉堡&#x27;</span>, <span class="string">&#x27;5块钱&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &#123;name: &quot;汉堡&quot;, price: &quot;5块钱&quot;, category: &quot;食品&quot;&#125;</span></span><br><span class="line">call 和 apply 的区别是 call 方法接受的是参数列表，而 apply 方法接受的是一个参数数组。</span><br><span class="line"></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)        <span class="comment">// call 用法</span></span><br><span class="line">func.apply(thisArg, [arg1, arg2, ...])     <span class="comment">// apply 用法</span></span><br></pre></td></tr></table></figure><blockquote><p>而 <code>bind</code> 方法是设置 <code>this</code> 为给定的值，并返回一个新的函数，且在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])    <span class="comment">// bind 用法</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> food = &#123;</span><br><span class="line">    name: <span class="string">&#x27;汉堡&#x27;</span>,</span><br><span class="line">    price: <span class="string">&#x27;5块钱&#x27;</span>,</span><br><span class="line">    getPrice: <span class="function"><span class="keyword">function</span>(<span class="params">place</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(place + <span class="built_in">this</span>.price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">food.getPrice(<span class="string">&#x27;KFC &#x27;</span>)   <span class="comment">// 浏览器中输出: &quot;KFC 5块钱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice1 = food.getPrice.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;鸡腿&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;7块钱&#x27;</span> &#125;, <span class="string">&#x27;肯打鸡 &#x27;</span>)</span><br><span class="line">getPrice1()       <span class="comment">// 浏览器中输出: &quot;肯打鸡 7块钱&quot;</span></span><br><span class="line">关于 bind 的原理，我们可以使用 apply 方法自己实现一个 bind 看一下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params">...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, [...rest1, ...rest2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ES6</code> 方式用了一些 <code>ES6</code> 的知识比如 <code>rest</code> 参数、数组解构</p></blockquote><p><strong>注意：</strong> 如果你把 <code>null</code> 或 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code>、<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="literal">null</span>)         <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind(this)</code>链式调用，实际上后几项未执行，实质上 <code>this</code> 指向第一个绑定</p><h4 id="1-3-隐式绑定"><a href="#1-3-隐式绑定" class="headerlink" title="1.3 隐式绑定"></a>1.3 隐式绑定</h4><blockquote><p>函数是否在某个上下文对象中调用，如果是的话 <code>this</code> 绑定的是那个上下文对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()       <span class="comment">// 浏览器中输出: &quot;world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>foo</code> 方法是作为对象的属性调用的，那么此时 <code>foo</code> 方法执行时，<code>this</code> 指向 <code>obj</code> 对象。也就是说，此时 <code>this</code> 指向调用这个方法的对象，如果嵌套了多个对象，那么指向最后一个调用这个方法的对象：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">        foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.b.foo()      <span class="comment">// 浏览器中输出: &quot;China&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>最后一个对象是 <code>obj</code> 上的 <code>b</code>，那么此时 <code>foo</code> 方法执行时，其中的 <code>this</code> 指向的就是 <code>b</code> 对象。</p></blockquote><h4 id="1-4-默认绑定"><a href="#1-4-默认绑定" class="headerlink" title="1.4 默认绑定"></a><strong>1.4 默认绑定</strong></h4><blockquote><p>函数独立调用，直接使用不带任何修饰的函数引用进行调用，也是上面几种绑定途径之外的方式。非严格模式下 this 绑定到全局对象（浏览器下是 <code>winodw</code>，<code>node</code> 环境是 <code>global</code>），严格模式下 <code>this</code> 绑定到 <code>undefined</code> （因为严格模式不允许 <code>this</code> 指向全局对象）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()             <span class="comment">// 相当于执行 window.foo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 浏览器中输出: Window 对象</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 <code>a</code> 被声明在全局作用域，成为全局对象 <code>window</code> 的一个同名属性。函数 <code>foo</code> 被执行时，<code>this</code> 此时指向的是全局对象，因此打印出来的 <code>a</code> 是全局对象的属性。</p></blockquote><p>注意有一种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"></span><br><span class="line">bar()              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时 <code>bar</code> 函数，也就是 <code>obj</code> 上的 <code>foo</code> 方法为什么又指向了全局对象呢，是因为 <code>bar</code> 方法此时是作为函数独立调用的，所以此时的场景属于默认绑定，而不是隐式绑定。这种情况和把方法作为回调函数的场景类似：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(obj.foo)              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数传递实际上也是一种隐式的赋值，只不过这里 <code>obj.foo</code> 方法是被隐式赋值给了函数 <code>func</code> 的形参 <code>fn</code>，而之前的情景是自己赋值，两种情景实际上类似。这种场景我们遇到的比较多的是 <code>setTimeout</code> 和 <code>setInterval</code>，如果回调函数不是箭头函数，那么其中的 <code>this</code> 指向的就是全局对象.</li><li>其实我们可以把默认绑定当作是隐式绑定的特殊情况，比如上面的 <code>bar()</code>，我们可以当作是使用 <code>window.bar()</code> 的方式调用的，此时 bar 中的 <code>this</code> 根据隐式绑定的情景指向的就是 <code>window</code>。</li></ul><h3 id="2-this-绑定的优先级"><a href="#2-this-绑定的优先级" class="headerlink" title="2. this 绑定的优先级"></a><strong>2. this 绑定的优先级</strong></h3><blockquote><p><code>this</code> 存在多个使用场景，那么多个场景同时出现的时候，<code>this</code> 到底应该如何指向呢。这里存在一个优先级的概念，<code>this</code> 根据优先级来确定指向。<strong>优先级：new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p></blockquote><p><strong>所以 this 的判断顺序：</strong></p><ul><li><code>new</code> 绑定： 函数是否在 <code>new</code> 中调用？如果是的话 <code>this</code> 绑定的是新创建的对象；</li><li>显式绑定： 函数是否是通过 <code>bind</code>、<code>call</code>、<code>apply</code> 调用？如果是的话，<code>this</code> 绑定的是指定的对象；</li><li>隐式绑定： 函数是否在某个上下文对象中调用？如果是的话，<code>this</code> 绑定的是那个上下文对象；</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象；</li></ul><h3 id="3-箭头函数中的-this"><a href="#3-箭头函数中的-this" class="headerlink" title="3. 箭头函数中的 this"></a><strong>3. 箭头函数中的 this</strong></h3><ul><li>箭头函数 是根据其声明的地方来决定 <code>this</code> 的</li><li>箭头函数的 <code>this</code> 绑定是无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 被修改的，且因为箭头函数没有构造函数 <code>constructor</code>，所以也不可以使用 new 调用，即不能作为构造函数，否则会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()             <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-一个-this-的小练习"><a href="#4-一个-this-的小练习" class="headerlink" title="4. 一个 this 的小练习"></a><strong>4. 一个 this 的小练习</strong></h3><p>用一个小练习来实战一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 20</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li><code>var a = 20</code> 这句在全局变量 <code>window</code> 上创建了个属性 <code>a</code> 并赋值为 <code>20</code>；</li><li>首先执行的是 <code>obj.foo()</code>，这是一个箭头函数，箭头函数不创建新的函数作用域直接沿用语句外部的作用域，因此 <code>obj.foo()</code> 执行时箭头函数中 <code>this</code> 是全局 <code>window</code>，首先打印出 window 上的属性 a 的值 20，箭头函数返回了一个原型上有个值为 <code>50</code> 的属性 <code>a</code> 的函数对象 <code>func</code> 给 <code>bar</code>；</li><li>继续执行的是 <code>bar()</code>，这里执行的是刚刚箭头函数返回的闭包 <code>func</code>，其内部的 <code>this</code> 指向 <code>window</code>，因此 <code>this.a</code> 修改了 <code>window.a</code> 的值为 <code>60</code> 并打印出来；</li><li>然后执行的是 <code>new bar()</code>，根据之前的表述，<code>new</code> 操作符会在 <code>func</code> 函数中创建一个继承了 <code>func</code> 原型的实例对象并用 <code>this</code> 指向它，随后 <code>this.a = 60</code> 又在实例对象上创建了一个属性 <code>a</code>，在之后的打印中已经在实例上找到了属性 <code>a</code>，因此就不继续往对象原型上查找了，所以打印出第三个 <code>60</code>；</li><li>如果把上面例子的箭头函数换成普通函数呢，结果会是什么样？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 40</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><h2 id="闭包与高阶函数"><a href="#闭包与高阶函数" class="headerlink" title="闭包与高阶函数"></a>闭包与高阶函数</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a><strong>1. 闭包</strong></h3><h4 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a><strong>1.1 什么是闭包</strong></h4><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>我们首先来看一个闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line"></span><br><span class="line">baz()            <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><ul><li><code>foo</code> 函数传递出了一个函数 <code>bar</code>，传递出来的 <code>bar</code> 被赋值给 <code>baz</code> 并调用，虽然这时 <code>baz</code> 是在 <code>foo</code> 作用域外执行的，但 <code>baz</code> 在调用的时候可以访问到前面的 <code>bar</code> 函数所在的 <code>foo</code> 的内部作用域。</li><li>由于 <code>bar</code> 声明在 <code>foo</code> 函数内部，<code>bar</code> 拥有涵盖 <code>foo</code> 内部作用域的闭包，使得 <code>foo</code> 的内部作用域一直存活不被回收。一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 <code>JavaScript</code> 的 <code>GC</code>（Garbage Collection）垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 <code>GC</code>，比如本例中 <code>foo()</code> 执行完，因为返回的 <code>bar</code> 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。</li><li>注意： 如果不是必须使用闭包，那么尽量避免创建它，因为闭包在处理速度和内存消耗方面对性能具有负面影响。</li></ul><h4 id="1-2-利用闭包实现结果缓存（备忘模式）"><a href="#1-2-利用闭包实现结果缓存（备忘模式）" class="headerlink" title="1.2 利用闭包实现结果缓存（备忘模式）"></a><strong>1.2 利用闭包实现结果缓存（备忘模式）</strong></h4><blockquote><p>备忘模式就是应用闭包的特点的一个典型应用。比如有个函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多次运行 <code>add()</code> 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。</li><li>所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>ES6</code> 的方式会更优雅一些：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li>备忘函数中用 <code>JSON.stringify</code> 把传给 <code>adder</code> 函数的参数序列化成字符串，把它当做 <code>cache</code> 的索引，将 <code>add</code> 函数运行的结果当做索引的值传递给 <code>cache</code>，这样 <code>adder</code> 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 <code>fn.apply(fn, args)</code>，再返回计算的结果。</li><li>当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：</li><li>缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 <code>n</code> 个；</li><li>在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 <code>cookie</code>、<code>localStorage</code> 等；</li><li>这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。</li><li>复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。</li></ul><blockquote><p>注意： <code>cache</code> 不可以是 <code>Map</code>，因为 <code>Map</code> 的键是使用 <code>===</code> 比较的，因此当传入引用类型值作为键时，虽然它们看上去是相等的，但实际并不是，比如 <code>[1]!==[1]</code>，所以还是被存为不同的键。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  X 错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(args) || cache.set(args, fn.apply(fn, args)).get(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)    <span class="comment">// 3    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2, [ 2 ] =&gt; 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a><strong>2. 高阶函数</strong></h3><blockquote><p>高阶函数就是输入参数里有函数，或者输出是函数的函数。</p></blockquote><h4 id="2-1-函数作为参数"><a href="#2-1-函数作为参数" class="headerlink" title="2.1 函数作为参数"></a><strong>2.1 函数作为参数</strong></h4><blockquote><p>如果你用过 <code>setTimeout</code>、<code>setInterval</code>、<code>ajax</code> 请求，那么你已经用过高阶函数了，这是我们最常看到的场景：回调函数，因为它将函数作为参数传递给另一个函数。</p></blockquote><blockquote><p>比如 <code>ajax</code> 请求中，我们通常使用回调函数来定义请求成功或者失败时的操作逻辑：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">&quot;/request/url&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Array</code>、<code>Object</code>、<code>String</code> 等等基本对象的原型上有很多操作方法，可以接受回调函数来方便地进行对象操作。这里举一个很常用的 <code>Array.prototype.filter()</code> 方法，这个方法返回一个新创建的数组，包含所有回调函数执行后返回 <code>true</code> 或真值的数组元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word.length &gt; <span class="number">6</span></span><br><span class="line">&#125;)  <span class="comment">// 输出: [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数还有一个应用就是钩子，如果你用过 Vue 或者 React 等框架，那么你应该对钩子很熟悉了，它的形式是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 一些操作</span></span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-函数作为返回值"><a href="#2-2-函数作为返回值" class="headerlink" title="2.2 函数作为返回值"></a><strong>2.2 函数作为返回值</strong></h4><blockquote><p>另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要是利用闭包来保持着作用域：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num = num + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder = add()</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)     <span class="comment">// 输出: 1</span></span><br><span class="line">adder(<span class="number">2</span>)     <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h5 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a><strong>1. 柯里化</strong></h5><ul><li>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的原函数变换成接受一个单一参数（原函数的第一个参数）的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。</li><li>核心思想是把多参数传入的函数拆成单（或部分）参数函数，内部再返回调用下一个单（或部分）参数函数，依次处理剩余的参数。</li></ul><p><strong>柯里化有 3 个常见作用：</strong></p><ul><li>参数复用</li><li>提前返回</li><li>延迟计算/运行</li></ul><p>先来看看柯里化的通用实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要记住 ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把剩余参数与当前参数拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用它将一个 <code>sayHello</code> 函数柯里化试试：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg1 = currying(sayHello, <span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">curryingShowMsg1(<span class="number">22</span>, <span class="string">&#x27;苹果&#x27;</span>)           <span class="comment">// 输出: 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg2 = currying(sayHello, <span class="string">&#x27;小衰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">curryingShowMsg2(<span class="string">&#x27;西瓜&#x27;</span>)               <span class="comment">// 输出: 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br></pre></td></tr></table></figure><blockquote><p>更高阶的用法参见：JavaScript 函数式编程技巧 - 柯里化</p></blockquote><h5 id="2-反柯里化"><a href="#2-反柯里化" class="headerlink" title="2. 反柯里化"></a><strong>2. 反柯里化</strong></h5><ul><li>柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</li><li>而反柯里化，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</li></ul><p>先来看看反柯里化的通用实现吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你觉得把函数放在 Function 的原型上不太好，也可以这样：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tar</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        rest.shift()</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">tar, ...argu</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, argu)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单说，函数柯里化就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)              // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3</span>)        // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3, arg4</span>)  // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)(<span class="params">arg4</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argn</span>)   // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)…(<span class="params">argn</span>)</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>而反柯里化就是反过来，增加适用范围，让方法使用场景更大。使用反柯里化, 可以把原生方法借出来，让任何对象拥有原生对象的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(arg1, arg2)        <span class="comment">// =&gt; func(obj, arg1, arg2)</span></span><br></pre></td></tr></table></figure><p><strong>可以这样理解柯里化和反柯里化的区别：</strong></p><ul><li>柯里化是在运算前提前传参，可以传递多个参数；</li><li>反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</li><li>更高阶的用法参见：JavaScript 函数式编程技巧 - 反柯里化</li></ul><h5 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3. 偏函数"></a><strong>3. 偏函数</strong></h5><blockquote><p>偏函数是创建一个调用另外一个部分（参数或变量已预制的函数）的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的逻辑代码，只是根据传入的参数返回其他的函数，返回的函数中才有真正的处理逻辑比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">&#x27;Function&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样就用偏函数快速创建了一组判断对象类型的方法~</p></blockquote><p><strong>偏函数和柯里化的区别：</strong></p><ul><li>柯里化是把一个接受 <code>n</code> 个参数的函数，由原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行，例如：<code>add = (x, y, z) =&gt; x + y + z→curryAdd = x =&gt; y =&gt; z =&gt; x + y + z；</code></li><li>偏函数固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个；</li><li>当一个柯里化函数只接受两次参数时，比如 <code>curry()()</code>，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote><p>在前文我们介绍了面向对象三大特性之继承，本文将主要介绍面向对象六大原则中的单一职责原则（SRP）、开放封闭原则（OCP）、最少知识原则（LKP）。</p></blockquote><blockquote><p>设计原则是指导思想，从思想上给我们指明程序设计的正确方向，是我们在开发设计过程中应该尽力遵守的准则。而设计模式是实现手段，因此设计模式也应该遵守这些原则，或者说，设计模式就是这些设计原则的一些具体体现。要达到的目标就是高内聚低耦合，高内聚是说模块内部要高度聚合，是模块内部的关系，低耦合是说模块与模块之间的耦合度要尽量低，是模块与模块间的关系。</p></blockquote><p><strong>注意</strong>，遵守设计原则是好，但是过犹不及，在实际项目中我们不要刻板遵守，需要根据实际情况灵活运用</p><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1. 单一职责原则 SRP"></a><strong>1. 单一职责原则 SRP</strong></h3><ul><li>单一职责原则 （Single Responsibility Principle, SRP）是指对一个类（方法、对象，下文统称对象）来说，应该仅有一个引起它变化的原因。也就是说，一个对象只做一件事。</li><li>单一职责原则可以让我们对对象的维护变得简单，如果一个对象具有多个职责的话，那么如果一个职责的逻辑需要修改，那么势必会影响到其他职责的代码。如果一个对象具有多种职责，职责之间相互耦合，对一个职责的修改会影响到其他职责的实现，这就是属于模块内低内聚高耦合的情况。负责的职责越多，耦合越强，对模块的修改就越来越危险。</li></ul><p><strong>优点：</strong></p><ul><li>降低单个类（方法、对象）的复杂度，提高可读性和可维护性，功能之间的界限更清晰； 类（方法、对象）之间根据功能被分为更小的粒度，有助于代码的复用；</li><li>缺点： 增加系统中类（方法、对象）的个数，实际上也增加了这些对象之间相互联系的难度，同时也引入了额外的复杂度。</li></ul><h3 id="2-开放封闭原则-OCP"><a href="#2-开放封闭原则-OCP" class="headerlink" title="2. 开放封闭原则 OCP"></a><strong>2. 开放封闭原则 OCP</strong></h3><blockquote><p>开放封闭原则 （Open－Close Principle, OCP）是指一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的，也就是对扩展开放，对修改封闭。</p></blockquote><blockquote><p>当需要增加需求的时候，则尽量通过扩展新代码的方式，而不是修改已有代码。因为修改已有代码，则会给依赖原有代码的模块带来隐患，因此修改之后需要把所有依赖原有代码的模块都测试一遍，修改一遍测试一遍，带来的成本很大，如果是上线的大型项目，那么代价和风险可能更高。</p></blockquote><p><strong>优点</strong>：</p><ul><li>增加可维护性，避免因为修改给系统带来的不稳定性。</li></ul><h3 id="3-最少知识原则-LKP"><a href="#3-最少知识原则-LKP" class="headerlink" title="3. 最少知识原则 LKP"></a><strong>3. 最少知识原则 LKP</strong></h3><ul><li>最少知识原则 （Least Knowledge Principle, LKP）又称为迪米特原则 （Law of Demeter, LOD），一个对象应该对其他对象有最少的了解。</li><li>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li><li>通常为了减少对象之间的联系，是通过引入一个第三者来帮助进行通信，阻隔对象之间的直接通信，从而减少耦合。</li></ul><p><strong>优点：</strong></p><ul><li>降低类（方法、对象）之间不必要的依赖，减少耦合。</li></ul><p><strong>缺点：</strong></p><ul><li>类（方法、对象）之间不直接通信也会经过一个第三者来通信，那么就要权衡引入第三者带来的复杂度是否值得。</li></ul><h1 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到，本节我们一起来学习一下。</li><li>单例模式 （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</li></ul><p>经营游戏单例示例代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ManageGame() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    ManageGame._schedule &#x3D; this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ManageGame.getInstance &#x3D; function() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    return ManageGame._schedule &#x3D; new ManageGame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const schedule1 &#x3D; new ManageGame()</span><br><span class="line">const schedule2 &#x3D; ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line">console.log(schedule1 &#x3D;&#x3D;&#x3D; schedule2)</span><br></pre></td></tr></table></figure><blockquote><p>稍微解释一下，这个构造函数在内部维护（或者直接挂载自己身上）一个实例，第一次执行 new 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。我们可以用 <code>ES6</code> 的 <code>class</code> 语法改造一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> _schedule = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        <span class="keyword">return</span> ManageGame._schedule = <span class="keyword">new</span> ManageGame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        ManageGame._schedule = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schedule1 = <span class="keyword">new</span> ManageGame()</span><br><span class="line"><span class="keyword">const</span> schedule2 = ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(schedule1 === schedule2)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面方法的缺点在于维护的实例作为静态属性直接暴露，外部可以直接修改。</p><p>可以使用闭包或块状作用域隐藏内部变量：</p><p><strong>单例模式赋能</strong></p><blockquote><p>之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据单一职责原则，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p></blockquote><p><strong>惰性单例、懒汉式-饿汉式</strong></p><ul><li>有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用惰性创建，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</li></ul><p><strong>单例模式的优缺点</strong></p><p>单例模式主要解决的问题就是节约资源，保持访问一致性。</p><p><strong>简单分析一下它的优点：</strong></p><ul><li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li><li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li><li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li></ul><p><strong>单例模式也是有缺点的</strong></p><ul><li>单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；</li><li>与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li></ul><p><strong>单例模式的使用场景</strong></p><p>那我们应该在什么场景下使用单例模式呢：</p><ul><li>当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；</li><li>当项目中需要一个公共的状态，那么需要使用单例模式来保证访问一致性；</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>访问者只需要知道产品名，就可以从工厂获得对应实例；</li><li>访问者不关心实例创建过程；</li></ul><p><strong>代码实现</strong></p><blockquote><p>如果你使用过 <code>document.createElement</code> 方法创建过 <code>DOM</code> 元素，那么你已经使用过工厂方法了，虽然这个方法实际上很复杂，但其使用的就是工厂方法的思想：访问者只需提供标签名（如 <code>div</code>、<code>img</code>），那么这个方法就会返回对应的 DOM 元素。</p></blockquote><p>我们可以使用 JavaScript 将上面饭馆例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restaurant</span>(<span class="params">menu</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDin</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDin.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法中这里使用 <code>switch-case</code> 语法，你也可以用 <code>if-else</code>，都可以。</p></blockquote><p>下面使用 ES6 的 class 语法改写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.getMenu(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.getMenu(<span class="string">&#x27;红烧排骨&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>这样就完成了一个工厂模式，但是这个实现有一个问题：工厂方法中包含了很多与创建产品相关的过程，如果产品种类很多的话，这个工厂方法中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应修改在工厂方法，违反了开闭原则，也导致这个工厂方法变得臃肿、高耦合。</li><li>严格上这种实现在面向对象语言中叫做简单工厂模式。适用于产品种类比较少，创建逻辑不复杂的时候使用。</li><li>工厂模式的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类，所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。关于抽象类的有关内容，可以参看抽象工厂模式。</li><li>然而作为灵活的 JavaScript，我们不必如此较真，可以把易变的参数提取出来：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.menuData = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu])</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; type, message &#125; = <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Menu(type, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加菜品种类 */</span></span><br><span class="line">    <span class="function"><span class="title">addMenu</span>(<span class="params">menu, type, message</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.menuData[menu]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.Info(<span class="string">&#x27;已经有这个菜了!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.menuData[menu] = &#123; type, message &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移除菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">removeMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu]) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="built_in">this</span>.message) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restaurant = <span class="keyword">new</span> Restaurant()</span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>, <span class="string">&#x27;鱼香肉丝&#x27;</span>, <span class="string">&#x27; 真香~&#x27;</span>)<span class="comment">// 注册菜品</span></span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;GongBaoJiDin&#x27;</span>, <span class="string">&#x27;宫保鸡丁&#x27;</span>, <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant.getMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant.getMenu(<span class="string">&#x27;HongSaoPaiGu&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>我们还给 Restaurant 类增加了 <code>addMenu/removeMenu</code> 私有方法，以便于扩展。</li><li>当然这里如果菜品参数不太一致，可以在 <code>addMenu</code> 时候注册构造函数或者类，创建的时候返回 <code>new</code> 出的对应类实例，灵活变通即可。</li></ul><p> <strong>工厂模式的优缺点</strong></p><p>工厂模式将对象的创建和实现分离，这带来了优点：</p><ul><li>良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下；</li><li>扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则；</li><li>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</li><li>工厂模式的缺点：带来了额外的系统复杂度，增加了抽象性；</li></ul><p><strong>工厂模式的使用场景</strong></p><p>那么什么时候使用工厂模式呢：</p><ul><li>对象的创建比较复杂，而访问者无需知道创建的具体流程；</li><li>处理大量具有相同属性的小对象；</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>抽象工厂 （Abstract Factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。</li><li>我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA、C#、C++ 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。</li></ul><p><strong>代码实现</strong></p><blockquote><p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 <code>new.target</code> 来判断 new 的类，在父类方法中 <code>throw new Error()</code>，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 抽象类，ES6 class 方式 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">operate</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象类，ES5 构造函数方式 */</span></span><br><span class="line"><span class="keyword">var</span> AbstractClass2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 抽象方法，使用原型方式添加 */</span></span><br><span class="line">AbstractClass2.prototype.operate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>下面用 JavaScript 将上面介绍的饭店例子实现一下。</p><p>首先使用原型方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Restaurant</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Restaurant.orderDish = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDing()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;紫菜蛋汤&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZiCaiDanTang()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dish</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象方法 */</span></span><br><span class="line">Dish.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDing</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br><span class="line">使用 <span class="class"><span class="keyword">class</span> 语法改写一下：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">orderDish</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Dish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish0 = <span class="keyword">new</span> Dish()  <span class="comment">// 输出: Error 抽象方法不能调用!</span></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br></pre></td></tr></table></figure><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>抽象模式的优点：</strong></p><blockquote><p>抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；</p></blockquote><p><strong>抽象模式的缺点：</strong></p><ul><li>扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；</li><li>带来了系统复杂度，增加了新的类，和新的继承关系；</li></ul><p><strong>抽象工厂模式的使用场景</strong></p><blockquote><p>如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。</p></blockquote><p> <strong>抽象工厂模式与工厂模式</strong></p><p>工厂模式和抽象工厂模式的区别：</p><ul><li>工厂模式 主要关注单独的产品实例的创建；</li><li>抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；根据场景灵活使用即可。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>建造者模式（Builder Pattern）又称生成器模式，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的构建层与其表示层分离。</p></blockquote><ul><li>在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。</li></ul><p>汽车装配代码模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">function CarBuilder(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">    this.color &#x3D; color</span><br><span class="line">    this.weight &#x3D; weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，轮胎</span><br><span class="line">CarBuilder.prototype.buildTyre &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，发动机</span><br><span class="line">CarBuilder.prototype.buildEngine &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 奔驰厂家，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">function benChiDirector(tyre, engine, param) &#123;</span><br><span class="line">    var _car &#x3D; new CarBuilder(param)</span><br><span class="line">    _car.buildTyre(tyre)</span><br><span class="line">    _car.buildEngine(engine)</span><br><span class="line">    return _car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">var benchi1 &#x3D; benChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>ES6写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">class CarBuilder &#123;</span><br><span class="line">    constructor(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">        this.weight &#x3D; weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，轮胎 *&#x2F;</span><br><span class="line">    buildTyre(type) &#123;</span><br><span class="line">        const tyre &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.tyre &#x3D; tyre</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，发动机 *&#x2F;</span><br><span class="line">    buildEngine(type) &#123;</span><br><span class="line">        const engine &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.engine &#x3D; engine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 指挥者，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">class BenChiDirector &#123;</span><br><span class="line">    constructor(tyre, engine, param) &#123;</span><br><span class="line">        const _car &#x3D; new CarBuilder(param)</span><br><span class="line">        _car.buildTyre(tyre)</span><br><span class="line">        _car.buildEngine(engine)</span><br><span class="line">        return _car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">const benchi1 &#x3D; new BenChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来完成部件的装配</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者，汽车部件厂家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">&#123; color = <span class="string">&#x27;white&#x27;</span>, weight = <span class="string">&#x27;0&#x27;</span> &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，轮胎 */</span></span><br><span class="line">    <span class="function"><span class="title">buildTyre</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tyre = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;小号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用小号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;中号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用中号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;大号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用大号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.tyre = tyre</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，发动机 */</span></span><br><span class="line">    <span class="function"><span class="title">buildEngine</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> engine = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;小马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用小马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;中马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用中马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;大马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用大马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车装配，获得产品实例</span></span><br><span class="line"><span class="keyword">const</span> benchi1 = <span class="keyword">new</span> CarBuilder(&#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">weight</span>: <span class="string">&#x27;1600kg&#x27;</span> &#125;)</span><br><span class="line">    .buildTyre(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    .buildEngine(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(benchi1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line"><span class="comment">//   weight: &quot;1600kg&quot;</span></span><br><span class="line"><span class="comment">//   tyre: Tyre &#123;tyre: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span></span><br><span class="line"><span class="comment">//   engine: Engine &#123;engine: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这样将最终产品的创建流程使用链模式来实现，相当于将指挥者退化，指挥的过程通过链模式让用户自己实现，这样既增加了灵活性，装配过程也一目了然。如果希望扩展产品的部件，那么在建造者上增加部件实现方法，再适当修改链模式即可。</p></blockquote><p><strong>建造者模式的优点：</strong></p><ul><li>使用建造者模式可以使产品的构建流程和产品的表现分离，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节；</li><li>扩展方便，如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；</li><li>更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性；</li></ul><p><strong>建造者模式的缺点：</strong></p><ul><li>建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；</li><li>实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；</li></ul><p> <strong>建造者模式的适用场景</strong></p><ul><li>相同的方法，不同的执行顺序，产生不一样的产品时，可以采用建造者模式；</li><li>产品的组成部件类似，通过组装不同的组件获得不同产品时，可以采用建造者模式；</li></ul><p><strong>建造者模式与工厂模式</strong></p><ul><li>建造者模式和工厂模式最终都是创建一个完整的产品，但是在建造者模式中我们更关心对象创建的过程，将创建对象的方法模块化，从而更好地复用这些模块。</li><li>当然建造者模式与工厂模式也是可以组合使用的，比如建造者中一般会提供不同的部件实现，那么这里就可以使用工厂模式来提供具体的部件对象，再通过指挥者来进行装配。</li></ul><p>** 建造者模式与模版方法模式**</p><ul><li>指挥者的实现可以和模版方法模式相结合。也就是说，指挥者中部件的装配过程，可以使用模版方法模式来固定装配算法，把部件实现方法分为模板方法和基本方法，进一步提取公共代码，扩展可变部分。</li><li>是否采用模版方法模式看具体场景，如果产品的部件装配顺序很明确，但是具体的实现是未知的、灵活的，那么你可以适当考虑是否应该将算法骨架提取出来。</li></ul><h1 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a><strong>三、结构型模式</strong></h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理模式 （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。</p></blockquote><ul><li>代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。</li></ul><p><strong>实例的代码实现</strong></p><p>我们使用 JavaScript 来将上面的明星例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">var</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">ad</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">var</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">reward, ad</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            SuperStar.playAdvertisement(ad)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br></pre></td></tr></table></figure><ul><li>我们可以升级一下，比如如果明星没有档期的话，可以通过经纪人安排档期，当明星有空的时候才让明星来拍广告。这里通过 <code>Promise</code> 的方式来实现档期的安排：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">const</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">ad</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">const</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">scheduleTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;小鲜鲜有空了&#x27;</span>)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;, <span class="number">2000</span>)                        <span class="comment">// 发现明星有空了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">reward, ad</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            ProxyAssistant.scheduleTime()   <span class="comment">// 安排上了</span></span><br><span class="line">                .then(<span class="function">() =&gt;</span> SuperStar.playAdvertisement(ad))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">1000001</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没问题，我们小鲜鲜最喜欢拍广告了！</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line"><span class="comment">// 输出： 小鲜鲜有空了</span></span><br><span class="line"><span class="comment">// 输出： 纯蒸酸牛奶，味道纯纯，尽享纯蒸</span></span><br></pre></td></tr></table></figure><p>这里就简单实现了经纪人对请求的过滤，对明星档期的安排，实现了一个代理对象的基本功能。</p><p><strong>代理模式的优缺点</strong></p><p><strong>代理模式的主要优点有：</strong></p><ul><li>代理对象在访问者与目标对象之间可以起到中介和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将访问者与目标对象分离，在一定程度上降低了系统的耦合度，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则；</li><li>代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（十八线明星就别请经纪人了）</li></ul><p><strong>其他相关模式</strong></p><p>很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。</p><p><strong>代理模式与适配器模式</strong></p><p>代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：</p><ul><li>适配器模式： 主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口；</li><li>代理模式： 提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口；</li></ul><p><strong>代理模式与装饰者模式</strong></p><p>装饰者模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p><ul><li>装饰者模式： 目的是为了方便地给目标对象添加功能，也就是动态地添加功能；</li><li>代理模式： 主要目的是控制其他访问者对目标对象的访问；</li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。</p></blockquote><blockquote><p>享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。</p></blockquote><p>Fly 意为苍蝇，Flyweight 指轻蝇量级，指代对象粒度很小。</p><p><strong>代码实现</strong></p><p>首先假设考生的 ID 为奇数则考的是手动档，为偶数则考的是自动档。如果给所有考生都 new 一个驾考车，那么这个系统中就会创建了和考生数量一致的驾考车对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = <span class="keyword">new</span> ExamCar(candidateId % <span class="number">2</span>)</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 10</span></span><br></pre></td></tr></table></figure><blockquote><p>如果考生很多，那么系统中就会存在更多个驾考车对象实例，假如驾考车对象比较复杂，那么这些新建的驾考车实例就会占用大量内存。这时我们将同种类型的驾考车实例进行合并，手动档和自动档档驾考车分别引用同一个实例，就可以节约大量内存：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manualExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> autoExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = candidateId % <span class="number">2</span> ? manualExamCar : autoExamCar</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 2</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到我们使用 2 个驾考车实例就实现了刚刚 10 个驾考车实例实现的功能。这是仅有 10 个考生的情况，如果有几百上千考生，这时我们节约的内存就比较可观了，这就是享元模式要达到的目的。</p></blockquote><p><strong>享元模式的优缺点</strong></p><p><strong>享元模式的优点：</strong></p><ul><li>由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度；</li><li>外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；</li></ul><p><strong>享元模式的缺点：</strong></p><ul><li>引入了共享对象，使对象结构变得复杂；</li><li>共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；</li></ul><p><strong>享元模式的适用场景</strong></p><ul><li>如果一个程序中大量使用了相同或相似对象，那么可以考虑引入享元模式；</li><li>如果使用了大量相同或相似对象，并造成了比较大的内存开销；</li><li>对象的大多数状态可以被转变为外部状态；</li><li>剥离出对象的外部状态后，可以使用相对较少的共享对象取代大量对象；</li><li>在一些程序中，如果引入享元模式对系统的性能和内存的占用影响不大时，比如目标对象不多，或者场景比较简单，则不需要引入，以免适得其反。</li></ul><p><strong>其他相关模式</strong></p><ul><li>享元模式和单例模式、工厂模式、组合模式、策略模式、状态模式等等经常会一起使用。</li></ul><p><strong>享元模式和工厂模式、单例模式</strong></p><ul><li>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</li></ul><p> <strong>享元模式和组合模式</strong></p><ul><li>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</li></ul><p><strong>享元模式和策略模式</strong></p><blockquote><p>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p></blockquote><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>适配器模式（Adapter Pattern）又称包装器模式，将一个类（对象）的接口（方法、属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。</li><li>主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说，访问者需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已。</li></ul><p><strong>代码实现</strong></p><p>我们可以实现一下电源适配器的例子，一开始我们使用的中国插头标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chinaPlug.chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><blockquote><p>但是我们出国旅游了，到了日本，需要增加一个日本插头到中国插头的电源适配器，来将我们原来的电源线用起来：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> japanPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;日本插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">japanInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日本插头电源适配器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">japanPlugAdapter</span>(<span class="params">plug</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> plug.japanInPlug()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">japanPlugAdapter(japanPlug).chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><p><strong>适配器模式的优缺点</strong></p><p><strong>适配器模式的优点：</strong></p><ul><li>已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</li><li>可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；</li><li>灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；</li><li>适配器模式的缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。</li></ul><p><strong>适配器模式的适用场景</strong></p><ul><li>当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。</li><li>如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；</li><li>如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；</li></ul><p><strong>其他相关模式</strong></p><blockquote><p>适配器模式和代理模式、装饰者模式看起来比较类似，都是属于包装模式，也就是用一个对象来包装另一个对象的模式，他们之间的异同在代理模式中已经详细介绍了，这里再简单对比一下。</p></blockquote><p><strong>适配器模式与代理模式</strong></p><ul><li>适配器模式： 提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；</li><li>代理模式： 提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；</li></ul><p><strong>适配器模式、装饰者模式与代理模式</strong></p><ul><li>适配器模式： 功能不变，只转换了原有接口访问格式；</li><li>装饰者模式： 扩展功能，原有功能不变且可直接使用；</li><li>代理模式： 原有功能不变，但一般是经过限制访问的；</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>装饰者模式 （Decorator Pattern）又称装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能。</p></blockquote><blockquote><p>本质是功能动态组合，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。</p></blockquote><p>我们可以使用 JavaScript 来将装修房子的例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OriginHouse</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">OriginHouse.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Furniture</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Furniture.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Painting</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Painting.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> house = <span class="keyword">new</span> OriginHouse() <span class="comment">// 毛坯房</span></span><br><span class="line">house = <span class="keyword">new</span> Furniture(house) <span class="comment">// 搬入家具</span></span><br><span class="line">house = <span class="keyword">new</span> Painting(house) <span class="comment">// 墙壁刷漆</span></span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br><span class="line">使用 ES6 的 Class 语法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> house = <span class="keyword">new</span> OriginHouse()</span><br><span class="line">house = <span class="keyword">new</span> Furniture(house)</span><br><span class="line">house = <span class="keyword">new</span> Painting(house)</span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><blockquote><p>是不是感觉很麻烦，装饰个功能这么复杂？我们 JSer 大可不必走这一套面向对象花里胡哨的，毕竟 JavaScript 的优点就是灵活：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="keyword">var</span> originHouse = &#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">furniture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">painting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 搬入家具 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        furniture()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 墙壁刷漆 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        painting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">originHouse.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><p>简洁明了，且更符合前端日常使用的场景。</p><p><strong>装饰者模式的优缺点</strong></p><p><strong>装饰者模式的优点：</strong></p><ul><li>我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下动态地修饰对象，添加功能，装饰者和被装饰者之间松耦合，可维护性好；</li><li>被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；</li><li>装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；</li><li>可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；</li></ul><p><strong>装饰者模式的缺点：</strong></p><ul><li>使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；</li><li>由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐；</li></ul><p><strong>装饰者模式的适用场景</strong></p><ul><li>如果不希望系统中增加很多子类，那么可以考虑使用装饰者模式；</li><li>需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，这时采用装饰者模式可以很好实现；</li><li>当对象的功能要求可以动态地添加，也可以动态地撤销，可以考虑使用装饰者模式；</li></ul><p><strong>其他相关模式</strong> </p><p>** 装饰者模式与适配器模式**</p><blockquote><p>装饰者模式和适配器模式都是属于包装模式，然而他们的意图有些不一样：</p></blockquote><ul><li>装饰者模式： 扩展功能，原有功能还可以直接使用，一般可以给目标对象多次叠加使用多个装饰者；</li><li>适配器模式： 功能不变，但是转换了原有接口的访问格式，一般只给目标对象使用一次；</li></ul><p><strong>装饰者模式与组合模式</strong></p><p>这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰者模式看做是只有一个组件的组合模式。</p><ul><li>装饰者模式： 动态地给对象增加功能；</li><li>组合模式： 管理组合对象和叶子对象，为它们提供一致的操作接口给客户端，方便客户端的使用；</li></ul><p><strong>装饰者模式与策略模式</strong></p><p>装饰者模式和策略模式都包含有许多细粒度的功能模块，但是他们的使用思路不同：</p><ul><li>装饰者模式： 可以递归调用，使用多个功能模式，功能之间可以叠加组合使用；</li><li>策略模式： 只有一层选择，选择某一个功能；</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>外观模式 （Facade Pattern）又叫门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。</p></blockquote><p>外观模式在源码中使用很多，具体可以参考后文中源码阅读部分。</p><p><strong>简化版本的代码： 无人机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uav = &#123;</span><br><span class="line">    <span class="comment">/* 电子调速器 */</span></span><br><span class="line">    diantiao1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 电机 */</span></span><br><span class="line">    dianji1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遥控器 */</span></span><br><span class="line">    controller: &#123;</span><br><span class="line">        <span class="comment">/* 上升 */</span></span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.up()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 前进 */</span></span><br><span class="line">        <span class="function"><span class="title">forward</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 下降 */</span></span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.down()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 左转 */</span></span><br><span class="line">        <span class="function"><span class="title">left</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操纵无人机 */</span></span><br><span class="line">uav.controller.down()    <span class="comment">// 发送下降指令</span></span><br><span class="line">uav.controller.left()    <span class="comment">// 发送左转指令</span></span><br></pre></td></tr></table></figure><p>无人机系统是比较复杂，但是可以看到无人机的操纵却比较简单，正是因为有遥控器这个外观的存在。</p><p><strong>外观模式的优点：</strong></p><ul><li>访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；</li><li>减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；</li><li>通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；</li></ul><p><strong>外观模式的缺点：</strong></p><ul><li>不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；</li><li>不需要或不合理的使用外观会让人迷惑，过犹不及；</li></ul><p><strong>外观模式的适用场景</strong></p><ul><li>维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可；</li><li>你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能；</li><li>团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间；</li><li>如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>外观模式与中介者模式</strong></p><ul><li>外观模式： 封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用；</li><li>中介者模式： 封装子系统间各模块之间的直接交互，松散模块间的耦合；</li></ul><p><strong>外观模式与单例模式</strong></p><blockquote><p>有时候一个系统只需要一个外观，比如之前举的 <code>Axios</code> 的 <code>HTTP</code> 模块例子。这时我们可以将外观模式和单例模式可以一起使用，把外观实现为单例。</p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>组合模式 （Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象</p></blockquote><p><strong>你曾见过的组合模式</strong></p><p>大家电脑里的文件夹结构相比很熟悉了，文件夹下面可以有子文件夹，也可以有文件，子文件夹下面还可以有文件夹和文件，以此类推，共同组成了一个文件树，结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Folder <span class="number">1</span></span><br><span class="line">├── Folder <span class="number">2</span></span><br><span class="line">│   ├── File <span class="number">1.</span>txt</span><br><span class="line">│   ├── File <span class="number">2.</span>txt</span><br><span class="line">│   └── File <span class="number">3.</span>txt</span><br><span class="line">└── Folder <span class="number">3</span></span><br><span class="line">    ├── File <span class="number">4.</span>txt</span><br><span class="line">    ├── File <span class="number">5.</span>txt</span><br><span class="line">    └── File <span class="number">6.</span>txt</span><br></pre></td></tr></table></figure><blockquote><p>文件夹是树形结构的容器节点，容器节点可以继续包含其他容器节点，像树枝上还可以有其他树枝一样；也可以包含文件，不再增加新的层级，就像树的叶子一样处于末端，因此被称为叶节点。本文中，叶节点又称为叶对象，容器节点因为可以包含容器节点和非容器节点，又称为组合对象。</p></blockquote><p><strong>代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的文件夹例子实现一下。</p><p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">var</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(fileOrFolder)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">                child.scan(cb)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">var</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子文件夹，并放入根文件夹</span></span><br><span class="line"><span class="keyword">var</span> foldMarvelMovies = createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldMarvelMovies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldDCMovies = createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldDCMovies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个子文件夹分别添加电影</span></span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>))</span><br><span class="line"></span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line">foldMovies.scan(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + item.name + <span class="string">&#x27; size:&#x27;</span> + item.size + <span class="string">&#x27;GB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来进行改造一下，让我们添加子文件更加直观和方便。对链模式还不熟悉的同学可以看一下后面有一篇单独介绍链模式的文章～</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">const</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹  */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(...fileOrFolder)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">const</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line">  .add(</span><br><span class="line">    createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)),</span><br><span class="line">    createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码比较 JavaScript 特色，如果我们使用传统的类呢，也是可以实现的，下面使用 ES6 的 class 语法来改写一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件夹类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, children</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.children = children</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.push(...fileOrFolder)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        cb(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = <span class="keyword">new</span> Folder(<span class="string">&#x27;电影&#x27;</span>, [</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;漫威英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)]),</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;DC英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><p>在传统的语言中，为了保证叶对象和组合对象的外观一致，还会让他们实现同一个抽象类或接口。</p><p><strong>组合模式的优缺点</strong> <strong>组合模式的优点：</strong></p><ul><li>由于组合对象和叶对象具有同样的接口，因此调用的是组合对象还是叶对象对使用者来说没有区别，使得使用者面向接口编程；</li><li>如果想在组合模式的树中增加一个节点比较容易，在目标组合对象中添加即可，不会影响到其他对象，对扩展友好，符合开闭原则，利于维护；</li></ul><p><strong>组合模式的缺点：</strong></p><ul><li>增加了系统复杂度，如果树中对象不多，则不一定需要使用；</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起；</li></ul><p><strong>组合模式的适用场景</strong></p><ul><li>如果对象组织呈树形结构就可以考虑使用组合模式，特别是如果操作树中对象的方法比较类似时；</li><li>使用者希望统一对待树形结构中的对象，比如用户不想写一堆 if-else 来处理树中的节点时，可以使用组合模式；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>组合模式和职责链模式</strong></p><p>正如前文所说，组合模式是天生实现了职责链模式的。</p><ul><li>组合模式： 请求在组合对象上传递，被深度遍历到组合对象的所有子孙叶节点具体执行；</li><li>职责链模式： 实现请求的发送者和接受者之间的解耦，把多个接受者组合起来形成职责链，请求在链上传递，直到有接受者处理请求为止；</li></ul><p><strong>组合模式和迭代器模式</strong></p><p>组合模式可以结合迭代器模式一起使用，在遍历组合对象的叶节点的时候，可以使用迭代器模式来遍历。</p><p><strong>组合模式和命令模式</strong></p><blockquote><p>命令模式里有一个用法「宏命令」，宏命令就是组合模式和命令模式一起使用的结果，是组合模式组装而成</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li>桥接模式（Bridge Pattern）又称桥梁模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。</li><li>抽象部分和实现部分可能不太好理解，举个例子，香蕉、苹果、西瓜，它们共同的抽象部分就是水果，可以吃，实现部分就是不同的水果实体。再比如黑色手提包、红色钱包、蓝色公文包，它们共同的抽象部分是包和颜色，这部分的共性就可以被作为抽象提取出来。</li></ul><p><strong>实例的代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的变频洗衣机例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Washer</span>(<span class="params">motorType, rollerType, transducerType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">    <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">    <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Washer.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor.run()</span><br><span class="line">    <span class="built_in">this</span>.roller.run()</span><br><span class="line">    <span class="built_in">this</span>.transducer.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Motor</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Motor.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Roller</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Roller.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Transducer</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transducer.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建洗衣机</span></span><br><span class="line"><span class="keyword">var</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br><span class="line">由于产品部件可以独立变化，所以创建新的洗衣机产品就非常容易：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> washerD = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;中功率&#x27;</span>)</span><br><span class="line">washerD.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      中功率变频器开始工作</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到由于洗衣机的结构被分别抽象为几个部件的组合，部件的实例化是在部件类各自的构造函数中完成，因此部件之间的实例化不会相互影响，新产品的创建也变得容易，这就是桥接模式的好处。</p></blockquote><p>下面我们用 ES6 的 Class 语法实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">motorType, rollerType, transducerType</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">        <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">        <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始使用 */</span></span><br><span class="line">    <span class="function"><span class="title">work</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor.run()</span><br><span class="line">        <span class="built_in">this</span>.roller.run()</span><br><span class="line">        <span class="built_in">this</span>.transducer.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Roller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br></pre></td></tr></table></figure><ul><li>如果再精致一点，可以让电机、滚筒、变频器等部件实例继承自各自的抽象类，将面向抽象进行到底，但是桥接模式在 JavaScript 中应用不多，适当了解即可，不用太死扣。</li><li>有时候为了更复用部件，可以将部件的实例化拿出来，对于洗衣机来说一个实体部件当然不能用两次，这里使用皮包的例子：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 皮包 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 展示 */</span></span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="built_in">this</span>.color.show() + <span class="built_in">this</span>.type.show()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.typeType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.typeType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包颜色 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colorType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.colorType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象实例化 */</span></span><br><span class="line"><span class="keyword">const</span> redColor = <span class="keyword">new</span> Color(<span class="string">&#x27;红色&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> walletType = <span class="keyword">new</span> Type(<span class="string">&#x27;钱包&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> briefcaseType = <span class="keyword">new</span> Type(<span class="string">&#x27;公文包&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagA = <span class="keyword">new</span> Bag(walletType, redColor)</span><br><span class="line">bagA.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色钱包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagB = <span class="keyword">new</span> Bag(briefcaseType, redColor)</span><br><span class="line">bagB.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色公文包</span></span><br></pre></td></tr></table></figure><h1 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a><strong>四、行为型模式</strong></h1><p>暂时搞不懂，后续理解</p><h1 id="五、其他模式"><a href="#五、其他模式" class="headerlink" title="五、其他模式"></a><strong>五、其他模式</strong></h1><h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><blockquote><p>在下文中，如果某些内容和你看的某本书或者某个帖子上的不一样，不要惊慌，多看几本书，多打开几个帖子，你会发现每个都不一样，所以模式具体是如何表现并不重要，重要的是，了解这三个模式主要的目的和思想是什么：</p></blockquote><ul><li><code>MVC</code> 模式： 从大锅烩时代进化，引入了分层的概念，但是层与层之间耦合明显，维护起来不容易；</li><li><code>MVP</code> 模式： 在 MVC 基础上进一步解耦，视图层和模型层完全隔离，交互只能通过管理层来进行，问题是更新视图需要管理层手动来进行；</li><li><code>MVVM</code> 模式： 引入双向绑定机制，帮助实现一些更新视图层和模型层的工作，让开发者可以更专注于业务逻辑，相比于之前的模式，可以使用更少的代码量完成更复杂的交互； MVC、MVP、MVVM 模式是我们经常遇到的概念，其中 MVVM 是最常用到的，在实际项目中往往没有严格按照模式的定义来设计的系统，开发中也不一定要纠结自己用的到底是哪个模式，合适的才是最好的。</li></ul><h3 id="1-MVC-（Model-View-Controller）"><a href="#1-MVC-（Model-View-Controller）" class="headerlink" title="1. MVC （Model View Controller）"></a><strong>1. MVC （Model View Controller）</strong></h3><blockquote><p><code>MVC</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、控制器（<code>Controller</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 业务数据的处理和存储，数据更新后更新；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Controller</code> 控制器层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，接受并处理 <code>View</code> 层触发的事件，并在 <code>Model</code> 层的数据状态变动时更新 <code>View</code> 层；</li><li><code>MVC</code> 模式的目的是通过引入 <code>Controller</code> 层来将 <code>Model</code> 层和 <code>View</code> 层分离，分层的引入是原来大锅烩方式的改进，使得系统在可维护性和可读性上有了进步。</li><li><code>MVC</code> 模式提出已经有四十余年，<code>MVC</code> 模式在各个书、各个教程、<code>WIKI</code> 的解释有各种版本，甚至 <code>MVC</code> 模式在不同系统中的具体表现也不同，这里只介绍典型 <code>MVC</code> 模式的思路。</li></ul><blockquote><p>典型思路是 <code>View</code> 层通过事件通知到 <code>Controller</code> 层，<code>Controller</code> 层经过对事件的处理完成相关业务逻辑，要求 <code>Model</code> 层改变数据状态，<code>Model</code> 层再将新数据更新到 <code>View</code>层。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，以通过事件通知 <code>Controller</code> 层，经过处理后修改 <code>Model</code> 层的数据，<code>Model</code> 层使用最新数据更新 <code>View</code>。</p><p>用户也可以直接触发 <code>Controller</code> 去更新 <code>Model</code> 层状态，再更新 View 层</p><p>某些场景下，<code>View</code> 层直接采用观察者/发布订阅模式监听 <code>Model</code> 层的变化，这样 <code>View</code>层和 <code>Model</code> 层相互持有、相互操作，导致紧密耦合，在可维护性上有待提升。由此，<code>MVP</code> 模式应运而生 。</p><h3 id="2-MVP-（Model-View-Presenter）"><a href="#2-MVP-（Model-View-Presenter）" class="headerlink" title="2. MVP （Model View Presenter）"></a><strong>2. MVP （Model View Presenter）</strong></h3><blockquote><p><code>MVP</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、管理层（<code>Presenter</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 只负责存储数据，与 <code>View</code> 呈现无关，也与 <code>UI</code> 处理逻辑无关，发生更新也不用主动通知 <code>View</code>；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Presenter</code> 管理层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，处理 <code>View</code> 层的事件，负责获取数据并将获取的数据经过处理后更新 <code>View</code>；</li><li><code>MVC</code> 模式的 <code>View</code> 层和 <code>Model</code> 层存在耦合，为了解决这个问题，<code>MVP</code> 模式将 <code>View</code> 层和 <code>Model</code> 层解耦，之间的交互只能通过 <code>Presenter</code> 层，实际上，<code>MVP</code> 模式的目的就是将 <code>View</code> 层和 Model 层完全解耦，使得对 <code>View</code> 层的修改不会影响到 <code>Model</code> 层，而对 <code>Model</code> 层的数据改动也不会影响到<code>View</code> 层。</li></ul><blockquote><p>典型流程是 <code>View</code> 层触发的事件传递到 <code>Presenter</code> 层中处理，<code>Presenter</code> 层去操作 <code>Model</code> 层，并且将数据返回给 <code>View</code>层，这个过程中，<code>View</code> 层和 <code>Model</code> 层没有直接联系。而 <code>View</code> 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 <code>Presenter</code> 层来更新自己，被称为「被动视图」。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，<code>View</code> 层通知 <code>Presenter</code> 层，<code>Presenter</code> 层操作 <code>Model</code> 层的数据，<code>Presenter</code> 层获取到数据之后更新 <code>View</code>。</p><ul><li>由于 <code>Presenter</code> 层负责了数据获取、数据处理、交互逻辑、<code>UI</code> 效果等等功能，所以 <code>Presenter</code> 层就变得强大起来，相应的，<code>Model</code> 层只负责数据存储，而 <code>View</code> 层只负责视图，<code>Model</code> 和 <code>View</code> 层的责任纯粹而单一，如果我们需要添加或修改功能模块，只需要修改 <code>Presenter</code> 层就够了。由于 <code>Presenter</code> 层需要调用 <code>View</code> 层的方法更新视图，<code>Presenter</code> 层直接持有 <code>View</code> 层导致了 <code>Presenter</code> 对 <code>View</code> 的依赖。</li></ul><blockquote><p>正如上所说，更新视图需要 <code>Presenter</code> 层直接持有 <code>View</code> 层，并通过调用 <code>View</code> 层中的方法来实现，还是需要一系列复杂操作，有没有什么机制自动去更新视图而不用我们手动去更新呢，所以，<code>MVVM</code> 模式应运而生。</p></blockquote><h3 id="3-MVVM-（Model-View-ViewModel）"><a href="#3-MVVM-（Model-View-ViewModel）" class="headerlink" title="3. MVVM （Model View ViewModel）"></a><strong>3. MVVM （Model View ViewModel）</strong></h3><blockquote><p><code>MVVM</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、视图模型（<code>View-Model</code>）。</p></blockquote><p>和 <code>MVP</code> 模式类似，<code>Model</code> 层和 <code>View</code> 层也被隔离开，彻底解耦，<code>ViewModel</code> 层相当于 <code>Presenter</code> 层，负责绑定 <code>Model</code> 层和 <code>View</code> 层，相比于 <code>MVP</code> 增加了双向绑定机制。</p><blockquote><p><code>MVVM</code> 模式的特征是 <code>ViewModel</code> 层和 <code>View</code> 层采用双向绑定的形式（Binding），<code>View</code> 层的变动，将自动反映在 <code>ViewModel</code> 层，反之亦然。</p></blockquote><ul><li>但是双向绑定给调试和错误定位带来困难，<code>View</code> 层的异常可能是 <code>View</code> 的代码有问题，也有可能是 <code>Model</code> 层的问题。数据绑定使得一个位置的 <code>Bug</code> 被传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li><li>对简单<code>UI</code> 来说，实现 <code>MVVM</code> 模式的开销是不必要的，而对于大型应用来说，引入 MVVM 模式则会节约大量手动更新视图的复杂过程，是否使用，还是看使用场景。</li></ul><p>这是为什么呢，因为 <code>MVVM</code> 模式要求 <code>Model</code> 层和 <code>View</code> 层完全解耦，但是由于 <code>Vue</code> 还提供了 <code>ref</code> 这样的 <code>API</code>，使得 <code>Model</code> 也可以直接持有 <code>View</code>：</p><p>但是大多数帖子都说直接称呼 <code>Vue</code> 为 <code>MVVM</code> 框架，可见这些模式的划分也不是那么严格。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见设计模式&quot;&gt;&lt;a href=&quot;#常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式&quot;&gt;&lt;/a&gt;常见设计模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#1-为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要学习设计模式？&quot;&gt;&lt;/a&gt;1.为什么要学习设计模式？&lt;/h2&gt;&lt;p&gt;在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。&lt;/p&gt;
&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;2-什么是设计模式。&quot;&gt;&lt;a href=&quot;#2-什么是设计模式。&quot; class=&quot;headerlink&quot; title=&quot;2.什么是设计模式。&quot;&gt;&lt;/a&gt;2.什么是设计模式。&lt;/h2&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;h2 id=&quot;3-设计模式的发展历史&quot;&gt;&lt;a href=&quot;#3-设计模式的发展历史&quot; class=&quot;headerlink&quot; title=&quot;3.设计模式的发展历史&quot;&gt;&lt;/a&gt;3.设计模式的发展历史&lt;/h2&gt;&lt;p&gt;设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。&lt;/p&gt;
&lt;p&gt;四人帮把这本书分成两部分：&lt;/p&gt;
&lt;p&gt;第一部分解释面向对象编程的优缺点。&lt;/p&gt;
&lt;p&gt;第二部分是关于 23 个经典设计模式的演变。&lt;/p&gt;
&lt;p&gt;自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。&lt;/p&gt;
&lt;h2 id=&quot;4-设计模式分类&quot;&gt;&lt;a href=&quot;#4-设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;4.设计模式分类&quot;&gt;&lt;/a&gt;4.设计模式分类&lt;/h2&gt;&lt;p&gt;根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来将概述属于这三种类型的 23 种设计模式的主要概念。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Weppack面试题整理</title>
    <link href="https://hxy1997.xyz/2020/10/20/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2020/10/20/Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2021-03-12T02:09:49.508Z</updated>
    
    <content type="html"><![CDATA[<p>这一块知识是我的盲区（话说我的盲区也太多了吧，根本就是眼瞎😭）直接复制人家整理好的吧 <a href="https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打Webpack面试题</a>，感觉自己啥也不会，就知道它是用来打包的工具</p><span id="more"></span><p>本文已收录在<code>Github</code> <a href="https://github.com/Geekhyt/front-end-canteen/">github.com/Geekhyt</a>，欢迎Star。</p><p>从头发的浓密程度和干练的走路姿势我察觉到，面前坐着的这位面试官也是一把好手。我像以往一样，准备花3分钟的时间进行自我介绍。在此期间，我的目光被16寸的MacBook Pro所吸引，这次的自我介绍我做足了准备，很有信心征服面试官。不出我所料，面试官被我引入了我擅长的领域。</p><blockquote><p>❝</p><p>看来你对Webpack很熟悉，那我来考考你</p><p>❞</p></blockquote><h1 id="0-有哪些常见的Loader？你用过哪些Loader？"><a href="#0-有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="0.有哪些常见的Loader？你用过哪些Loader？"></a>0.有哪些常见的Loader？你用过哪些Loader？</h1><p>(我开始熟悉的报起了菜名)</p><ul><li><code>raw-loader</code>：加载文件原始内容（utf-8）</li><li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li><li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li><li><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</li><li><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</li><li><code>image-loader</code>：加载并且压缩图片文件</li><li><code>json-loader</code> 加载 JSON 文件（默认包含）</li><li><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</li><li><code>babel-loader</code>：把 ES6 转换成 ES5</li><li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li><li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li><li><code>sass-loader</code>：将SCSS/SASS代码转换成CSS</li><li><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</li><li><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li><li><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</li><li><code>mocha-loader</code>：加载 Mocha 测试用例的代码</li><li><code>coverjs-loader</code>：计算测试的覆盖率</li><li><code>vue-loader</code>：加载 Vue.js 单文件组件</li><li><code>i18n-loader</code>: 国际化</li><li><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ul><p>更多 Loader 请参考<a href="https://webpack.docschina.org/loaders/">官网</a></p><p>(面试官：挺好，知道的还挺多)</p><h1 id="1-有哪些常见的Plugin？你用过哪些Plugin？"><a href="#1-有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="1.有哪些常见的Plugin？你用过哪些Plugin？"></a>1.有哪些常见的Plugin？你用过哪些Plugin？</h1><p>(这大兄弟好像听上瘾了，继续开启常规操作)</p><ul><li><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li><code>ignore-plugin</code>：忽略部分文件</li><li><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</li><li><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li><li><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</li><li><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</li><li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li><li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</li><li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</li><li><code>clean-webpack-plugin</code>: 目录清理</li><li><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</li><li><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li><li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li></ul><p>更多 Plugin 请参考<a href="https://webpack.docschina.org/plugins/">官网</a></p><p>(Double Kill)</p><h1 id="2-那你再说一说Loader和Plugin的区别？"><a href="#2-那你再说一说Loader和Plugin的区别？" class="headerlink" title="2.那你再说一说Loader和Plugin的区别？"></a>2.那你再说一说Loader和Plugin的区别？</h1><p>(就知道你会问这个，我用手掩盖着嘴角的微笑)</p><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h1 id="3-Webpack构建流程简单说一下"><a href="#3-Webpack构建流程简单说一下" class="headerlink" title="3.Webpack构建流程简单说一下"></a>3.Webpack构建流程简单说一下</h1><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li><li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><p>简单说</p><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li><li>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><p>对源码感兴趣的同学可以移步我的另一篇专栏<a href="https://juejin.im/post/6844904046294204429">从源码窥探Webpack4.x原理</a></p><h1 id="4-使用webpack开发时，你用过哪些可以提高效率的插件？"><a href="#4-使用webpack开发时，你用过哪些可以提高效率的插件？" class="headerlink" title="4.使用webpack开发时，你用过哪些可以提高效率的插件？"></a>4.使用webpack开发时，你用过哪些可以提高效率的插件？</h1><p>(这道题还蛮注重实际，用户的体验还是要从小抓起的)</p><ul><li><code>webpack-dashboard</code>：可以更友好的展示相关打包信息。</li><li><code>webpack-merge</code>：提取公共配置，减少重复配置代码</li><li><code>speed-measure-webpack-plugin</code>：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li><code>size-plugin</code>：监控资源体积变化，尽早发现问题</li><li><code>HotModuleReplacementPlugin</code>：模块热替换</li></ul><h1 id="5-source-map是什么？生产环境怎么用？"><a href="#5-source-map是什么？生产环境怎么用？" class="headerlink" title="5.source map是什么？生产环境怎么用？"></a>5.source map是什么？生产环境怎么用？</h1><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p><p>map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li><li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h1 id="6-模块打包原理知道吗？"><a href="#6-模块打包原理知道吗？" class="headerlink" title="6.模块打包原理知道吗？"></a>6.模块打包原理知道吗？</h1><p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p><h1 id="7-文件监听原理呢？"><a href="#7-文件监听原理呢？" class="headerlink" title="7.文件监听原理呢？"></a>7.文件监听原理呢？</h1><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p><p>Webpack开启监听模式，有两种方式：</p><ul><li>启动 webpack 命令时，带上 –watch 参数</li><li>在配置 webpack.config.js 中设置 watch:true</li></ul><p>缺点：每次需要手动刷新浏览器</p><p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <code>aggregateTimeout</code> 后再执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.export &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认false,也就是不开启</span><br><span class="line">    watch: true,</span><br><span class="line">    &#x2F;&#x2F; 只有开启监听模式时，watchOptions才有意义</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为空，不监听的文件或者文件夹，支持正则匹配</span><br><span class="line">        ignored: &#x2F;node_modules&#x2F;,</span><br><span class="line">        &#x2F;&#x2F; 监听到变化发生后会等300ms再去执行，默认300ms</span><br><span class="line">        aggregateTimeout:300,</span><br><span class="line">        &#x2F;&#x2F; 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次</span><br><span class="line">        poll:1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-说一下-Webpack-的热更新原理吧"><a href="#8-说一下-Webpack-的热更新原理吧" class="headerlink" title="8.说一下 Webpack 的热更新原理吧"></a>8.说一下 Webpack 的热更新原理吧</h1><p>(敲黑板，这道题必考)</p><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><p>细节请参考<a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></p><p>(面试官：不错不错，小伙子表达能力不错)</p><p>(基操，勿6)</p><h1 id="9-如何对bundle体积进行监控和分析？"><a href="#9-如何对bundle体积进行监控和分析？" class="headerlink" title="9.如何对bundle体积进行监控和分析？"></a>9.如何对bundle体积进行监控和分析？</h1><p><code>VSCode</code> 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，还可以使用 <code>webpack-bundle-analyzer</code> 生成 <code>bundle</code> 的模块组成图，显示所占体积。</p><p><code>bundlesize</code> 工具包可以进行自动化资源体积监控。</p><h1 id="10-文件指纹是什么？怎么用？"><a href="#10-文件指纹是什么？怎么用？" class="headerlink" title="10.文件指纹是什么？怎么用？"></a>10.文件指纹是什么？怎么用？</h1><p>文件指纹是打包后输出的文件名的后缀。</p><ul><li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</li><li><code>Chunkhash</code>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</li><li><code>Contenthash</code>：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</li></ul><h2 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h2><p>设置 output 的 filename，用 chunkhash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;scr&#x2F;app.js&#39;,</span><br><span class="line">        search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;[name][chunkhash:8].js&#39;,</span><br><span class="line">        path:__dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h2><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &#39;.&#x2F;scr&#x2F;app.js&#39;,</span><br><span class="line">        search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#39;[name][chunkhash:8].js&#39;,</span><br><span class="line">        path:__dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#96;[name][contenthash:8].css&#96;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h2><p>设置file-loader的name，使用hash。</p><p>占位符名称及含义</p><ul><li>ext 资源后缀名</li><li>name 文件名称</li><li>path 文件的相对路径</li><li>folder 文件所在的文件夹</li><li>contenthash 文件的内容hash，默认是md5生成</li><li>hash 文件内容的hash，默认是md5生成</li><li>emoji 一个随机的指代文件内容的emoj</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename:&#39;bundle.js&#39;,</span><br><span class="line">        path:path.resolve(__dirname, &#39;dist&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:&#x2F;\.(png|svg|jpg|gif)$&#x2F;,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:&#39;file-loader&#39;,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    name:&#39;img&#x2F;[name][hash:8].[ext]&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"><a href="#11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？" class="headerlink" title="11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"></a>11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？</h1><p>可以使用 <code>enforce</code> 强制执行 <code>loader</code> 的作用顺序，<code>pre</code> 代表在所有正常 loader 之前执行，<code>post</code> 是所有 loader 之后执行。(inline 官方不推荐使用)</p><h1 id="12-如何优化-Webpack-的构建速度？"><a href="#12-如何优化-Webpack-的构建速度？" class="headerlink" title="12.如何优化 Webpack 的构建速度？"></a>12.如何优化 Webpack 的构建速度？</h1><p>(这个问题就像能不能说一说<strong>「从URL输入到页面显示发生了什么」</strong>一样）</p><p>(我只想说：您希望我讲多长时间呢？)</p><p>(面试官：。。。)</p><ul><li>使用<code>高版本</code>的 Webpack 和 Node.js</li><li><code>多进程/多实例构建</code>：HappyPack(不维护了)、thread-loader</li><li><code>压缩代码</code><ul><li>多进程并行压缩<ul><li>webpack-paralle-uglify-plugin</li><li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li><li>terser-webpack-plugin 开启 parallel 参数</li></ul></li><li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li></ul></li><li><code>图片压缩</code><ul><li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li><li>配置 image-webpack-loader</li></ul></li><li><code>缩小打包作用域</code>：<ul><li>exclude/include (确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li>IgnorePlugin (完全排除模块)</li><li>合理使用alias</li></ul></li><li><code>提取页面公共资源</code>：<ul><li>基础包分离：<ul><li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li><li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</li></ul></li></ul></li><li><code>DLL</code>：<ul><li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li><li>HashedModuleIdsPlugin 可以解决模块数字id问题</li></ul></li><li><code>充分利用缓存提升二次构建速度</code>：<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li><code>Tree shaking</code><ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul><li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li></ul></li></ul></li><li><code>Scope hoisting</code><ul><li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li><li>必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li></ul></li><li><code>动态Polyfill</code><ul><li>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li></ul></li></ul><p>更多优化请参考<a href="https://www.webpackjs.com/guides/build-performance/">官网-构建性能</a></p><h1 id="13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"><a href="#13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？" class="headerlink" title="13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"></a>13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？</h1><p>代码分割的本质其实就是在<code>源代码直接上线</code>和<code>打包成唯一脚本main.bundle.js</code>这两种极端方案之间的一种更适合实际场景的中间状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阿卡丽：荣耀剑下取，均衡乱中求</span><br></pre></td></tr></table></figure><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><p>(Easy peezy right)</p><h1 id="14-是否写过Loader？简单描述一下编写loader的思路？"><a href="#14-是否写过Loader？简单描述一下编写loader的思路？" class="headerlink" title="14.是否写过Loader？简单描述一下编写loader的思路？"></a>14.是否写过Loader？简单描述一下编写loader的思路？</h1><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><p><a href="https://www.webpackjs.com/api/loaders/">Loader的API</a> 可以去官网查阅</p><ul><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<ul><li>Npm link</li><li>ResolveLoader</li></ul></li></ul><h1 id="15-是否写过Plugin？简单描述一下编写Plugin的思路？"><a href="#15-是否写过Plugin？简单描述一下编写Plugin的思路？" class="headerlink" title="15.是否写过Plugin？简单描述一下编写Plugin的思路？"></a>15.是否写过Plugin？简单描述一下编写Plugin的思路？</h1><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><p><a href="https://www.webpackjs.com/api/plugins/">Plugin的API</a> 可以去官网查阅</p><ul><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>找出合适的事件点去完成想要的功能<ul><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</li><li>watch-run 当依赖的文件发生变化时会触发</li></ul></li><li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li></ul><h1 id="16-聊一聊Babel原理吧"><a href="#16-聊一聊Babel原理吧" class="headerlink" title="16.聊一聊Babel原理吧"></a>16.聊一聊Babel原理吧</h1><p>大多数JavaScript Parser遵循 <code>estree</code> 规范，Babel 最初基于 <code>acorn</code> 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p><ul><li>解析：将代码转换成 AST<ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ul><li><a href="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15">Taro</a>就是利用 babel 完成的小程序语法转换</li></ul></li><li>生成：以新的 AST 为基础生成代码</li></ul><p>想了解如何一步一步实现一个编译器的同学可以移步 Babel 官网曾经推荐的开源项目 <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">the-super-tiny-compiler</a></p><blockquote><p>❝</p><p>面试官：(我听的口渴了，咱们休息一会，一会进行下半场)</p><p>❞</p></blockquote><p>面试官拿起旁边已经凉透的龙井，喝了一口。</p><p>(这小伙子有点东西)</p><p><strong>「持续更新……」</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>深入浅出 Webpack</li><li>Webpack 实战</li><li>玩转 Webpack</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一块知识是我的盲区（话说我的盲区也太多了吧，根本就是眼瞎😭）直接复制人家整理好的吧 &lt;a href=&quot;https://juejin.cn/post/6844904094281236487&quot;&gt;「吐血整理」再来一打Webpack面试题&lt;/a&gt;，感觉自己啥也不会，就知道它是用来打包的工具&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Weppack" scheme="https://hxy1997.xyz/tags/Weppack/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="打包" scheme="https://hxy1997.xyz/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js函数手写</title>
    <link href="https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/"/>
    <id>https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2021-03-29T14:34:57.667Z</updated>
    
    <content type="html"><![CDATA[<p>手写常见js函数，面试必备，多练几遍，争取手撕</p><span id="more"></span><h1 id="1-手动实现call-apply-bind"><a href="#1-手动实现call-apply-bind" class="headerlink" title="1.手动实现call,apply,bind"></a>1.手动实现call,apply,bind</h1><h2 id="模拟实现call"><a href="#模拟实现call" class="headerlink" title="模拟实现call"></a>模拟实现call</h2><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>r5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span></span><br><span class="line"><span class="comment">* args 为一个数组或者类数组对象，是调用函数时的参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// 这里this指向调用myCall的函数</span></span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，调用myCall的函数,并接收返回值</span></span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 最后删除这个临时属性</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span></span><br><span class="line"><span class="comment">* args 为一个数组或者类数组对象，是调用函数时的参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// 这里this指向调用myApply的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 最后删除这个临时属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h2><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试够用版"><a href="#面试够用版" class="headerlink" title="面试够用版"></a>面试够用版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span><br><span class="line">* args 为一个数组或者类数组对象，是调用函数时的参数列表</span><br><span class="line">*&#x2F;</span><br><span class="line">Function.prototype.myBind &#x3D; function (context &#x3D; window, ...args) &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span><br><span class="line">    let fn &#x3D; Symbol();</span><br><span class="line">    &#x2F;&#x2F; 这里this指向调用myApply的函数</span><br><span class="line">    context[fn] &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 返回闭包函数</span><br><span class="line">    return function (..._args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 与当前参数组合</span><br><span class="line">        args &#x3D; args.concat(_args);</span><br><span class="line">        &#x2F;&#x2F; 重点代码，执行函数</span><br><span class="line">        context[fn](...args);</span><br><span class="line">        &#x2F;&#x2F; 最后删除这个临时属性</span><br><span class="line">        delete context[fn];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>获取函数中的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    fn(...args);</span><br><span class="line">    fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以广泛应用于异步编程，它可以代替我们传统的回调函数</li><li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li><li>取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。</li><li>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</li></ul><h2 id="Nodejs的EventEmitter"><a href="#Nodejs的EventEmitter" class="headerlink" title="Nodejs的EventEmitter"></a>Nodejs的EventEmitter</h2><p><code>Nodejs</code>的<code>EventEmitter</code>就是观察者模式的典型实现，<code>Nodejs</code>的<code>events</code>模块只提供了一个对象： <code>events.EventEmitter``。EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。</p><blockquote><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p></blockquote><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p><strong>addListener(event, listener)</strong></p><p>为指定事件添加一个监听器，默认添加到监听器数组的尾部。</p><p><strong>removeListener(event, listener)</strong></p><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><p><strong>setMaxListeners(n)</strong></p><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p><p><strong>once(event, listener)</strong></p><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p><p><strong>emit(event, [arg1], [arg2], […])</strong></p><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，调用一次，处理函数为 listener2</span></span><br><span class="line">eventEmitter.once(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="手动实现EventEmitter"><a href="#手动实现EventEmitter" class="headerlink" title="手动实现EventEmitter"></a>手动实现EventEmitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件</span></span><br><span class="line"><span class="comment">// prepend为true表示向事件队列头部添加事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, prepend</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].unshift(listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type] = [listener];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某个事件</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>._events[type]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type] = <span class="built_in">this</span>._events[type].filter(<span class="function"><span class="params">e</span> =&gt;</span> e !== listener &amp;&amp; e.origin !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件，只执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> only = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="built_in">this</span>.addListener(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某类事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大事件监听个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.maxListeners = count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceListener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我只能被执行一次&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我是一个listener&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">&#x27;click&#x27;</span>, onceListener);</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">emitter.removeListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JavaScript自定义事件"><a href="#JavaScript自定义事件" class="headerlink" title="JavaScript自定义事件"></a>JavaScript自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建事件</span></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;myEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册事件监听器</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;myEvent&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、触发事件</span></span><br><span class="line">elem.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><h1 id="3-防抖-debounce"><a href="#3-防抖-debounce" class="headerlink" title="3.防抖(debounce)"></a>3.防抖(debounce)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p><p>在前端开发中会遇到一些频繁的事件触发，比如：</p><ol><li>window 的 resize、scroll</li><li>mousedown、mousemove</li><li>keyup、keydown<br>……</li></ol><p>为此，我们举个示例代码来了解事件如何频繁的触发：</p><p>我们写个 <code>index.html</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;zh-cmn-Hans&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;x-ua-compatible&quot; content&#x3D;&quot;IE&#x3D;edge, chrome&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;title&gt;debounce&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #container&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #444;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;debounce.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><code>debounce.js</code> 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var container &#x3D; document.getElementById(&#39;container&#39;);</span><br><span class="line"></span><br><span class="line">function getUserAction() &#123;</span><br><span class="line">    container.innerHTML &#x3D; count++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">container.onmousemove &#x3D; getUserAction;</span><br></pre></td></tr></table></figure><p>我们来看看效果：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce.gif" alt="debounce"></a></p><p>从左边滑到右边就触发了 165 次 getUserAction 函数！</p><p>因为这个例子很简单，所以浏览器完全反应的过来，可是如果是复杂的回调函数或是 ajax 请求呢？假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。</p><p>为了解决这个问题，一般有两种解决方案：</p><ol><li>debounce 防抖</li><li>throttle 节流</li></ol><h2 id="防抖是什么"><a href="#防抖是什么" class="headerlink" title="防抖是什么"></a>防抖是什么</h2><p>今天重点讲讲防抖的实现。</p><p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>根据这段表述，我们可以写第一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要使用它，以最一开始的例子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.onmousemove &#x3D; debounce(getUserAction, 1000);</span><br></pre></td></tr></table></figure><p>现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce-1.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce-1.gif" alt="debounce 第一版"></a></p><p>顿时就从 165 次降低成了 1 次!</p><p>棒棒哒，我们接着完善它。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如果我们在 <code>getUserAction</code> 函数中 <code>console.log(this)</code>，在不使用 <code>debounce</code> 函数的时候，<code>this</code> 的值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！</p><p>所以我们需要将 this 指向正确的对象。</p><p>我们修改下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">            func.apply(context)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 this 已经可以正确指向了。让我们看下个问题：</p><h2 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h2><p>JavaScript 在事件处理函数中会提供事件对象 event，我们修改下 getUserAction 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">    container.innerHTML &#x3D; count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们不使用 debouce 函数，这里会打印 MouseEvent 对象，如图所示：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/event.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/event.png" alt="MouseEvent"></a></p><p>但是在我们实现的 debounce 函数中，却只会打印 undefined!</p><p>所以我们再修改一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们修复了两个小问题：</p><ol><li>this 指向</li><li>event 对象</li></ol><h2 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h2><p>这个时候，代码已经很是完善了，但是为了让这个函数更加完善，我们接下来思考一个新的需求。</p><p>这个需求就是：</p><p>我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。</p><p>想想这个需求也是很有道理的嘛，那我们加个 immediate 参数判断是否是立刻执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    </span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timeout;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) func.apply(context, args)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看使用效果：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce-4.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/debounce/debounce-4.gif" alt="debounce 第四版"></a></p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>此时注意一点，就是 getUserAction 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以我们只在 immediate 为 true 的时候返回函数的执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第五版</span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timeout;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result &#x3D; func.apply(context, args)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>最后我们再思考一个小需求，我希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦，是不是很开心？</p><p>为了这个需求，我们写最后一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第六版</span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var debounced &#x3D; function () &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timeout;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result &#x3D; func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel &#x3D; function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么该如何使用这个 cancel 函数呢？依然是以上面的 demo 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var container &#x3D; document.getElementById(&#39;container&#39;);</span><br><span class="line"></span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    container.innerHTML &#x3D; count++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var setUseAction &#x3D; debounce(getUserAction, 10000, true);</span><br><span class="line"></span><br><span class="line">container.onmousemove &#x3D; setUseAction;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;button&quot;).addEventListener(&#39;click&#39;, function()&#123;</span><br><span class="line">    setUseAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>演示效果如下：</p><p><a href="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/debounce/debounce-cancel.gif"><img data-src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/debounce/debounce-cancel.gif" alt="debounce-cancel"></a></p><p>至此我们已经完整实现了一个 underscore 中的 debounce 函数，恭喜，撒花！</p><h2 id="面试版代码"><a href="#面试版代码" class="headerlink" title="面试版代码"></a>面试版代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><blockquote><p>按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</p></blockquote><h1 id="4-节流-throttle"><a href="#4-节流-throttle" class="headerlink" title="4.节流(throttle)"></a>4.节流(throttle)</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p><h2 id="节流是什么"><a href="#节流是什么" class="headerlink" title="节流是什么"></a>节流是什么</h2><p>节流的原理很简单：</p><p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p><p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。<br>我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p><p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p><h2 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h2><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p><p>看了这个表述，是不是感觉已经可以写出代码了…… 让我们来写第一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var context, args;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">        if (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子依然是用讲 debounce 中的例子，如果你要使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.onmousemove &#x3D; throttle(getUserAction, 1000);</span><br></pre></td></tr></table></figure><p>效果演示如下：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle1.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle1.gif" alt="使用时间戳"></a></p><p>我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。</p><h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>接下来，我们讲讲第二种实现方式，使用定时器。</p><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">        if (!timeout) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让效果更加明显，我们设置 wait 的时间为 3s，效果演示如下：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle2.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle2.gif" alt="使用定时器"></a></p><p>我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。</p><p>所以比较两个方法：</p><ol><li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li><li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li></ol><h2 id="双剑合璧"><a href="#双剑合璧" class="headerlink" title="双剑合璧"></a>双剑合璧</h2><p>那我们想要一个什么样的呢？</p><p>有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！</p><p>所以我们综合两者的优势，然后双剑合璧，写一版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">        previous &#x3D; +new Date();</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        &#x2F;&#x2F;下次触发 func 剩余的时间</span><br><span class="line">        var remaining &#x3D; wait - (now - previous);</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">         &#x2F;&#x2F; 如果没有剩余的时间了或者你改了系统时间</span><br><span class="line">        if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; else if (!timeout) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示如下：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle3.gif"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/throttle/throttle3.gif" alt="throttle3"></a></p><p>我们可以看到：鼠标移入，事件立刻执行，晃了 3s，事件再一次执行，当数字变成 3 的时候，也就是 6s 后，我们立刻移出鼠标，停止触发事件，9s 的时候，依然会再执行一次事件。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>但是我有时也希望无头有尾，或者有头无尾，这个咋办？</p><p>那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p><p>leading：false 表示禁用第一次执行<br>trailing: false 表示禁用停止触发的回调</p><p>我们来改一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    if (!options) options &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">        previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : new Date().getTime();</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">        var now &#x3D; new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; now;</span><br><span class="line">        var remaining &#x3D; wait - (now - previous);</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">        if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消-1"><a href="#取消-1" class="headerlink" title="取消"></a>取消</h2><p>在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第五版 非完整代码，完整代码请查看最后的演示代码链接</span><br><span class="line">...</span><br><span class="line">throttled.cancel &#x3D; function() &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous &#x3D; 0;</span><br><span class="line">    timeout &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们要注意 underscore 的实现中有这样一个问题：</p><p>那就是 <code>leading：false</code> 和 <code>trailing: false</code> 不能同时设置。</p><p>如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">container.onmousemove &#x3D; throttle(getUserAction, 1000);</span><br><span class="line">container.onmousemove &#x3D; throttle(getUserAction, 1000, &#123;</span><br><span class="line">    leading: false</span><br><span class="line">&#125;);</span><br><span class="line">container.onmousemove &#x3D; throttle(getUserAction, 1000, &#123;</span><br><span class="line">    trailing: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此我们已经完整实现了一个 underscore 中的 throttle 函数，恭喜，撒花！</p><h2 id="面试版代码-1"><a href="#面试版代码-1" class="headerlink" title="面试版代码"></a>面试版代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><blockquote><ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器<code>resize</code></li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul></blockquote><h1 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h1><p><strong>深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型赋值，则会进行地址的拷贝，最终两个变量指向同一份数据。</strong>对于引用类型，会导致a b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个，有时候这可能不是我们想要的结果，如果对这种现象不清楚的话，还可能造成不必要的bug。</p><p>那么如何切断a和b之间的关系呢，可以拷贝一份a的数据，根据拷贝的层级不同可以分为浅拷贝和深拷贝，浅拷贝就是只进行一层拷贝，深拷贝就是无限层级拷贝<strong>假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</strong></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="简单版："><a href="#简单版：" class="headerlink" title="简单版："></a>简单版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a><strong>局限性：</strong></h3><ul><li>他无法实现对函数 、RegExp等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用,会报错</li></ul><h3 id="面试版-递归"><a href="#面试版-递归" class="headerlink" title="面试版:递归"></a>面试版:递归</h3><p>考虑到数组和对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">let res </span><br><span class="line">&#x2F;&#x2F; 判断是否是简单数据类型</span><br><span class="line">if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">&#x2F;&#x2F; 复杂数据类型</span><br><span class="line">res &#x3D; obj.constructor &#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">res[i] &#x3D; typeof obj[i] &#x3D;&#x3D; &quot;object&quot; ? deepCopy(obj[i]) : obj[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 简单数据类型 直接 &#x3D;&#x3D; 赋值</span><br><span class="line">res &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>上述版本执行下面这样一个测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;</span><br></pre></td></tr></table></figure><p>因为递归进入死循环导致栈内存溢出了。</p><p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p><p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p><p>这个存储空间，需要可以存储 <code>key-value</code>形式的数据，且 <code>key</code>可以是一个引用类型，我们可以选择 <code>Map</code>这种数据结构：</p><ul><li>检查<code>map</code>中有无克隆过的对象</li><li>有 - 直接返回</li><li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li><li>继续克隆</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        res = obj.constructor == <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(obj, res);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            res[i] = <span class="keyword">typeof</span> obj[i] == <span class="string">&quot;object&quot;</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 简单数据类型 直接 == 赋值</span></span><br><span class="line">res = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，执行没有报错，且 <code>target</code>属性，变为了一个 <code>Circular</code>类型，即循环应用的意思。</p><p>接下来，我们可以使用， <code>WeakMap</code>提代 <code>Map</code>来使代码达到画龙点睛的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么要这样做呢？，先来看看 <code>WeakMap</code>的作用：</p><blockquote><p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p></blockquote><p>什么是弱引用呢？</p><blockquote><p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p></blockquote><p>我们默认创建一个对象：<code>const obj=&#123;&#125;</code>，就默认创建了一个强引用的对象，我们只有手动将 <code>obj=null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p><p>举个例子：</p><p>如果我们使用 <code>Map</code>的话，那么对象间是存在强引用关系的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">&#x27;ConardLi&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    obj:<span class="string">&#x27;code秘密花园&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>虽然我们手动将 <code>obj</code>，进行释放，然是 <code>target</code>依然对 <code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p><p>再来看 <code>WeakMap</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">&#x27;ConardLi&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">target.set(obj,<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果是 <code>WeakMap</code>的话， <code>target</code>和 <code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p><p>设想一下，如果我们要拷贝的对象非常庞大时，使用 <code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除 <code>Map</code>的属性才能释放这块内存，而 <code>WeakMap</code>会帮我们巧妙化解这个问题。</p><p>我也经常在某些代码中看到有人使用 <code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解 <code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p><p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用 <code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>在上面的代码中，我们遍历数组和对象都使用了 <code>forin</code>这种方式，实际上 <code>forin</code>在遍历时效率是非常低的，对比下常见的三种循环 <code>for、while、forin</code>的执行效率：</p><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3713434/sf9725l2cd.jpeg?imageView2/2/w/1620" alt="img"></p><p> <code>while</code>的效率是最好的，所以，我们可以想办法把 <code>forin</code>遍历改变为 <code>while</code>遍历。</p><p>我们先使用 <code>while</code>来实现一个通用的 <code>forEach</code>遍历， <code>iteratee</code>是遍历的回掉函数，他可以接收每次遍历的 <code>value</code>和 <code>index</code>两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对我们的 <code>cloen</code>函数进行改写：当遍历数组时，直接使用 <code>forEach</code>进行遍历，当遍历对象时，使用 <code>Object.keys</code>取出所有的 <code>key</code>进行遍历，然后在遍历时把 <code>forEach</code>会调函数的 <code>value</code>当作 <code>key</code>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        res = obj.constructor == <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(obj, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> keys = obj.constructor == <span class="built_in">Array</span> ?  <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">        forEach(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">                key = value;</span><br><span class="line">            &#125;</span><br><span class="line">            res[key] = deepCopy(obj[key], map);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 简单数据类型 直接 == 赋值</span></span><br><span class="line">res = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h3><p>在上面的代码中，我们其实只考虑了普通的 <code>object</code>和 <code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p><h4 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="headerlink" title="合理的判断引用类型"></a>合理的判断引用类型</h4><p>首先，判断是否为引用类型，我们还需要考虑 <code>function</code>和 <code>null</code>两种特殊的数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h4><p>我们可以使用 <code>toString</code>来获取准确的引用类型：</p><blockquote><p>每一个引用类型都有 <code>toString</code>方法，默认情况下， <code>toString()</code>方法被每个 <code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，t <code>oString()</code>返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p></blockquote><p>注意，上面提到了如果此方法在自定义对象中未被覆盖， <code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如 <code>Array、Date、RegExp</code>等都重写了 <code>toString</code>方法。</p><p>我们可以直接调用 <code>Object</code>原型上未被覆盖的 <code>toString()</code>方法，使用 <code>call</code>来改变 <code>this</code>指向来达到我们想要的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3713434/nb0dwyns7q.jpeg?imageView2/2/w/1620" alt="img"></p><p>下面我们抽离出一些常用的数据类型以便后面使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上面的集中类型中，我们简单将他们分为两类：</p><ul><li>可以继续遍历的类型</li><li>不可以继续遍历的类型</li></ul><p>我们分别为它们做不同的拷贝。</p><h4 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="headerlink" title="可继续遍历的类型"></a>可继续遍历的类型</h4><p>上面我们已经考虑的 <code>object</code>、 <code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有 <code>Map</code>， <code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p><p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的 <code>[]</code>和 <code>&#123;&#125;</code>，我们可以通过拿到 <code>constructor</code>的方式来通用的获取。</p><p>例如：<code>consttarget=&#123;&#125;</code>就是 <code>consttarget=newObject()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的 <code>&#123;&#125;</code>，那么原型必然是丢失了的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们改写 <code>clone</code>函数，对可继续遍历的数据类型进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 克隆原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> type = getType(obj);</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">        res = getInit(obj, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(obj, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆set</span></span><br><span class="line">    <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">        ob.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            res.add(deepCopy(value));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆map</span></span><br><span class="line">    <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            res.set(key, deepCopy(value));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆对象和数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    forEach(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        res[key] = deepCopy(obj[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行clone5.test.js对下面的测试用例进行测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3713434/fh73smmild.jpeg?imageView2/2/w/1620" alt="img"></p><p>没有问题，继续处理其他类型：</p><h4 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="headerlink" title="不可继续遍历的类型"></a>不可继续遍历的类型</h4><p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p><p><code>Bool</code>、 <code>Number</code>、 <code>String</code>、 <code>String</code>、 <code>Date</code>、 <code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">obj, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = obj.constructor;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag:</span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneReg(obj);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(obj);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆 <code>Symbol</code>类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">克隆正则：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> obj.constructor(obj.source, reFlags.exec(obj));</span><br><span class="line">    res.lastIndex = obj.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p><p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对 <code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p><h3 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h3><p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下 <code>lodash</code>对函数的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value == <span class="string">&#x27;function&#x27;</span></span><br><span class="line"> <span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p><p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p><p>首先，我们可以通过 <code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有 <code>prototype</code>的。</p><p>我们可以直接使用 <code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p><p>我们可以使用正则来处理普通函数：</p><p>分别使用正则取出函数体和函数参数，然后使用 <code>newFunction([arg1[,arg2[,...argN]],]functionBody)</code>构造函数重新构造一个新的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;普通函数&#x27;);</span></span><br><span class="line">        <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">        <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">        <span class="keyword">if</span> (body) &#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;匹配到函数体：&#x27;, body[0]);</span></span><br><span class="line">            <span class="keyword">if</span> (param) &#123;</span><br><span class="line">                <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;匹配到参数：&#x27;</span>, paramArr);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们再来执行clone6.test.js对下面的测试用例进行测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;ConardLi&#x27;</span>, <span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line">set.add(<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    set,</span><br><span class="line">    bool: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">    num: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>),</span><br><span class="line">    str: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">2</span>),</span><br><span class="line">    symbol: <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="number">1</span>)),</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">    error: <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">    func1: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3713434/xtb15ikjai.jpeg?imageView2/2/w/1620" alt="img"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>为了更好的阅读，我们用一张图来展示上面所有的代码：</p><p><img data-src="https://ask.qcloudimg.com/http-save/yehe-3713434/im20c61hq4.jpeg?imageView2/2/w/1620" alt="img"></p><p>完整代码：<a href="https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js">https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js</a></p><p>可见，一个小小的深拷贝还是隐藏了很多的知识点的。</p><p>千万不要以最低的要求来要求自己，如果你只是为了应付面试中的一个题目，那么你可能只会去准备上面最简陋的深拷贝的方法。</p><p>但是面试官考察你的目的是全方位的考察你的思维能力，如果你写出上面的代码，可以体现你多方位的能力：</p><ul><li>基本实现<ul><li>递归能力</li></ul></li><li>循环引用<ul><li>考虑问题的全面性</li><li>理解weakmap的真正意义</li></ul></li><li>多种类型<ul><li>考虑问题的严谨性</li><li>创建各种引用类型的方法，JS API的熟练程度</li><li>准确的判断数据类型，对数据类型的理解程度</li></ul></li><li>通用遍历：<ul><li>写代码可以考虑性能优化</li><li>了解集中遍历的效率</li><li>代码抽象能力</li></ul></li><li>拷贝函数：<ul><li>箭头函数和普通函数的区别</li><li>正则表达式熟练程度</li></ul></li></ul><p>看吧，一个小小的深拷贝能考察你这么多的能力，如果面试官看到这样的代码，怎么能够不惊艳呢？</p><p>其实面试官出的所有题目你都可以用这样的思路去考虑。不要为了应付面试而去背一些代码，这样在有经验的面试官面前会都会暴露出来。你写的每一段代码都要经过深思熟虑，为什么要这样用，还能怎么优化…这样才能给面试官展现一个最好的你。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>WeakMap</li><li>lodash</li></ul><h1 id="6-数组去重、扁平、最值"><a href="#6-数组去重、扁平、最值" class="headerlink" title="6.数组去重、扁平、最值"></a>6.数组去重、扁平、最值</h1><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique (array) &#123;</span><br><span class="line">    let container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-filter"><a href="#indexOf-filter" class="headerlink" title="indexOf + filter"></a>indexOf + filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return  [...new Set(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h2><blockquote><p><a href="https://github.com/NieZhuZhu/Blog">https://github.com/NieZhuZhu/Blog</a>)</p></blockquote><h3 id="一段代码总结-Array-prototype-flat-特性"><a href="#一段代码总结-Array-prototype-flat-特性" class="headerlink" title="一段代码总结 Array.prototype.flat() 特性"></a>一段代码总结 <code>Array.prototype.flat()</code> 特性</h3><blockquote><p>注：数组拍平方法 <code>Array.prototype.flat()</code> 也叫数组扁平化、数组拉平、数组降维。 本文统一叫：数组拍平</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const animals &#x3D; [&quot;🐷&quot;, [&quot;🐶&quot;, &quot;🐂&quot;], [&quot;🐎&quot;, [&quot;🐑&quot;, [&quot;🐲&quot;]], &quot;🐛&quot;]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不传参数时，默认“拉平”一层</span><br><span class="line">animals.flat();</span><br><span class="line">&#x2F;&#x2F; [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, [&quot;🐑&quot;, [&quot;🐲&quot;]], &quot;🐛&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传入一个整数参数，整数即“拉平”的层数</span><br><span class="line">animals.flat(2);</span><br><span class="line">&#x2F;&#x2F; [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, &quot;🐑&quot;, [&quot;🐲&quot;], &quot;🐛&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组</span><br><span class="line">animals.flat(Infinity);</span><br><span class="line">&#x2F;&#x2F; [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;, &quot;🐑&quot;, &quot;🐲&quot;, &quot;🐛&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传入 &lt;&#x3D;0 的整数将返回原数组，不“拉平”</span><br><span class="line">animals.flat(0);</span><br><span class="line">animals.flat(-10);</span><br><span class="line">&#x2F;&#x2F; [&quot;🐷&quot;, [&quot;🐶&quot;, &quot;🐂&quot;], [&quot;🐎&quot;, [&quot;🐑&quot;, [&quot;🐲&quot;]], &quot;🐛&quot;]];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果原数组有空位，flat()方法会跳过空位。</span><br><span class="line">[&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;,,].flat();</span><br><span class="line">&#x2F;&#x2F; [&quot;🐷&quot;, &quot;🐶&quot;, &quot;🐂&quot;, &quot;🐎&quot;]</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-flat-特性总结"><a href="#Array-prototype-flat-特性总结" class="headerlink" title="Array.prototype.flat() 特性总结"></a><code>Array.prototype.flat()</code> 特性总结</h3><ul><li><code>Array.prototype.flat()</code> 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</li><li>不传参数时，默认“拉平”一层，可以传入一个整数，表示想要“拉平”的层数。</li><li>传入 <code>&lt;=0</code> 的整数将返回原数组，不“拉平”</li><li><code>Infinity</code> 关键字作为参数时，无论多少层嵌套，都会转为一维数组</li><li>如果原数组有空位，<code>Array.prototype.flat()</code> 会跳过空位。</li></ul><h3 id="面试官-N-连问"><a href="#面试官-N-连问" class="headerlink" title="面试官 N 连问"></a>面试官 N 连问</h3><h4 id="第一问：实现一个简单的数组拍平-flat-函数"><a href="#第一问：实现一个简单的数组拍平-flat-函数" class="headerlink" title="第一问：实现一个简单的数组拍平 flat 函数"></a>第一问：实现一个简单的数组拍平 <code>flat</code> 函数</h4><p>首先，我们将花一点篇幅来探讨如何实现一个简单的数组拍平 <code>flat</code> 函数，详细介绍多种实现的方案，然后再尝试接住面试官的连环追问。</p><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>如何实现呢，思路非常简单：实现一个有数组拍平功能的 <code>flat</code> 函数，<strong>我们要做的就是在数组中找到是数组类型的元素，然后将他们展开</strong>。这就是实现数组拍平 <code>flat</code> 方法的关键思路。</p><p>有了思路，我们就需要解决实现这个思路需要克服的困难：</p><ul><li><strong>第一个要解决的就是遍历数组的每一个元素；</strong></li><li><strong>第二个要解决的就是判断元素是否是数组；</strong></li><li><strong>第三个要解决的就是将数组的元素展开一层；</strong></li></ul><h5 id="遍历数组的方案"><a href="#遍历数组的方案" class="headerlink" title="遍历数组的方案"></a>遍历数组的方案</h5><p>遍历数组并取得数组元素的方法非常之多，<strong>包括且不限于下面几种</strong>：</p><ul><li><code>for 循环</code></li><li><code>for...of</code></li><li><code>for...in</code></li><li><code>forEach()</code></li><li><code>entries()</code></li><li><code>keys()</code></li><li><code>values()</code></li><li><code>reduce()</code></li><li><code>map()</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line">&#x2F;&#x2F; 遍历数组的方法有太多，本文只枚举常用的几种</span><br><span class="line">&#x2F;&#x2F; for 循环</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; for...of</span><br><span class="line">for (let value of arr) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; for...in</span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">  console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; forEach 循环</span><br><span class="line">arr.forEach(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; entries（）</span><br><span class="line">for (let [index, value] of arr.entries()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; keys()</span><br><span class="line">for (let index of arr.keys()) &#123;</span><br><span class="line">  console.log(arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; values()</span><br><span class="line">for (let value of arr.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; reduce()</span><br><span class="line">arr.reduce((pre, cur) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(cur);</span><br><span class="line">&#125;, []);</span><br><span class="line">&#x2F;&#x2F; map()</span><br><span class="line">arr.map(value &#x3D;&gt; console.log(value));</span><br></pre></td></tr></table></figure><p>只要是能够遍历数组取到数组中每一个元素的方法，都是一种可行的解决方案。</p><h5 id="判断元素是数组的方案"><a href="#判断元素是数组的方案" class="headerlink" title="判断元素是数组的方案"></a>判断元素是数组的方案</h5><ul><li><code>instanceof</code></li><li><code>constructor</code></li><li><code>Object.prototype.toString</code></li><li><code>isArray</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line">arr instanceof Array</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">arr.constructor &#x3D;&#x3D;&#x3D; Array</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">Object.prototype.toString.call(arr) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">Array.isArray(arr)</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li><p><code>instanceof</code> 操作符是假定只有一种全局环境，如果网页中包含多个框架，多个全局环境，如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。（所以在这种情况下会不准确）</p></li><li><p><code>typeof</code> 操作符对数组取类型将返回 <code>object</code></p></li><li><p>因为<code> constructor</code> 可以被重写，所以不能确保一定是数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const str &#x3D; &#39;abc&#39;;</span><br><span class="line">str.constructor &#x3D; Array;</span><br><span class="line">str.constructor &#x3D;&#x3D;&#x3D; Array </span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ul><h5 id="将数组的元素展开一层的方案"><a href="#将数组的元素展开一层的方案" class="headerlink" title="将数组的元素展开一层的方案"></a>将数组的元素展开一层的方案</h5><ul><li>扩展运算符 +concat</li><li><code>concat()</code> 方法用于合并两个或多个数组，在拼接的过程中加上扩展运算符会展开一层数组。详细见下面的代码。</li><li><code>conca</code>t +<code> apply</code></li></ul><p>主要是利用 <code>apply</code> 在绑定作用域时，传入的第二个参数是一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>func</code> 函数。也就是在调用 <code>apply</code> 函数的过程中，会将传入的数组一个一个的传入到要执行的函数中，也就是相当对数组进行了一层的展开。</p><ul><li><code>toString</code> + <code>split</code></li></ul><p>不推荐使用 <code>toString</code> + <code>split</code> 方法，因为操作字符串是和危险的事情，在<a href="https://segmentfault.com/a/1190000021230185">上一文章</a>中我做了一个操作字符串的案例还被许多小伙伴们批评了。如果数组中的元素所有都是数字的话，<code>toString</code> +<code> split</code> 是可行的，并且是一步搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line">&#x2F;&#x2F; 扩展运算符 + concat</span><br><span class="line">[].concat(...arr)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; concat + apply</span><br><span class="line">[].concat.apply([], arr);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toString  + split</span><br><span class="line">const arr2 &#x3D;[1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]]]</span><br><span class="line">arr2.toString().split(&#39;,&#39;).map(v&#x3D;&gt;parseInt(v))</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure><p>总结完要解决的三大困难，那我们就可以非常轻松的实现一版数组拍平 <code>flat</code> 函数了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line">&#x2F;&#x2F; concat + 递归</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">  let arrResult &#x3D; [];</span><br><span class="line">  arr.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      arrResult &#x3D; arrResult.concat(arguments.callee(item));   &#x2F;&#x2F; 递归</span><br><span class="line">      &#x2F;&#x2F; 或者用扩展运算符</span><br><span class="line">      &#x2F;&#x2F; arrResult.push(...arguments.callee(item));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      arrResult.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return arrResult;</span><br><span class="line">&#125;</span><br><span class="line">flat(arr)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><p>到这里，恭喜你成功得到了面试官对你手撕代码能力的基本认可🎉。但是面试官往往会不止于此，将继续考察面试者的各种能力。</p><h4 id="第二问：用-reduce-实现-flat-函数"><a href="#第二问：用-reduce-实现-flat-函数" class="headerlink" title="第二问：用 reduce 实现 flat 函数"></a>第二问：用 <code>reduce</code> 实现 <code>flat</code> 函数</h4><p>我见过很多的面试官都很喜欢点名道姓的要面试者直接用 <code>reduce</code> 去实现 <code>flat</code> 函数。想知道为什么？文章后半篇我们考虑数组空位的情况的时候就知道为啥了。其实思路也是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先使用 reduce 展开一层</span><br><span class="line">arr.reduce((pre, cur) &#x3D;&gt; pre.concat(cur), []);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用 reduce 展开一层 + 递归</span><br><span class="line">const flat &#x3D; arr &#x3D;&gt; &#123;</span><br><span class="line">  return arr.reduce((pre, cur) &#x3D;&gt; &#123;</span><br><span class="line">    return pre.concat(Array.isArray(cur) ? flat(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><h4 id="第三问：使用栈的思想实现-flat-函数"><a href="#第三问：使用栈的思想实现-flat-函数" class="headerlink" title="第三问：使用栈的思想实现 flat 函数"></a>第三问：使用栈的思想实现 <code>flat</code> 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 栈思想</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">  const result &#x3D; []; </span><br><span class="line">  const stack &#x3D; [].concat(arr);  &#x2F;&#x2F; 将数组元素拷贝至栈，直接赋值会改变原数组</span><br><span class="line">  &#x2F;&#x2F;如果栈不为空，则循环遍历</span><br><span class="line">  while (stack.length !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    const val &#x3D; stack.pop(); </span><br><span class="line">    if (Array.isArray(val)) &#123;</span><br><span class="line">      stack.push(...val); &#x2F;&#x2F;如果是数组再次入栈，并且展开了一层</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.unshift(val); &#x2F;&#x2F;如果不是数组就将其取出来放入结果数组中</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;]</span><br><span class="line">flat(arr)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><h4 id="第四问：通过传入整数参数控制“拉平”层数"><a href="#第四问：通过传入整数参数控制“拉平”层数" class="headerlink" title="第四问：通过传入整数参数控制“拉平”层数"></a>第四问：通过传入整数参数控制“拉平”层数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reduce + 递归</span><br><span class="line">function flat(arr, num &#x3D; 1) &#123;</span><br><span class="line">  return num &gt; 0</span><br><span class="line">    ? arr.reduce(</span><br><span class="line">        (pre, cur) &#x3D;&gt;</span><br><span class="line">          pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur),</span><br><span class="line">        []</span><br><span class="line">      )</span><br><span class="line">    : arr.slice();</span><br><span class="line">&#125;</span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;]</span><br><span class="line">flat(arr, Infinity);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><h4 id="第五问：使用-Generator-实现-flat-函数"><a href="#第五问：使用-Generator-实现-flat-函数" class="headerlink" title="第五问：使用 Generator 实现 flat 函数"></a>第五问：使用 <code>Generator</code> 实现 <code>flat</code> 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function* flat(arr, num) &#123;</span><br><span class="line">  if (num &#x3D;&#x3D;&#x3D; undefined) num &#x3D; 1;</span><br><span class="line">  for (const item of arr) &#123;</span><br><span class="line">    if (Array.isArray(item) &amp;&amp; num &gt; 0) &#123;   &#x2F;&#x2F; num &gt; 0</span><br><span class="line">      yield* flat(item, num - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;]</span><br><span class="line">&#x2F;&#x2F; 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。</span><br><span class="line">&#x2F;&#x2F; 也就是遍历器对象（Iterator Object）。所以我们要用一次扩展运算符得到结果</span><br><span class="line">[...flat(arr, Infinity)]    </span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><h4 id="第六问：实现在原型链上重写-flat-函数"><a href="#第六问：实现在原型链上重写-flat-函数" class="headerlink" title="第六问：实现在原型链上重写 flat 函数"></a>第六问：实现在原型链上重写 <code>flat</code> 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.fakeFlat &#x3D; function(num &#x3D; 1) &#123;</span><br><span class="line">  if (!Number(num) || Number(num) &lt; 0) &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  let arr &#x3D; this.concat();    &#x2F;&#x2F; 获得调用 fakeFlat 函数的数组</span><br><span class="line">  while (num &gt; 0) &#123;           </span><br><span class="line">    if (arr.some(x &#x3D;&gt; Array.isArray(x))) &#123;</span><br><span class="line">      arr &#x3D; [].concat.apply([], arr);    &#x2F;&#x2F; 数组中还有数组元素的话并且 num &gt; 0，继续展开一层数组 </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      break; &#x2F;&#x2F; 数组中没有数组元素并且不管 num 是否依旧大于 0，停止循环。</span><br><span class="line">    &#125;</span><br><span class="line">    num--;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;]</span><br><span class="line">arr.fakeFlat(Infinity)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span><br></pre></td></tr></table></figure><h4 id="第七问：考虑数组空位的情况"><a href="#第七问：考虑数组空位的情况" class="headerlink" title="第七问：考虑数组空位的情况"></a>第七问：考虑数组空位的情况</h4><p>由最开始我们总结的 <code>flat</code> 特性知道，<code>flat</code> 函数执行是会跳过空位的。ES5 大多数数组方法对空位的处理都会选择跳过空位包括：<code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和 <code>some()</code> 都会跳过空位。</p><p>所以我们可以利用上面几种方法来实现 flat 跳过空位的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; reduce + 递归</span><br><span class="line">Array.prototype.fakeFlat &#x3D; function(num &#x3D; 1) &#123;</span><br><span class="line">  if (!Number(num) || Number(num) &lt; 0) &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  let arr &#x3D; [].concat(this);</span><br><span class="line">  return num &gt; 0</span><br><span class="line">    ? arr.reduce(</span><br><span class="line">        (pre, cur) &#x3D;&gt;</span><br><span class="line">          pre.concat(Array.isArray(cur) ? cur.fakeFlat(--num) : cur),</span><br><span class="line">        []</span><br><span class="line">      )</span><br><span class="line">    : arr.slice();</span><br><span class="line">&#125;;</span><br><span class="line">const arr &#x3D; [1, [3, 4], , ,];</span><br><span class="line">arr.fakeFlat()</span><br><span class="line">&#x2F;&#x2F; [1, 3, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foEach + 递归</span><br><span class="line">Array.prototype.fakeFlat &#x3D; function(num &#x3D; 1) &#123;</span><br><span class="line">  if (!Number(num) || Number(num) &lt; 0) &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  let arr &#x3D; [];</span><br><span class="line">  this.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      arr &#x3D; arr.concat(item.fakeFlat(--num));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      arr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return arr;</span><br><span class="line">&#125;;</span><br><span class="line">const arr &#x3D; [1, [3, 4], , ,];</span><br><span class="line">arr.fakeFlat()</span><br><span class="line">&#x2F;&#x2F; [1, 3, 4]</span><br></pre></td></tr></table></figure><h4 id="扩展阅读：由于空位的处理规则非常不统一，所以建议避免出现空位。"><a href="#扩展阅读：由于空位的处理规则非常不统一，所以建议避免出现空位。" class="headerlink" title="扩展阅读：由于空位的处理规则非常不统一，所以建议避免出现空位。"></a>扩展阅读：<strong>由于空位的处理规则非常不统一，所以建议避免出现空位。</strong></h4><p><strong>ES5 对空位的处理，就非常不一致，大多数情况下会忽略空位。</strong></p><ul><li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code> 都会跳过空位。</li><li><code>map()</code> 会跳过空位，但会保留这个值。</li><li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code>，而<code>undefined</code> 和 <code>null</code> 会被处理成空字符串。</li></ul><p><strong>ES6 明确将空位转为 <code>undefined</code>。</strong></p><ul><li><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code> 和 <code>findIndex()</code> 会将空位处理成 <code>undefined</code>。</li><li><code>for...of</code> 循环会遍历空位。</li><li><code>fill()</code> 会将空位视为正常的数组位置。</li><li><code>copyWithin()</code> 会连空位一起拷贝。</li><li>扩展运算符（<code>...</code>）也会将空位转为 <code>undefined</code>。</li><li><code>Array.from</code> 方法会将数组的空位，转为 <code>undefined</code>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试官现场考察一道写代码的题目，其实不仅仅是写代码，在写代码的过程中会遇到各种各样的知识点和代码的边界情况。虽然大多数情况下，面试官不会那么变态，就 <code>flat</code> 实现去连续追问面试者，并且手撕好几个版本，但面试官会要求在你写的那版代码的基础上再写出一个更完美的版本是常有的事情。只有我们沉下心来把基础打扎实，不管面试官如何追问，我们都能自如的应对。<code>flat</code> 的实现绝对不会只有文中列出的这几个版本，敲出自己的代码是最好的进步，在评论区或者在 <a href="https://github.com/NieZhuZhu/Blog/issues/2">issue</a> 中写出你自己的版本吧！</p><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>递归调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用reduce简化"><a href="#使用reduce简化" class="headerlink" title="使用reduce简化"></a>使用reduce简化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(</span><br><span class="line">        (target, current) =&gt; <span class="built_in">Array</span>.isArray(current) ? target.concat(flatten(current)) : target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种处理</span></span><br><span class="line">arr_flat = arr.flat(<span class="literal">Infinity</span>);</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二种处理</span><br><span class="line">ary &#x3D; arr.toSting()).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;).split(&#39;,&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三种处理：递归处理</span></span><br><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">ary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.length; i++) &#125;&#123;</span><br><span class="line">    <span class="keyword">let</span> item = ary[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(ary[i]))&#123;</span><br><span class="line">      fn(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n));</span><br></pre></td></tr></table></figure><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null, array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">        target.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="7-数组乱序-洗牌算法"><a href="#7-数组乱序-洗牌算法" class="headerlink" title="7.数组乱序-洗牌算法"></a>7.数组乱序-洗牌算法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disorder</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> current = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> random;</span><br><span class="line">    <span class="keyword">while</span> (current &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">        [array[current], array[random]] = [array[random], array[current]];</span><br><span class="line">        current--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-函数柯里化"><a href="#8-函数柯里化" class="headerlink" title="8.函数柯里化"></a>8.函数柯里化</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args &#x3D; []) &#123;</span><br><span class="line">    let length &#x3D; fn.length;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        newArgs &#x3D; args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">        if (newArgs.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function multiFn(a, b, c) &#123;</span><br><span class="line">    return a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var multi &#x3D; curry(multiFn);</span><br><span class="line"></span><br><span class="line">multi(2)(3)(4);</span><br><span class="line">multi(2,3,4);</span><br><span class="line">multi(2)(3,4);</span><br><span class="line">multi(2,3)(4)</span><br></pre></td></tr></table></figure><h3 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const curry &#x3D; (fn, arr &#x3D; []) &#x3D;&gt; (...args) &#x3D;&gt; (</span><br><span class="line">  arg &#x3D;&gt; arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, arg)</span><br><span class="line">)([...arr, ...args])</span><br><span class="line"></span><br><span class="line">let curryTest&#x3D;curry((a,b,c,d) &#x3D;&gt; a + b + c + d)</span><br><span class="line">curryTest(1,2,3)(4) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(4)(3) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(3,4) &#x2F;&#x2F; 返回10</span><br></pre></td></tr></table></figure><h3 id="简单写法版"><a href="#简单写法版" class="headerlink" title="简单写法版"></a>简单写法版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, ...args) &#123;</span><br><span class="line">    if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span><br><span class="line">    return fn(...args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回currying函数</span><br><span class="line">    return (...args2) &#x3D;&gt; currying(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-手动实现JSONP"><a href="#9-手动实现JSONP" class="headerlink" title="9.手动实现JSONP"></a>9.手动实现JSONP</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p><ul><li>1.将传入的data数据转化为url字符串形式</li><li>2.处理url中的回调函数</li><li>3.创建一个script标签并插入到页面中</li><li>4.挂载回调函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp &#x3D; function (url, data, callback) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        &#x2F;&#x2F; 例子&#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">        var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">        &#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">        dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.$jsonp &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用script属性</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">&#x27;http://xxx&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="10-模拟实现promise"><a href="#10-模拟实现promise" class="headerlink" title="10.模拟实现promise"></a>10.模拟实现promise</h1><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.status === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="面试够用版-1"><a href="#面试够用版-1" class="headerlink" title="面试够用版"></a>面试够用版</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">    constructor(fn) &#123;</span><br><span class="line">        &#x2F;&#x2F;三个状态</span><br><span class="line">        this.status &#x3D; &#39;pending&#39;,</span><br><span class="line">        this.resolve &#x3D; undefined;</span><br><span class="line">        this.reject &#x3D; undefined;</span><br><span class="line">        let resolve &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.status &#x3D; &#39;resolved&#39;;</span><br><span class="line">                this.resolve &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        let reject &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                this.status &#x3D; &#39;rejected&#39;;</span><br><span class="line">                this.reject &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            fn(resolve, reject)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    then(onResolved, onRejected) &#123;</span><br><span class="line">        switch (this.status) &#123;</span><br><span class="line">            case &#39;resolved&#39;: onResolved(this.resolve); break;</span><br><span class="line">            case &#39;rejected&#39;: onRejected(this.resolve); break;</span><br><span class="line">            default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    catch(onRejected) &#123;</span><br><span class="line">        return this.then(null, onRejected);</span><br><span class="line">    &#125;;</span><br><span class="line">    finally (fn) &#123;</span><br><span class="line">        return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">           fn();</span><br><span class="line">           return value;</span><br><span class="line">        &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">            fn();</span><br><span class="line">            throw reason;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all() 它接收一个promise对象组成的数组作为参数，并返回一个新的promise对象。</p><p>当数组中所有的对象都resolve时，新对象状态变为fulfilled，所有对象的resolve的value依次添加组成一个新的数组，并以新的数组作为新对象resolve的value。<br>当数组中有一个对象reject时，新对象状态变为rejected，并以当前对象reject的reason作为新对象reject的reason。</p><pre><code>Promise.prototype.all(promises) &#123;    if (!Array.isArray(promises)) &#123;        throw new Error(&quot;promises must be an array&quot;)    &#125;    return new Promise(function (resolve, reject) &#123;        let promsieNum = promises.length;        let resolvedCount = 0;        let resolveValues = new Array(promsieNum);        for (let i = 0; i &lt; promsieNum; i++) &#123;            Promise.resolve(promises[i].then(function (value) &#123;                    resolveValues[i] = value;                    resolvedCount++;                    if (resolvedCount === promsieNum) &#123;                        return resolve(resolveValues)                    &#125;                &#125;, function (reason) &#123;                    return reject(reason);                &#125;           ))        &#125;    &#125;)&#125;</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race() 它同样接收一个promise对象组成的数组作为参数，并返回一个新的promise对象。</p><p>与Promise.all()不同，它是在数组中有一个对象（最早改变状态）resolve或reject时，就改变自身的状态，并执行响应的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.race(promises) &#123;</span><br><span class="line">    if (!Array.isArray(promises)) &#123;</span><br><span class="line">    throw new Error(&quot;promises must be an array&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        promises.forEach(p &#x3D;&gt;</span><br><span class="line">            Promise.resolve(p).then(data &#x3D;&gt; &#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;, err &#x3D;&gt; &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-手动实现ES5继承"><a href="#11-手动实现ES5继承" class="headerlink" title="11.手动实现ES5继承"></a>11.手动实现ES5继承</h1><p>Child继承Parent</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote><p>子类的原型指向父类。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p><h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><blockquote><p>在子类构造函数中调用父类构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>使用构造继承继承父类参数，使用原型继承继承父类函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：Parent的构造函数会多执行了一次（<code>Child.prototype = new Parent()</code>;）</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><blockquote><p>将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure><p>父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p><h2 id="寄生组合继承优化"><a href="#寄生组合继承优化" class="headerlink" title="寄生组合继承优化"></a>寄生组合继承优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>最推荐的一种方式，接近完美的继承。</p><h1 id="12-手动实现instanceof"><a href="#12-手动实现instanceof" class="headerlink" title="12.手动实现instanceof"></a>12.手动实现instanceof</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>按照target原型链的向上查找，直到找到 origin 或 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = target.__proto__;</span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.prototype == proto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myInstanceof(proto, origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改用循环而不是递归  </p><pre><code>// target instanceof origin// 变量origin的原型 存在于变量target的原型链上function myInstanceof(target, origin)&#123;        // 验证如果为基本数据类型，就直接返回false    const baseType = [&#39;string&#39;, &#39;number&#39;,&#39;boolean&#39;,&#39;undefined&#39;,&#39;symbol&#39;]    if(baseType.includes(typeof(target))) return false;    let oP  = origin.prototype;  // 取 origin 的显示原型    proto = target.__proto__;       // 取 target 的隐式原型    while(true)&#123;           // 无线循环的写法（也可以使 for(;;) ）        if(proto === null)&#123;    // 找到最顶层            return false;        &#125;        if(proto === oP)&#123;       // 严格相等            return true;        &#125;        proto = proto.__proto__;  //没找到继续向上一层原型链查找    &#125;&#125;</code></pre><h1 id="13-基于Promise的ajax封装"><a href="#13-基于Promise的ajax封装" class="headerlink" title="13.基于Promise的ajax封装"></a>13.基于Promise的ajax封装</h1><p>基于把原生<code>ajax</code>封装为<code>Promise</code>形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">const</span> paramString = getStringParam(param);</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;get&#x27;</span> &amp;&amp; paramString) &#123;</span><br><span class="line">        url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? url += paramString : url += <span class="string">`?<span class="subst">$&#123;paramString&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = &#123;</span><br><span class="line">                status: xhr.status,</span><br><span class="line">                statusText: xhr.statusText,</span><br><span class="line">                headers: xhr.getAllResponseHeaders(),</span><br><span class="line">                data: xhr.response || xhr.responseText</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="comment">// 跨域携带cookie</span></span><br><span class="line">        xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求出错&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.timeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求超时&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求被终止&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        xhr.send(paramString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringParam</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> param) &#123;</span><br><span class="line">    dataString += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;param[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-单例模式"><a href="#14-单例模式" class="headerlink" title="14.单例模式"></a>14.单例模式</h1><p>在合适的时候才创建对像，并且只创建唯一的一个。创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。使用闭包实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Singleton (name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Single.getInstance &#x3D; (function(name) &#123;</span><br><span class="line">let instance;</span><br><span class="line">return function(name) &#123;</span><br><span class="line">if (!instance) &#123;</span><br><span class="line">instance &#x3D; new Singleton(name);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a &#x3D; Singleton.getInstance(&#39;ConardLi&#39;);</span><br><span class="line">var b &#x3D; Singleton.getInstance(&#39;ConardLi2&#39;);</span><br><span class="line"></span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><blockquote><p>另一种实现方式，核心要点: 用闭包和Proxy属性拦截</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">      <span class="title">constructor</span> (<span class="params">target, args</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="built_in">Reflect</span>.constructor(fun, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-异步循环打印"><a href="#15-异步循环打印" class="headerlink" title="15.异步循环打印"></a>15.异步循环打印</h1><p>使用<code>promise + async await</code>实现异步循环打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(i);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><h1 id="16-图片懒加载"><a href="#16-图片懒加载" class="headerlink" title="16.图片懒加载"></a>16.图片懒加载</h1><h2 id="监听图片高度"><a href="#监听图片高度" class="headerlink" title="监听图片高度"></a>监听图片高度</h2><p>图片，用一个其他属性存储真正的图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="built_in">window</span>.innerHeight; <span class="comment">//可见区域高度</span></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; img.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">        <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><blockquote><p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">    <span class="keyword">let</span> lazyImageObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> lazyImage = entry.target;</span><br><span class="line">            <span class="comment">// 如果元素可见            </span></span><br><span class="line">            <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyImage.getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                    lazyImage.src = lazyImage.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; img.length; i++) &#123;</span><br><span class="line">        lazyImageObserver.observe(img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-模拟Object-create"><a href="#17-模拟Object-create" class="headerlink" title="17.模拟Object.create"></a>17.模拟Object.create</h1><blockquote><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-实现一个JSON-stringify"><a href="#18-实现一个JSON-stringify" class="headerlink" title="18.实现一个JSON.stringify"></a>18.实现一个JSON.stringify</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])：</span><br></pre></td></tr></table></figure><ul><li><code>Boolean | Number| String</code>类型会自动转换成对应的原始值。</li><li><code>undefined</code>、任意函数以及<code>symbol</code>，会被忽略（出现在非数组对象的属性值中时），或者被转换成 <code>null</code>（出现在数组中时）。</li><li>不可枚举的属性会被忽略如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li><li>如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是字符串 undefined 和 function 类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">            obj = <span class="string">&#x27;&quot;&#x27;</span> + obj + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// JSON为空数组</span></span><br><span class="line">        <span class="keyword">let</span> json = []</span><br><span class="line">        <span class="comment">// 是否为数组</span></span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">let</span> v = obj[k];</span><br><span class="line">            <span class="keyword">let</span> type = <span class="keyword">typeof</span> v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">                v = <span class="string">&#x27;&quot;&#x27;</span> + v + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                v = jsonStringify(v);</span><br><span class="line">            &#125;</span><br><span class="line">            json.push((arr ? <span class="string">&quot;&quot;</span> : <span class="string">&#x27;&quot;&#x27;</span> + k + <span class="string">&#x27;&quot;:&#x27;</span>) + <span class="built_in">String</span>(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonStringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;) <span class="comment">// &quot;&#123;&quot;x&quot;:5&#125;&quot;</span></span><br><span class="line">jsonStringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]) <span class="comment">// &quot;[1,&quot;false&quot;,false]&quot;</span></span><br><span class="line">jsonStringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;) <span class="comment">// &quot;&#123;&quot;b&quot;:&quot;undefined&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="19-实现一个JSON-parse"><a href="#19-实现一个JSON-parse" class="headerlink" title="19.实现一个JSON.parse"></a>19.实现一个JSON.parse</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text[, reviver])</span><br></pre></td></tr></table></figure><blockquote><p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p></blockquote><h2 id="方法1：直接调用-eval"><a href="#方法1：直接调用-eval" class="headerlink" title="方法1：直接调用 eval"></a>方法1：直接调用 eval</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function jsonParse(opt) &#123;</span><br><span class="line">    return eval(&#39;(&#39; + opt + &#39;)&#39;);</span><br><span class="line">&#125;</span><br><span class="line">jsonParse(jsonStringify(&#123;x : 5&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; x: 5&#125;</span><br><span class="line">jsonParse(jsonStringify([1, &quot;false&quot;, false]))</span><br><span class="line">&#x2F;&#x2F; [1, &quot;false&quot;, falsr]</span><br><span class="line">jsonParse(jsonStringify(&#123;b: undefined&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; b: &quot;undefined&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p></blockquote><p>如果你只想记这个方法，就得对参数json做校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json</span><br><span class="line">            .replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：Function"><a href="#方法2：Function" class="headerlink" title="方法2：Function"></a>方法2：Function</h2><blockquote><p>核心：Function与eval有相同的字符串参数特性</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var func = new Function(arg1, arg2, ..., functionBody);</span><br></pre></td></tr></table></figure><p>在转换JSON的实际应用中，只需要这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> json = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))();</span><br></pre></td></tr></table></figure><blockquote><p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p></blockquote><h1 id="20-解析-URL-Params-为对象"><a href="#20-解析-URL-Params-为对象" class="headerlink" title="20.解析 URL Params 为对象"></a>20.解析 URL Params 为对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line">parseParam(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">        <span class="comment">// 分割 key 和 value</span></span><br><span class="line">        <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 递归调用解码</span></span><br><span class="line">        val = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="comment">// 判断是否转为数字</span></span><br><span class="line">        val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">            paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">        paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21-模板引擎实现"><a href="#21-模板引擎实现" class="headerlink" title="21.模板引擎实现"></a>21.模板引擎实现</h1><p>underscore 提供了模板引擎的功能，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var tpl &#x3D; &quot;hello: &lt;%&#x3D; name %&gt;&quot;;</span><br><span class="line"></span><br><span class="line">var compiled &#x3D; _.template(tpl);</span><br><span class="line">compiled(&#123;name: &#39;Kevin&#39;&#125;); &#x2F;&#x2F; &quot;hello: Kevin&quot;</span><br></pre></td></tr></table></figure><p>感觉好像没有什么强大的地方，再来举个例子：</p><p>在 HTML 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;name_list&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;user_tmpl&quot;&gt;</span><br><span class="line">    &lt;%for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; %&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&lt;%&#x3D;users[i].url%&gt;&quot;&gt;</span><br><span class="line">                &lt;%&#x3D;users[i].name%&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>JavaScript 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var container &#x3D; document.getElementById(&quot;name_list&quot;);</span><br><span class="line"></span><br><span class="line">var data &#x3D; &#123;</span><br><span class="line">    users: [</span><br><span class="line">        &#123; &quot;name&quot;: &quot;Kevin&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;,</span><br><span class="line">        &#123; &quot;name&quot;: &quot;Daisy&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;,</span><br><span class="line">        &#123; &quot;name&quot;: &quot;Kelly&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">var precompile &#x3D; _.template(document.getElementById(&quot;user_tmpl&quot;).innerHTML);</span><br><span class="line">var html &#x3D; precompile(data);</span><br><span class="line"></span><br><span class="line">container.innerHTML &#x3D; html;</span><br></pre></td></tr></table></figure><p>效果为：</p><p><a href="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/template/template.png"><img data-src="https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/template/template.png" alt="模板引擎效果"></a></p><p>那么该如何实现这样一个 _.template 函数呢？</p><h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><p>underscore 的 template 函数参考了 jQuery 的作者 John Resig 在 2008 年发表的一篇文章 <a href="https://johnresig.com/blog/javascript-micro-templating/#postcomment">JavaScript Micro-Templating</a>，我们先从这篇文章的思路出发，思考一下如何写一个简单的模板引擎。</p><p>依然是以这段模板字符串为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&lt;%&#x3D;users[i].url%&gt;&quot;&gt;</span><br><span class="line">            &lt;%&#x3D;users[i].name%&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>John Resig 的思路是将这段代码转换为这样一段程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟数据</span><br><span class="line">var users &#x3D; [&#123;&quot;name&quot;: &quot;Kevin&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot;&#125;];</span><br><span class="line"></span><br><span class="line">var p &#x3D; [];</span><br><span class="line">for (var i &#x3D; 0; i &lt; users.length; i++) &#123;</span><br><span class="line">    p.push(&#39;&lt;li&gt;&lt;a href&#x3D;&quot;&#39;);</span><br><span class="line">    p.push(users[i].url);</span><br><span class="line">    p.push(&#39;&quot;&gt;&#39;);</span><br><span class="line">    p.push(users[i].name);</span><br><span class="line">    p.push(&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后 join 一下就可以得到最终拼接好的模板字符串</span><br><span class="line">console.log(p.join(&#39;&#39;)) &#x2F;&#x2F; &lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;localhost&quot;&gt;Kevin&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure><p>我们注意，模板其实是一段字符串，我们怎么根据一段字符串生成一段代码呢？很容易就想到用 eval，那我们就先用 eval 吧。</p><p>然后我们会发现，为了转换成这样一段代码，我们需要将<code>&lt;%xxx%&gt;</code>转换为 <code>xxx</code>，其实就是去掉包裹的符号，还要将 <code>&lt;%=xxx%&gt;</code>转化成 <code>p.push(xxx)</code>，这些都可以用正则实现，但是我们还需要写 <code>p.push(&#39;&lt;li&gt;&lt;a href=&quot;&#39;);</code> 、<code>p.push(&#39;&quot;&gt;&#39;);</code>呐，这些该如何实现呢？</p><p>那我们换个思路，依然是用正则，但是我们</p><ol><li>将 <code>%&gt;</code> 替换成 <code>p.push(&#39;</code></li><li>将 <code>&lt;%</code> 替换成 <code>&#39;);</code></li><li>将 <code>&lt;%=xxx%&gt;</code> 替换成 <code>&#39;);p.push(xxx);p.push(&#39;</code></li></ol><p>我们来举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&lt;%&#x3D;users[i].url%&gt;&quot;&gt;</span><br><span class="line">            &lt;%&#x3D;users[i].name%&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>按照这个替换规则会被替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;);for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; p.push(&#39;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#39;);p.push(users[i].url);p.push(&#39;&quot;&gt;</span><br><span class="line">            &#39;);p.push(users[i].name);p.push(&#39;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&#39;); &#125; p.push(&#39;</span><br></pre></td></tr></table></figure><p>这样肯定会报错，毕竟代码都没有写全，我们在首和尾加上部分代码，变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加的首部代码</span><br><span class="line">var p &#x3D; []; p.push(&#39;</span><br><span class="line"></span><br><span class="line">&#39;);for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; p.push(&#39;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#39;);p.push(users[i].url);p.push(&#39;&quot;&gt;</span><br><span class="line">            &#39;);p.push(users[i].name);p.push(&#39;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&#39;); &#125; p.push(&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加的尾部代码</span><br><span class="line">&#39;);</span><br></pre></td></tr></table></figure><p>我们整理下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; []; p.push(&#39;&#39;);</span><br><span class="line">for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; </span><br><span class="line">    p.push(&#39;&lt;li&gt;&lt;a href&#x3D;&quot;&#39;);</span><br><span class="line">    p.push(users[i].url);</span><br><span class="line">    p.push(&#39;&quot;&gt;&#39;);</span><br><span class="line">    p.push(users[i].name);</span><br><span class="line">    p.push(&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;); </span><br><span class="line">&#125;</span><br><span class="line">    p.push(&#39;&#39;);</span><br></pre></td></tr></table></figure><p>恰好可以实现这个功能，不过还要注意一点，要将换行符替换成空格，防止解析成代码的时候报错，不过在这里为了方便理解原理，就只在代码里实现。</p><h2 id="第一版-1"><a href="#第一版-1" class="headerlink" title="第一版"></a>第一版</h2><p>我们来尝试实现第一版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">function tmpl(str, data) &#123;</span><br><span class="line">    var str &#x3D; document.getElementById(str).innerHTML;</span><br><span class="line"></span><br><span class="line">    var string &#x3D; &quot;var p &#x3D; []; p.push(&#39;&quot; +</span><br><span class="line">    str</span><br><span class="line">    .replace(&#x2F;[\r\t\n]&#x2F;g, &quot;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x3D;(.*?)%&gt;&#x2F;g, &quot;&#39;);p.push($1);p.push(&#39;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x2F;g, &quot;&#39;);&quot;)</span><br><span class="line">    .replace(&#x2F;%&gt;&#x2F;g,&quot;p.push(&#39;&quot;)</span><br><span class="line">    + &quot;&#39;);&quot;</span><br><span class="line"></span><br><span class="line">    eval(string)</span><br><span class="line"></span><br><span class="line">    return p.join(&#39;&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了验证是否有用：</p><p>HTML 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;user_tmpl&quot;&gt;</span><br><span class="line">    &lt;%for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; %&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&lt;%&#x3D;users[i].url%&gt;&quot;&gt;</span><br><span class="line">                &lt;%&#x3D;users[i].name%&gt;</span><br><span class="line">            &lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>JavaScript 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var users &#x3D; [</span><br><span class="line">    &#123; &quot;name&quot;: &quot;Byron&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;Casper&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;Frank&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost&quot; &#125;</span><br><span class="line">]</span><br><span class="line">tmpl(&quot;user_tmpl&quot;, users)</span><br></pre></td></tr></table></figure><p>完整的 Demo 可以查看 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template1">template 示例一</a></p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>在这里我们使用了 eval ，实际上 John Resig 在文章中使用的是 Function 构造函数。</p><p>Function 构造函数创建一个新的 Function 对象。 在 JavaScript 中, 每个函数实际上都是一个 Function 对象。</p><p>使用方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Function ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure><p>arg1, arg2, … argN 表示函数用到的参数，functionBody 表示一个含有包括函数定义的 JavaScript 语句的字符串。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var adder &#x3D; new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);</span><br><span class="line"></span><br><span class="line">adder(2, 6); &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure><p>那么 John Resig 到底是如何实现的呢？</p><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>使用 Function 构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function tmpl(str, data) &#123;</span><br><span class="line">    var str &#x3D; document.getElementById(str).innerHTML;</span><br><span class="line"></span><br><span class="line">    var fn &#x3D; new Function(&quot;obj&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;var p &#x3D; []; p.push(&#39;&quot; +</span><br><span class="line"></span><br><span class="line">    str</span><br><span class="line">    .replace(&#x2F;[\r\t\n]&#x2F;g, &quot;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x3D;(.*?)%&gt;&#x2F;g, &quot;&#39;);p.push($1);p.push(&#39;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x2F;g, &quot;&#39;);&quot;)</span><br><span class="line">    .replace(&#x2F;%&gt;&#x2F;g,&quot;p.push(&#39;&quot;)</span><br><span class="line">    + &quot;&#39;);return p.join(&#39;&#39;);&quot;);</span><br><span class="line"></span><br><span class="line">    return fn(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方法依然跟第一版相同，具体 Demo 可以查看 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template2">template 示例二</a></p><p>不过值得注意的是：其实 tmpl 函数没有必要传入 data 参数，也没有必要在最后 return 的时候，传入 data 参数，即使你把这两个参数都去掉，代码还是可以正常执行的。</p><p>这是因为:</p><blockquote><p>使用Function构造器生成的函数，并不会在创建它们的上下文中创建闭包；它们一般在全局作用域中被创建。当运行这些函数的时候，它们只能访问自己的本地变量和全局变量，不能访问Function构造器被调用生成的上下文的作用域。这和使用带有函数表达式代码的 eval 不同。</p></blockquote><p>这里之所以依然传入了 data 参数，是为了下一版做准备。</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>现在有一个小问题，就是实际上我们传入的数据结构可能比较复杂，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    name: &#39;kevin&#39;,</span><br><span class="line">    friends: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将这个数据结构传入 tmpl 函数中，在模板字符串中，如果要用到某个数据，总是需要使用 <code>data.name</code>、<code>data.friends</code> 的形式来获取，麻烦就麻烦在我想直接使用 name、friends 等变量，而不是繁琐的使用 <code>data.</code> 来获取。</p><p>这又该如何实现的呢？答案是 with。</p><p>with 语句可以扩展一个语句的作用域链(scope chain)。当需要多次访问一个对象的时候，可以使用 with 做简化。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var hostName &#x3D; location.hostname;</span><br><span class="line">var url &#x3D; location.href;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 with</span><br><span class="line">with(location)&#123;</span><br><span class="line">    var hostname &#x3D; hostname;</span><br><span class="line">    var url &#x3D; href;</span><br><span class="line">&#125;</span><br><span class="line">function Person()&#123;</span><br><span class="line">    this.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">    this.age &#x3D; &#39;18&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">with(person) &#123;</span><br><span class="line">    console.log(&#39;my name is &#39; + name + &#39;, age is &#39; + age + &#39;.&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; my name is Kevin, age is 18.</span><br></pre></td></tr></table></figure><p>最后：不建议使用 with 语句，因为它可能是混淆错误和兼容性问题的根源，除此之外，也会造成性能低下</p><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>使用 with ，我们再写一版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function tmpl(str, data) &#123;</span><br><span class="line">    var str &#x3D; document.getElementById(str).innerHTML;</span><br><span class="line"></span><br><span class="line">    var fn &#x3D; new Function(&quot;obj&quot;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其实就是这里多添加了一句 with(obj)&#123;...&#125;</span><br><span class="line">    &quot;var p &#x3D; []; with(obj)&#123;p.push(&#39;&quot; +</span><br><span class="line"></span><br><span class="line">    str</span><br><span class="line">    .replace(&#x2F;[\r\t\n]&#x2F;g, &quot;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x3D;(.*?)%&gt;&#x2F;g, &quot;&#39;);p.push($1);p.push(&#39;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x2F;g, &quot;&#39;);&quot;)</span><br><span class="line">    .replace(&#x2F;%&gt;&#x2F;g,&quot;p.push(&#39;&quot;)</span><br><span class="line">    + &quot;&#39;);&#125;return p.join(&#39;&#39;);&quot;);</span><br><span class="line"></span><br><span class="line">    return fn(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体 Demo 可以查看 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template3">template 示例三</a></p><h2 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h2><p>如果我们的模板不变，数据却发生了变化，如果使用我们的之前写的 tmpl 函数，每次都会 new Function，这其实是没有必要的，如果我们能在使用 tmpl 的时候，返回一个函数，然后使用该函数，传入不同的数据，只根据数据不同渲染不同的 html 字符串，就可以避免这种无谓的损失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">function tmpl(str, data) &#123;</span><br><span class="line">    var str &#x3D; document.getElementById(str).innerHTML;</span><br><span class="line">    var fn &#x3D; new Function(&quot;obj&quot;,</span><br><span class="line">    &quot;var p &#x3D; []; with(obj)&#123;p.push(&#39;&quot; +</span><br><span class="line">    str</span><br><span class="line">    .replace(&#x2F;[\r\t\n]&#x2F;g, &quot;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x3D;(.*?)%&gt;&#x2F;g, &quot;&#39;);p.push($1);p.push(&#39;&quot;)</span><br><span class="line">    .replace(&#x2F;&lt;%&#x2F;g, &quot;&#39;);&quot;)</span><br><span class="line">    .replace(&#x2F;%&gt;&#x2F;g,&quot;p.push(&#39;&quot;)</span><br><span class="line">    + &quot;&#39;);&#125;return p.join(&#39;&#39;);&quot;);</span><br><span class="line"></span><br><span class="line">    var template &#x3D; function(data) &#123;</span><br><span class="line">        return fn.call(this, data)</span><br><span class="line">    &#125;</span><br><span class="line">    return template;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用时</span><br><span class="line">var compiled &#x3D; tmpl(&quot;user_tmpl&quot;);</span><br><span class="line">results.innerHTML &#x3D; compiled(data);</span><br></pre></td></tr></table></figure><p>具体 Demo 可以查看 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template4">template 示例四</a></p><h2 id="反斜杠的作用"><a href="#反斜杠的作用" class="headerlink" title="反斜杠的作用"></a>反斜杠的作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var txt &#x3D; &quot;We are the so-called &quot;Vikings&quot; from the north.&quot;</span><br><span class="line">console.log(txt);</span><br></pre></td></tr></table></figure><p>我们的本意是想打印带 <code>&quot;&quot;</code> 包裹的 <code>Vikings</code> 字符串，但是在 JavaScript 中，字符串使用单引号或者双引号来表示起始或者结束，这段代码会报 <code>Unexpected identifier</code> 错误。</p><p>如果我们就是想要在字符串中使用单引号或者双引号呢？</p><p>我们可以使用反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var txt &#x3D; &quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;</span><br><span class="line">console.log(txt);</span><br></pre></td></tr></table></figure><p>现在 JavaScript 就可以输出正确的文本字符串了。</p><p><strong>这种由反斜杠后接字母或数字组合构成的字符组合就叫做“转义序列”。</strong></p><p>值得注意的是，转义序列会被视为单个字符。</p><p>我们常见的转义序列还有 <code>\n</code> 表示换行、<code>\t</code> 表示制表符、<code>\r</code> 表示回车等等。</p><h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>在 JavaScript 中，字符串值是一个由零或多个 Unicode 字符（字母、数字和其他字符）组成的序列。</p><p>字符串中的每个字符均可由一个转义序列表示。比如字母 <code>a</code>，也可以用转义序列 <code>\u0061</code> 表示。</p><blockquote><p>转义序列以反斜杠 <code>\</code> 开头，它的作用是告知 JavaScript 解释器下一个字符是特殊字符。</p></blockquote><blockquote><p>转义序列的语法为 <code>\uhhhh</code>，其中 hhhh 是四位十六进制数。</p></blockquote><p>根据这个规则，我们可以算出常见字符的转义序列，以字母 <code>m</code> 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 求出字符 &#96;m&#96; 对应的 unicode 值</span><br><span class="line">var unicode &#x3D; &#39;m&#39;.charCodeAt(0) &#x2F;&#x2F; 109</span><br><span class="line">&#x2F;&#x2F; 2. 转成十六进制</span><br><span class="line">var result &#x3D; unicode.toString(16); &#x2F;&#x2F; &quot;6d&quot;</span><br></pre></td></tr></table></figure><p>我们就可以使用 <code>\u006d</code> 表示 <code>m</code>，不信你可以直接在浏览器命令行中直接输入字符串 <code>&#39;\u006d&#39;</code>，看下打印结果。</p><p>值得注意的是: <code>\n</code> 虽然也是一种转义序列，但是也可以使用上面的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var unicode &#x3D; &#39;\n&#39;.charCodeAt(0) &#x2F;&#x2F; 10</span><br><span class="line">var result &#x3D; unicode.toString(16); &#x2F;&#x2F; &quot;a&quot;</span><br></pre></td></tr></table></figure><p>所以我们可以用 <code>\u000A</code> 来表示换行符 <code>\n</code>，比如在浏览器命令行中直接输入 <code>&#39;a \n b&#39;</code> 和 <code>&#39;a \u000A b&#39;</code> 效果是一样的。</p><p>讲了这么多，我们来看看一些常用字符的转义序列以及含义：</p><table><thead><tr><th>Unicode 字符值</th><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td>\u0009</td><td>\t</td><td>制表符</td></tr><tr><td>\u000A</td><td>\n</td><td>换行</td></tr><tr><td>\u000D</td><td>\r</td><td>回车</td></tr><tr><td>\u0022</td><td>&quot;</td><td>双引号</td></tr><tr><td>\u0027</td><td>&#39;</td><td>单引号</td></tr><tr><td>\u005C</td><td>\</td><td>反斜杠</td></tr><tr><td>\u2028</td><td></td><td>行分隔符</td></tr><tr><td>\u2029</td><td></td><td>段落分隔符</td></tr></tbody></table><h2 id="Line-Terminators"><a href="#Line-Terminators" class="headerlink" title="Line Terminators"></a>Line Terminators</h2><p>Line Terminators，中文译文<code>行终结符</code>。像空白字符一样，<code>行终结符</code>可用于改善源文本的可读性。</p><p>在 ES5 中，有四个字符被认为是<code>行终结符</code>，其他的折行字符都会被视为空白。</p><p>这四个字符如下所示：</p><table><thead><tr><th>字符编码值</th><th>名称</th></tr></thead><tbody><tr><td>\u000A</td><td>换行符</td></tr><tr><td>\u000D</td><td>回车符</td></tr><tr><td>\u2028</td><td>行分隔符</td></tr><tr><td>\u2029</td><td>段落分隔符</td></tr></tbody></table><h2 id="Function-1"><a href="#Function-1" class="headerlink" title="Function"></a>Function</h2><p>试想我们写这样一段代码，能否正确运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var log &#x3D; new Function(&quot;var a &#x3D; &#39;1\t23&#39;;console.log(a)&quot;);</span><br><span class="line">log()</span><br></pre></td></tr></table></figure><p>答案是可以，那下面这段呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var log &#x3D; new Function(&quot;var a &#x3D; &#39;1\n23&#39;;console.log(a)&quot;);</span><br><span class="line">log()</span><br></pre></td></tr></table></figure><p>答案是不可以，会报错 <code>Uncaught SyntaxError: Invalid or unexpected token</code>。</p><p>这是为什么呢？</p><p>这是因为在 Function 构造函数的实现中，首先会将函数体代码字符串进行一次 <code>ToString</code> 操作，这时候字符串变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#39;1</span><br><span class="line">23&#39;;console.log(a)</span><br></pre></td></tr></table></figure><p>然后再检测代码字符串是否符合代码规范，在 JavaScript 中，<strong>字符串表达式中是不允许换行的</strong>，这就导致了报错。</p><p>为了避免这个问题，我们需要将代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var log &#x3D; new Function(&quot;var a &#x3D; &#39;1\\n23&#39;;console.log(a)&quot;);</span><br><span class="line">log()</span><br></pre></td></tr></table></figure><p>其实不止 <code>\n</code>，其他三种 <code>行终结符</code>，如果你在字符串表达式中直接使用，都会导致报错！</p><p>之所以讲这个问题，是因为在模板引擎的实现中，就是使用了 Function 构造函数，如果我们在模板字符串中使用了 <code>行终结符</code>，便有可能会出现一样的错误，所以我们必须要对这四种 <code>行终结符</code> 进行特殊的处理。</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>除了这四种 <code>行终结符</code> 之外，我们还要对两个字符进行处理。</p><p>一个是 <code>\</code>。</p><p>比如说我们的模板内容中使用了<code>\</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var log &#x3D; new Function(&quot;var a &#x3D; &#39;1\23&#39;;console.log(a)&quot;);</span><br><span class="line">log(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>其实我们是想打印 ‘1\23’，但是因为把 <code>\</code> 当成了特殊字符的标记进行处理，所以最终打印了 1。</p><p>同样的道理，如果我们在使用模板引擎的时候，使用了 <code>\</code> 字符串，也会导致错误的处理。</p><p>第二个是 <code>&#39;</code>。</p><p>如果我们在模板引擎中使用了 <code>&#39;</code>，因为我们会拼接诸如 <code>p.push(&#39;</code> <code>&#39;)</code> 等字符串，因为 <code>&#39;</code> 的原因，字符串会被错误拼接，也会导致错误。</p><p>所以总共我们需要对六种字符进行特殊处理，处理的方式，就是正则匹配出这些特殊字符，然后比如将 <code>\n</code> 替换成 <code>\\n</code>，<code>\</code> 替换成 <code>\\</code>，<code>&#39;</code> 替换成 <code>\\&#39;</code>，处理的代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var escapes &#x3D; &#123;</span><br><span class="line">    &quot;&#39;&quot;: &quot;&#39;&quot;,</span><br><span class="line">    &#39;\\&#39;: &#39;\\&#39;,</span><br><span class="line">    &#39;\r&#39;: &#39;r&#39;,</span><br><span class="line">    &#39;\n&#39;: &#39;n&#39;,</span><br><span class="line">    &#39;\u2028&#39;: &#39;u2028&#39;,</span><br><span class="line">    &#39;\u2029&#39;: &#39;u2029&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var escapeRegExp &#x3D; &#x2F;\\|&#39;|\r|\n|\u2028|\u2029&#x2F;g;</span><br><span class="line"></span><br><span class="line">var escapeChar &#x3D; function(match) &#123;</span><br><span class="line">    return &#39;\\&#39; + escapes[match];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;console.log(&quot;I am \n Kevin&quot;);&#39;;</span><br><span class="line">var newStr &#x3D; str.replace(escapeRegExp, escapeChar);</span><br><span class="line"></span><br><span class="line">eval(newStr)</span><br><span class="line">&#x2F;&#x2F; I am </span><br><span class="line">&#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>我们来讲一讲字符串的 replace 函数：</p><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(regexp|substr, newSubStr|function)</span><br></pre></td></tr></table></figure><p>replace 的第一个参数，可以传一个字符串，也可以传一个正则表达式。</p><p>第二个参数，可以传一个新字符串，也可以传一个函数。</p><p>我们重点看下传入函数的情况，简单举一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;hello world&#39;;</span><br><span class="line">var newStr &#x3D; str.replace(&#39;world&#39;, function(match)&#123;</span><br><span class="line">    return match + &#39;!&#39;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newStr); &#x2F;&#x2F; hello world!</span><br></pre></td></tr></table></figure><p>match 表示匹配到的字符串，但函数的参数其实不止有 match，我们看个更复杂的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function replacer(match, p1, p2, p3, offset, string) &#123;</span><br><span class="line">    &#x2F;&#x2F; match，表示匹配的子串 abc12345#$*%</span><br><span class="line">    &#x2F;&#x2F; p1，第 1 个括号匹配的字符串 abc</span><br><span class="line">    &#x2F;&#x2F; p2，第 2 个括号匹配的字符串 12345</span><br><span class="line">    &#x2F;&#x2F; p3，第 3 个括号匹配的字符串 #$*%</span><br><span class="line">    &#x2F;&#x2F; offset，匹配到的子字符串在原字符串中的偏移量 0</span><br><span class="line">    &#x2F;&#x2F; string，被匹配的原字符串 abc12345#$*%</span><br><span class="line">    return [p1, p2, p3].join(&#39; - &#39;);</span><br><span class="line">&#125;</span><br><span class="line">var newString &#x3D; &#39;abc12345#$*%&#39;.replace(&#x2F;([^\d]*)(\d*)([^\w]*)&#x2F;, replacer); &#x2F;&#x2F; abc - 12345 - #$*%</span><br></pre></td></tr></table></figure><p>另外要注意的是，如果第一个参数是正则表达式，并且其为全局匹配模式， 那么这个方法将被多次调用，每次匹配都会被调用。</p><p>举个例子，如果我们要在一段字符串中匹配出 <code>&lt;%=xxx%&gt;</code> 中的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;&lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g, function(match, p1, offset, string)&#123;</span><br><span class="line">    console.log(match);</span><br><span class="line">    console.log(p1);</span><br><span class="line">    console.log(offset);</span><br><span class="line">    console.log(string);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传入的函数会被执行两次，第一次的打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%&#x3D;www.baidu.com%&gt;</span><br><span class="line">www.baidu.com</span><br><span class="line">13</span><br><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure><p>第二次的打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%&#x3D;baidu%&gt;</span><br><span class="line">&#39;baidu&#39;</span><br><span class="line">33</span><br><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure><h2 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h2><p>当我们要建立一个正则表达式的时候，我们可以直接创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;ab+c&#x2F;i;</span><br></pre></td></tr></table></figure><p>也可以使用构造函数的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(&#39;ab+c&#39;, &#39;i&#39;);</span><br></pre></td></tr></table></figure><p>值得一提的是：每个正则表达式对象都有一个 source 属性，返回当前正则表达式对象的模式文本的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var regex &#x3D; &#x2F;fooBar&#x2F;ig;</span><br><span class="line">console.log(regex.source); &#x2F;&#x2F; &quot;fooBar&quot;，不包含 &#x2F;...&#x2F; 和 &quot;ig&quot;。</span><br></pre></td></tr></table></figure><h2 id="正则表达式的特殊字符"><a href="#正则表达式的特殊字符" class="headerlink" title="正则表达式的特殊字符"></a>正则表达式的特殊字符</h2><p>正则表达式中有一些特殊字符，比如 <code>\d</code> 就表示了匹配一个数字，等价于 [0-9]。</p><p>在上节，我们使用 <code>/&lt;%=(.+?)%&gt;/g</code> 来匹配 <code>&lt;%=xxx%&gt;</code>，然而在 underscore 的实现中，用的却是 <code>/&lt;%=([\s\S]+?)%&gt;/g</code>。</p><p>我们知道 \s 表示匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格，\S<br>匹配一个非空白符，[\s\S]就表示匹配所有的内容，可是为什么我们不直接使用 <code>.</code> 呢？</p><p>我们可能以为 <code>.</code> 匹配任意单个字符，实际上，并不是如此， <code>.</code>匹配除<code>行终结符</code>之外的任何单个字符，不信我们做个试验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;%&#x3D;hello world%&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g, function(match)&#123;</span><br><span class="line">    console.log(match); &#x2F;&#x2F; &lt;%&#x3D;hello world%&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是如果我们在 hello world 之间加上一个<code>行终结符</code>，比如说 ‘\u2029’：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;%&#x3D;hello \u2029 world%&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g, function(match)&#123;</span><br><span class="line">    console.log(match);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为匹配不到，所以也不会执行 console.log 函数。</p><p>但是改成 <code>/&lt;%=([\s\S]+?)%&gt;/g</code> 就可以正常匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;%&#x3D;hello \u2029 world%&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;([\s\S]+?)%&gt;&#x2F;g, function(match)&#123;</span><br><span class="line">    console.log(match); &#x2F;&#x2F; &lt;%&#x3D;hello   world%&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h2><p>仔细看 <code>/&lt;%=([\s\S]+?)%&gt;/g</code> 这个正则表达式，我们知道 <code>x+</code> 表示匹配 <code>x</code> 1 次或多次。<code>x?</code>表示匹配 <code>x</code> 0 次或 1 次，但是 <code>+?</code> 是个什么鬼？</p><p>实际上，如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;aaabc&quot;.replace(&#x2F;a+&#x2F;g, &quot;d&quot;)); &#x2F;&#x2F; dbc</span><br><span class="line"></span><br><span class="line">console.log(&quot;aaabc&quot;.replace(&#x2F;a+?&#x2F;g, &quot;d&quot;)); &#x2F;&#x2F; dddbc</span><br></pre></td></tr></table></figure><p>在这里我们应该使用非惰性匹配，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;&lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g, function(match)&#123;</span><br><span class="line">    console.log(match);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &lt;%&#x3D;www.baidu.com%&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;%&#x3D;baidu%&gt;</span><br></pre></td></tr></table></figure><p>如果我们使用惰性匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;&lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;&lt;%&#x3D;(.+)%&gt;&#x2F;g, function(match)&#123;</span><br><span class="line">    console.log(match);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &lt;%&#x3D;www.baidu.com%&gt;&quot;&gt;&lt;%&#x3D;baidu%&gt;</span><br></pre></td></tr></table></figure><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>讲完需要的知识点，我们开始讲 underscore 模板引擎的实现。</p><p>与我们上篇使用数组的 push ，最后再 join 的方法不同，underscore 使用的是字符串拼接的方式。</p><p>比如下面这样一段模板字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&lt;%&#x3D;users[i].url%&gt;&quot;&gt;</span><br><span class="line">            &lt;%&#x3D;users[i].name%&gt;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>我们先将 <code>&lt;%=xxx%&gt;</code> 替换成 <code>&#39;+ xxx +&#39;</code>，再将 <code>&lt;%xxx%&gt;</code> 替换成 <code>&#39;; xxx __p+=&#39;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;;for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; __p+&#x3D;&#39;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#39;+ users[i].url + &#39;&quot;&gt;</span><br><span class="line">            &#39;+ users[i].name +&#39;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&#39;;  &#125; __p+&#x3D;&#39;</span><br></pre></td></tr></table></figure><p>这段代码肯定会运行错误的，所以我们再添加些头尾代码，然后组成一个完整的代码字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var __p&#x3D;&#39;&#39;;</span><br><span class="line">with(obj)&#123;</span><br><span class="line">__p+&#x3D;&#39;</span><br><span class="line"></span><br><span class="line">&#39;;for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; __p+&#x3D;&#39;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#39;+ users[i].url + &#39;&quot;&gt;</span><br><span class="line">            &#39;+ users[i].name +&#39;</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&#39;;  &#125; __p+&#x3D;&#39;</span><br><span class="line"></span><br><span class="line">&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">return __p;</span><br></pre></td></tr></table></figure><p>整理下代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var __p&#x3D;&#39;&#39;;</span><br><span class="line">with(obj)&#123;</span><br><span class="line">    __p+&#x3D;&#39;&#39;;</span><br><span class="line">    for ( var i &#x3D; 0; i &lt; users.length; i++ ) &#123; </span><br><span class="line">        __p+&#x3D;&#39;&lt;li&gt;&lt;a href&#x3D;&quot;&#39;+ users[i].url + &#39;&quot;&gt; &#39;+ users[i].name +&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    __p+&#x3D;&#39;&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">return __p</span><br></pre></td></tr></table></figure><p>然后我们将 <code>__p</code> 这段代码字符串传入 Function 构造函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var render &#x3D; new Function(data, __p)</span><br></pre></td></tr></table></figure><p>我们执行这个 render 函数，传入需要的 data 数据，就可以返回一段 HTML 字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(data)</span><br></pre></td></tr></table></figure><h2 id="第五版-特殊字符的处理"><a href="#第五版-特殊字符的处理" class="headerlink" title="第五版 - 特殊字符的处理"></a>第五版 - 特殊字符的处理</h2><p>我们接着上篇的<a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template4">第四版</a>进行书写，不过加入对特殊字符的转义以及使用字符串拼接的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第五版</span><br><span class="line">var settings &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 求值</span><br><span class="line">    evaluate: &#x2F;&lt;%([\s\S]+?)%&gt;&#x2F;g,</span><br><span class="line">    &#x2F;&#x2F; 插入</span><br><span class="line">    interpolate: &#x2F;&lt;%&#x3D;([\s\S]+?)%&gt;&#x2F;g,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var escapes &#x3D; &#123;</span><br><span class="line">    &quot;&#39;&quot;: &quot;&#39;&quot;,</span><br><span class="line">    &#39;\\&#39;: &#39;\\&#39;,</span><br><span class="line">    &#39;\r&#39;: &#39;r&#39;,</span><br><span class="line">    &#39;\n&#39;: &#39;n&#39;,</span><br><span class="line">    &#39;\u2028&#39;: &#39;u2028&#39;,</span><br><span class="line">    &#39;\u2029&#39;: &#39;u2029&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var escapeRegExp &#x3D; &#x2F;\\|&#39;|\r|\n|\u2028|\u2029&#x2F;g;</span><br><span class="line"></span><br><span class="line">var template &#x3D; function(text) &#123;</span><br><span class="line"></span><br><span class="line">    var source &#x3D; &quot;var __p&#x3D;&#39;&#39;;\n&quot;;</span><br><span class="line">    source &#x3D; source + &quot;with(obj)&#123;\n&quot;</span><br><span class="line">    source &#x3D; source + &quot;__p+&#x3D;&#39;&quot;;</span><br><span class="line"></span><br><span class="line">    var main &#x3D; text</span><br><span class="line">    .replace(escapeRegExp, function(match) &#123;</span><br><span class="line">        return &#39;\\&#39; + escapes[match];</span><br><span class="line">    &#125;)</span><br><span class="line">    .replace(settings.interpolate, function(match, interpolate)&#123;</span><br><span class="line">        return &quot;&#39;+\n&quot; + interpolate + &quot;+\n&#39;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    .replace(settings.evaluate, function(match, evaluate)&#123;</span><br><span class="line">        return &quot;&#39;;\n &quot; + evaluate + &quot;\n__p+&#x3D;&#39;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    source &#x3D; source + main + &quot;&#39;;\n &#125;; \n return __p;&quot;;</span><br><span class="line"></span><br><span class="line">    console.log(source)</span><br><span class="line"></span><br><span class="line">    var render &#x3D; new Function(&#39;obj&#39;,  source);</span><br><span class="line"></span><br><span class="line">    return render;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的使用代码可以参考 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template5">template 示例五</a>。</p><h2 id="第六版-特殊值的处理"><a href="#第六版-特殊值的处理" class="headerlink" title="第六版 - 特殊值的处理"></a>第六版 - 特殊值的处理</h2><p>不过有一点需要注意的是：</p><p>如果数据中 <code>users[i].url</code> 不存在怎么办？此时取值的结果为 undefined，我们知道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;1&#39; + undefined &#x2F;&#x2F; &quot;1undefined&quot;</span><br></pre></td></tr></table></figure><p>就相当于拼接了 undefined 字符串，这肯定不是我们想要的。我们可以在代码中加入一点判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.replace(settings.interpolate, function(match, interpolate)&#123;</span><br><span class="line">    return &quot;&#39;+\n&quot; + (interpolate &#x3D;&#x3D; null ? &#39;&#39; : interpolate) + &quot;+\n&#39;&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是吧，我就是不喜欢写两遍 interpolate …… 嗯？那就这样吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var source &#x3D; &quot;var __t, __p&#x3D;&#39;&#39;;\n&quot;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.replace(settings.interpolate, function(match, interpolate)&#123;</span><br><span class="line">    return &quot;&#39;+\n((__t&#x3D;(&quot; + interpolate + &quot;))&#x3D;&#x3D;null?&#39;&#39;:__t)+\n&#39;&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实就相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var __t;</span><br><span class="line"></span><br><span class="line">var result &#x3D; (__t &#x3D; interpolate) &#x3D;&#x3D; null ? &#39;&#39; : __t;</span><br></pre></td></tr></table></figure><p>完整的使用代码可以参考 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template6">template 示例六</a>。</p><h2 id="第七版"><a href="#第七版" class="headerlink" title="第七版"></a>第七版</h2><p>现在我们使用的方式是将模板字符串进行多次替换，然而在 underscore 的实现中，只进行了一次替换，我们来看看 underscore 是怎么实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var template &#x3D; function(text) &#123;</span><br><span class="line">    var matcher &#x3D; RegExp([</span><br><span class="line">        (settings.interpolate).source,</span><br><span class="line">        (settings.evaluate).source</span><br><span class="line">    ].join(&#39;|&#39;) + &#39;|$&#39;, &#39;g&#39;);</span><br><span class="line"></span><br><span class="line">    var index &#x3D; 0;</span><br><span class="line">    var source &#x3D; &quot;__p+&#x3D;&#39;&quot;;</span><br><span class="line"></span><br><span class="line">    text.replace(matcher, function(match, interpolate, evaluate, offset) &#123;</span><br><span class="line">        source +&#x3D; text.slice(index, offset).replace(escapeRegExp, function(match) &#123;</span><br><span class="line">            return &#39;\\&#39; + escapes[match];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        index &#x3D; offset + match.length;</span><br><span class="line"></span><br><span class="line">        if (interpolate) &#123;</span><br><span class="line">            source +&#x3D; &quot;&#39;+\n((__t&#x3D;(&quot; + interpolate + &quot;))&#x3D;&#x3D;null?&#39;&#39;:__t)+\n&#39;&quot;;</span><br><span class="line">        &#125; else if (evaluate) &#123;</span><br><span class="line">            source +&#x3D; &quot;&#39;;\n&quot; + evaluate + &quot;\n__p+&#x3D;&#39;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return match;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    source +&#x3D; &quot;&#39;;\n&quot;;</span><br><span class="line"></span><br><span class="line">    source &#x3D; &#39;with(obj||&#123;&#125;)&#123;\n&#39; + source + &#39;&#125;\n&#39;</span><br><span class="line"></span><br><span class="line">    source &#x3D; &quot;var __t, __p&#x3D;&#39;&#39;;&quot; +</span><br><span class="line">        source + &#39;return __p;\n&#39;;</span><br><span class="line"></span><br><span class="line">    var render &#x3D; new Function(&#39;obj&#39;, source);</span><br><span class="line"></span><br><span class="line">    return render;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实原理也很简单，就是在执行多次匹配函数的时候，不断复制字符串，处理字符串，拼接字符串，最后拼接首尾代码，得到最终的代码字符串。</p><p>不过值得一提的是：在这段代码里，matcher 的表达式最后为：<code>/&lt;%=([\s\S]+?)%&gt;|&lt;%([\s\S]+?)%&gt;|$/g</code></p><p>问题是为什么还要加个 <code>|$</code> 呢？我们来看下 $：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;abc&quot;;</span><br><span class="line">str.replace(&#x2F;$&#x2F;g, function(match, offset)&#123;</span><br><span class="line">    console.log(typeof match) &#x2F;&#x2F; 空字符串</span><br><span class="line">    console.log(offset) &#x2F;&#x2F; 3</span><br><span class="line">    return match</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们之所以匹配 $，是为了获取最后一个字符串的位置，这样当我们 text.slice(index, offset)的时候，就可以截取到最后一个字符。</p><p>完整的使用代码可以参考 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template7">template 示例七</a>。</p><h2 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h2><p>其实代码写到这里，就已经跟 underscore 的实现很接近了，只是 underscore 加入了更多细节的处理，比如：</p><ol><li>对数据的转义功能</li><li>可传入配置项</li><li>对错误的处理</li><li>添加 source 属性，以方便查看代码字符串</li><li>添加了方便调试的 print 函数</li><li>…</li></ol><p>但是这些内容都还算简单，就不一版一版写了，最后的版本在 <a href="https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template8">template 示例八</a>，如果对其中有疑问，欢迎留言讨论</p><h2 id="面试简化版"><a href="#面试简化版" class="headerlink" title="面试简化版"></a>面试简化版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template &#x3D; &#39;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;姓名&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); &#x2F;&#x2F; 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">     <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        template = template.replace(reg, data[name]);</span><br><span class="line">        <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="22-转化为驼峰命名"><a href="#22-转化为驼峰命名" class="headerlink" title="22.转化为驼峰命名"></a>22.转化为驼峰命名</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span></span><br><span class="line"><span class="comment">// 转化为 getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 首字母大写</span></span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="23-查找字符串中出现最多的字符和个数"><a href="#23-查找字符串中出现最多的字符和个数" class="headerlink" title="23.查找字符串中出现最多的字符和个数"></a>23.查找字符串中出现最多的字符和个数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 自己用哈希表</span></span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.replace(re, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; $<span class="number">0.</span>length)&#123;</span><br><span class="line">        num = $<span class="number">0.</span>length;</span><br><span class="line">        char = $<span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure><h1 id="24-字符串查找"><a href="#24-字符串查找" class="headerlink" title="24.字符串查找"></a>24.字符串查找</h1><blockquote><p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p></blockquote><p>暴力解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var strStr &#x3D; function(haystack, needle) &#123;</span><br><span class="line">    let m &#x3D;  haystack.length;</span><br><span class="line">    let n &#x3D; needle.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt;&#x3D; m - n; i++) &#123;</span><br><span class="line">        let j;</span><br><span class="line">        for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (needle[j] !&#x3D;&#x3D; haystack[i + j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; needle子串全都匹配了</span><br><span class="line">        if (j &#x3D;&#x3D;&#x3D; n) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; haystack中不存在needle</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = -<span class="number">1</span>, n = haystack.length, p = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="built_in">Array</span>(p).fill(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算next数组</span></span><br><span class="line">    calNext(needle, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; -<span class="number">1</span> &amp;&amp; needle[k + <span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">            <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] == haystack[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == p - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数- 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calNext</span>(<span class="params">needle, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>, p = -<span class="number">1</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; -<span class="number">1</span> &amp;&amp; needle[p + <span class="number">1</span>] != needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p + <span class="number">1</span>] == needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 位置j处更新最长前缀</span></span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>马拉车水平不够</p><h1 id="25-实现千位分隔符"><a href="#25-实现千位分隔符" class="headerlink" title="25.实现千位分隔符"></a>25.实现千位分隔符</h1><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a>1.方法一</h3><p>实现思路是将数字转换为字符数组，再循环整个数组， 每三位添加一个分隔逗号，最后再合并成字符串。因为分隔符在顺序上是从后往前添加的：比如 1234567添加后是1,234,567 而不是 123,456,7 ，所以方便起见可以先把数组倒序，添加完之后再倒序回来，就是正常的顺序了。要注意的是如果数字带小数的话，要把小数部分分开处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function numFormat(num)&#123;</span><br><span class="line">    num<span class="operator">=</span>num.toString().split(<span class="string">&quot;.&quot;</span>);  <span class="comment">// 分隔小数点</span></span><br><span class="line">    <span class="keyword">var</span> arr<span class="operator">=</span>num[<span class="number">0</span>].split(<span class="string">&quot;&quot;</span>).reverse();  <span class="comment">// 转换成字符数组并且倒序排列</span></span><br><span class="line">    <span class="keyword">var</span> res<span class="operator">=</span>[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i<span class="operator">=</span><span class="number">0</span>,len<span class="operator">=</span>arr.length;i<span class="operator">&lt;</span>len;i<span class="operator">++</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i<span class="operator">%</span><span class="number">3</span><span class="operator">===</span><span class="number">0</span><span class="operator">&amp;&amp;</span>i<span class="operator">!==</span><span class="number">0</span>)&#123;</span><br><span class="line">         res.push(<span class="string">&quot;,&quot;</span>);   <span class="comment">// 添加分隔符</span></span><br><span class="line">      &#125;</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.reverse(); <span class="comment">// 再次倒序成为正确的顺序</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="number">1</span>])&#123;  <span class="comment">// 如果有小数的话添加小数部分</span></span><br><span class="line">      res<span class="operator">=</span>res.join(<span class="string">&quot;&quot;</span>).concat(<span class="string">&quot;.&quot;</span><span class="operator">+</span>num[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res<span class="operator">=</span>res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a<span class="operator">=</span><span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">var</span> b<span class="operator">=</span><span class="number">673439.4542</span>;</span><br><span class="line">console.log(numFormat(a)); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line">console.log(numFormat(b)); <span class="comment">// &quot;673,439.4542&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2.方法二"></a>2.方法二</h3><p>使用JS自带的函数 <a href="https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString">toLocaleString</a></p><blockquote><p>语法：  <code>numObj.toLocaleString([locales [, options]])</code></p></blockquote><p><code>toLocaleString()</code> 方法返回这个数字在特定语言环境下的表示字符串。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">673439.4542</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString());  <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toLocaleString());  <span class="comment">// &quot;673,439.454&quot;  （小数部分四舍五入了）</span></span><br></pre></td></tr></table></figure><p>要注意的是这个函数在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串，所以不同地区数字格式可能会有一定的差异。最好确保使用 locales 参数指定了使用的语言。<br> 注：我测试的环境下小数部分会根据四舍五入只留下三位。</p><h3 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3. 方法三"></a>3. 方法三</h3><p>使用<a href="https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>和<a href="https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">replace</a>函数，相对前两种我更喜欢这种方法，虽然正则有点难以理解。</p><blockquote><p>replace 语法：<code>str.replace(regexp|substr, newSubStr|function)</code></p></blockquote><p>其中第一个 <a href="https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp">RegExp </a> 对象或者其字面量所匹配的内容会被第二个参数的返回值替换。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numFormat</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res=num.toString().replace(<span class="regexp">/\d+/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="comment">// 先提取整数部分</span></span><br><span class="line">       <span class="keyword">return</span> n.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> $<span class="number">1</span>+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">673439.4542</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numFormat(a)); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(numFormat(b)); <span class="comment">// &quot;673,439.4542&quot;</span></span><br></pre></td></tr></table></figure><p>正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    return (n + &#39;&#39;).replace(&#x2F;(?!^)(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g, &#39;.&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    let ans &#x3D; &quot;&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        let cur &#x3D; n % 10;</span><br><span class="line">        n &#x3D; Math.floor(n &#x2F; 10);</span><br><span class="line">        ans +&#x3D; cur;</span><br><span class="line">        count++;</span><br><span class="line">        if (count % 3 &#x3D;&#x3D; 0 &amp;&amp; n) &#123;</span><br><span class="line">            ans +&#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (n);</span><br><span class="line">    return ans.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="26-判断是否是电话号码"><a href="#26-判断是否是电话号码" class="headerlink" title="26.判断是否是电话号码"></a>26.判断是否是电话号码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isPhone(tel) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;</span><br><span class="line">    return regx.test(tel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="27-验证是否是邮箱"><a href="#27-验证是否是邮箱" class="headerlink" title="27.验证是否是邮箱"></a>27.验证是否是邮箱</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEmail(email) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^([a-zA-Z0-9_\-]+@([a-zA-Z0-9_\-]+)+$&#x2F;;</span><br><span class="line">    return regx.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="28-用ES5实现数组的map方法"><a href="#28-用ES5实现数组的map方法" class="headerlink" title="28.用ES5实现数组的map方法"></a>28.用ES5实现数组的map方法</h1><ul><li>回调函数的参数有哪些，返回值如何处理</li><li>不修改原来的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.MyMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 转换类数组，由于是ES5所以就不用...展开符了</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> mappedArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 把当前值、索引、当前数组返回去。调用的时候传到函数参数中 [1,2,3,4].map((curr,index,arr))</span></span><br><span class="line">        mappedArr.push(fn.call(context, arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29-用ES5实现数组的reduce方法"><a href="#29-用ES5实现数组的reduce方法" class="headerlink" title="29.用ES5实现数组的reduce方法"></a>29.用ES5实现数组的reduce方法</h1><ul><li>初始值不传怎么处理</li><li>回调函数的参数有哪些，返回值如何处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce &#x3D; function(fn, initialValue) &#123;</span><br><span class="line">    let arr &#x3D; Array.prototpye.slice.call(this);</span><br><span class="line">    let res, startIndex;</span><br><span class="line">    &#x2F;&#x2F; 不传默认取数组第一项</span><br><span class="line">    res &#x3D; initialValue ? initialValue : arr[0];</span><br><span class="line">    startIndex &#x3D; initialValue ? 0 : 1;</span><br><span class="line">    for (let i &#x3D; startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 把初始值、当前值、索引、当前数组返回去。调用的时候传到函数参数中 [1,2,3,4].reduce((initVal,curr,index,arr))</span><br><span class="line">    res &#x3D; fn.call(null, res, arr[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于普通函数，绑定this指向</li><li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li></ul><h1 id="30-请实现一个-add-函数，满足以下功能"><a href="#30-请实现一个-add-函数，满足以下功能" class="headerlink" title="30.请实现一个 add 函数，满足以下功能"></a>30.请实现一个 add 函数，满足以下功能</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> fn_args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">returm args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="31-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒"><a href="#31-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒" class="headerlink" title="31.实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒"></a>31.实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sleep &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">return new Promise(resolve &#x3D;&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(1000).then(() &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 这里写你的函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="32-实现-5-add-3-minus-2-功能"><a href="#32-实现-5-add-3-minus-2-功能" class="headerlink" title="32.实现 (5).add(3).minus(2) 功能"></a>32.实现 (5).add(3).minus(2) 功能</h1><blockquote><p>例： 5 + 3 - 2，结果为 6</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="33-实现一个双向绑定"><a href="#33-实现一个双向绑定" class="headerlink" title="33.实现一个双向绑定"></a>33.实现一个双向绑定</h1><p><strong>defineProperty 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">Object.defineProperty(data, &#39;text&#39;, &#123;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">set(newVal) &#123;</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">data.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>proxy 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">set(target, key, value) &#123;</span><br><span class="line">target[key] &#x3D; value;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(data, handler);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图更改 --&gt; 数据变化</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">proxy.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="34-Array-isArray-实现"><a href="#34-Array-isArray-实现" class="headerlink" title="34.Array.isArray 实现"></a>34.Array.isArray 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.myIsArray &#x3D; function(o) &#123;</span><br><span class="line">return Object.prototype.toString.call(Object(o)) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Array.myIsArray([])); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="35-实现一个函数判断数据类型"><a href="#35-实现一个函数判断数据类型" class="headerlink" title="35.实现一个函数判断数据类型"></a>35.实现一个函数判断数据类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    <span class="comment">// 对象类型 &quot;[object XXX]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="string">&#x27;[object &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase() : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getType(<span class="literal">null</span>); <span class="comment">// -&gt; null</span></span><br><span class="line">getType(<span class="literal">undefined</span>); <span class="comment">// -&gt; undefined</span></span><br><span class="line">getType(&#123;&#125;); <span class="comment">// -&gt; object</span></span><br><span class="line">getType([]); <span class="comment">// -&gt; array</span></span><br><span class="line">getType(<span class="number">123</span>); <span class="comment">// -&gt; number</span></span><br><span class="line">getType(<span class="literal">true</span>); <span class="comment">// -&gt; boolean</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// -&gt; string</span></span><br><span class="line">getType(<span class="regexp">/123/</span>); <span class="comment">// -&gt; regexp</span></span><br><span class="line">getType(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// -&gt; date</span></span><br></pre></td></tr></table></figure><h1 id="36-实现Event-event-bus"><a href="#36-实现Event-event-bus" class="headerlink" title="36. 实现Event(event bus)"></a>36. 实现Event(event bus)</h1><blockquote><p>event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础</p></blockquote><p><strong>简单版：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmeitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">this</span>._events || <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 储存事件/回调键值对</span></span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="built_in">this</span>._maxListeners || <span class="number">10</span>; <span class="comment">// 设立监听上限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从储存事件键值对的this._events中获取对应事件回调函数</span></span><br><span class="line">  <span class="keyword">let</span> handler = <span class="built_in">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handler.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.call(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将type事件以及对应的fn函数放入this._events中储存</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._events.get(type)) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.set(type, fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>面试版：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmeitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">this</span>._events || <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 储存事件/回调键值对</span></span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="built_in">this</span>._maxListeners || <span class="number">10</span>; <span class="comment">// 设立监听上限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler;</span><br><span class="line">  handler = <span class="built_in">this</span>._events.get(type);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">    <span class="comment">// 如果是一个数组说明有多个监听者,需要依次此触发里面的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        handler[i].apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler[i].call(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单个函数的情况我们直接触发即可</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      handler.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听名为type的事件</span></span><br><span class="line">EventEmeitter.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="built_in">this</span>._events.get(type); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line">  <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.set(type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果handler是函数说明只有一个监听者</span></span><br><span class="line">    <span class="built_in">this</span>._events.set(type, [handler, fn]); <span class="comment">// 多个监听者我们需要用数组储存</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler.push(fn); <span class="comment">// 已经有多个监听者,那么直接往数组里push函数即可</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmeitter.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = <span class="built_in">this</span>._events.get(type); <span class="comment">// 获取对应事件名称的函数清单</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是函数,说明只被监听了一次</span></span><br><span class="line">  <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> handler === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events.delete(type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> postion;</span><br><span class="line">    <span class="comment">// 如果handler是数组,说明被监听多次要找到对应的函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (handler[i] === fn) &#123;</span><br><span class="line">        postion = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postion = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到匹配的函数,从数组中清除</span></span><br><span class="line">    <span class="keyword">if</span> (postion !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到数组对应的位置,直接清除此回调</span></span><br><span class="line">      handler.splice(postion, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果清除后只有一个函数,那么取消数组,以函数形式保存</span></span><br><span class="line">      <span class="keyword">if</span> (handler.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events.set(type, handler[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="37-模拟new"><a href="#37-模拟new" class="headerlink" title="37.模拟new"></a>37.模拟new</h1><p><strong>new操作符做了这些事：</strong></p><ul><li>创建一个全新的对象，这个对象的<code>__proto__</code>要指向构造函数的原型对象</li><li>执行构造函数</li><li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(instance, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res: instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="38-手写实现set和map"><a href="#38-手写实现set和map" class="headerlink" title="38.手写实现set和map"></a>38.手写实现set和map</h1><h2 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h2><p>ES6提供给我们的构造函数，能够造出一种新的存储数据的结构，只有属性值，成员值唯一（不重复）。</p><pre><code>class MySet&#123;    constructor(iterator)&#123;        // 判断是否是可迭代对象        if(typeof iterator[Symbol.iterator] !== &quot;function&quot;)&#123;            throw new Error(`你提供的$&#123;iterator&#125;不是一个课迭代的对象`);        &#125;        this._datas = [];        // 循环可迭代对象，将结果加入到set中        for (const item of iterator) &#123;            this.add(item);        &#125;    &#125;    add(data)&#123;        if(!this.has(data))&#123;            this._datas.push(data);        &#125;    &#125;    has(data)&#123;        for (const item of this._datas) &#123;            if(this.isEqual(data,item))&#123;                return true;            &#125;        &#125;        return false;    &#125;    delete(data)&#123;        for (let i = 0; i &lt; this._datas.length; i++) &#123;            const element = this._datas[i];            if(this.isEqual(element, data))&#123;                this._datas.splice(i,1);                return true;            &#125;        &#125;        return false;    &#125;    // 遍历    *[Symbol.iterator]()&#123;        for (const item of this._datas) &#123;            yield item;        &#125;    &#125;    forEach(callback)&#123;        for (const item of this._datas) &#123;            callback(item,ietm,this);        &#125;    &#125;    clear()&#123;        this._datas.length = 0;    &#125;    /**     * 判断两个数据是否相等     * @param &#123;*&#125; data1      * @param &#123;*&#125; data2      */    isEqual(data1,data2)&#123;        if(data1 === 0 &amp;&amp; data2 === 0)&#123;            return true;        &#125;        return Object.is(data1,data2);    &#125;&#125;</code></pre><h2 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h2><p>ES6提供给我们的构造函数，能够造出一种新的存储数据的结构。本质上是键值对的集合。key对应value，key和value唯一，任何值都可以当属性。</p><pre><code>class MyMap&#123;    constructor(iterable = [])&#123;         //判断是否是可迭代对象         if(typeof iterable[Symbol.iterator] !== &quot;function&quot;)&#123;            throw new Error(`你提供的$&#123;iterable&#125;不是一个课迭代的对象`);        &#125;        this._datas = [];        for (const item of iterable) &#123;            //item也是一个可迭代的对象            if(typeof item[Symbol.iterator] !== &quot;function&quot;)&#123;                throw new Error(`你提供的$&#123;item&#125;不是一个课迭代的对象`)            &#125;            const iterator = item[Symbol.iterator]();            const key = iterator.next().value;            const value = iterator.next().value;            this.set(key,value);        &#125;    &#125;    set(key, value)&#123;        //看里面有没有，如果有，则直接修改key对应的value值        const obj = this._getObj(key);        if(obj)&#123;            //修改            obj.value = value;        &#125;else&#123;            this._datas.push(&#123;                key,                value            &#125;)        &#125;    &#125;    get(key)&#123;        const item = this._getObj(key);        if(item)&#123;            return item.value;        &#125;        return undefined;    &#125;    get_size()&#123;        return this._datas.length;    &#125;    delete(key)&#123;       for (let i = 0; i &lt; this._datas.length; i++) &#123;           const element = this._datas[i];           if(this.isEqual(element.key,key))&#123;               this._datas.splice(i,1);               return true;           &#125;       &#125;       return false;    &#125;    clear()&#123;        this._datas.length = 0;    &#125;    has(key)&#123;        const item = this._getObj(key);        return item !== undefined;    &#125;    /**     * 根据key值找到对应的数组项     * @param &#123;*&#125; key      */    _getObj(key)&#123;        for (const item of this._datas) &#123;            if(this.isEqual(item.key,key))&#123;                return item;            &#125;        &#125;        return undefined;    &#125;    isEqual(data1,data2)&#123;        if(data1 === 0 &amp;&amp; data2 === 0)&#123;            return true;        &#125;        return Object.is(data1,data2);    &#125;    *[Symbol.iterator]()&#123;        for (const item of this._datas) &#123;            yield[item.key,item.value];        &#125;    &#125;    forEach(callback)&#123;        for (const item of this._datas) &#123;            callback(item.value,item.key,this);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;手写常见js函数，面试必备，多练几遍，争取手撕&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
</feed>
