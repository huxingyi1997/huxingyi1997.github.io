<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Frog_16px_1177822_easyicon.net.ico">
  <link rel="mask-icon" href="/images/Frog_32px_1177822_easyicon.net.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hxy1997.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"输入关键字","hits_empty":"没有找到与「${query}」相关搜索","hits_stats":"${hits} 条相关记录，共耗时 ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="这个部分用来介绍操作系统，作为非科班同学，这一块应该好好学习，不仅仅是应付面试，之前就突击了线程、进程、死锁的知识，别的就是一窍不通了，这次尽可能了解完整的操作系统知识体系。一个简单的例子：  在我们的JS代码里，只需要输入 console.log(1 + 1); 就可以在浏览器面板中看到2，这其中发生了什么事情呢? 首先键盘输入代码1 + 1到显示器输出2, 需要CPU控制键盘（输入设备），将获">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://hxy1997.xyz/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="hxy的博客">
<meta property="og:description" content="这个部分用来介绍操作系统，作为非科班同学，这一块应该好好学习，不仅仅是应付面试，之前就突击了线程、进程、死锁的知识，别的就是一窍不通了，这次尽可能了解完整的操作系统知识体系。一个简单的例子：  在我们的JS代码里，只需要输入 console.log(1 + 1); 就可以在浏览器面板中看到2，这其中发生了什么事情呢? 首先键盘输入代码1 + 1到显示器输出2, 需要CPU控制键盘（输入设备），将获">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210422113506.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221335.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221441.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221459.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aab9e83fd9946a0be42d6554b57d11f~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca5bf6a988942cf8f2c0f5649620b0b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8221b4f6af5a4098b0d186bda0af7bf5~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b4acbaaf16f4572b0f03b28f7011c6a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ce896feb7f4699b9d755c3cb83a7dd~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/4/170a4342ae392e20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/4/170a447e4751bf4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/4/170a44da4cba4ed1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b6ab407a3294608a04bf7b7767c807a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/4/170a581fb91ee433?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/4/170a5a014655ce2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c0707f849940caa35f5f1adcda7515~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/5/170a64d4316feb29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/5/170a64d9fe429957?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/5/170a653c025a0a46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/5/170ab316637293c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/5/170ab453215e0426?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52dde03332984dc9b9b3b6b0e9472b1a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae1ed19358374?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae2cd01ca96d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae8d9a26f1029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ee05d2b123420b8e6172131abc8108~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae9b1af241626?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae9c18688717f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a2bb469deeb4cb78b03a0aff606d29b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170ae9cde4d8ffde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170aee393ffd0e82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170aef6e29ddaf75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1dffc1075d42eeb00619ea4fe3e8b1~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47292fc492ee437d8c48a6b6fccb19ee~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170aef9d07c0a489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/6/170af037199fbd9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/7/170b0a32298a1f62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/7/170b0a75d10bd130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/22/17101701a8b5229d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/22/17101706689b2238?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/22/17101d0ebef25336?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/7/170b0c6245723138?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/7/170b0cdff976f56b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55ee47325c448bd833d30e34aa6b856~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380e331a1d0e4422b8a79e186248d3ec~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30b66758daf74316b725cf3b00039b7f~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c466a876ef043068fc4bcd8a14aa0b8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c96f6a295d4e4386a8cbbc9120daa9ac~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12b88d9f80b74c7b834fda64f9f70514~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/17124ab5c2726806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/1/17133a8c513bbc25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/1/17133ad6cd968301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/1/171360901ecc8590?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/1/17136299db333910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e19d5e052c4d2aa40c0c7fd0112e8b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed60e922592e4fdc9d798cafb87a945c~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e4680bebd4e4762af719d8860f3cb80~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://range0122.github.io/imgs/page1.png">
<meta property="og:image" content="https://range0122.github.io/imgs/page2.png">
<meta property="og:image" content="https://range0122.github.io/imgs/segment.png">
<meta property="og:image" content="https://range0122.github.io/imgs/page&segment.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3d27b068b124589baee535da749bcc0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171265b304cd6988?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171266931ce296e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171266eca83a1fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171267e499b86cba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/30/1712958537512c5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/30/1712987dbb104bf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/1712f7c62e640c55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/1712f97d9c361d47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/1712fa51d0e2cd5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/1712faea7fb6a47a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/1713015837097fc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/171301b2fb9a17b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/17130b5dbd9375ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/17130c781a0ab962?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/31/17130f1a1ebbde6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62ac3982ff84a12af120b76dd8da95b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08c9eaae7d44d76975cb790dbbff765~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d93b28049444348a2fb25650dc3b6b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/184e699da9aa45d6af274952d81c476e~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a63f65a6f9483dabe5b951a5915c98~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3917654aeb4f65ab0ecde925675531~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171255f53e94df47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/1712560a47c66aba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/17125616ebd6d68d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://range0122.github.io/imgs/IO.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/171258cd27939935?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/3/29/17125a5e38698d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b460cfde9e48df86195e34aeea1ea3~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55f7584a42543ff92cb0214a70ba6b0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55249c1fb9734d1ebd5af53a63bc128a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c332cc68dd79441ebe50b6f99c85735a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-ecd96829be63c2c7fdfba106413c9396_720w.jpg">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d399e4206ebb4ae49c7037c77f8a91e0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2021-03-27T13:49:00.000Z">
<meta property="article:modified_time" content="2021-05-14T14:17:30.632Z">
<meta property="article:author" content="hxy">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210422113506.png">

<link rel="canonical" href="https://hxy1997.xyz/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | hxy的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="hxy的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxy的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Mia san Mia!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/huxingyi1997" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hxy1997.xyz/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Robben.gif">
      <meta itemprop="name" content="hxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxy的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-27 21:49:00" itemprop="dateCreated datePublished" datetime="2021-03-27T21:49:00+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 22:17:30" itemprop="dateModified" datetime="2021-05-14T22:17:30+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">计算机基础知识</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这个部分用来介绍操作系统，作为非科班同学，这一块应该好好学习，不仅仅是应付面试，之前就突击了线程、进程、死锁的知识，别的就是一窍不通了，这次尽可能了解完整的操作系统知识体系。一个简单的例子：</p>
<ul>
<li>在我们的JS代码里，只需要输入 <code>console.log(1 + 1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?</li>
<li>首先键盘输入代码<code>1 + 1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备），将获取的<code>1 + 1</code>指令放入内存</li>
<li>然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1 + 1</code>的加法运算</li>
<li>此时CPU的控制将控制CPU的运算器做<code>1 + 1</code>的加法运算，并得出结果<code>2</code></li>
<li>最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li>
</ul>
<p>好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。</p>
<span id="more"></span>

<h1 id="1-操作系统简介"><a href="#1-操作系统简介" class="headerlink" title="1. 操作系统简介"></a>1. 操作系统简介</h1><h2 id="1-1-什么是操作系统-面试必背"><a href="#1-1-什么是操作系统-面试必背" class="headerlink" title="1.1 什么是操作系统(面试必背)"></a>1.1 什么是操作系统(面试必背)</h2><p><strong>操作系统是管理硬件和软件的一种应用程序</strong>。操作系统是运行在计算机上最重要的一种<code>软件</code>，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210422113506.png" alt="img"></p>
<p>通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统保证这些访问和交互能够准确无误的进行。</p>
<p>操作系统是一种软件，它的主要目的有三种</p>
<ul>
<li>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。</li>
<li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li>
<li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li>
</ul>
<h2 id="1-2-操作系统的主要功能"><a href="#1-2-操作系统的主要功能" class="headerlink" title="1.2 操作系统的主要功能"></a>1.2 操作系统的主要功能</h2><p>一般来说，现代操作系统主要提供下面几种功能</p>
<ul>
<li><code>进程管理</code>: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题</li>
<li><code>内存管理</code>：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出</li>
<li><code>设备管理</code>：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。</li>
<li><code>文件管理</code>：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。</li>
<li><code>提供用户接口</code>：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。</li>
</ul>
<h2 id="1-3-操作系统的四个特征"><a href="#1-3-操作系统的四个特征" class="headerlink" title="1.3 操作系统的四个特征"></a>1.3 操作系统的四个特征</h2><p>操作系统有以下四个特征：</p>
<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>接下来，我们分别来搞定每一个特征。</p>
<h3 id="1-3-1-并发是什么？和并行有啥区别？"><a href="#1-3-1-并发是什么？和并行有啥区别？" class="headerlink" title="1.3.1 并发是什么？和并行有啥区别？"></a>1.3.1 并发是什么？和并行有啥区别？</h3><p>举个例子，假如你在语音跟同学玩英雄联盟：</p>
<ul>
<li>你一边用鼠标移动打游戏，同时语音嘴里说”队友挂机，真坑！”, 这叫并行（边移动鼠标边语音BB）</li>
<li>你一边用鼠标移动打游戏，然后离开鼠标，去砸键盘, 这叫并发（先离开鼠标然后砸键盘）</li>
</ul>
<p>并发只是把时间分成若干段，<code>使多个任务交替的执行</code>。 并行的关键是你有<code>同时处理</code>多个任务的能力。</p>
<ul>
<li>所以我认为它们最关键的点就是：<code>是否是『同时』</code></li>
</ul>
<p>那么对于操作系统而言，操作系统的并发性指计算机系统中<code>同时存在多个运行着的程序</code>。</p>
<ul>
<li>比如说以前的计算机是单核CPU，那么如何在操作系统上同时运行QQ、浏览器，记事本、ppt等多个程序呢，这就需要操作系统具有并发性</li>
<li><code>CPU时间片</code>（操作系统分配给每个正在运行的进程微观上的一段CPU时间）轮着给进程执行的时间，因为执行速度很快，<code>看起来就像</code>浏览器能同时执行任务一样。</li>
<li>有人会说，现在都多核CPU了，还需要并发吗，答案肯定是需要的，比如你有8核CPU，但是桌面要执行的任务很可能超过8个。</li>
</ul>
<h3 id="1-3-2-共享是什么？共享和并发有什么关系？"><a href="#1-3-2-共享是什么？共享和并发有什么关系？" class="headerlink" title="1.3.2 共享是什么？共享和并发有什么关系？"></a>1.3.2 共享是什么？共享和并发有什么关系？</h3><p>举一个例子： 你同时用QQ和微信发”年终述职.ppt”文件给领导，这时候QQ和微信都在读取这个ppt文件</p>
<ul>
<li>两个进程正在并发执行（并发性）</li>
<li>需要共享地访问硬盘资源（共享性） 如果没有并发，也就是只有一个进程在运行，那就没有共享了。如果没有共享，QQ和微信就不能同时发文件，无法同时访问硬盘资源，也就无法并发。</li>
</ul>
<p>其中共享分为两种情况：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221335.webp" alt="img"></p>
<ul>
<li>上面的例子，QQ和微信都要访问同一个文件，属于<code>同时共享</code>。</li>
<li>对于互斥共享，比如打印机，<code>只能同一时刻被一个进程控制</code>，如打印机，虽然他可以提供多个进程使用，但是试想，同时打印多个东西，会造成打印结果的混乱，因此规定，某些资源在进行使用的时候，必须要先让某进程先使用，等使用完之后，再同一其他进程进行访问。</li>
<li>我们把一段时间内只允许一个进程访问的资源称为<code>独占资源</code>，或<code>临界资源</code>。</li>
</ul>
<h3 id="1-3-3-虚拟是什么？"><a href="#1-3-3-虚拟是什么？" class="headerlink" title="1.3.3 虚拟是什么？"></a>1.3.3 虚拟是什么？</h3><p>先举例，再说定义。</p>
<p>假如一个叫<code>范桶</code>的货车司机在玩英雄联盟，平时因为酒驾太多，自己装了很多次别人的车，住院也花了不少钱，所以家里没钱，只能买个<code>1G内存</code>的二手电脑玩游戏。可<code>英雄联盟</code>至少需要<code>2G内存</code>，这就奇怪了，老司机虽然一到团战就卡死，但是还是能运行英雄联盟。为什么需要<code>2G内存</code>的游戏，<code>1G电脑</code>还能运行呢？</p>
<p>这就是虚拟存储器技术。实际上<code>只有1G内存</code>，在用户看来<code>远远大于1G</code>。</p>
<p>还有，<code>范桶</code>的电脑还是<code>单核的</code>，但<code>范桶</code>居然能一边迅雷下着爱情动作片，一边听着网易云音乐，还在QQ上撩妹子，既然一个程序要被分配CPU才能正常执行，按道理来说同一时间只有1个程序在运行，为啥电脑能同时运行这么多程序呢？</p>
<p>这就是虚拟处理器技术。实际上只有<code>一个CPU</code>，在用户看来有<code>3个CPU</code>在同时服务。（因为CPU来回切换进程的速度特别块，感觉就像很多CPU在为我们服务）</p>
<p>虚拟这块的总结如下:</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221441.webp" alt="img"></p>
<h3 id="1-3-4-异步性是什么"><a href="#1-3-4-异步性是什么" class="headerlink" title="1.3.4 异步性是什么?"></a>1.3.4 异步性是什么?</h3><p>异步在JS里是很常见的，比如<code>ajax请</code>求，我们发出请求后并不是立马得到信息，也不会去等待<code>ajax</code>结果返回，而是继续执行下面的代码，等ajax结果回来，通知<code>JS线程</code>。这就跟<code>CPU处理进程</code>很类似。</p>
<p>比如，CPU正在执行一个进程，进程需要读取文件，读取文件可能要<code>1个小时</code>，那CPU不可能一直等一个小时，CPU会继续把时间片分给别的进程，等文件读取完成了（类似ajax返回结果了），<code>CPU再继续执行</code>之前被<code>中断</code>的进程。</p>
<p>所以异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。</p>
<h2 id="1-4-软件访问硬件的几种方式"><a href="#1-4-软件访问硬件的几种方式" class="headerlink" title="1.4 软件访问硬件的几种方式"></a>1.4 软件访问硬件的几种方式</h2><p>软件访问硬件其实就是一种 IO 操作，软件访问硬件的方式，也就是 I/O 操作的方式有哪些。</p>
<p>硬件在 I/O 上大致分为<strong>并行和串行</strong>，同时也对应串行接口和并行接口。</p>
<p>随着计算机技术的发展，I/O 控制方式也在不断发展。选择和衡量 I/O 控制方式有如下三条原则</p>
<blockquote>
<p>（1） 数据传送速度足够快，能满足用户的需求但又不丢失数据；</p>
<p>（2） 系统开销小，所需的处理控制程序少；</p>
<p>（3） 能充分发挥硬件资源的能力，使 I/O 设备尽可能忙，而 CPU 等待时间尽可能少。</p>
</blockquote>
<p>根据以上控制原则，I/O 操作可以分为四类</p>
<ul>
<li><code>直接访问</code>：直接访问由用户进程直接控制主存或 CPU 和外围设备之间的信息传送。直接程序控制方式又称为忙/等待方式。</li>
<li><code>中断驱动</code>：为了减少程序直接控制方式下 CPU 的等待时间以及提高系统的并行程度，系统引入了中断机制。中断机制引入后，外围设备仅当操作正常结束或异常结束时才向 CPU 发出中断请求。在 I/O 设备输入每个数据的过程中，由于无需 CPU 的干预，一定程度上实现了 CPU 与 I/O 设备的并行工作。</li>
</ul>
<p>上述两种方法的特点都是以 <code>CPU</code> 为中心，数据传送通过一段程序来实现，软件的传送手段限制了数据传送的速度。接下来介绍的这两种 I/O 控制方式采用硬件的方法来显示 I/O 的控制</p>
<ul>
<li><code>DMA 直接内存访问</code>：为了进一步减少 CPU 对 I/O 操作的干预，防止因并行操作设备过多使 CPU 来不及处理或因速度不匹配而造成的数据丢失现象，引入了 DMA 控制方式。</li>
<li><code>通道控制方式</code>：通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。</li>
</ul>
<h2 id="1-5-常见的操作系统"><a href="#1-5-常见的操作系统" class="headerlink" title="1.5 常见的操作系统"></a>1.5 常见的操作系统</h2><p>常见的操作系统只有三种：<strong>Windows、macOS 和 Linux</strong>。</p>
<h3 id="1-5-1-Linux应用程序可以直接在Windows下运行吗"><a href="#1-5-1-Linux应用程序可以直接在Windows下运行吗" class="headerlink" title="1.5.1 Linux应用程序可以直接在Windows下运行吗"></a>1.5.1 Linux应用程序可以直接在Windows下运行吗</h3><p>Linux 系统下的应用程序不能直接在 Windows 下运行，其中一点是因为 Linux 系统和 Windows 系统的格式不同，<strong>格式就是协议</strong>，就是在固定位置有意义的数据。Linux 下的可执行程序文件格式是 <code>elf</code>，可以使用 <code>readelf</code> 命令查看 elf 文件头。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210514221459.png" alt="img"></p>
<p>而 Windows 下的可执行程序是 <code>PE</code> 格式，它是一种可移植的可执行文件。</p>
<p>还有一点是因为 Linux 系统和 Windows 系统的 <code>API</code> 不同，这个 API 指的就是操作系统的 API，Linux 中的 API 被称为<code>系统调用</code>，是通过 <code>int 0x80</code> 这个软中断实现的。而 Windows 中的 API 是放在动态链接库文件中的，也就是 Windows 开发人员所说的 <code>DLL</code> ，这是一个库，里面包含代码和数据。Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。</p>
<h3 id="1-5-2-Linux-操作系统的启动过程"><a href="#1-5-2-Linux-操作系统的启动过程" class="headerlink" title="1.5.2 Linux 操作系统的启动过程"></a>1.5.2 Linux 操作系统的启动过程</h3><p>当计算机电源通电后，<code>BIOS</code>会进行<code>开机自检(Power-On-Self-Test, POST)</code>，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 <code>MBR(Master Boot Record)</code> 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。</p>
<p>复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。</p>
<p>内核启动代码是使用<code>汇编语言</code>完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。</p>
<p>这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。</p>
<p>然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。</p>
<p>配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 <code>init 进程(进程 1 )</code> 和 <code>守护进程(进程 2)</code>。</p>
<p>init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。</p>
<p>然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 <code>getty</code> 的程序。</p>
<p>getty 程序会在终端上输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login:</span><br></pre></td></tr></table></figure>

<p>等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 <code>/bin/login</code> 开始运行。login 程序需要输入密码，并与保存在 <code>/etc/passwd</code> 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。</p>
<p>整个系统启动过程如下</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aab9e83fd9946a0be42d6554b57d11f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="1-5-3-实时系统"><a href="#1-5-3-实时系统" class="headerlink" title="1.5.3 实时系统"></a>1.5.3 实时系统</h3><p>实时操作系统对时间做出了严格的要求，实时操作系统分为两种：<strong>硬实时和软实时</strong></p>
<p><code>硬实时操作系统</code>规定某个动作必须在规定的时刻内完成或发生，比如汽车生产车间，焊接机器必须在某一时刻内完成焊接，焊接的太早或者太晚都会对汽车造成永久性伤害。</p>
<p><code>软实时操作系统</code>虽然不希望偶尔违反最终的时限要求，但是仍然可以接受。并且不会引起任何永久性伤害。比如数字音频、多媒体、手机都是属于软实时操作系统。</p>
<p>你可以简单理解硬实时和软实时的两个指标：<strong>是否在时刻内必须完成以及是否造成严重损害</strong>。</p>
<h2 id="1-6-操作系统结构"><a href="#1-6-操作系统结构" class="headerlink" title="1.6 操作系统结构"></a>1.6 操作系统结构</h2><h3 id="1-6-1-单体系统"><a href="#1-6-1-单体系统" class="headerlink" title="1.6.1 单体系统"></a>1.6.1 单体系统</h3><p>在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序，这种系统称为单体系统。</p>
<p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p>
<p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca5bf6a988942cf8f2c0f5649620b0b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p>
<h3 id="1-6-2-分层系统"><a href="#1-6-2-分层系统" class="headerlink" title="1.6.2 分层系统"></a>1.6.2 分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8221b4f6af5a4098b0d186bda0af7bf5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="1-6-3-微内核"><a href="#1-6-3-微内核" class="headerlink" title="1.6.3 微内核"></a>1.6.3 微内核</h3><p>为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p>
<p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b4acbaaf16f4572b0f03b28f7011c6a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p>
<h3 id="1-6-4-客户-服务器模式"><a href="#1-6-4-客户-服务器模式" class="headerlink" title="1.6.4 客户-服务器模式"></a>1.6.4 客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p>
<p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ce896feb7f4699b9d755c3cb83a7dd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p>
<h2 id="1-7-操作系统运行机制和体系结构"><a href="#1-7-操作系统运行机制和体系结构" class="headerlink" title="1.7 操作系统运行机制和体系结构"></a>1.7 操作系统运行机制和体系结构</h2><p>预备知识： 什么是指令</p>
<p>比如说，如下图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a4342ae392e20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>a+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成汇编语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 意思是将内存的16号单元数据，放到A寄存器，</span><br><span class="line">LOAD A, 16</span><br><span class="line">&#x2F;&#x2F; 意思是将内存的16号单元数据，放到B寄存器</span><br><span class="line">LOAD B, 17</span><br><span class="line">&#x2F;&#x2F; 存器里的A,B数据相加，得到C</span><br><span class="line">ADD C, A, B</span><br></pre></td></tr></table></figure>

<p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p>
<h3 id="1-7-1-两种指令、两种处理器状态、两种程序"><a href="#1-7-1-两种指令、两种处理器状态、两种程序" class="headerlink" title="1.7.1 两种指令、两种处理器状态、两种程序"></a>1.7.1 两种指令、两种处理器状态、两种程序</h3><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a447e4751bf4f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图:</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a44da4cba4ed1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>CPU通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。</p>
<ul>
<li><code>内核态</code>：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</li>
<li><code>用户态</code>：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>
</ul>
<blockquote>
<p>那么为什么要有用户态和内核态呢？</p>
</blockquote>
<p>这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>
<h4 id="必背考点：内核态与用户态概念"><a href="#必背考点：内核态与用户态概念" class="headerlink" title="必背考点：内核态与用户态概念"></a>必背考点：内核态与用户态概念</h4><ul>
<li>内核态：cpu 可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu 也可以将自己从一个程序切换到另一个程序。</li>
<li>用户态：只能受限的访问内存，且不允许访问外围设备，占用 cpu 的能力被剥夺，cpu 资源可以被其他程序获取。</li>
</ul>
<h4 id="用户态和内核态是如何切换的？"><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h4><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 <code>系统调用</code>，而能够执行系统调用的就只有 <code>操作系统</code>。</p>
<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 <code>陷阱指令(trap instruction)</code>。</p>
<p>他们的工作流程如下：</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b6ab407a3294608a04bf7b7767c807a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>首先用户程序会调用 <code>glibc</code> 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用<code>系统调用</code>的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用<code>软件中断指令(SWI)</code> ，这个指令通过更新 <code>CPSR</code> 寄存器将模式改为超级用户模式，然后跳转到地址 <code>0x08</code> 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 <code>vector_swi()</code>。</li>
<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 <code>sys_call_table</code> 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ul>
<p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a581fb91ee433?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="必背考点：用户态到内核态的切换"><a href="#必背考点：用户态到内核态的切换" class="headerlink" title="必背考点：用户态到内核态的切换"></a>必背考点：用户态到内核态的切换</h4><ul>
<li>异常事件： 当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li>外围设备的中断：当外围设备完成用户的请求操作后，会像 CPU 发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ul>
<h3 id="1-7-2-操作系统内核简单介绍"><a href="#1-7-2-操作系统内核简单介绍" class="headerlink" title="1.7.2 操作系统内核简单介绍"></a>1.7.2 操作系统内核简单介绍</h3><p>从下图，我们先看看操作系统内核包含哪些</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/4/170a5a014655ce2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>在计算机中，内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容</strong>。内核通常是在 boot loader 装载程序之前加载的第一个程序。</p>
<p>这里还需要了解一下什么是 <code>boot loader</code>。</p>
<blockquote>
<p>boot loader 又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一些初始测试，然后将控制权转移到引导加载程序所在的<code>主引导记录(MBR)</code> 。</p>
</blockquote>
<p>操作系统内核中跟硬件紧密相关的部分有：</p>
<ul>
<li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li>
<li>中断处理</li>
<li>原语。可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li>
</ul>
<h3 id="1-7-3-陷入内核"><a href="#1-7-3-陷入内核" class="headerlink" title="1.7.3 陷入内核"></a>1.7.3 陷入内核</h3><p>如果把软件结构进行分层说明的话，应该是这个样子的，最外层是应用程序，里面是操作系统内核。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c0707f849940caa35f5f1adcda7515~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>应用程序处于特权级 3，操作系统内核处于特权级 0 。如果用户程序想要访问操作系统资源时，会发起系统调用，陷入内核，这样 CPU 就进入了内核态，执行内核代码。至于为什么是陷入，我们看图，内核是一个凹陷的构造，有陷下去的感觉，所以称为陷入。</p>
<h2 id="1-8-中断"><a href="#1-8-中断" class="headerlink" title="1.8 中断"></a>1.8 中断</h2><h3 id="1-8-1-什么是中断"><a href="#1-8-1-什么是中断" class="headerlink" title="1.8.1 什么是中断"></a>1.8.1 什么是中断</h3><ul>
<li>在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a64d4316feb29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>第一个应用程序在用户态执行了一段时间后</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a64d9fe429957?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接着操作系统切换到核心态，处理中断信号</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170a653c025a0a46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li>
<li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li>
<li><code>进程</code>2需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li>
<li>打印机开始工作，此时<code>进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到<code>第三个应用程序</code>执行</li>
<li>等到打印机准备好了，此时打印机通过I/O控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把CPU给程序2继续执行。</li>
</ul>
<p>好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?</p>
<ul>
<li>“用户态 —&gt; 核心态”是通过中断实现的。<code>并且中断是实现其的唯一途径</code>。</li>
<li>“核心态 —&gt; 用户态”的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。</li>
</ul>
<h3 id="1-8-2-中断的分类"><a href="#1-8-2-中断的分类" class="headerlink" title="1.8.2 中断的分类"></a>1.8.2 中断的分类</h3><p>举一个例子，什么是内中断和外中断：</p>
<p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p>
<p>官方解释如下：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170ab316637293c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li>
<li>外中断常见的情况如<code>I/O中断</code>（由I/O控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I/O中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。</li>
</ul>
<h3 id="1-8-3-系统调用"><a href="#1-8-3-系统调用" class="headerlink" title="1.8.3 系统调用"></a>1.8.3 系统调用</h3><blockquote>
<p>为什么需要系统调用？</p>
</blockquote>
<ul>
<li>比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时CPU在<code>内核态</code>去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li>
<li>这里就引出系统调用的概念和作用。</li>
<li>应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li>
</ul>
<p>以下内容简单看一下即可，系统调用的分类：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/5/170ab453215e0426?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p>
<ul>
<li>库是可重用的模块 <code>处于用户态</code></li>
<li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li>
</ul>
<p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入创建子进程的模块</span><br><span class="line">const childProcess &#x3D; require(&#39;child_process&#39;)</span><br><span class="line">&#x2F;&#x2F; 获取cpu的数量</span><br><span class="line">const cpuNum &#x3D; require(&#39;os&#39;).cpus().length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建与cpu数量一样的子进程</span><br><span class="line">for (let i &#x3D; 0; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">	childProcess.fork(&#39;.&#x2F;worker.js&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><h2 id="2-1-多处理系统的优势"><a href="#2-1-多处理系统的优势" class="headerlink" title="2.1 多处理系统的优势"></a>2.1 多处理系统的优势</h2><p>随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52dde03332984dc9b9b3b6b0e9472b1a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。</p>
<h2 id="2-2-为什么要引入进程"><a href="#2-2-为什么要引入进程" class="headerlink" title="2.2 为什么要引入进程"></a>2.2 为什么要引入进程</h2><ul>
<li><p>早期的计算机只支持<strong>单道程序</strong>（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae1ed19358374?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
</li>
<li><p>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</p>
</li>
<li><p>拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</p>
</li>
<li><p>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</p>
</li>
</ul>
<h2 id="2-3-进程和进程控制块的定义"><a href="#2-3-进程和进程控制块的定义" class="headerlink" title="2.3 进程和进程控制块的定义"></a>2.3 进程和进程控制块的定义</h2><h3 id="2-3-1-进程"><a href="#2-3-1-进程" class="headerlink" title="2.3.1 进程"></a>2.3.1 进程</h3><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>(强调动态性)，换而言之，<code>进程</code>就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。</p>
<p>操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用 CPU，操作系统还会为每个进程分配特定的资源。</p>
<h4 id="必背考点"><a href="#必背考点" class="headerlink" title="必背考点"></a>必背考点</h4><ul>
<li>进程是程序在一个数据集合上运行的过程。</li>
<li>进程实体 = 程序段 + 数据段 + PCB</li>
<li>进程资源分配和资源调度的基本单位。</li>
<li>孤儿进程和僵尸进程<ul>
<li>孤儿进程：<ul>
<li>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li>孤儿进程并不会有什么危害。</li>
</ul>
</li>
<li>僵尸进程：<ul>
<li>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li>
<li>进程号就会一直被占用，但是系统所能使用的进程号是有限的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-进程控制块"><a href="#2-3-2-进程控制块" class="headerlink" title="2.3.2 进程控制块"></a>2.3.2 进程控制块</h3><p>操作系统为了跟踪每个进程的活动状态，维护了一个<code>进程控制块</code>。在进程控制块的内部，列出了每个进程的状态以及每个进程使用的资源等。</p>
<p>分别说明一下</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae2cd01ca96d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，<code>用于区分不同的进程</code>。</li>
<li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li>
<li>进程当前状态和优先级下一小节会详细介绍</li>
<li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li>
<li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li>
<li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li>
<li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来</li>
</ul>
<h2 id="2-4-进程的状态"><a href="#2-4-进程的状态" class="headerlink" title="2.4 进程的状态"></a>2.4 进程的状态</h2><h3 id="2-4-1-进程的组织"><a href="#2-4-1-进程的组织" class="headerlink" title="2.4.1 进程的组织"></a>2.4.1 进程的组织</h3><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae8d9a26f1029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="2-4-2-进程的状态模型"><a href="#2-4-2-进程的状态模型" class="headerlink" title="2.4.2 进程的状态模型"></a>2.4.2 进程的状态模型</h3><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<h4 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h4><p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ee05d2b123420b8e6172131abc8108~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>进程的三种基本状态详细图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9b1af241626?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>图中会涉及三种状态</p>
<ol>
<li><code>运行态</code>：运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。</li>
</ol>
<p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p>
<p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p>
<blockquote>
<p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p>
<h4 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h4><p>在三态模型的基础上，增加了两个状态，即 <code>新建</code> 和 <code>终止</code> 状态。</p>
<p>进程的另<code>新建</code> 和 <code>终止</code> 状态：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9c18688717f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a2bb469deeb4cb78b03a0aff606d29b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>新建态：进程的新建态就是进程刚创建出来的时候</li>
</ul>
<blockquote>
<p>创建进程需要两个步骤：即为新进程分配所需要的资源和空间，设置进程为就绪态，并等待调度执行。</p>
</blockquote>
<ul>
<li>终止态：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。</li>
</ul>
<blockquote>
<p>终止一个进程需要两个步骤：</p>
<ol>
<li>先等待操作系统或相关的进程进行善后处理。</li>
<li>然后回收占用的资源并被系统删除。</li>
</ol>
</blockquote>
<h3 id="2-4-3-进程状态的转换"><a href="#2-4-3-进程状态的转换" class="headerlink" title="2.4.3 进程状态的转换"></a>2.4.3 进程状态的转换</h3><p>进程的状态并不是一成不变的，在一定情况下会动态转换。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170ae9cde4d8ffde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫<code>原语</code>。</p>
<ul>
<li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aee393ffd0e82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p>
<ul>
<li>首先执行关中断指令</li>
<li>然后外部来了中断信号，不予以处理</li>
<li>等到开中断指令执行后，其他中断信号才有机会处理。</li>
</ul>
<h3 id="2-4-4-进程的终止"><a href="#2-4-4-进程的终止" class="headerlink" title="2.4.4 进程的终止"></a>2.4.4 进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p>
<h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c	</span><br></pre></td></tr></table></figure>

<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>
<h2 id="2-5-进程的通信"><a href="#2-5-进程的通信" class="headerlink" title="2.5 进程的通信"></a>2.5 进程的通信</h2><blockquote>
<p>为什么需要进程间通信呢？</p>
</blockquote>
<p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aef6e29ddaf75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>进程间的通信方式比较多，首先你需要理解下面这几个概念</p>
<ul>
<li><p>竞态条件：即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为<code>竞态条件(race condition)</code>。</p>
</li>
<li><p>临界区：不仅<code>共享资源</code>会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。</p>
<p>一个好的解决方案，应该包含下面四种条件</p>
<ol>
<li>任何时候两个进程不能同时处于临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>位于临界区外的进程不得阻塞其他进程</li>
<li>不能使任何进程无限等待进入临界区</li>
</ol>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1dffc1075d42eeb00619ea4fe3e8b1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
</li>
<li><p>忙等互斥：当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。</p>
</li>
</ul>
<p>进程间的通信用专业一点的术语来表示就是 <code>Inter Process Communication，IPC</code>，它主要有下面 7种通信方式</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47292fc492ee437d8c48a6b6fccb19ee~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="必背考点：进程有哪些通信方式"><a href="#必背考点：进程有哪些通信方式" class="headerlink" title="必背考点：进程有哪些通信方式"></a>必背考点：进程有哪些通信方式</h4><ul>
<li><code>消息传递</code>：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方</li>
<li><code>先进先出队列</code>：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式</li>
<li><code>管道</code>：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。</li>
<li><code>直接通信</code>：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。</li>
<li><code>间接通信</code>：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。</li>
<li><code>消息队列</code>：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。</li>
<li><code>共享内存</code>：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。</li>
<li>套接字： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li>信号：用于Linux系统中，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
</ul>
<p>详细介绍3种</p>
<h3 id="2-5-1-进程通信方法—共享内存"><a href="#2-5-1-进程通信方法—共享内存" class="headerlink" title="2.5.1 进程通信方法—共享内存"></a>2.5.1 进程通信方法—共享内存</h3><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170aef9d07c0a489?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>其中，介绍一下基于存储区的共享。</p>
<ul>
<li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li>
</ul>
<h3 id="2-5-2-进程通信方法—管道（匿名管道）"><a href="#2-5-2-进程通信方法—管道（匿名管道）" class="headerlink" title="2.5.2 进程通信方法—管道（匿名管道）"></a>2.5.2 进程通信方法—管道（匿名管道）</h3><p><img data-src="https://user-gold-cdn.xitu.io/2020/3/6/170af037199fbd9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li>
<li>如果没写满就不允许读。如果都没空就不允许写。</li>
<li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li>
</ul>
<h3 id="2-5-3-进程通信方法—消息传递"><a href="#2-5-3-进程通信方法—消息传递" class="headerlink" title="2.5.3 进程通信方法—消息传递"></a>2.5.3 进程通信方法—消息传递</h3><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>&quot;发送消息/接收消息&quot;</code>两个原语进行数据交换。</p>
<p>其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0a32298a1f62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布-订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0a75d10bd130?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="2-6-进程的同步和互斥"><a href="#2-6-进程的同步和互斥" class="headerlink" title="2.6 进程的同步和互斥"></a>2.6 进程的同步和互斥</h2><blockquote>
<p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p>
</blockquote>
<p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图1所示。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101701a8b5229d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p>
</blockquote>
<p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程B才可以继续执行。概念如图3所示。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101706689b2238?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="必背考点：进程同步的原则"><a href="#必背考点：进程同步的原则" class="headerlink" title="必背考点：进程同步的原则"></a>必背考点：进程同步的原则</h4><ul>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ul>
<h3 id="2-6-1-信号量（了解概念即可）"><a href="#2-6-1-信号量（了解概念即可）" class="headerlink" title="2.6.1 信号量（了解概念即可）"></a>2.6.1 信号量（了解概念即可）</h3><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p>
<p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*记录型信号量的定义*&#x2F;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int value; &#x2F;&#x2F; 剩余资源</span><br><span class="line">    Struct process *L &#x2F;&#x2F; 等待队列</span><br><span class="line">&#125; semaphore</span><br></pre></td></tr></table></figure>

<p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。</p>
<p><code>Struct process *L</code>意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*P 操作，也就是记录型信号量的请求资源操作*&#x2F;</span><br><span class="line">void wait (semaphore S) &#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    if (S.value &lt; 0)&#123;</span><br><span class="line">        block (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*V 操作，也就是记录型信号量的释放资源操作*&#x2F;</span><br><span class="line">void singal (semaphore S) &#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    if (S.value &lt;&#x3D; 0)&#123;</span><br><span class="line">        wakeup (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。</p>
<h3 id="2-6-2-生产者消费者问题（了解概念即可）"><a href="#2-6-2-生产者消费者问题（了解概念即可）" class="headerlink" title="2.6.2 生产者消费者问题（了解概念即可）"></a>2.6.2 生产者消费者问题（了解概念即可）</h3><p>为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/22/17101d0ebef25336?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>这里我们需要两个同步信号量和一个互斥信号量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 同步信号量，表示目前还可以生产几个产品</span><br><span class="line">semaphore empty &#x3D; n;</span><br><span class="line">&#x2F;&#x2F; 同步信号量，表示目前可以消耗几个产品</span><br><span class="line">semaphore full &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>生产者代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 生产一个产品</span><br><span class="line">        P(empty);</span><br><span class="line">        &#x2F;&#x2F; 对缓冲区加锁</span><br><span class="line">        P(mutex);</span><br><span class="line">        这里的代码是生产一个产品</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        V(mutex);</span><br><span class="line">        &#x2F;&#x2F; 产出一个产品</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 消费一个产品</span><br><span class="line">        P(full);</span><br><span class="line">        &#x2F;&#x2F; 对缓冲区加锁</span><br><span class="line">        P(mutex);</span><br><span class="line">        这里的代码是消费一个产品</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        V(mutex);</span><br><span class="line">        &#x2F;&#x2F; 消费一个产品</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-线程和协程"><a href="#2-7-线程和协程" class="headerlink" title="2.7 线程和协程"></a>2.7 线程和协程</h2><h3 id="2-7-1-为什么要引入线程"><a href="#2-7-1-为什么要引入线程" class="headerlink" title="2.7.1 为什么要引入线程"></a>2.7.1 为什么要引入线程</h3><ul>
<li>比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能<code>同一时间做一件事情</code>（比如QQ打字聊天）</li>
<li>但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ<code>没有多线程并发能力</code>，QQ能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0c6245723138?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>引入线程后带来的变化</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/7/170b0cdff976f56b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="2-7-2-线程的定义"><a href="#2-7-2-线程的定义" class="headerlink" title="2.7.2 线程的定义"></a>2.7.2 线程的定义</h3><p>我们上面说到进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中的某些属性，所以线程又被称为轻量级的进程。浏览器如果是一个进程的话，那么浏览器下面的每个 tab 页可以看作是一个个的线程。</p>
<p>下面是线程和进程持有资源的区别</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55ee47325c448bd833d30e34aa6b856~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>线程不像进程那样具有很强的独立性，线程之间会共享数据</p>
<p>创建线程的开销要比进程小很多，因为创建线程仅仅需要<code>堆栈指针</code>和<code>程序计数器</code>就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。</p>
<h4 id="必背考点：什么是线程？"><a href="#必背考点：什么是线程？" class="headerlink" title="必背考点：什么是线程？"></a>必背考点：什么是线程？</h4><ul>
<li>CPU调度的基本单位。</li>
<li>更小的能独立运行的基本单位。</li>
<li>一个进程中可以有多个线程。<ul>
<li>内核支持线程KST（Kernel Supported Threads）<ul>
<li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行。</li>
<li>如果进程中的一个线程被阻塞了，内核可以知晓，并分配处理机给该进程中的其他线程。</li>
<li>线程切换快，开销小。</li>
<li>但是对于用户的线程切换，需要从用户态切换到内核态，开销大。</li>
</ul>
</li>
<li>用户级线程ULT（User Level Threads）<ul>
<li>线程的创建、撤销、同步、通信都无需内核的支持，内核甚至完全不知道用户级线程的存在。</li>
<li>用户的线程阻塞了，则会导致整个进程阻塞，因为内核只知道进程，不知道线程，就会认为是这个进程阻塞了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="必背考点：进程和线程的区别"><a href="#必背考点：进程和线程的区别" class="headerlink" title="必背考点：进程和线程的区别"></a>必背考点：进程和线程的区别</h4><ul>
<li>基本单位：进程是资源分配和调度的基本单位，线程是CPU调度的基本单位。</li>
<li>系统开销：进程的切换涉及进程上下文的切换，线程切换的代价远小于进程切换。</li>
<li>拥有资源：线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源（程序计数器PC、一组寄存器和栈）。此外还允许多个线程共享该进程所拥有的资源。而进程拥有比线程更多的资源。</li>
<li>独立性：线程间的独立性比进程间的独立性要低得多，因为线程是提高并发性而合作的，它们共享进程的内存地址空间和资源。而进程一般是独占某块内存。</li>
</ul>
<h3 id="2-7-3-什么是上下文切换"><a href="#2-7-3-什么是上下文切换" class="headerlink" title="2.7.3 什么是上下文切换"></a>2.7.3 什么是上下文切换</h3><p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 <strong>将 CPU 资源从一个进程分配给另一个进程的机制</strong>。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p>
<h3 id="2-7-4-使用多线程的好处是什么"><a href="#2-7-4-使用多线程的好处是什么" class="headerlink" title="2.7.4 使用多线程的好处是什么"></a>2.7.4 使用多线程的好处是什么</h3><p>多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处</p>
<ul>
<li>能够提高对用户的响应顺序</li>
<li>在流程中的资源共享</li>
<li>比较经济适用</li>
<li>能够对多线程架构有深入的理解</li>
</ul>
<h3 id="2-7-5-协程是什么"><a href="#2-7-5-协程是什么" class="headerlink" title="2.7.5 协程是什么"></a>2.7.5 协程是什么</h3><ul>
<li>协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。</li>
<li>不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。</li>
<li>协程属于用户态，协程之间的切换不需要系统调用，</li>
<li>其本质就是控制流主动让出和恢复机制，让控制流更加流畅</li>
</ul>
<h3 id="2-7-6-线程和协程的区别"><a href="#2-7-6-线程和协程的区别" class="headerlink" title="2.7.6 线程和协程的区别"></a>2.7.6 线程和协程的区别</h3><ul>
<li>调度方式：线程是操作系统调度，协程是应用程序自己调度（用户态）</li>
<li>栈空间：协程的栈空间是可以动态调整的</li>
<li>并发/并行：<ul>
<li>协程是协作式多任务，只能并发</li>
<li>线程是抢占式多任务，可以并发也可以并行</li>
</ul>
</li>
</ul>
<h2 id="2-8-调度算法"><a href="#2-8-调度算法" class="headerlink" title="2.8 调度算法"></a>2.8 调度算法</h2><h3 id="2-8-1-调度算法有哪些"><a href="#2-8-1-调度算法有哪些" class="headerlink" title="2.8.1 调度算法有哪些"></a>2.8.1 调度算法有哪些</h3><p>调度算法分为三大类：批处理中的调度、交互系统中的调度、实时系统中的调度</p>
<h4 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h4><p>先来先服务</p>
<p>很像是先到先得。。。可能最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380e331a1d0e4422b8a79e186248d3ec~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p>
<p>不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30b66758daf74316b725cf3b00039b7f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，平均时间内为 14 分钟。</p>
<p>现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。</p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p>
<h3 id="2-8-2-交互式系统中的调度"><a href="#2-8-2-交互式系统中的调度" class="headerlink" title="2.8.2 交互式系统中的调度"></a>2.8.2 交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p>
<h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c466a876ef043068fc4bcd8a14aa0b8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>事实情况是不是所有的进程都是优先级相等的。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c96f6a295d4e4386a8cbbc9120daa9ac~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p>
<p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12b88d9f80b74c7b834fda64f9f70514~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p>
<p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。他的基本思想为进程提供各种系统资源的<code>彩票</code>。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得资源。比如在 CPU 进行调度时，系统可以每秒持有 50 次抽奖，每个中奖进程会获得额外运行时间的奖励。</p>
<blockquote>
<p>可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 <code>速度之靴</code> 的效果。</p>
</blockquote>
<h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p>
<p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p>
<h3 id="2-8-3-影响调度程序的指标"><a href="#2-8-3-影响调度程序的指标" class="headerlink" title="2.8.3 影响调度程序的指标"></a>2.8.3 影响调度程序的指标</h3><p>会有下面几个因素决定调度程序的好坏</p>
<ul>
<li><h4 id="CPU-使用率："><a href="#CPU-使用率：" class="headerlink" title="CPU 使用率："></a>CPU 使用率：</h4></li>
</ul>
<p>CPU 正在执行任务（即不处于空闲状态）的时间百分比。</p>
<ul>
<li><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4></li>
</ul>
<p>这是进程轮流执行的时间，也就是进程切换的时间</p>
<ul>
<li><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4></li>
</ul>
<p>单位时间内完成进程的数量</p>
<ul>
<li><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4></li>
</ul>
<p>这是从提交流程到获得有用输出所经过的时间。</p>
<ul>
<li><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4></li>
</ul>
<p>从提交流程到完成流程所经过的时间。</p>
<h3 id="2-8-4-RR-调度算法"><a href="#2-8-4-RR-调度算法" class="headerlink" title="2.8.4 RR 调度算法"></a>2.8.4 RR 调度算法</h3><p><code>RR(round-robin)</code> 调度算法主要针对分时系统，RR 的调度算法会把时间片以相同的部分并循环的分配给每个进程，RR 调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片，并不存在线程饥饿的问题</p>
<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><h2 id="3-1-内存的基础知识和概念"><a href="#3-1-内存的基础知识和概念" class="headerlink" title="3.1 内存的基础知识和概念"></a>3.1 内存的基础知识和概念</h2><blockquote>
<p>为什么需要内存</p>
</blockquote>
<p>内存是计算机<code>其它硬件设备</code>与<code>CPU沟通</code>的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。</p>
<h3 id="3-1-1-cpu如何区分执行程序的数据在内存的什么地方"><a href="#3-1-1-cpu如何区分执行程序的数据在内存的什么地方" class="headerlink" title="3.1.1 cpu如何区分执行程序的数据在内存的什么地方"></a>3.1.1 cpu如何区分执行程序的数据在内存的什么地方</h3><ul>
<li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li>
<li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里<code>let a = 1</code>这段代码。</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17124ab5c2726806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="3-1-2-内存管理-内存空间的分配与回收"><a href="#3-1-2-内存管理-内存空间的分配与回收" class="headerlink" title="3.1.2 内存管理-内存空间的分配与回收"></a>3.1.2 内存管理-内存空间的分配与回收</h3><ul>
<li>内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li>
<li>这里我们只讲连续分配中的<code>动态分区分配</code>。</li>
<li>什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB…，现在我们有几个进程要装入内存，如下图）</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17133a8c513bbc25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li>
</ul>
<p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17133ad6cd968301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？</p>
<p>我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/171360901ecc8590?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。</p>
<p>这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/4/1/17136299db333910?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p>
<p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p>
<p>进程的页与内存的页框有着一一对应的关系。各个页不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p>
<h2 id="3-2-虚拟内存"><a href="#3-2-虚拟内存" class="headerlink" title="3.2 虚拟内存"></a>3.2 虚拟内存</h2><h3 id="3-2-1-什么是虚拟内存"><a href="#3-2-1-什么是虚拟内存" class="headerlink" title="3.2.1 什么是虚拟内存"></a>3.2.1 什么是虚拟内存</h3><p><code>虚拟内存</code>是一种内存分配方案，是一项可以用来辅助内存分配的机制。我们知道，应用程序是按页装载进内存中的。但并不是所有的页都会装载到内存中，计算机中的硬件和软件会将数据从 RAM 临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你将计算机内存填满后，计算机会对你说，<strong>对不起，您无法再加载任何应用程序，请关闭另一个应用程序以加载新的应用程序</strong>。对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后将其复制到硬盘上。复制是自动进行的，你无法感知到它的存在。</p>
<h3 id="3-2-2-虚拟内存的实现方式"><a href="#3-2-2-虚拟内存的实现方式" class="headerlink" title="3.2.2 虚拟内存的实现方式"></a>3.2.2 虚拟内存的实现方式</h3><p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或<code>永久</code>的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。</li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
<h3 id="3-2-3-按需分页"><a href="#3-2-3-按需分页" class="headerlink" title="3.2.3 按需分页"></a>3.2.3 按需分页</h3><p>在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种<code>虚拟内存</code>的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了<code>缺页异常</code>，操作系统才会将磁盘页面复制到内存中。</p>
<h2 id="3-3-内存管理"><a href="#3-3-内存管理" class="headerlink" title="3.3 内存管理"></a>3.3 内存管理</h2><h3 id="3-3-1-分析内存为什么要分段"><a href="#3-3-1-分析内存为什么要分段" class="headerlink" title="3.3.1 分析内存为什么要分段"></a>3.3.1 分析内存为什么要分段</h3><p>内存是随机访问设备，对于内存来说，不需要从头开始查找，只需要直接给出地址即可。内存的分段是从 <code>8086 CPU</code> 开始的，8086 的 CPU 还是 16 位的寄存器宽，16 位的寄存器可以存储的数字范围是 2 的 16 次方，即 64 KB，8086 的 CPU 还没有 <code>虚拟地址</code>，只有物理地址，也就是说，如果两个相同的程序编译出来的地址相同，那么这两个程序是无法同时运行的。为了解决这个问题，操作系统设计人员提出了让 CPU 使用 <code>段基址 + 段内偏移</code> 的方式来访问任意内存。这样的好处是让程序可以 <code>重定位</code>，<strong>这也是内存为什么要分段的第一个原因</strong>。</p>
<blockquote>
<p>那么什么是重定位呢？</p>
</blockquote>
<p>简单来说就是将程序中的指令地址改为另一个地址，地址处存储的内容还是原来的。</p>
<p>CPU 采用段基址 + 段内偏移地址的形式访问内存，就需要提供专门的寄存器，这些专门的寄存器就是 <strong>CS、DS、ES 等</strong>。</p>
<p>也就是说，程序中需要用到哪块内存，就需要先加载合适的段到段基址寄存器中，再给出相对于该段基址的段偏移地址即可。CPU 中的地址加法器会将这两个地址进行合并，从地址总线送入内存。</p>
<p>8086 的 CPU 有 20 根地址总线，最大的寻址能力是 1MB，而段基址所在的寄存器宽度只有 16 位，最大为你 64 KB 的寻址能力，64 KB 显然不能满足 1MB 的最大寻址范围，所以就要把内存分段，每个段的最大寻址能力是 64KB，但是仍旧不能达到最大 1 MB 的寻址能力，所以这时候就需要 <code>偏移地址</code>的辅助，偏移地址也存入寄存器，同样为 64 KB 的寻址能力，这么一看还是不能满足 1MB 的寻址，所以 CPU 的设计者对地址单元动了手脚，将段基址左移 4 位，然后再和 16 位的段内偏移地址相加，就达到了 1MB 的寻址能力。<strong>所以内存分段的第二个目的就是能够访问到所有内存</strong>。</p>
<h3 id="3-3-2-物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"><a href="#3-3-2-物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别" class="headerlink" title="3.3.2 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别"></a>3.3.2 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</h3><p>物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p>
<p>在<code>实模式</code>下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为<code>物理地址</code>。</p>
<p>但是在<code>保护模式</code>下，段基址 + 段内偏移被称为<code>线性地址</code>，不过此时的段基址不能称为真正的地址，而是会被称作为一个<code>选择子</code>的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是<code>虚拟地址</code>。</p>
<p>不论在实模式还是保护模式下，段内偏移地址都叫做<code>有效地址</code>。有效地址也是逻辑地址。</p>
<p>线性地址可以看作是<code>虚拟地址</code>，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e19d5e052c4d2aa40c0c7fd0112e8b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="3-3-3-空闲内存管理的方式"><a href="#3-3-3-空闲内存管理的方式" class="headerlink" title="3.3.3 空闲内存管理的方式"></a>3.3.3 空闲内存管理的方式</h3><p>操作系统在动态分配内存时（malloc，new），需要对空间内存进行管理。一般采用了两种方式：位图和空闲链表。</p>
<h4 id="使用位图进行管理"><a href="#使用位图进行管理" class="headerlink" title="使用位图进行管理"></a>使用位图进行管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed60e922592e4fdc9d798cafb87a945c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>图 a 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 b 表示对应的位图；图 c 表示用链表表示同样的信息</p>
</blockquote>
<p>分配单元的大小是一个重要的设计因素，分配单位越小，位图越大。然而，即使只有 4 字节的分配单元，32 位的内存也仅仅只需要位图中的 1 位。<code>32n</code> 位的内存需要 n 位的位图，所以<strong>1 个位图只占用了 1/32 的内存</strong>。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。</p>
<p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p>
<h4 id="使用空闲链表"><a href="#使用空闲链表" class="headerlink" title="使用空闲链表"></a>使用空闲链表</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p>
<p>在这个例子中，<code>段链表(segment list)</code>是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e4680bebd4e4762af719d8860f3cb80~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。</p>
<ul>
<li>首次适配算法：在链表中进行搜索，直到找到最初的一个足够大的空闲区，将其分配。除非进程大小和空间区大小恰好相同，否则会将空闲区分为两部分，一部分为进程使用，一部分成为新的空闲区。该方法是速度很快的算法，因为索引链表结点的个数较少。</li>
<li>下次适配算法：工作方式与首次适配算法相同，但每次找到新的空闲区位置后都记录当前位置，下次寻找空闲区从上次结束的地方开始搜索，而不是与首次适配放一样从头开始；</li>
<li>最佳适配算法：搜索整个链表，找出能够容纳进程分配的最小的空闲区。这样存在的问题是，尽管可以保证为进程找到一个最为合适的空闲区进行分配，但大多数情况下，这样的空闲区被分为两部分，一部分用于进程分配，一部分会生成很小的空闲区，而这样的空闲区很难再被进行利用。</li>
<li>最差适配算法：与最佳适配算法相反，每次分配搜索最大的空闲区进行分配，从而可以使得空闲区拆分得到的新的空闲区可以更好的被进行利用。</li>
</ul>
<h3 id="3-3-4-分页和分段式的存储管理方式"><a href="#3-3-4-分页和分段式的存储管理方式" class="headerlink" title="3.3.4 分页和分段式的存储管理方式"></a>3.3.4 分页和分段式的存储管理方式</h3><h4 id="分页式"><a href="#分页式" class="headerlink" title="分页式"></a>分页式</h4><ul>
<li>页内碎片：内零头</li>
<li>页（逻辑）</li>
<li>块（物理）</li>
<li>页表：系统为每个进程建立的一张页面映射表，页-&gt;块（页号-&gt;块号）</li>
<li>快表：高速缓冲寄存器，存放最近访问的页号/块号映射对。</li>
<li>寻址（逻辑地址 -&gt; 物理地址）</li>
<li>两级/多级页表</li>
</ul>
<p><img data-src="https://range0122.github.io/imgs/page1.png" alt="image"></p>
<p><img data-src="https://range0122.github.io/imgs/page2.png" alt="image"></p>
<h4 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h4><ul>
<li>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</li>
<li>每个段都有自己的名字。</li>
<li>每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。</li>
<li>段表：段号，该段在内存中的起始地址（基址），段的长度。</li>
</ul>
<p><img data-src="https://range0122.github.io/imgs/segment.png" alt="image"></p>
<h4 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h4><p>外零头：可变分区时，可能会形成大量较小的，难以再分配的分区。动态划分没有内零头，静态划分有内零头</p>
<table>
<thead>
<tr>
<th align="left">分页</th>
<th>分段</th>
</tr>
</thead>
<tbody><tr>
<td align="left">信息的物理单位，减少外零头，提高内存利用率。</td>
<td>段是信息的逻辑单位，方便用户。</td>
</tr>
<tr>
<td align="left">大小固定，由系统决定</td>
<td>长度不固定，取决于用户所编写的程序。</td>
</tr>
<tr>
<td align="left">作业地址空间是一维的，因为页是连续的，逻辑地址空间是一维的，一张页表走到底就行了。（直接根据逻辑地址可以算出页号和页内地址，取余和除法取整）</td>
<td>作业地址空间是二维的，数据段、代码段、堆栈段等段号连续，但物理地址空间不连续。（二维：哪个段+段内地址）</td>
</tr>
<tr>
<td align="left">减少了外零头，但不能避免内零头</td>
<td>内零头不清楚，但是因为物理地址空间不连续，可能会产生一些外零头</td>
</tr>
</tbody></table>
<h4 id="段页式的存储管理方式"><a href="#段页式的存储管理方式" class="headerlink" title="段页式的存储管理方式"></a>段页式的存储管理方式</h4><p>先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。（先分段，段内再分页）</p>
<p><img data-src="https://range0122.github.io/imgs/page&segment.png" alt="image"></p>
<p>段号-&gt;段表-&gt;页表地址-&gt; + 页号-&gt;块号-&gt; +页内地址 =&gt; 物理地址</p>
<h2 id="3-4-页面置换算法"><a href="#3-4-页面置换算法" class="headerlink" title="3.4 页面置换算法"></a>3.4 页面置换算法</h2><p>在地址映射过程中，如果在页面中发现所要访问的页面不在内存中，那么就会产生一条缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，那么操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<p>下面我汇总的这些页面置换算法比较齐全，只给出简单介绍，算法具体的实现和原理读者可以自行了解。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3d27b068b124589baee535da749bcc0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="3-4-1-最佳置换算法-OPT，Optlmal"><a href="#3-4-1-最佳置换算法-OPT，Optlmal" class="headerlink" title="3.4.1 最佳置换算法(OPT，Optlmal)"></a>3.4.1 最佳置换算法(OPT，Optlmal)</h3><p>最佳置换算法又称作<code>最优算法</code>，在当前页面中置换最后要访问的页面。是所选择被淘汰的页面，将是以后永不使用的，或许是在最长时间内不再被访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，理想化，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</p>
<h3 id="3-4-2最近未使用算法-NRU"><a href="#3-4-2最近未使用算法-NRU" class="headerlink" title="3.4.2最近未使用算法(NRU)"></a>3.4.2最近未使用算法(NRU)</h3><p><code>NRU</code> 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</p>
<h3 id="3-4-3-先进先出置换算法（FIFO，First-In-First-Out）"><a href="#3-4-3-先进先出置换算法（FIFO，First-In-First-Out）" class="headerlink" title="3.4.3 先进先出置换算法（FIFO，First In First Out）"></a>3.4.3 先进先出置换算法（FIFO，First In First Out）</h3><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰 。跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面</p>
<p>页面调入的先后并不能反映页面的使用情况。所以这个效率差。</p>
<p><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</p>
<h3 id="3-4-4-最近最久未使用置换算法（LRU，Least-Recently-Used）"><a href="#3-4-4-最近最久未使用置换算法（LRU，Least-Recently-Used）" class="headerlink" title="3.4.4 最近最久未使用置换算法（LRU，Least Recently Used）"></a>3.4.4 最近最久未使用置换算法（LRU，Least Recently Used）</h3><ul>
<li>选择最近最久未使用的页面予以淘汰。</li>
<li>硬件支持：寄存器 和 栈</li>
</ul>
<p><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</p>
<ul>
<li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li>
<li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择。使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</li>
</ul>
<h3 id="3-4-5-最不经常使用算法（Least-Frequently-Used，LFU）"><a href="#3-4-5-最不经常使用算法（Least-Frequently-Used，LFU）" class="headerlink" title="3.4.5 最不经常使用算法（Least Frequently Used，LFU）"></a>3.4.5 最不经常使用算法（Least Frequently Used，LFU）</h3><p>使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</p>
<h3 id="3-4-6-时钟置换算法（Clock）："><a href="#3-4-6-时钟置换算法（Clock）：" class="headerlink" title="3.4.6 时钟置换算法（Clock）："></a>3.4.6 时钟置换算法（Clock）：</h3><ul>
<li>每页设置一个访问位，该页第一次装入内存或者被重新访问到时，置 = 1</li>
<li>置换时，检查每一页：<ul>
<li>若 = 1，则置 = 0；</li>
<li>若 = 0，则换出。</li>
</ul>
</li>
<li>其实就是多给被访问过的页面一次机会。</li>
</ul>
<p><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</p>
<h3 id="3-4-7-改进的时钟置换算法（Clock）："><a href="#3-4-7-改进的时钟置换算法（Clock）：" class="headerlink" title="3.4.7 改进的时钟置换算法（Clock）："></a>3.4.7 改进的时钟置换算法（Clock）：</h3><ul>
<li><p>除了访问位，还要考虑是否被修改过：</p>
<ul>
<li>访问过，修改过：别搞我</li>
<li>访问过，未修改：最好也别搞我</li>
<li>未访问，但修改过：也还是别搞我</li>
<li>未访问，也未修改：搞我搞我</li>
</ul>
</li>
<li><p>扫描：</p>
<ul>
<li>先扫描第一遍：找第四种，</li>
<li>没有的话扫描第二遍，访问位置0，寻找未访问，但修改过的。</li>
<li>没有的话第三遍，这个时候一定能成功</li>
</ul>
<p>是时钟置换算法的一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</p>
</li>
</ul>
<p><strong>最好的算法是老化算法和WSClock算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p>
<h1 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4.文件系统"></a>4.文件系统</h1><h2 id="4-1-文件的定义和属性"><a href="#4-1-文件的定义和属性" class="headerlink" title="4.1 文件的定义和属性"></a>4.1 文件的定义和属性</h2><p>文件就是一组有意义的<code>信息/数据</code>集合。</p>
<p>计算机中存放了各种各样的文件，文件的属性包括：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171265b304cd6988?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li>
<li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li>
<li>类型。文件的类型。</li>
<li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li>
<li>创建时间、上次修改时间、文件所有者就是字面意思。</li>
<li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li>
</ul>
<h2 id="4-2-文件的组织方式"><a href="#4-2-文件的组织方式" class="headerlink" title="4.2 文件的组织方式"></a>4.2 文件的组织方式</h2><p>文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p>
<h3 id="4-2-1-文件内部数据如何组织在一起"><a href="#4-2-1-文件内部数据如何组织在一起" class="headerlink" title="4.2.1 文件内部数据如何组织在一起"></a>4.2.1 文件内部数据如何组织在一起</h3><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171266931ce296e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4-2-2-文件之间如何组织起来"><a href="#4-2-2-文件之间如何组织起来" class="headerlink" title="4.2.2 文件之间如何组织起来"></a>4.2.2 文件之间如何组织起来</h3><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171266eca83a1fd0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p>
<h3 id="4-2-3-文件的逻辑结构"><a href="#4-2-3-文件的逻辑结构" class="headerlink" title="4.2.3 文件的逻辑结构"></a>4.2.3 文件的逻辑结构</h3><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171267e499b86cba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code></p>
<ul>
<li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li>
<li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li>
</ul>
<p>接下来我了解一下有结构文件的三种逻辑结构</p>
<h4 id="4-2-3-1-顺序文件"><a href="#4-2-3-1-顺序文件" class="headerlink" title="4.2.3.1 顺序文件"></a>4.2.3.1 顺序文件</h4><blockquote>
<p>什么是顺序文件</p>
</blockquote>
<p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/30/1712958537512c5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li>
<li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li>
<li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li>
</ul>
<p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/30/1712987dbb104bf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="4-2-3-2-索引文件"><a href="#4-2-3-2-索引文件" class="headerlink" title="4.2.3.2 索引文件"></a>4.2.3.2 索引文件</h4><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录，但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712f7c62e640c55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li>
<li>其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。</li>
<li>但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li>
</ul>
<h4 id="4-2-3-3-索引顺序文件"><a href="#4-2-3-3-索引顺序文件" class="headerlink" title="4.2.3.3 索引顺序文件"></a>4.2.3.3 索引顺序文件</h4><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712f97d9c361d47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4-2-4-文件目录"><a href="#4-2-4-文件目录" class="headerlink" title="4.2.4 文件目录"></a>4.2.4 文件目录</h3><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712fa51d0e2cd5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p>
<p>文件目录的结构通常是<code>树状的</code>，例如linux里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1712faea7fb6a47a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）</li>
<li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li>
</ul>
<h3 id="4-2-5-文件存储空间管理"><a href="#4-2-5-文件存储空间管理" class="headerlink" title="4.2.5 文件存储空间管理"></a>4.2.5 文件存储空间管理</h3><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/1713015837097fc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/171301b2fb9a17b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130b5dbd9375ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li>
<li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li>
</ul>
<p>如何回收磁盘块呢，主要分为以下4中情况</p>
<ul>
<li>回收区的前后没有相邻空闲区</li>
<li>回收区前后都是空闲区</li>
<li>回收区前面是空前去</li>
<li>回收区后面是空闲区</li>
</ul>
<p>最重要的是要注意表项合并的问题。(比如说回收区前后都有空闲区就将其一起合并为一个空闲区)</p>
<h2 id="4-3-文件共享"><a href="#4-3-文件共享" class="headerlink" title="4.3 文件共享"></a>4.3 文件共享</h2><p>文件共享分为两种</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130c781a0ab962?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li>
<li>软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li>
<li>硬链接可以理解为js里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li>
</ul>
<h2 id="4-4-文件保护"><a href="#4-4-文件保护" class="headerlink" title="4.4 文件保护"></a>4.4 文件保护</h2><p>操作系统需要保护文件的安全，一般有如下3种方式：</p>
<ul>
<li>口令保护。是指为文件设置一个<code>“口令”</code>（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li>
<li>加密保护。使用某个<code>&quot;密码&quot;</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li>
<li>访问控制。在每个文件的FCB或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/31/17130f1a1ebbde6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="4-5-提高文件系统性能的方式"><a href="#4-5-提高文件系统性能的方式" class="headerlink" title="4.5 提高文件系统性能的方式"></a>4.5 提高文件系统性能的方式</h2><p>访问磁盘的效率要比内存慢很多，是时候又祭出这张图了</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62ac3982ff84a12af120b76dd8da95b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p>
<h3 id="4-5-1-高速缓存"><a href="#4-5-1-高速缓存" class="headerlink" title="4.5.1 高速缓存"></a>4.5.1 高速缓存</h3><p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p>
<p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p>
<p>高速缓存的操作如下图所示</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08c9eaae7d44d76975cb790dbbff765~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作。然后在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p>
<p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似。</p>
<h3 id="4-5-2-块提前读"><a href="#4-5-2-块提前读" class="headerlink" title="4.5.2 块提前读"></a>4.5.2 块提前读</h3><p>第二个明显提高文件系统的性能是<strong>在需要用到块之前试图提前将其写入高速缓存从而提高命中率</strong>。许多文件都是<code>顺序读取</code>。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p>
<p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p>
<h3 id="4-5-3-减少磁盘臂运动"><a href="#4-5-3-减少磁盘臂运动" class="headerlink" title="4.5.3 减少磁盘臂运动"></a>4.5.3 减少磁盘臂运动</h3><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p>
<p>不过，即使采用空闲表，也可以使用 <code>块簇</code> 技术。即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有 512 个字节，有可能系统采用 1 KB 的块（2 个扇区），但却按每 2 块（4 个扇区）一个单位来分配磁盘存储区。这和 2 KB 的磁盘块并不相同，因为在高速缓存中它仍然使用 1 KB 的块，磁盘与内存数据之间传送也是以 1 KB 进行，但在一个空闲的系统上顺序读取这些文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方法的变体。在分配块时，系统尽量把一个文件中的连续块存放在同一个柱面上。</p>
<p>在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：<strong>一次是访问 inode，一次是访问块</strong>。通常情况下，inode 的放置如下图所示</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d93b28049444348a2fb25650dc3b6b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。</p>
<p>一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表，如上图 b 所示。</p>
<p>当然，只有在磁盘中装有磁盘臂的情况下，讨论寻道时间和旋转时间才是有意义的。现在越来越多的电脑使用 <code>固态硬盘(SSD)</code>，对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问和顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。但是也引发了新的问题。</p>
<h3 id="4-5-4-磁盘碎片整理"><a href="#4-5-4-磁盘碎片整理" class="headerlink" title="4.5.4 磁盘碎片整理"></a>4.5.4 磁盘碎片整理</h3><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p>
<p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p>
<p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p>
<h2 id="4-6-磁盘臂调度算法"><a href="#4-6-磁盘臂调度算法" class="headerlink" title="4.6 磁盘臂调度算法"></a>4.6 磁盘臂调度算法</h2><p>一般情况下，影响磁盘快读写的时间由下面几个因素决定</p>
<ul>
<li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li>
<li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li>
<li>实际数据的读取或者写入时间</li>
</ul>
<p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p>
<p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p>
<p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p>
<p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p>
<p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/184e699da9aa45d6af274952d81c476e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a63f65a6f9483dabe5b951a5915c98~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p>
<p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p>
<p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p>
<p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN </code>时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p>
<p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3917654aeb4f65ab0ecde925675531~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p>
<p>电梯算法通常情况下不如 SSF 算法。</p>
<p>一些磁盘控制器为软件提供了一种检查磁头下方当前扇区号的方法，使用这样的控制器，能够进行另一种优化。如果对一个相同的柱面有两个或者多个请求正等待处理，驱动程序可以发出请求读写下一次要通过磁头的扇区。</p>
<blockquote>
<p>这里需要注意一点，当一个柱面有多条磁道时，相继的请求可能针对不同的磁道，这种选择没有代价，因为选择磁头不需要移动磁盘臂也没有旋转延迟。</p>
</blockquote>
<p>对于磁盘来说，最影响性能的就是寻道时间和旋转延迟，所以一次只读取一个或两个扇区的效率是非常低的。出于这个原因，许多磁盘控制器总是读出多个扇区并进行高速缓存，即使只请求一个扇区时也是这样。一般情况下读取一个扇区的同时会读取该扇区所在的磁道或者是所有剩余的扇区被读出，读出扇区的数量取决于控制器的高速缓存中有多少可用的空间。</p>
<p>磁盘控制器的高速缓存和操作系统的高速缓存有一些不同，磁盘控制器的高速缓存用于缓存没有实际被请求的块，而操作系统维护的高速缓存由显示地读出的块组成，并且操作系统会认为这些块在近期仍然会频繁使用。</p>
<p>当同一个控制器上有多个驱动器时，操作系统应该为每个驱动器都单独的维护一个未完成的请求表。一旦有某个驱动器闲置时，就应该发出一个寻道请求来将磁盘臂移到下一个被请求的柱面。如果下一个寻道请求到来时恰好没有磁盘臂处于正确的位置，那么驱动程序会在刚刚完成传输的驱动器上发出一个新的寻道命令并等待，等待下一次中断到来时检查哪个驱动器处于闲置状态。</p>
<h2 id="4-7-RAID-的不同级别"><a href="#4-7-RAID-的不同级别" class="headerlink" title="4.7 RAID 的不同级别"></a>4.7 RAID 的不同级别</h2><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p>
<p>RAID 有不同的级别</p>
<ul>
<li>RAID 0 - 无容错的条带化磁盘阵列</li>
<li>RAID 1 - 镜像和双工</li>
<li>RAID 2 - 内存式纠错码</li>
<li>RAID 3 - 比特交错奇偶校验</li>
<li>RAID 4 - 块交错奇偶校验</li>
<li>RAID 5 - 块交错分布式奇偶校验</li>
<li>RAID 6 - P + Q冗余</li>
</ul>
<h1 id="5-IO设备"><a href="#5-IO设备" class="headerlink" title="5. IO设备"></a>5. IO设备</h1><h2 id="5-1-I-O设备的定义与分类"><a href="#5-1-I-O设备的定义与分类" class="headerlink" title="5.1 I/O设备的定义与分类"></a>5.1 I/O设备的定义与分类</h2><h3 id="5-1-1-I-O设备定义"><a href="#5-1-1-I-O设备定义" class="headerlink" title="5.1.1 I/O设备定义"></a>5.1.1 I/O设备定义</h3><p>I/O就是<code>输入输出</code>(Input/Output)的意思，I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171255f53e94df47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="5-1-2-I-O设备分类——按使用特性"><a href="#5-1-2-I-O设备分类——按使用特性" class="headerlink" title="5.1.2 I/O设备分类——按使用特性"></a>5.1.2 I/O设备分类——按使用特性</h3><ul>
<li>人机交互类设备，这类设备传输数据的速度慢</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/1712560a47c66aba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>存储设备，这类设备传输数据的速度较快</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17125616ebd6d68d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li>
</ul>
<h3 id="5-1-3-设备驱动程序"><a href="#5-1-3-设备驱动程序" class="headerlink" title="5.1.3 设备驱动程序"></a>5.1.3 设备驱动程序</h3><p>在计算机中，设备驱动程序是一种计算机程序，它能够控制或者操作连接到计算机的特定设备。驱动程序提供了与硬件进行交互的软件接口，使操作系统和其他计算机程序能够访问特定设备，不用需要了解其硬件的具体构造。</p>
<h3 id="5-1-4-五种I-O模型"><a href="#5-1-4-五种I-O模型" class="headerlink" title="5.1.4 五种I/O模型"></a>5.1.4 五种I/O模型</h3><p><img data-src="https://range0122.github.io/imgs/IO.png" alt="image"></p>
<h2 id="5-2-I-O控制"><a href="#5-2-I-O控制" class="headerlink" title="5.2 I/O控制"></a>5.2 I/O控制</h2><h3 id="5-2-1-I-O控制器"><a href="#5-2-1-I-O控制器" class="headerlink" title="5.2.1 I/O控制器"></a>5.2.1 I/O控制器</h3><p>CPU无法直接控制<code>I/O设备的机械部件</code>，因此I/O设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现CPU对设备的控制。这个电子部件就是<code>I/O控制器</code>。I/O控制器是一个<code>可编址</code>的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；如果I/O控制器控制多个可连接设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。</p>
<p>I/O控制器主要分为两种：字符设备和块设备</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/171258cd27939935?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>接收和识别CPU发出的指令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li>
<li>向cpu报告设备的状态是指，I/O控制器会有相应的<code>状态寄存器</code>，用来记录I/O设备<code>是否空闲</code>或者<code>忙碌</code></li>
<li>数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li>
<li>地址识别：为了区分I/O控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器地址唯一。I/O控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器</li>
<li>差错检测：I/O控制器还具有对设备传递过来的数据进行检测的功能。</li>
</ul>
<h3 id="5-2-2-I-O控制方式"><a href="#5-2-2-I-O控制方式" class="headerlink" title="5.2.2 I/O控制方式"></a>5.2.2 I/O控制方式</h3><ul>
<li><p>这里我们指讲一下目前比较先进的方式，通道控制方式。</p>
</li>
<li><p>通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。</p>
</li>
</ul>
<p><img data-src="https://user-gold-cdn.xitu.io/2020/3/29/17125a5e38698d63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><br>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向CPU发出<code>中断</code>，不需要轮询来问I/O设备是否完成CPU下达的任务。</p>
<h2 id="5-3-操作系统中的时钟"><a href="#5-3-操作系统中的时钟" class="headerlink" title="5.3 操作系统中的时钟"></a>5.3 操作系统中的时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p>
<h4 id="5-3-1-时钟硬件"><a href="#5-3-1-时钟硬件" class="headerlink" title="5.3.1 时钟硬件"></a>5.3.1 时钟硬件</h4><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p>
<ul>
<li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li>
<li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li>
</ul>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b460cfde9e48df86195e34aeea1ea3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p>
<h2 id="5-4-操作系统的中断处理过程"><a href="#5-4-操作系统的中断处理过程" class="headerlink" title="5.4 操作系统的中断处理过程"></a>5.4 操作系统的中断处理过程</h2><p>中断处理方案有很多种，下面是 《<strong>ARM System Developer’s Guide</strong></p>
<p><strong>Designing and Optimizing System Software</strong>》列出来的一些方案</p>
<ul>
<li><code>非嵌套</code>的中断处理程序按照顺序处理各个中断，非嵌套的中断处理程序也是最简单的中断处理</li>
<li><code>嵌套</code>的中断处理程序会处理多个中断而无需分配优先级</li>
<li><code>可重入</code>的中断处理程序可使用优先级处理多个中断</li>
<li><code>简单优先级</code>中断处理程序可处理简单的中断</li>
<li><code>标准优先级</code>中断处理程序比低优先级的中断处理程序在更短的时间能够处理优先级更高的中断</li>
<li><code>高优先级</code> 中断处理程序在短时间能够处理优先级更高的任务，并直接进入特定的服务例程。</li>
<li><code>优先级分组</code>中断处理程序能够处理不同优先级的中断任务</li>
</ul>
<p>下面是一些通用的中断处理程序的步骤，不同的操作系统实现细节不一样</p>
<ul>
<li>保存所有没有被中断硬件保存的寄存器</li>
<li>为中断服务程序设置上下文环境，可能包括设置 <code>TLB</code>、<code>MMU</code> 和页表，如果不太了解这三个概念，请参考另外一篇文章</li>
<li>为中断服务程序设置栈</li>
<li>对中断控制器作出响应，如果不存在集中的中断控制器，则继续响应中断</li>
<li>把寄存器从保存它的地方拷贝到进程表中</li>
<li>运行中断服务程序，它会从发出中断的设备控制器的寄存器中提取信息</li>
<li>操作系统会选择一个合适的进程来运行。如果中断造成了一些优先级更高的进程变为就绪态，则选择运行这些优先级高的进程</li>
<li>为进程设置 MMU 上下文，可能也会需要 TLB，根据实际情况决定</li>
<li>加载进程的寄存器，包括 PSW 寄存器</li>
<li>开始运行新的进程</li>
</ul>
<p>上面我们罗列了一些大致的中断步骤，不同性质的操作系统和中断处理程序能够处理的中断步骤和细节也不尽相同，下面是一个嵌套中断的具体运行步骤</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e55f7584a42543ff92cb0214a70ba6b0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="5-5-DMA-直接内存访问"><a href="#5-5-DMA-直接内存访问" class="headerlink" title="5.5 DMA(直接内存访问)"></a>5.5 DMA(直接内存访问)</h2><p>DMA 的中文名称是<code>直接内存访问</code>，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。</p>
<p>DMA 方式有如下特点：</p>
<ul>
<li>数据传送以数据块为基本单位</li>
<li>所传送的数据从设备直接送入主存，或者从主存直接输出到设备上</li>
<li>仅在传送一个或多个数据块的开始和结束时才需 CPU 的干预，而整块数据的传送则是在控制器的控制下完成。</li>
</ul>
<p>DMA 方式和中断驱动控制方式相比，减少了 CPU 对 I/O 操作的干预，进一步提高了 CPU 与 I/O 设备的并行操作程度。</p>
<p>DMA 方式的线路简单、价格低廉，适合高速设备与主存之间的成批数据传送，小型、微型机中的快速设备均采用这种方式，但其功能较差，不能满足复杂的 I/O 要求。</p>
<h1 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6. 死锁"></a>6. 死锁</h1><h2 id="6-1-产生死锁的原因"><a href="#6-1-产生死锁的原因" class="headerlink" title="6.1 产生死锁的原因"></a>6.1 产生死锁的原因</h2><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p>
<h4 id="必背考点：死锁产生的原因"><a href="#必背考点：死锁产生的原因" class="headerlink" title="必背考点：死锁产生的原因"></a>必背考点：死锁产生的原因</h4><ul>
<li>死锁：进程间因为竞争资源而导致的一种僵持状态。</li>
<li>竞争资源（不可抢占性资源、可消耗性资源）</li>
<li>进程间推进顺序非法。（进程在运行过程中，请求和释放资源的顺序不当）</li>
</ul>
<h2 id="6-2-死锁的原因"><a href="#6-2-死锁的原因" class="headerlink" title="6.2 死锁的原因"></a>6.2 死锁的原因</h2><p>死锁产生的原因大致有两个：资源竞争和程序执行顺序不当</p>
<p>资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<h4 id="必背考点：死锁产生的必要条件"><a href="#必背考点：死锁产生的必要条件" class="headerlink" title="必背考点：死锁产生的必要条件"></a>必背考点：死锁产生的必要条件</h4><ul>
<li>互斥：进程对所分配的资源排他性使用</li>
<li>请求和保持：进程有一/多个资源了，还在请求新的资源</li>
<li>不可抢占：进程所分配的资源，用完之前不能被剥夺，只能在用完的时候进程自己释放。</li>
<li>循环等待：发生死锁的时候，必然存在一个进程与资源的环形链</li>
</ul>
<h2 id="6-3-死锁的恢复方式"><a href="#6-3-死锁的恢复方式" class="headerlink" title="6.3 死锁的恢复方式"></a>6.3 死锁的恢复方式</h2><p>所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p>
<h3 id="6-3-1-通过抢占进行恢复"><a href="#6-3-1-通过抢占进行恢复" class="headerlink" title="6.3.1 通过抢占进行恢复"></a>6.3.1 通过抢占进行恢复</h3><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>
<h3 id="6-3-2-通过回滚进行恢复"><a href="#6-3-2-通过回滚进行恢复" class="headerlink" title="6.3.2 通过回滚进行恢复"></a>6.3.2 通过回滚进行恢复</h3><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>
<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>
<h3 id="6-3-3-杀死进程恢复"><a href="#6-3-3-杀死进程恢复" class="headerlink" title="6.3.3 杀死进程恢复"></a>6.3.3 杀死进程恢复</h3><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
<h2 id="6-4-如何破坏死锁"><a href="#6-4-如何破坏死锁" class="headerlink" title="6.4 如何破坏死锁"></a>6.4 如何破坏死锁</h2><p>和死锁产生的必要条件一样，如果要破坏死锁，也是从下面四种方式进行破坏。</p>
<h3 id="6-4-1-破坏互斥条件"><a href="#6-4-1-破坏互斥条件" class="headerlink" title="6.4.1 破坏互斥条件"></a>6.4.1 破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p>
<p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p>
<p>因此，尽量做到尽可能少的进程可以请求资源。</p>
<h3 id="6-4-2-破坏保持等待的条件"><a href="#6-4-2-破坏保持等待的条件" class="headerlink" title="6.4.2 破坏保持等待的条件"></a>6.4.2 破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p>
<p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p>
<p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p>
<h3 id="6-4-3-破坏不可抢占条件"><a href="#6-4-3-破坏不可抢占条件" class="headerlink" title="6.4.3 破坏不可抢占条件"></a>6.4.3 破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过<code>虚拟化</code>的方式来避免这种情况。</p>
<h3 id="6-4-4-破坏循环等待条件"><a href="#6-4-4-破坏循环等待条件" class="headerlink" title="6.4.4 破坏循环等待条件"></a>6.4.4 破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。</p>
<p>另一种方式是将所有的资源统一编号，如下图所示</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55249c1fb9734d1ebd5af53a63bc128a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c332cc68dd79441ebe50b6f99c85735a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h4 id="必背考点-预防死锁"><a href="#必背考点-预防死锁" class="headerlink" title="必背考点 预防死锁"></a>必背考点 预防死锁</h4><ul>
<li><p><strong>“互斥”</strong>：必不可少，无法打破。</p>
</li>
<li><p>“请求和保持”</p>
<p>：一次性分配所有所需的资源</p>
<ul>
<li>（或者 需要什么就请求什么，不再需要什么就释放什么）</li>
<li>简单、易实现、安全</li>
<li>资源被浪费、进程延迟运行</li>
</ul>
</li>
<li><p>“不可抢占”</p>
<p>：进程已经获得一些资源的时候，如果请求新的资源失败，则放弃当前已经拥有的资源</p>
<ul>
<li>实现复杂、代价大，可能前功尽弃、进程前后两次运行的信息不连续</li>
</ul>
</li>
<li><p>“循环等待”</p>
<p>：系统将资源按类型先行排序，并且赋予不同的序号。进程对资源的请求必须严格按照资源的序号递增的次序提出，这样就不会出现环路。</p>
<ul>
<li>进程使用资源的顺序，可能与系统规定的顺序不同，造成资源的浪费。</li>
<li>序号稳定之后，限制了新设备的增加</li>
</ul>
</li>
</ul>
<h2 id="6-5-孤儿进程和僵尸进程"><a href="#6-5-孤儿进程和僵尸进程" class="headerlink" title="6.5 孤儿进程和僵尸进程"></a>6.5 孤儿进程和僵尸进程</h2><h3 id="6-5-1-父进程与子进程"><a href="#6-5-1-父进程与子进程" class="headerlink" title="6.5.1 父进程与子进程"></a>6.5.1 父进程与子进程</h3><p>在学习接下来的内容之前，需要对父进程和子进程有一个清晰的认识</p>
<p>在Linux里，除了进程0（即PID=0的进程）以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。</p>
<p>fork函数包含在unistd.h库中，其最主要的特点是，调用一次，返回两次，当父进程fork()创建子进程失败时，fork()返回-1，当父进程fork()创建子进程成功时，此时，父进程会返回子进程的pid，而子进程返回的是0。所以可以根据返回值的不同让父进程和子进程执行不同的代码</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-ecd96829be63c2c7fdfba106413c9396_720w.jpg" alt="img"></p>
<p>如上图所示，当fork()函数调用后，父进程中的变量pid赋值成子进程的pid(pid&gt;0)，所以父进程会执行else里的代码，打印出”This is the parent”，而子进程的变量pid赋值成0，所以子进程执行if(pid == 0)里的代码，打印出”This is the child”</p>
<p>现在我们知道，在Linux中，正常情况下，子进程是通过父进程创建的，子进程再创建新的子进程。但是子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态</p>
<p>知道了这些，我们再来了解两种特殊的进程</p>
<h3 id="6-5-2-僵尸进程"><a href="#6-5-2-僵尸进程" class="headerlink" title="6.5.2 僵尸进程"></a>6.5.2 僵尸进程</h3><p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。僵尸进程通常发生在父子关系的进程中，由于父进程仍需要读取其子进程的退出状态所造成的。</p>
<blockquote>
<p>当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程</p>
</blockquote>
<p>简单来说，当进程退出但是父进程并没有调用wait或waitpid获取子进程的状态信息时就会产生僵尸进程</p>
<p>上文中提到的进程的僵死状态Z(zombie)就是僵尸进程对应的状态</p>
<p>我们可以写一个程序来查看一下僵尸进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>,getpid());</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//这段代码只有子进程能够运行到，因为在子进程中fork的返回值为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the child!pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//退出进程</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//这段代码只有父进程能运行到</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the parent!pid = %d\n&quot;</span>,getpid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当fork成功时下面的代码父子进程都会运行到</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ ./zombie </span><br><span class="line">pid = 24816</span><br><span class="line">This is the parent!pid = 24816</span><br><span class="line">-------------pid = 24816</span><br><span class="line">This is the child!pid = 24817</span><br><span class="line">-------------pid = 24816</span><br><span class="line">-------------pid = 24816</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>在程序开始运行时立即查看进程：</p>
<p><em>(这里我分别运行了两次，分别使用ps -ef和ps -aux查看了进程状态，所以两次的进程PID是不同的)</em></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -ef | grep -v grep | grep zombie</span><br><span class="line">ubuntu   23797 15818  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line">ubuntu   23798 23797  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -aux | grep -v grep | grep zombie</span><br><span class="line">ubuntu   24288  0.0  0.0   4352   648 pts/0    S+   14:56   0:00 ./zombie</span><br><span class="line">ubuntu   24289  0.0  0.0   4352    80 pts/0    S+   14:56   0:00 ./zombie</span><br></pre></td></tr></table></figure>

<p>在进程运行五秒后再次查看进程：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -ef | grep -v grep | grep zombie</span><br><span class="line">ubuntu   23797 15818  0 14:53 pts/0    00:00:00 ./zombie</span><br><span class="line">ubuntu   23798 23797  0 14:53 pts/0    00:00:00 [zombie] &lt;defunct&gt;</span><br><span class="line"></span><br><span class="line">ubuntu@VM-0-7-ubuntu:~$ ps -aux | grep -v grep | grep zombie</span><br><span class="line">ubuntu   24288  0.0  0.0   4352   648 pts/0    S+   14:56   0:00 ./zombie</span><br><span class="line">ubuntu   24289  0.0  0.0      0     0 pts/0    Z+   14:56   0:00 [zombie] &lt;defunct&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出当进程运行五秒后，子进程状态变成Z，就是僵死状态，子进程就成了僵尸进程</p>
<p>其实，僵尸进程是有危害的。进程的退出状态必须被维持下去，因为它要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态。维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说，当一个进程一直处于Z状态，那么它的PCB也就一直都要被维护。因为PCB本身就是一个结构体会占用空间，僵尸进程也就会造成资源浪费，所以我们应该避免僵尸进程的产生</p>
<h3 id="6-5-3-孤儿进程"><a href="#6-5-3-孤儿进程" class="headerlink" title="6.5.3 孤儿进程"></a>6.5.3 孤儿进程</h3><p>孤儿进程则是指当一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>来段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the child!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());<span class="comment">//父进程退出前的pid和ppid</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\npid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());<span class="comment">//父进程退出后的pid和ppid</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the father!\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process is exited!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ ./orphan </span><br><span class="line">This is the father!</span><br><span class="line">This is the child!</span><br><span class="line">pid = 2338,ppid = 2337</span><br><span class="line">father process is exited!</span><br><span class="line">ubuntu@VM-0-7-ubuntu:~/c_practice$ </span><br><span class="line">pid = 2338,ppid = 1</span><br></pre></td></tr></table></figure>

<p>我们可以看到结果和我们预见的是一样的，孤儿进程在父进程退出后会被init进程领养，直到自己运行结束为止。这个程序很容易理解,先输出子进程的pid和父进程的pid，再然后子进程开始睡眠父进程退出，这时候子进程变成孤儿进程，再次输出时，该进程的父进程变为init</p>
<p>孤儿进程由于有init进程循环的wait()回收资源，因此并没有什么危害。</p>
<h2 id="6-6-死锁类型"><a href="#6-6-死锁类型" class="headerlink" title="6.6 死锁类型"></a>6.6 死锁类型</h2><h3 id="6-6-1-两阶段加锁"><a href="#6-6-1-两阶段加锁" class="headerlink" title="6.6.1 两阶段加锁"></a>6.6.1 两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p>
<p>一种解决方式是使用 <code>两阶段提交(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p>
<p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p>
<p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p>
<h3 id="6-6-2-通信死锁"><a href="#6-6-2-通信死锁" class="headerlink" title="6.6.2 通信死锁"></a>6.6.2 通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p>
<p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p>
<p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p>
<p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p>
<p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d399e4206ebb4ae49c7037c77f8a91e0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p>
<h3 id="6-6-3-活锁"><a href="#6-6-3-活锁" class="headerlink" title="6.6.3 活锁"></a>6.6.3 活锁</h3><p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p>
<p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p>
<h3 id="6-6-4-饥饿"><a href="#6-6-4-饥饿" class="headerlink" title="6.6.4 饥饿"></a>6.6.4 饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p>
<p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>
<h1 id="7-Linux常用命令"><a href="#7-Linux常用命令" class="headerlink" title="7. Linux常用命令"></a>7. Linux常用命令</h1><h2 id="7-1-Linux系统"><a href="#7-1-Linux系统" class="headerlink" title="7.1 Linux系统"></a>7.1 Linux系统</h2><ul>
<li><code>pwd</code> 打印当前工作目录</li>
<li><code>cd</code> 改变目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;bin  绝对路径从根目录出发，到达目标目录</span><br><span class="line">cd .&#x2F;usr 相对路径从工作目录出发，到达目标目录</span><br><span class="line">cd .. 到达父目录</span><br><span class="line">cd(cd ~) 到达家目录，如果未root用户，pwd会打印出 &#x2F;root，其上一层为 根目录&#x2F;</span><br><span class="line">cd &#x2F; (cd -) 回到根目录</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls</code> 列出目录内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -l 使用长格式显示结果</span><br><span class="line">ls -t 按修改时间排序</span><br><span class="line">ls -r 以相反的顺序显示</span><br><span class="line">ls -S 按文件大小对结果进行排序</span><br><span class="line">ls -R [文件夹] 列出文件树</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file</code> 确定文件类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure>

<ul>
<li><code>less</code> 查看文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<ul>
<li><code>touch</code> 新建文件</li>
</ul>
<h2 id="7-2-操作文件与目录"><a href="#7-2-操作文件与目录" class="headerlink" title="7.2 操作文件与目录"></a>7.2 操作文件与目录</h2><ul>
<li><code>mkdir</code> 创建目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1              创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3    创建多个目录</span><br><span class="line">mkdir -p dir&#123;1..9&#125;      创建多个目录a1到a9</span><br><span class="line">mkdir -p a&#123;1..3&#125;&#x2F;b&#123;1..3&#125;创建多个目录a1到a3，并且在每个目录下创建b1到b3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cp</code> 复制文件或目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2          将文件file1复制到file2中,file2内容将会被覆盖</span><br><span class="line">cp -r dir1 dir2         复制目录时一定要加 -r，如果dir2目录存在，则会复制到dir2目录下和mv是一样的道理</span><br><span class="line">cp file1 file2 dir1     将多个文件复制到一个目录下</span><br></pre></td></tr></table></figure>

<p><code>cp</code>命令选项</p>
<p><code>cp</code>在覆盖已存在的文件时默认情况下是 <code>cp -i</code>，即需要用户确认，我们可以这样 <code>\cp</code> 即可无需确认</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-r          递归复制目录及其内容。复制目录时需要这个选项</span><br><span class="line">-u          将文件从一个目录复制到另一个目录时，只会复制目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          复制文件时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mv</code> 重命名或移动文件和目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv item1 item2              将文件或目录item1移动或重命名为item2</span><br><span class="line">mv item1 item2 item3 dir1   将多个条目移动到dir1目录下</span><br></pre></td></tr></table></figure>

<p><code>mv</code>命令选项与<code>cp</code>大致相同，<code>mv</code>没有<code>-r</code>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i          在覆盖一个已存在的文件前，提示用户进行确认。</span><br><span class="line">-u          将文件从一个目录移动到另一个目录时，只会移动目标目录不存在的文件或是目标目录相应文件的更新文件</span><br><span class="line">-v          移动时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rm</code> 删除文件或目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r item1 item2 item3         删除item1,item2,item3,删除目录时需要-r</span><br><span class="line">rm *.html                       删除以.html结尾的文件</span><br></pre></td></tr></table></figure>

<p><code>rm</code>命令选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i          删除前提示用户确认</span><br><span class="line">-r          递归删除目录及其内容。删除目录时需要这个选项</span><br><span class="line">-f          忽略不存在的文件，并无需提示确认</span><br><span class="line">-v          删除时显示信息性消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ln</code> 创建硬链接和符号链接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln file hard-link-name      创建file文件的硬链接</span><br><span class="line">ln -s file sym-link-name    创建file文件的符号链接，符号链接指向源文件，与源文件内容保持一致</span><br></pre></td></tr></table></figure>

<p><code>file</code>为相对于<code>sym-link-name</code>的文件，即为相对路径，当然也可以是绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ..&#x2F;file sym-link-name     file在当前目录的父目录中，即file相对于sym-link-name的位置</span><br></pre></td></tr></table></figure>

<h2 id="7-3-读写文件"><a href="#7-3-读写文件" class="headerlink" title="7.3 读写文件"></a>7.3 读写文件</h2><p>1.grep 搜索文本 文件名 搜索文本内容<br>-n 显示行号； -v 不包括该内容的 ； ^a查找以a开头的行； a$ 查找以a结尾的行</p>
<p>2.cat 显示文件完整内容</p>
<p>3.more 分屏显示文件内容</p>
<p>4.less 分屏显示文件内容，上下键控制翻页</p>
<p>5.head 打印文件中的前n行</p>
<p>6.tail 打印文件中的末尾几行<br><strong>显示10~15行内容</strong> tail 文件名 +10| head +5</p>
<p>7.find<br><code>find 目录 -name 搜索字符</code> 搜索名字为xxx的文件 可以使用通配符<br><code>find 目录 -size 数据块</code> 搜索大小为xxx的文件，1数据块=0.5kB<br>+n 大于 -n 小于 n等于<br>组合条件：-o 或者；-a 并且<br>find \ -size +163840 -a -size -204800 查找根目录下大于80MB小于100MB的文件<br><code>find 目录 -group xxx</code> 查询所属组为xxx的文件<br><code>find 目录 -user xxx</code> 查询所属者为xxx的文件 </p>
<p>8.wc<br>wc 文件 -l 统计文件的行数<br>wc 文件 -w 统计文件的单词数<br>wc 文件 -c 统计文件的字节数</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;I am fine&quot;                        打印 I am fine</span><br><span class="line">echo &quot;I am fine&quot; &gt; &#x2F;root&#x2F;test.txt       将 I am fine写入&#x2F;root&#x2F;test.txt中</span><br><span class="line">echo &quot;I am fine&quot; &gt;&gt; &#x2F;root&#x2F;test.txt      将 I am fine追加到&#x2F;root&#x2F;test.txt末尾</span><br><span class="line">grep &quot;关键字&quot; test.txt                  在test.txt中查找含有关键字的行并打印</span><br><span class="line">grep -v &quot;关键字&quot; test.txt               在test.txt中查找不含有关键字的行并打印</span><br><span class="line">grep ^&quot;关键字&quot; test.txt                 在test.txt中查找以关键字开头的行并打印</span><br><span class="line">grep $&quot;关键字&quot; test.txt                 在test.txt中查找以关键字结尾的行并打印</span><br></pre></td></tr></table></figure>

<h2 id="7-4-管道"><a href="#7-4-管道" class="headerlink" title="7.4 管道"></a>7.4 管道</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &quot;关键字&quot; &gt; &#x2F;root&#x2F;test.txt  列出当前目录文件信息并交给grep过滤，最后写入&#x2F;root&#x2F;test.txt</span><br></pre></td></tr></table></figure>

<h2 id="7-5-进程与内存相关"><a href="#7-5-进程与内存相关" class="headerlink" title="7.5 进程与内存相关"></a>7.5 进程与内存相关</h2><p>1.top 动态实时显示cpu、内存、进程使用情况</p>
<p>2.ps 列出进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep xxx 查看xx进程，可以获得pid</span><br><span class="line">ps -a 列出所有运行中的进程</span><br><span class="line">pgrep -l xxx 查看xx进程的pid</span><br><span class="line">netstat -atnp| grep xxx 查询pid</span><br></pre></td></tr></table></figure>

<p>3.kill 杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid 强制杀死某进程</span><br></pre></td></tr></table></figure>

<p>4.netstat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -atnp | grep xxxx 查看端口号&#x2F;状态的进程pid</span><br><span class="line">查看端口占用情况 lsof -i</span><br><span class="line">查看指定端口占用情况 lsof -i:端口号</span><br></pre></td></tr></table></figure>

<p>5.free 显示当前内存使用情况</p>
<p>6.df 以字节形式显示磁盘使用情况</p>

    </div>

    
    
    
      
<div>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
</div>
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 基础</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="prev" title="计算机组成">
      <i class="fa fa-chevron-left"></i> 计算机组成
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" rel="next" title="操作系统面试题">
      操作系统面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="nav-text">1. 操作系统简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%9D%A2%E8%AF%95%E5%BF%85%E8%83%8C"><span class="nav-text">1.1 什么是操作系统(面试必背)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-text">1.2 操作系统的主要功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="nav-text">1.3 操作系统的四个特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E5%B9%B6%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1.3.1 并发是什么？和并行有啥区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E5%85%B1%E4%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%B1%E4%BA%AB%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">1.3.2 共享是什么？共享和并发有什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-%E8%99%9A%E6%8B%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.3.3 虚拟是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-%E5%BC%82%E6%AD%A5%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1.3.4 异步性是什么?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E8%BD%AF%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">1.4 软件访问硬件的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.5 常见的操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%9C%A8Windows%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%90%97"><span class="nav-text">1.5.1 Linux应用程序可以直接在Windows下运行吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-Linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">1.5.2 Linux 操作系统的启动过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.5.3 实时系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">1.6 操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.6.1 单体系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E5%88%86%E5%B1%82%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.6.2 分层系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-text">1.6.3 微内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.6.4 客户-服务器模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">1.7 操作系统运行机制和体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-%E4%B8%A4%E7%A7%8D%E6%8C%87%E4%BB%A4%E3%80%81%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81%E3%80%81%E4%B8%A4%E7%A7%8D%E7%A8%8B%E5%BA%8F"><span class="nav-text">1.7.1 两种指令、两种处理器状态、两种程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E6%A6%82%E5%BF%B5"><span class="nav-text">必背考点：内核态与用户态概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="nav-text">用户态和内核态是如何切换的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-text">必背考点：用户态到内核态的切换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.7.2 操作系统内核简单介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8"><span class="nav-text">1.7.3 陷入内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E4%B8%AD%E6%96%AD"><span class="nav-text">1.8 中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="nav-text">1.8.1 什么是中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-2-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">1.8.2 中断的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">1.8.3 系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-text">2. 进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%A4%9A%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-text">2.1 多处理系统的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.2 为什么要引入进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.3 进程和进程控制块的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.3.1 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9"><span class="nav-text">必背考点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">2.3.2 进程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">2.4 进程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-text">2.4.1 进程的组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.4.2 进程的状态模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-text">进程的三态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-text">进程的五态模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.4.3 进程状态的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-text">2.4.4 进程的终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA"><span class="nav-text">正常退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%80%80%E5%87%BA"><span class="nav-text">错误退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF"><span class="nav-text">严重错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E6%9D%80%E6%AD%BB"><span class="nav-text">被其他进程杀死</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">2.5 进程的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">必背考点：进程有哪些通信方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">2.5.1 进程通信方法—共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E7%AE%A1%E9%81%93%EF%BC%88%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%89"><span class="nav-text">2.5.2 进程通信方法—管道（匿名管道）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-text">2.5.3 进程通信方法—消息传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="nav-text">2.6 进程的同步和互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-text">必背考点：进程同步的原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E4%BA%86%E8%A7%A3%E6%A6%82%E5%BF%B5%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-text">2.6.1 信号量（了解概念即可）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%86%E8%A7%A3%E6%A6%82%E5%BF%B5%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-text">2.6.2 生产者消费者问题（了解概念即可）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="nav-text">2.7 线程和协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="nav-text">2.7.1 为什么要引入线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.7.2 线程的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">必背考点：什么是线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">必背考点：进程和线程的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">2.7.3 什么是上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-4-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">2.7.4 使用多线程的好处是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-5-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">2.7.5 协程是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-6-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.7.6 线程和协程的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">2.8 调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">2.8.1 调度算法有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-text">批处理中的调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="nav-text">最短作业优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-text">最短剩余时间优先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-text">2.8.2 交互式系统中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6"><span class="nav-text">轮询调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-text">优先级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88"><span class="nav-text">最短进程优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6"><span class="nav-text">彩票调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E5%88%86%E4%BA%AB%E8%B0%83%E5%BA%A6"><span class="nav-text">公平分享调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-%E5%BD%B1%E5%93%8D%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8C%87%E6%A0%87"><span class="nav-text">2.8.3 影响调度程序的指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E4%BD%BF%E7%94%A8%E7%8E%87%EF%BC%9A"><span class="nav-text">CPU 使用率：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="nav-text">等待时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-text">响应时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="nav-text">周转时间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-4-RR-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">2.8.4 RR 调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">3. 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 内存的基础知识和概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-cpu%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="nav-text">3.1.1 cpu如何区分执行程序的数据在内存的什么地方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-text">3.1.2 内存管理-内存空间的分配与回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">3.2 虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">3.2.1 什么是虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">3.2.2 虚拟内存的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E6%8C%89%E9%9C%80%E5%88%86%E9%A1%B5"><span class="nav-text">3.2.3 按需分页</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">3.3 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E6%AE%B5"><span class="nav-text">3.3.1 分析内存为什么要分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.3.2 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3.3 空闲内存管理的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%9B%BE%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86"><span class="nav-text">使用位图进行管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">使用空闲链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E5%BC%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3.4 分页和分段式的存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F"><span class="nav-text">分页式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%BC%8F"><span class="nav-text">分段式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">分段和分页的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">段页式的存储管理方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">3.4 页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT%EF%BC%8COptlmal"><span class="nav-text">3.4.1 最佳置换算法(OPT，Optlmal)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-NRU"><span class="nav-text">3.4.2最近未使用算法(NRU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%8CFirst-In-First-Out%EF%BC%89"><span class="nav-text">3.4.3 先进先出置换算法（FIFO，First In First Out）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%8CLeast-Recently-Used%EF%BC%89"><span class="nav-text">3.4.4 最近最久未使用置换算法（LRU，Least Recently Used）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%88Least-Frequently-Used%EF%BC%8CLFU%EF%BC%89"><span class="nav-text">3.4.5 最不经常使用算法（Least Frequently Used，LFU）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-6-%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88Clock%EF%BC%89%EF%BC%9A"><span class="nav-text">3.4.6 时钟置换算法（Clock）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-7-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88Clock%EF%BC%89%EF%BC%9A"><span class="nav-text">3.4.7 改进的时钟置换算法（Clock）：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-text">4.1 文件的定义和属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-text">4.2 文件的组织方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="nav-text">4.2.1 文件内部数据如何组织在一起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5"><span class="nav-text">4.2.2 文件之间如何组织起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">4.2.3 文件的逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-1-%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="nav-text">4.2.3.1 顺序文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-2-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="nav-text">4.2.3.2 索引文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-3-%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="nav-text">4.2.3.3 索引顺序文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-text">4.2.4 文件目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">4.2.5 文件存储空间管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">4.3 文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">4.4 文件保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%8F%90%E9%AB%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">4.5 提高文件系统性能的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-text">4.5.1 高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-%E5%9D%97%E6%8F%90%E5%89%8D%E8%AF%BB"><span class="nav-text">4.5.2 块提前读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E8%87%82%E8%BF%90%E5%8A%A8"><span class="nav-text">4.5.3 减少磁盘臂运动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="nav-text">4.5.4 磁盘碎片整理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E7%A3%81%E7%9B%98%E8%87%82%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">4.6 磁盘臂调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-RAID-%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB"><span class="nav-text">4.7 RAID 的不同级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-IO%E8%AE%BE%E5%A4%87"><span class="nav-text">5. IO设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">5.1 I&#x2F;O设备的定义与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-I-O%E8%AE%BE%E5%A4%87%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1.1 I&#x2F;O设备定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-I-O%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB%E2%80%94%E2%80%94%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7"><span class="nav-text">5.1.2 I&#x2F;O设备分类——按使用特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">5.1.3 设备驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B"><span class="nav-text">5.1.4 五种I&#x2F;O模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-I-O%E6%8E%A7%E5%88%B6"><span class="nav-text">5.2 I&#x2F;O控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">5.2.1 I&#x2F;O控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.2 I&#x2F;O控制方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%97%B6%E9%92%9F"><span class="nav-text">5.3 操作系统中的时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E6%97%B6%E9%92%9F%E7%A1%AC%E4%BB%B6"><span class="nav-text">5.3.1 时钟硬件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">5.4 操作系统的中断处理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-DMA-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="nav-text">5.5 DMA(直接内存访问)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%AD%BB%E9%94%81"><span class="nav-text">6. 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">6.1 产生死锁的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">必背考点：死锁产生的原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">6.2 死锁的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9%EF%BC%9A%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">必背考点：死锁产生的必要条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">6.3 死锁的恢复方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E9%80%9A%E8%BF%87%E6%8A%A2%E5%8D%A0%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="nav-text">6.3.1 通过抢占进行恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E9%80%9A%E8%BF%87%E5%9B%9E%E6%BB%9A%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="nav-text">6.3.2 通过回滚进行恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%E6%81%A2%E5%A4%8D"><span class="nav-text">6.3.3 杀死进程恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E6%AD%BB%E9%94%81"><span class="nav-text">6.4 如何破坏死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.4.1 破坏互斥条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E7%A0%B4%E5%9D%8F%E4%BF%9D%E6%8C%81%E7%AD%89%E5%BE%85%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.4.2 破坏保持等待的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.4.3 破坏不可抢占条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-text">6.4.4 破坏循环等待条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%83%8C%E8%80%83%E7%82%B9-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-text">必背考点 预防死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.5 孤儿进程和僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.5.1 父进程与子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.5.2 僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-text">6.5.3 孤儿进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E6%AD%BB%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.6 死锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81"><span class="nav-text">6.6.1 两阶段加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E9%80%9A%E4%BF%A1%E6%AD%BB%E9%94%81"><span class="nav-text">6.6.2 通信死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-%E6%B4%BB%E9%94%81"><span class="nav-text">6.6.3 活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-4-%E9%A5%A5%E9%A5%BF"><span class="nav-text">6.6.4 饥饿</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">7. Linux常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Linux%E7%B3%BB%E7%BB%9F"><span class="nav-text">7.1 Linux系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95"><span class="nav-text">7.2 操作文件与目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">7.3 读写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E7%AE%A1%E9%81%93"><span class="nav-text">7.4 管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-text">7.5 进程与内存相关</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxy"
      src="/images/Robben.gif">
  <p class="site-author-name" itemprop="name">hxy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huxingyi1997" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huxingyi1997" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huxingyi1997@zju.edu.cn" title="E-Mail → mailto:huxingyi1997@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-frog"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxy</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共703.3k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQsO3ySbU4VtWN2j1FLA74Ha-gzGzoHsz',
      appKey     : 'QYacMDY2VY7Wazprg1X6FiUv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
  <!-- 动态背景特效 -->
  <!-- 樱花特效 -->
    <script async src="/js/src/sakura.js"></script>
    <script async src="/js/src/fairyDustCursor.js"></script>
</body>
</html>
