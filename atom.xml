<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hxy的博客</title>
  
  <subtitle>Mia san Mia!</subtitle>
  <link href="https://hxy1997.xyz/atom.xml" rel="self"/>
  
  <link href="https://hxy1997.xyz/"/>
  <updated>2021-03-07T04:19:26.124Z</updated>
  <id>https://hxy1997.xyz/</id>
  
  <author>
    <name>hxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue项目部署到gitee pages</title>
    <link href="https://hxy1997.xyz/2021/03/07/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0gitee%20pages/"/>
    <id>https://hxy1997.xyz/2021/03/07/vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0gitee%20pages/</id>
    <published>2021-03-07T04:02:39.000Z</published>
    <updated>2021-03-07T04:19:26.124Z</updated>
    
    <content type="html"><![CDATA[<p>使用Gitee Page实现静态页面（<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器</a> ）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Page，实现项目的正式上线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目</a></p><a id="more"></a><h1 id="一、简单的音乐播放器静态页面"><a href="#一、简单的音乐播放器静态页面" class="headerlink" title="一、简单的音乐播放器静态页面"></a>一、简单的音乐播放器静态页面</h1><h2 id="1-1-将项目提交至gitee"><a href="#1-1-将项目提交至gitee" class="headerlink" title="1.1 将项目提交至gitee"></a>1.1 将项目提交至gitee</h2><p>到Gitee上新建仓库，写仓库名称 选择是否开源 </p><p>使用git remote add origin <a href="https://gitee.com/%E7%A0%81%E4%BA%91%E7%94%A8%E6%88%B7%E5%90%8D/%E9%A1%B9%E7%9B%AE%E5%90%8D">https://gitee.com/码云用户名/项目名</a> / 添加远程仓库。</p><p>git pull origin master 命令，将码云上的仓库pull到先前创建的文件夹中，期间需要输入gitee上面的账号和密码，输入完成密码之后点击 OK。<br>可能会出现以下提示问题：</p><p>这是因为没有配置提交时的用户名和邮箱的原因，你可以直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure><p>完毕之后再把将要上传的文件，全部添加到之前在桌面创建的文件夹中并使用git add .（. 表示所有的）或者 git add 文件名 // 将文件保存到缓存区<br>然后使用git commit -m ‘这里写新推送的文件描述’ //添加文件描述<br>使用git push origin master ，将本地仓库推送到远程仓库，之后去刷新gitee就能看到推送上去的项目了。</p><h2 id="1-2-配置Gitee-Page"><a href="#1-2-配置Gitee-Page" class="headerlink" title="1.2 配置Gitee Page"></a>1.2 配置Gitee Page</h2><p><img data-src="https://www.pianshen.com/images/787/f15acfa42d77a529ca3163842b954a93.png" alt="在这里插入图片描述"></p><p>点击项目导航栏中的<code>服务 --&gt; Gitee Pages</code></p><h2 id="1-3-访问网站"><a href="#1-3-访问网站" class="headerlink" title="1.3 访问网站"></a>1.3 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，我的项目入口文件不是，所以需要，打开<a href="https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF">悦听播放器</a> 可以享用音乐了</p><h1 id="二、使用vue-cli脚手架创建的页面"><a href="#二、使用vue-cli脚手架创建的页面" class="headerlink" title="二、使用vue-cli脚手架创建的页面"></a>二、使用vue-cli脚手架创建的页面</h1><h2 id="2-1-调整本地项目"><a href="#2-1-调整本地项目" class="headerlink" title="2.1 调整本地项目"></a>2.1 调整本地项目</h2><h3 id="在根目录下增加-spa文件"><a href="#在根目录下增加-spa文件" class="headerlink" title="在根目录下增加.spa文件"></a>在根目录下增加.spa文件</h3><p>首先，根据<a href="https://gitee.com/help/articles/4237">官方指示</a></p><p><img data-src="https://www.pianshen.com/images/763/d160e86218b36d31956264b83badf383.png" alt="在这里插入图片描述"></p><p>在项目路径中添加<code>.spa</code>文件</p><p><img data-src="https://www.pianshen.com/images/47/56f6b7fcdf231191cb0eee073e26c65f.png" alt="在这里插入图片描述"></p><p>原理，我不是很清楚，应该是给Nginx做一个<code>标识</code>作用吧。</p><h3 id="配置production版本路径名称"><a href="#配置production版本路径名称" class="headerlink" title="配置production版本路径名称"></a>配置production版本路径名称</h3><p>根目录下的vue.config.js文件，如下图箭头那个要改为项目文件名称</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003141513-937920345.png" alt="img"></p><p>在本地运行<code>npm run build</code>，得到/dist</p><p><img data-src="https://www.pianshen.com/images/168/5518c17f01e39d7a0984962b7276a2e0.png" alt="在这里插入图片描述">`</p><h3 id="配置-gitignore文件"><a href="#配置-gitignore文件" class="headerlink" title="配置.gitignore文件"></a>配置.gitignore文件</h3><p>首先要在.gitignore文件去掉/dist，这个文件默认是不上传的，但是执行打包bulid的时候会生成dist文件，而线上访问的是打包之后的dist文件；</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208002522081-1246305362.png" alt="img"></p><h2 id="2-2-将项目提交至gitee"><a href="#2-2-将项目提交至gitee" class="headerlink" title="2.2 将项目提交至gitee"></a>2.2 将项目提交至gitee</h2><p>参考1.2节的做法，此步不再赘述</p><h2 id="2-3-配置Gitee-Page"><a href="#2-3-配置Gitee-Page" class="headerlink" title="2.3 配置Gitee Page"></a>2.3 配置Gitee Page</h2><p>用上次同样的方法点进Gitee Pages</p><p><img data-src="https://img2018.cnblogs.com/i-beta/475401/202002/475401-20200208002750052-1156032907.png" alt="img"></p><p>这一次部署目录要填写dist</p><p><img data-src="https://img2018.cnblogs.com/common/475401/202002/475401-20200208003016869-817429112.png" alt="img"></p><h2 id="2-4-访问网站"><a href="#2-4-访问网站" class="headerlink" title="2.4 访问网站"></a>2.4 访问网站</h2><p>打开网站 https://码云用户名.gitee.io/项目名/入口文件 即可访问，注意入口文件为index.html可省略，这次vue-cli创建的项目不需要，打开线 <a href="https://hxy1997.gitee.io/vue_shops/">Vue电商项目</a> 就可以体验电商项目了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Gitee Page实现静态页面（&lt;a href=&quot;https://hxy1997.gitee.io/music_player/%E6%A8%A1%E6%9D%BF&quot;&gt;悦听播放器&lt;/a&gt; ）部署后 ，我尝试着将自己学习搭建的Vue电商项目托管至Gitee Page，实现项目的正式上线 &lt;a href=&quot;https://hxy1997.gitee.io/vue_shops/&quot;&gt;Vue电商项目&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://hxy1997.xyz/tags/vue/"/>
    
    <category term="gitee page" scheme="https://hxy1997.xyz/tags/gitee-page/"/>
    
    <category term="实战" scheme="https://hxy1997.xyz/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>css面试题</title>
    <link href="https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/06/css%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-06T04:02:39.000Z</published>
    <updated>2021-03-07T04:16:21.507Z</updated>
    
    <content type="html"><![CDATA[<p>CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS样式基本布局也是前端的基本功课，相比JS，自己这方面并没有做足功课，只能根据常见的面试题反向逼迫自己尽快复习了，实习春招和秋招加油吧&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CSS" scheme="https://hxy1997.xyz/tags/CSS/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-04T11:14:39.000Z</published>
    <updated>2021-03-04T11:45:54.772Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。</p><a id="more"></a><h1 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章主要介绍进程与线程的区别与联系相关知识点，也是我们面试过程中，经常会问到的一个问题。希望通过这篇文章，能让大家理解相关知识点~</p><p>涉及面试题：</p><ul><li>1.进程与线程之间有什么区别？</li><li>2.进程、线程都各有什么特点？</li><li>3.进程之间的是怎么进行交互的呢？</li><li>4.什么是缓冲区溢出？</li><li>5.进程之间如何进行交互？</li><li>6.线程之间如何进行交互？</li></ul><blockquote><p>上面的面试题可以看出，其实都是一回事，只是换了一种提问方式，只要我们能掌握核心要点，随便面试官怎么提问，我们都能轻松应对！</p></blockquote><h2 id="1-小例子："><a href="#1-小例子：" class="headerlink" title="1. 小例子："></a>1. 小例子：</h2><blockquote><p>我们生活中有许许多多关于进程与线程的小例子，比如：1.我们使用打开一个微信软件，这个时候就开启了一个进程，<br>当我们在微信里面进行各种操作（查看朋友圈，扫一扫…），这么多的操作就是线程。<br>所以我们可以说“进程”是包含“线程”的，“线程”是“进程”的一个子集。</p></blockquote><blockquote><p><strong>来源百度百科：</strong></p></blockquote><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><blockquote><p>我们简单总结下：</p></blockquote><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p><h2 id="2-深入理解："><a href="#2-深入理解：" class="headerlink" title="2. 深入理解："></a>2. 深入理解：</h2><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3bb5683b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-1-进程-线程-内存-文件-网络句柄"><a href="#2-1-进程-线程-内存-文件-网络句柄" class="headerlink" title="2.1 进程(线程+内存+文件/网络句柄)"></a>2.1 进程(线程+内存+文件/网络句柄)</h3><p>我们通过上面的图片进行进一步理解：</p><p><strong>“内存”：</strong> 我们通常所理解的内存是我们所见到的(2G/4G/8G/16G)物理内存,它为什么会在进程之中呢？ 实际上，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。 否则的话会出现一个问题：我们把指针的值改一改就指向其他进程的内存了，通过这样我们岂不是就可以看到其他进程中”微信”或者是”网上银行”的信息， 这样的话，那我们的微信聊天记录或者是银行账户的信息就都被别人找到了，这是一个很危险的信号！显然这样是不可能的。</p><p><strong>“文件/网络句柄”：</strong> 它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。</p><p><strong>“线程”：</strong> 接下来，我们就要介绍一下我们的“线程”有关知识</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/3/21/1699ecde3ba97f25?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在这里插入图片描述"></p><h3 id="2-2-线程-栈-PC-TLS"><a href="#2-2-线程-栈-PC-TLS" class="headerlink" title="2.2 线程(栈+PC+TLS)"></a>2.2 线程(栈+PC+TLS)</h3><h4 id="2-2-1-栈"><a href="#2-2-1-栈" class="headerlink" title="2.2.1 栈:"></a>2.2.1 栈:</h4><p>我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。 那么我们的栈里面有什么呢？ 我们从主线程的入口main函数，会不断的进行函数调用， 每次调用的时候，会把所有的参数和返回地址压入到栈中。</p><h4 id="2-2-2-PC："><a href="#2-2-2-PC：" class="headerlink" title="2.2.2 PC："></a>2.2.2 PC：</h4><p>Program Counter 程序计数器，操作系统真正运行的是一个个的线程， 而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。 计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的 这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。</p><h5 id="2-2-2-1-缓冲区溢出"><a href="#2-2-2-1-缓冲区溢出" class="headerlink" title="2.2.2.1 缓冲区溢出"></a>2.2.2.1 缓冲区溢出</h5><p>例如我们经常听到一个漏洞：<strong>缓冲区溢出</strong> 这是什么意思呢？ 例如：我们有个地方要输入用户名，本来是用来存数据的地方。 然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了 我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码 写入到用户名框中，来植入进来。我们的解决方法就是，用用户名的长度来限制不要超过 用户名的缓冲区的大小来解决。</p><h4 id="2-3-TLS"><a href="#2-3-TLS" class="headerlink" title="2.3 TLS:"></a>2.3 TLS:</h4><p>全称：thread local storage 之前我们看到每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢?答案是有的，就是TLS。 可以用来存储我们线程所独有的数据。 可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。</p><h3 id="3-小结："><a href="#3-小结：" class="headerlink" title="3.小结："></a>3.小结：</h3><p>1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了. 2.一个程序至少有一个进程,一个进程至少有一个线程. 3.进程是资源分配的最小单位，线程是程序执行的最小单位。 4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.</p><h1 id="2-进程间通信"><a href="#2-进程间通信" class="headerlink" title="2.进程间通信"></a>2.进程间通信</h1><h2 id="一、进程间通信的概念"><a href="#一、进程间通信的概念" class="headerlink" title="一、进程间通信的概念"></a>一、进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-76c95f147203c797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/222/format/webp" alt="img"></p><p>进程间通信模型</p><h2 id="二、进程间通信的7种方式"><a href="#二、进程间通信的7种方式" class="headerlink" title="二、进程间通信的7种方式"></a>二、进程间通信的7种方式</h2><p><strong>第一类：传统的Unix通信机制</strong><br> <strong>1. 管道/匿名管道(pipe)</strong></p><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp" alt="img"></p><p>进程间管道通信模型</p></li></ul><p><strong>管道的实质：</strong><br> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><p><strong>2. 有名管道(FIFO)</strong><br> 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><p><strong>3. 信号(Signal)</strong></p><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br> （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-3eed8cca67aa9f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p><p>信号的生命周期</p><p><strong>4. 消息(Message)队列</strong></p><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com/?t=http://blog.csdn.net/yang_yulei/article/details/19772649">延伸阅读：消息队列C语言的实践</a></li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><p><strong>5. 共享内存(share memory)</strong></p><ul><li><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p></li><li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="img"></p><p>共享内存原理图</p></li></ul><p><strong>6. 信号量(semaphore)</strong><br> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br> （3）<strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</p><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com/?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/635/format/webp" alt="img"></p><p>两个进程使用一个二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a72c8fbe22340031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="img"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/284/format/webp" alt="img"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><p><strong>7. 套接字(socket)</strong><br> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/319/format/webp" alt="img"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> 原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p></blockquote><p><strong>套接字通信的建立</strong></p><p><img data-src="https://upload-images.jianshu.io/upload_images/1281379-2575b81bbab6b67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/437/format/webp" alt="img"></p><p>Socket通信基本流程</p><p>** 服务器端**<br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。<br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。<br> <a href="https://link.jianshu.com/?t=http://developer.51cto.com/art/201509/490775.htm">延伸阅读 ：Java socket编程</a></p><h2 id="三、参考引用"><a href="#三、参考引用" class="headerlink" title="三、参考引用"></a>三、参考引用</h2><p><a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html">1. 进程间通信–管道 </a><br> <a href="https://link.jianshu.com/?t=http://blog.csdn.net/ljianhui/article/details/10253345">2. Linux进程间通信——使用共享内存</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-26833883-id-3230564.html">3. 进程间通信—共享内存</a><br> <a href="https://link.jianshu.com/?t=http://www.cnblogs.com/diyingyun/archive/2011/12/04/2275229.html">4. 信号量与互斥锁</a><br> <a href="https://link.jianshu.com/?t=http://blog.chinaunix.net/uid-23193900-id-3194924.html">5. 信号量</a></p><h1 id="3-进程调度策略"><a href="#3-进程调度策略" class="headerlink" title="3.进程调度策略"></a>3.进程调度策略</h1><h2 id="1-先来先服务调度算法："><a href="#1-先来先服务调度算法：" class="headerlink" title="1.先来先服务调度算法："></a>1.先来先服务调度算法：</h2><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><h2 id="2-短作业-进程-优先调度算法："><a href="#2-短作业-进程-优先调度算法：" class="headerlink" title="2.短作业(进程)优先调度算法："></a>2.短作业(进程)优先调度算法：</h2><p>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><h2 id="3-高优先权优先调度算法："><a href="#3-高优先权优先调度算法：" class="headerlink" title="3.高优先权优先调度算法："></a>3.高优先权优先调度算法：</h2><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><h3 id="3-1-非抢占式优先权算法："><a href="#3-1-非抢占式优先权算法：" class="headerlink" title="3.1) 非抢占式优先权算法："></a>3.1) 非抢占式优先权算法：</h3><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><h3 id="3-2-抢占式优先权调度算法："><a href="#3-2-抢占式优先权调度算法：" class="headerlink" title="3.2) 抢占式优先权调度算法："></a>3.2) 抢占式优先权调度算法：</h3><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><h3 id="3-3-容易出现优先级倒置现象："><a href="#3-3-容易出现优先级倒置现象：" class="headerlink" title="3.3)容易出现优先级倒置现象："></a>3.3)容易出现优先级倒置现象：</h3><p>优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p><h3 id="3-4-优先级反转案例解释："><a href="#3-4-优先级反转案例解释：" class="headerlink" title="3.4)优先级反转案例解释："></a>3.4)优先级反转案例解释：</h3><p>不同优先级线程对共享资源的访问的同步机制。优先级为高和低的线程tall和线程low需要访问共享资源，优先级为中等的线程mid不访问该共享资源。当low正在访问共享资源时，tall等待该共享资源的互斥锁，但是此时low被mid抢先了，导致mid运行tall阻塞。即优先级低的线程mid运行，优先级高的tall被阻塞。</p><h3 id="3-5-优先级倒置解决方案："><a href="#3-5-优先级倒置解决方案：" class="headerlink" title="3.5)优先级倒置解决方案："></a>3.5)优先级倒置解决方案：</h3><p>​       (3.5.1）设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。<br>​     （3.5.2）优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。<br>​       这里还有一个八卦，1997年的美国的火星探测器（使用的就是vxworks)就遇到一个优先级反转问题引起的故障。简单说下，火星探测器有一个信息总线，有一个高优先级的总线任务负责总线数据的存取，访问总线都需要通过一个互斥锁（共享资源出现了）；还有一个低优先级的，运行不是很频繁的气象搜集任务，它需要对总线写数据，也就同样需要访问互斥锁；最后还有一个中优先级的通信任务，它的运行时间比较长。平常这个系统运行毫无问题，但是有一天，在气象任务获得互斥锁往总线写数据的时候，一个中断发生导致通信任务被调度就绪，通信任务抢占了低优先级的气象任务，而无巧不成书的是，此时高优先级的总线任务正在等待气象任务写完数据归还互斥锁，但是由于通信任务抢占了CPU并且运行时间比较长，导致气象任务得不到CPU时间也无法释放互斥锁，本来是高优先级的总线任务也无法执行，总线任务无法及时执行的后果被探路者认为是一个严重错误，最后就是整个系统被重启。Vxworks允许优先级继承，然而遗憾的工程师们将这个选项关闭了。<br>​     （3.5.3）第三种方法就是临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</p><h2 id="4、高响应比优先调度算法："><a href="#4、高响应比优先调度算法：" class="headerlink" title="4、高响应比优先调度算法："></a>4、高响应比优先调度算法：</h2><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p><img data-src="https://img-blog.csdn.net/20180922085248936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>   在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h2 id="5、时间片轮转法："><a href="#5、时间片轮转法：" class="headerlink" title="5、时间片轮转法："></a>5、时间片轮转法：</h2><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p><h2 id="6、多级反馈队列调度算法："><a href="#6、多级反馈队列调度算法：" class="headerlink" title="6、多级反馈队列调度算法："></a>6、多级反馈队列调度算法：</h2><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p><p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p><p>(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p><p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p><p><img data-src="https://img-blog.csdn.net/20180922085249110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？<br>批处理系统常用调度算法：<br>①、先来先服务：FCFS<br>②、最短作业优先<br>③、最短剩余时间优先<br>④、响应比最高者优先</p><p>分时系统调度算法：<br>①、轮转调度<br>②、优先级调度<br>③、多级队列调度<br>④、彩票调度</p><p>实时系统调度算法：<br>①、单比率调度<br>②、限期调度<br>③、最少裕度法</p><h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h1><p>死锁是什么，以及在并发程序中如何避免死锁一直是面试官偏爱的一个问题。<br> 本文尽量以最简洁的示例来帮助你快速理解，掌握死锁发生的原因及其解决方法。在阅读接下来的内容之前，你必须具备java中独占锁与线程之间通信的基本知识。</p><p><strong>死锁</strong><br> 当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p>下面用一个非常简单的死锁示例来帮助你理解死锁的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取String.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">线程b尝试获取String.class</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">无限阻塞下去</span><br></pre></td></tr></table></figure><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>教科书般的回答应该是，结合“哲学家就餐[<a href="#fn1">1]</a>”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p><p>造成死锁必须达成的4个条件（原因）：</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p><ol><li>互斥条件 —&gt; 独占锁的特点之一。</li><li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li><li>不剥夺条件 —&gt; 独占锁的特点之一。</li><li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li></ol><p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p><p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p><p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是否能够简单明了的在面试中阐述清楚死锁产生的原因，并给出解决死锁的方案，可以体现程序员在面对对并发问题时思路是否清晰，对并发的基础掌握是否牢固等等。<br> 而且在实际项目中并发模块的逻辑往往比本文的示例复杂许多，所以写并发应用之前一定要充分理解本文所总结的要点，并切记，并发程序编程在不显著影响程序性能的情况下，一定要尽可能的保守。</p><h1 id="5-I-O-多路复用，select-poll-epoll-详解"><a href="#5-I-O-多路复用，select-poll-epoll-详解" class="headerlink" title="5.I/O 多路复用，select / poll / epoll 详解"></a>5.I/O 多路复用，select / poll / epoll 详解</h1><h2 id="从阻塞-I-O-到-I-O-多路复用"><a href="#从阻塞-I-O-到-I-O-多路复用" class="headerlink" title="从阻塞 I/O 到 I/O 多路复用"></a>从阻塞 I/O 到 I/O 多路复用</h2><p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用<strong>多线程</strong>来处理多个文件描述符。</p><p>多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在<strong>一个线程</strong>里<em>轮询</em>多个文件描述符是否就绪。</p><p>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查<strong>一个</strong>文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。</p><p>因此引入了 I/O 多路复用，可以<strong>通过一次系统调用，检查多个文件描述符的状态</strong>。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p><blockquote><p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询。</p></blockquote><p>进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：<strong>如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回</strong>。使用非阻塞 I/O 检查每个描述符的就绪状态。</p><p>如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><p>I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。这部分内容可以查看最下文 <a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">Redis 的线程模型</a>。</p><h3 id="为什么-I-O-多路复用内部需要使用非阻塞-I-O"><a href="#为什么-I-O-多路复用内部需要使用非阻塞-I-O" class="headerlink" title="为什么 I/O 多路复用内部需要使用非阻塞 I/O"></a>为什么 I/O 多路复用内部需要使用非阻塞 I/O</h3><p>I/O 多路复用<strong>内部</strong>会遍历集合中的每个文件描述符，判断其是否就绪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for fd in read_set</span><br><span class="line">    if（ readable(fd) ) &#x2F;&#x2F; 判断 fd 是否就绪</span><br><span class="line">        count++</span><br><span class="line">        FDSET(fd, &amp;res_rset) &#x2F;&#x2F; 将 fd 添加到就绪集合中</span><br><span class="line">        break</span><br><span class="line">...</span><br><span class="line">return count</span><br></pre></td></tr></table></figure><p>这里的 <code>readable(fd)</code> 就是一个非阻塞 I/O 调用。试想，如果这里使用阻塞 I/O，那么 <code>fd</code> 未就绪时，<code>select</code> 会阻塞在这个文件描述符上，无法检查下个文件描述符。</p><p>注意：这里说的是 I/O 多路复用的内部实现，而不是说，使用 I/O 多路复用就必须使用非阻塞 I/O，见下文<a href="https://imageslr.github.io/2020/02/27/select-poll-epoll.html#whynonblock">为什么边缘触发必须使用非阻塞 I/O</a>。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="函数签名与参数"><a href="#函数签名与参数" class="headerlink" title="函数签名与参数"></a>函数签名与参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds,</span><br><span class="line">            fd_set *restrict readfds,</span><br><span class="line">            fd_set *restrict writefds,</span><br><span class="line">            fd_set *restrict errorfds,</span><br><span class="line">            struct timeval *restrict timeout);</span><br></pre></td></tr></table></figure><p><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。<code>select</code> 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。</p><p><code>timeout</code> 参数表示调用 <code>select</code> 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 <code>timeout</code> 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 <code>timeout</code> 参数设为 0，会立即返回，不阻塞。</p><h3 id="什么是文件描述符-fd"><a href="#什么是文件描述符-fd" class="headerlink" title="什么是文件描述符 fd"></a>什么是文件描述符 fd</h3><p>文件描述符（file descriptor）是一个非负整数，从 0 开始。进程使用文件描述符来标识一个打开的文件。</p><p>系统为每一个进程维护了一个文件描述符表，表示该进程打开文件的记录表，而<strong>文件描述符实际上就是这张表的索引</strong>。当进程打开（<code>open</code>）或者新建（<code>create</code>）文件时，内核会在该进程的文件列表中新增一个表项，同时返回一个文件描述符 —— 也就是新增表项的下标。</p><p>一般来说，每个进程最多可以打开 64 个文件，<code>fd ∈ 0~63</code>。在不同系统上，最多允许打开的文件个数不同，Linux 2.4.22 强制规定最多不能超过 1,048,576。</p><p><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.md">这篇文章</a>以图示的方式对文件描述符作了深入地讲解，可以进一步阅读。</p><h3 id="socket-与-fd-的关系"><a href="#socket-与-fd-的关系" class="headerlink" title="socket 与 fd 的关系"></a>socket 与 fd 的关系</h3><p>socket 是 Unix 中的术语。socket 可以用于同一台主机的不同进程间的通信，也可以用于不同主机间的通信。一个 socket 包含地址、类型和通信协议等信息，通过 <code>socket()</code> 函数创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol)</span><br></pre></td></tr></table></figure><p>返回的就是这个 socket 对应的文件描述符 <code>fd</code>。</p><p>可以这样理解：<strong>socket 是进程间通信规则的高层抽象，而 fd 提供的是底层的具体实现</strong>。socket 与 fd 是一一对应的。<strong>通过 socket 通信，实际上就是通过文件描述符 <code>fd</code> 读写文件</strong>。这也符合 Unix“一切皆文件”的哲学。</p><p>后面可以将 socket 和 fd 视为同义词。</p><h3 id="fd-set-文件描述符集合"><a href="#fd-set-文件描述符集合" class="headerlink" title="fd_set 文件描述符集合"></a>fd_set 文件描述符集合</h3><p>参数中的 <code>fd_set</code> 类型表示文件描述符的集合。</p><p>由于文件描述符 <code>fd</code> 是一个从 0 开始的无符号整数，所以可以使用 <code>fd_set</code> 的<strong>二进制每一位</strong>来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 <code>fd_set</code> 长度为 1 字节，则一个 <code>fd_set</code> 变量最大可以表示 8 个文件描述符。当 <code>select</code> 返回 <code>fd_set = 00010011</code> 时，表示文件描述符 <code>1</code>、<code>2</code>、<code>5</code> 已经就绪。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;select.h&gt;   </span><br><span class="line">int FD_ZERO(int fd, fd_set *fdset);  &#x2F;&#x2F; 将 fd_set 所有位置 0</span><br><span class="line">int FD_CLR(int fd, fd_set *fdset);   &#x2F;&#x2F; 将 fd_set 某一位置 0</span><br><span class="line">int FD_SET(int fd, fd_set *fd_set);  &#x2F;&#x2F; 将 fd_set 某一位置 1</span><br><span class="line">int FD_ISSET(int fd, fd_set *fdset); &#x2F;&#x2F; 检测 fd_set 某一位是否为 1</span><br></pre></td></tr></table></figure><h3 id="select-使用示例"><a href="#select-使用示例" class="headerlink" title="select 使用示例"></a>select 使用示例</h3><p>下图的代码说明：</p><ol><li>先声明一个 <code>fd_set</code> 类型的变量 <code>readFDs</code></li><li>调用 <code>FD_ZERO</code>，将 <code>readFDs</code> 所有位置 0</li><li>调用 <code>FD_SET</code>，将 <code>readFDs</code> 感兴趣的位置 1，表示要监听这几个文件描述符</li><li>将 <code>readFDs</code> 传给 <code>select</code>，调用 <code>select</code></li><li><code>select</code> 会将 <code>readFDs</code> 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量</li><li>当 <code>select</code> 返回后，调用 <code>FD_ISSET</code> 检测给定位是否为 1，表示对应文件描述符是否就绪</li></ol><p>比如进程想监听 1、2、5 这三个文件描述符，就将 <code>readFDs</code> 设置为 <code>00010011</code>，然后调用 <code>select</code>。</p><p>如果 <code>fd=1</code>、<code>fd=2</code> 就绪，而 <code>fd=5</code> 未就绪，<code>select</code> 会将 <code>readFDs</code> 设置为 <code>00000011</code> 并返回 2。</p><p>如果每个文件描述符都未就绪，<code>select</code> 会阻塞 <code>timeout</code> 时长，再返回。这期间，如果 <code>readFDs</code> 监听的某个文件描述符上发生可读事件，则 <code>select</code> 会将对应位置 1，并立即返回。</p><p><img data-src="https://imageslr.github.io/media/15732186159520.jpg" alt="15732186159520"></p><h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><ol><li>性能开销大<ol><li>调用 <code>select</code> 时会陷入内核，这时需要将参数中的 <code>fd_set</code> 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 <code>fd_set</code> 的每一位，不管它们是否就绪</li></ol></li><li>同时能够监听的文件描述符数量太少。受限于 <code>sizeof(fd_set)</code> 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 和 select 几乎没有区别。poll 采用链表的方式存储文件描述符，没有最大存储数量的限制。</p><p>从性能开销上看，poll 和 select 的差别不大。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ul><li>使用<strong>红黑树</strong>存储文件描述符集合</li><li>使用<strong>队列</strong>存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li></ul><p>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个 <code>epoll</code> 实例，同时返回一个引用该实例的文件描述符。</p><p>返回的文件描述符仅仅指向对应的 <code>epoll</code> 实例，并不表示真实的磁盘文件节点。其他 API 如 <code>epoll_ctl</code>、<code>epoll_wait</code> 会使用这个文件描述符来操作相应的 <code>epoll</code> 实例。</p><p>当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 <code>/proc/进程id/fd/</code>，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 <code>close(epfd)</code> 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 <code>epoll</code> 实例的所有文件描述符都被关闭后，操作系统会销毁这个 <code>epoll</code> 实例。</p><p><code>epoll</code> 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 会监听文件描述符 <code>fd</code> 上发生的 <code>event</code> 事件。</p><p>参数说明：</p><ul><li><p><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</p></li><li><p><code>fd</code> 表示要监听的目标文件描述符</p></li><li><p><code>event</code> 表示要监听的事件（可读、可写、发送错误…）</p></li><li><pre><code class="plaintext">op<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">表示要对</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;plaintext</span><br><span class="line">fd</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>  执行的操作，有以下几种：</p><ul><li><code>EPOLL_CTL_ADD</code>：为 <code>fd</code> 添加一个监听事件 <code>event</code></li><li><code>EPOLL_CTL_MOD</code>：Change the event event associated with the target file descriptor fd（<code>event</code> 是一个结构体变量，这相当于变量 <code>event</code> 本身没变，但是更改了其内部字段的值）</li><li><code>EPOLL_CTL_DEL</code>：删除 <code>fd</code> 的所有监听事件，这种情况下 <code>event</code> 参数没用</li></ul><p>返回值 0 或 -1，表示上述操作成功与否。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到 <code>epoll</code> 实例的监听列表里，同时为 <code>fd</code> 设置一个回调函数，并监听事件 <code>event</code>。当 <code>fd</code> 上发生相应事件时，会调用回调函数，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">               int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>这是 epoll 模型的主要函数，功能相当于 <code>select</code>。</p><p>参数说明：</p><ul><li><code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，指向一个 <code>epoll</code> 实例</li><li><code>events</code> 是一个数组，保存就绪状态的文件描述符，其空间由调用者负责申请</li><li><code>maxevents</code> 指定 <code>events</code> 的大小</li><li><code>timeout</code> 类似于 <code>select</code> 中的 timeout。如果没有文件描述符就绪，即就绪队列为空，则 <code>epoll_wait</code> 会阻塞 timeout 毫秒。如果 timeout 设为 -1，则 <code>epoll_wait</code> 会一直阻塞，直到有文件描述符就绪；如果 timeout 设为 0，则 <code>epoll_wait</code> 会立即返回</li></ul><p>返回值表示 <code>events</code> 中存储的就绪描述符个数，最大不超过 <code>maxevents</code>。</p><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll 的优点"></a>epoll 的优点</h3><p>一开始说，epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p><p>对于“性能开销大”，<code>epoll_ctl</code> 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 <code>select</code> 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p><blockquote><p>相当于时间复杂度从 O(n) 降为 O(1)</p></blockquote><p>此外，每次调用 <code>select</code> 时都需要向内核拷贝所有要监听的描述符集合，而 epoll 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递。这也大大提高了效率。</p><h3 id="水平触发、边缘触发"><a href="#水平触发、边缘触发" class="headerlink" title="水平触发、边缘触发"></a>水平触发、边缘触发</h3><p><code>select</code> 只支持水平触发，<code>epoll</code> 支持水平触发和边缘触发。</p><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。</p><p>区别：边缘触发效率更高，<strong>减少了事件被重复触发的次数</strong>，函数不会返回大量用户程序可能不需要的文件描述符。</p><blockquote><p>水平触发、边缘触发的名称来源：数字电路当中的电位水平，高低电平切换瞬间的触发动作叫边缘触发，而处于高电平的触发动作叫做水平触发。</p></blockquote><h3 id="为什么边缘触发必须使用非阻塞-I-O？"><a href="#为什么边缘触发必须使用非阻塞-I-O？" class="headerlink" title="为什么边缘触发必须使用非阻塞 I/O？"></a>为什么边缘触发必须使用非阻塞 I/O？</h3><p>关于这个问题的解答，强烈建议阅读<a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">这篇文章</a>。下面是一些关键摘要：</p><ul><li><p>每次通过 <code>read</code> 系统调用读取数据时，最多只能读取缓冲区大小的字节数；如果某个文件描述符一次性收到的数据超过了缓冲区的大小，那么需要对其 <code>read</code> 多次才能全部读取完毕</p></li><li><p><code>select</code> 可以使用阻塞 I/O</p><p>。通过</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select</span><br></pre></td></tr></table></figure><p>  获取到所有可读的文件描述符后，遍历每个文件描述符，</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read</span><br></pre></td></tr></table></figure><p>  一次</p><p>  数据（见上文</p><p>  select 示例</p><p>  ）</p><ul><li>这些文件描述符都是可读的，因此即使 <code>read</code> 是阻塞 I/O，也一定可以读到数据，不会一直阻塞下去</li><li><code>select</code> 采用水平触发模式，因此如果第一次 <code>read</code> 没有读取完全部数据，那么下次调用 <code>select</code> 时依然会返回这个文件描述符，可以再次 <code>read</code></li><li><strong><code>select</code> 也可以使用非阻塞 I/O</strong>。当遍历某个可读文件描述符时，使用 <code>for</code> 循环调用 <code>read</code> <strong>多次</strong>，直到读取完所有数据为止（返回 <code>EWOULDBLOCK</code>）。这样做会多一次 <code>read</code> 调用，但可以减少调用 <code>select</code> 的次数</li></ul><ul><li>在</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll</span><br></pre></td></tr></table></figure><p>  的边缘触发模式下，只会在文件描述符的可读/可写状态发生切换时，才会收到操作系统的通知</p><ul><li>因此，如果使用 <code>epoll</code> 的<strong>边缘触发模式</strong>，在收到通知时，<strong>必须使用非阻塞 I/O，并且必须循环调用 <code>read</code> 或 <code>write</code> 多次，直到返回 <code>EWOULDBLOCK</code> 为止</strong>，然后再调用 <code>epoll_wait</code> 等待操作系统的下一次通知</li><li>如果没有一次性读/写完所有数据，那么在操作系统看来这个文件描述符的状态没有发生改变，将不会再发起通知，调用 <code>epoll_wait</code> 会使得该文件描述符一直等待下去，服务端也会一直等待客户端的响应，业务流程无法走完</li><li>这样做的好处是每次调用 <code>epoll_wait</code> 都是<strong>有效</strong>的——保证数据全部读写完毕了，等待下次通知。在水平触发模式下，如果调用 <code>epoll_wait</code> 时数据没有读/写完毕，会直接返回，再次通知。因此边缘触发能显著减少事件被触发的次数</li><li>为什么 <code>epoll</code> 的<strong>边缘触发模式不能使用阻塞 I/O</strong>？很显然，边缘触发模式需要循环读/写一个文件描述符的所有数据。如果使用阻塞 I/O，那么一定会在最后一次调用（没有数据可读/写）时阻塞，导致无法正常结束</li></ul><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h2><ul><li><code>select</code>：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li><code>poll</code>：poll 采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li><code>epoll</code>：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ul><p><code>select</code>、<code>poll</code> 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；<code>epoll</code> 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。</p><p>此外 <code>select</code> 只支持水平触发，<code>epoll</code> 支持边缘触发。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多。当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。</p><h2 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h2><p>Redis 是一个单线程的工作模型，使用 I/O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？</p><p>I/O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I/O 请求时，先将它挂起，切换到别的线程；当 I/O 设备就绪时，再切换回该线程。总之，<strong>多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景</strong>。</p><p>而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I/O 操作，因此<strong>多线程频繁的上下文切换反而是一种负优化</strong>。Redis 选择基于非阻塞 I/O 的 <strong>I/O 多路复用机制</strong>，在单线程里<strong>并发</strong>处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。</p><p>不过 redis 在最新的几个版本中也引入了多线程，目的是：</p><ol><li>异步处理删除操作。当删除超大键值对的时候，单线程内同步地删除可能会阻塞待处理的任务</li><li>应对网络 I/O 的场景，网络 I/O 是慢速 I/O。redis6 吞吐量提高了 1 倍</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://linux.die.net/man/7/epoll">Linux man page - epoll</a></li><li><a href="https://linux.die.net/man/2/epoll_create">Linux man page - epoll_create</a></li><li><a href="https://linux.die.net/man/2/epoll_ctl">Linux man page - epoll_ctl</a></li><li><a href="https://linux.die.net/man/2/epoll_wait">Linux man page - epoll_wait</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍操作系统，目前这一块知识是我的盲区，需要掌握这些基础知识，不仅仅是应付面试，为以后全栈学习打好基础。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://hxy1997.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="操作系统" scheme="https://hxy1997.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>javascript面试问题</title>
    <link href="https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://hxy1997.xyz/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-22T16:09:54.000Z</published>
    <updated>2021-03-06T03:47:04.620Z</updated>
    
    <content type="html"><![CDATA[<p>javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  <a href="https://github.com/mqyqingfeng/Blog">冴羽的博客</a> ，内容丰富，适合有一定JS基础的人进行阅读</p><a id="more"></a><h1 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h1><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个构造函数都有一个 prototype 属性 ，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 虽然写在注释里，但是你要注意：</span><br><span class="line">&#x2F;&#x2F; prototype是对象的属性</span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person2.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在Firefox或者Chrome中控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图"></a></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为同一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person &#x3D;&#x3D;&#x3D; Person.prototype.constructor); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图"></a></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图"></a></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 就是 Object.prototype 没有原型，表达了同一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 关键 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>缺点：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向Parent传参</p><h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义每个子类实例不能共享父函数，浪费内存，开销较大。不能继承父类原型。</p><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">Child.prototype.constructor &#x3D; Child;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#39;black&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class="line">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class="line">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;kevin&#39;,</span><br><span class="line">    friends: [&#39;daisy&#39;, &#39;kelly&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; createObj(person);</span><br><span class="line">var person2 &#x3D; createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name &#x3D; &#39;person1&#39;;</span><br><span class="line">console.log(person2.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#39;taylor&#39;);</span><br><span class="line">console.log(person2.friends); &#x2F;&#x2F; [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone &#x3D; Object.create(o);</span><br><span class="line">    clone.sayName &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype &#x3D; new Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键的三步</span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line">F.prototype &#x3D; Parent.prototype;</span><br><span class="line">Child.prototype &#x3D; new F();</span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype(child, parent) &#123;</span><br><span class="line">    var prototype &#x3D; object(parent.prototype);</span><br><span class="line">    prototype.constructor &#x3D; child;</span><br><span class="line">    child.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h1 id="3-作用域链"><a href="#3-作用域链" class="headerlink" title="3.作用域链"></a>3.作用域链</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>函数的作用域在函数定义的时候就决定了,这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] &#x3D; [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] &#x3D; [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope &#x3D; [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h2 id="按照步骤分析"><a href="#按照步骤分析" class="headerlink" title="按照步骤分析"></a>按照步骤分析</h2><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 &#x3D; &#39;local scope&#39;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#39;local scope&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>MDN 对闭包的定义为：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p><p>那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛……</p><p>还真是这样的！</p><p>所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p><p>这只是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：</p><p>ECMAScript中，从实践角度，以下函数才算是闭包：</p><p>1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</p><p>2.在代码中引用了自由变量</p><p>接下来就来讲讲实践上的闭包。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scope &#x3D; &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope &#x3D; &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><p>这里直接给出简要的执行过程：</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p>了解到这个过程，我们应该思考一个问题，那就是：</p><p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……)</p><p>然而 JavaScript 却是可以的！</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext &#x3D; &#123;</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</p><p>所以，让我们再看一遍实践角度上闭包的定义：</p><ol><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol><p>在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义:</p><blockquote><p>This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p></blockquote><p>闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。</p><h2 id="必刷题"><a href="#必刷题" class="headerlink" title="必刷题"></a>必刷题</h2><p>接下来，看这道刷题必刷，面试必考的闭包题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>答案是都是 3，让我们分析一下原因：</p><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><p>data[1] 和 data[2] 是一样的道理。</p><p>所以让我们改成闭包看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  data[i] &#x3D; (function (i) &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0]();</span><br><span class="line">data[1]();</span><br><span class="line">data[2]();</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟没改之前一模一样。</p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数执行上下文的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context &#x3D; &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            0: 0,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。</p><p>data[1] 和 data[2] 是一样的道理。</p><h1 id="5-变量对象"><a href="#5-变量对象" class="headerlink" title="5.变量对象"></a>5.变量对象</h1><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><p>因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>我们先了解一个概念，叫全局对象。在 <a href="http://www.w3school.com.cn/jsref/jsref_obj_global.asp">W3School</a> 中也有介绍：</p><blockquote><p>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。</p></blockquote><blockquote><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p></blockquote><blockquote><p>例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p></blockquote><p>如果看的不是很懂的话，容我再来介绍下全局对象:</p><p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);</span><br></pre></td></tr></table></figure><p>2.全局对象是由 Object 构造函数实例化的一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this instanceof Object);</span><br></pre></td></tr></table></figure><p>3.预定义了一堆，嗯，一大堆函数和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 都能生效</span><br><span class="line">console.log(Math.random());</span><br><span class="line">console.log(this.Math.random());</span><br></pre></td></tr></table></figure><p>4.作为全局变量的宿主。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(this.a);</span><br></pre></td></tr></table></figure><p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">console.log(window.a);</span><br><span class="line"></span><br><span class="line">this.window.b &#x3D; 2;</span><br><span class="line">console.log(this.b);</span><br></pre></td></tr></table></figure><p>花了一个大篇幅介绍全局对象，其实就想说：</p><p>全局上下文中的变量对象就是全局对象呐！</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>最后让我们看几个例子：</p><p>1.第一题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; ???</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; ???</span><br></pre></td></tr></table></figure><p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>。</p><p>第二段会打印：<code>1</code>。</p><p>这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p><p>第一段执行 console 的时候， AO 的值是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p><p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p><p>2.第二题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo);</span><br><span class="line"></span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; 1;</span><br></pre></td></tr></table></figure><p>会打印函数，而不是 undefined 。</p><p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><h1 id="6-从ECMAScript规范解读this"><a href="#6-从ECMAScript规范解读this" class="headerlink" title="6.从ECMAScript规范解读this"></a>6.从ECMAScript规范解读this</h1><p> ECMAScript 5.1 规范地址：</p><p>英文版：<a href="http://es5.github.io/#x15.1">http://es5.github.io/#x15.1</a></p><p>中文版：<a href="http://yanhaijing.com/es5/#115">http://yanhaijing.com/es5/#115</a></p><p>让我们开始了解规范吧！</p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>首先是第 8 章 Types：</p><p>ECMAScript 的类型分为语言类型和规范类型。</p><p>ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。</p><p>而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。</p><p>没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p> Reference 类型。它与 this 的指向有着密切的关联。</p><p>让我们看 8.7 章 The Reference Specification Type：</p><blockquote><p>The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.</p></blockquote><p>所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。</p><p>抄袭尤雨溪大大的话，就是：</p><blockquote><p>这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。</p></blockquote><p>再看接下来的这段具体介绍 Reference 的内容：</p><blockquote><p>A Reference is a resolved name binding.</p></blockquote><blockquote><p>A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.</p></blockquote><blockquote><p>The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1).</p></blockquote><blockquote><p>A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>这段讲述了 Reference 的构成，由三个组成部分，分别是：</p><ul><li>base value</li><li>referenced name</li><li>strict reference</li></ul><p>可是这些到底是什么呢？</p><p>我们简单的理解的话：</p><p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。</p><p>referenced name 就是属性的名称。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 对应的Reference是：</span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bar对应的Reference是：</span><br><span class="line">var BarReference &#x3D; &#123;</span><br><span class="line">    base: foo,</span><br><span class="line">    propertyName: &#39;bar&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。</p><p>这两个方法很简单，简单看一看：</p><p>1.GetBase</p><blockquote><p>GetBase(V). Returns the base value component of the reference V.</p></blockquote><p>返回 reference 的 base value。</p><p>2.IsPropertyReference</p><blockquote><p>IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.</p></blockquote><p>简单的理解：如果 base value 是一个对象，就返回true。</p><h2 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h2><p>除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。</p><p>简单模拟 GetValue 的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetValue(fooReference) &#x2F;&#x2F; 1;</span><br></pre></td></tr></table></figure><p>GetValue 返回对象属性真正的值，但是要注意：</p><p><strong>调用 GetValue，返回的将是具体的值，而不再是一个 Reference</strong></p><p>这个很重要，这个很重要，这个很重要。</p><h2 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h2><p>关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：</p><p>看规范 11.2.3 Function Calls：</p><p>这里讲了当函数调用的时候，如何确定 this 的取值。</p><p>只看第一步、第六步、第七步：</p><blockquote><p>1.Let <em>ref</em> be the result of evaluating MemberExpression.</p></blockquote><blockquote><p>6.If Type(<em>ref</em>) is Reference, then</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.If IsPropertyReference(ref) is true, then</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be GetBase(ref).</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.Else, the base of ref is an Environment Record</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref).</span><br></pre></td></tr></table></figure><p>7.Else, Type(<em>ref</em>) is not Reference.</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a. Let thisValue be undefined.</span><br></pre></td></tr></table></figure></blockquote><p>让我们描述一下：</p><p>1.计算 MemberExpression 的结果赋值给 ref</p><p>2.判断 ref 是不是一个 Reference 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</span><br><span class="line"></span><br><span class="line">2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</span><br><span class="line"></span><br><span class="line">2.3 如果 ref 不是 Reference，那么 this 的值为 undefined</span><br></pre></td></tr></table></figure><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>让我们一步一步看：</p><ol><li>计算 MemberExpression 的结果赋值给 ref</li></ol><p>什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions：</p><p>MemberExpression :</p><ul><li>PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》</li><li>FunctionExpression // 函数定义表达式</li><li>MemberExpression [ Expression ] // 属性访问表达式</li><li>MemberExpression . IdentifierName // 属性访问表达式</li><li>new MemberExpression Arguments // 对象创建表达式</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; MemberExpression 是 foo</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); &#x2F;&#x2F; MemberExpression 是 foo()</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    bar: function () &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); &#x2F;&#x2F; MemberExpression 是 foo.bar</span><br></pre></td></tr></table></figure><p>所以简单理解 MemberExpression 其实就是()左边的部分。</p><p>2.判断 ref 是不是一个 Reference 类型。</p><p>关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。</p><p>举最后一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar());</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)());</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><h3 id="foo-bar"><a href="#foo-bar" class="headerlink" title="foo.bar()"></a>foo.bar()</h3><p>在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？</p><p>查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：</p><blockquote><p>Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.</p></blockquote><p>我们得知该表达式返回了一个 Reference 类型！</p><p>根据之前的内容，我们知道该值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Reference &#x3D; &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  name: &#39;bar&#39;,</span><br><span class="line">  strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来按照 2.1 的判断流程走：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？</p><p>前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。</p><p>base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。</p><p>这个时候我们就可以确定 this 的值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this &#x3D; GetBase(ref)，</span><br></pre></td></tr></table></figure><p>GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！</p><p>唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。</p><h3 id="foo-bar-1"><a href="#foo-bar-1" class="headerlink" title="(foo.bar)()"></a>(foo.bar)()</h3><p>看示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((foo.bar)());</span><br></pre></td></tr></table></figure><p>foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator</p><p>直接看结果部分：</p><blockquote><p>Return the result of evaluating Expression. This may be of type Reference.</p></blockquote><blockquote><p>NOTE This algorithm does not apply GetValue to the result of evaluating Expression.</p></blockquote><p>实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。</p><h3 id="foo-bar-foo-bar"><a href="#foo-bar-foo-bar" class="headerlink" title="(foo.bar = foo.bar)()"></a>(foo.bar = foo.bar)()</h3><p>看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ):</p><p>计算的第三步：</p><blockquote><p>3.Let rval be GetValue(rref).</p></blockquote><p>因为使用了 GetValue，所以返回的值不是 Reference 类型，</p><p>按照之前讲的判断逻辑：</p><blockquote><p>2.3 如果 ref 不是Reference，那么 this 的值为 undefined</p></blockquote><p>this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。</p><h3 id="false-foo-bar"><a href="#false-foo-bar" class="headerlink" title="(false || foo.bar)()"></a>(false || foo.bar)()</h3><p>看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators：</p><p>计算第二步：</p><blockquote><p>2.Let lval be GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="foo-bar-foo-bar-1"><a href="#foo-bar-foo-bar-1" class="headerlink" title="(foo.bar, foo.bar)()"></a>(foo.bar, foo.bar)()</h3><p>看示例5，逗号操作符，查看规范11.14 Comma Operator ( , )</p><p>计算第二步：</p><blockquote><p>2.Call GetValue(lref).</p></blockquote><p>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</p><h3 id="揭晓结果"><a href="#揭晓结果" class="headerlink" title="揭晓结果"></a>揭晓结果</h3><p>所以最后一个例子的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">console.log(foo.bar()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">console.log((foo.bar)()); &#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F;示例3</span><br><span class="line">console.log((foo.bar &#x3D; foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例4</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;示例5</span><br><span class="line">console.log((foo.bar, foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。</p><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>最最后，忘记了一个最最普通的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure><p>MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooReference &#x3D; &#123;</span><br><span class="line">    base: EnvironmentRecord,</span><br><span class="line">    name: &#39;foo&#39;,</span><br><span class="line">    strict: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来进行判断：</p><blockquote><p>2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)</p></blockquote><p>因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。</p><p>IsPropertyReference(ref) 的结果为 false，进入下个判断：</p><blockquote><p>2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)</p></blockquote><p>base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)</p><p>查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。</p><p>所以最后 this 的值就是 undefined。</p><h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">  value: 2,</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log((false || foo.bar)()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。</p><p>此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。</p><h1 id="7-立即执行函数"><a href="#7-立即执行函数" class="headerlink" title="7.立即执行函数"></a>7.立即执行函数</h1><p>可能你并没有注意到，我是一个对于专业术语有一点坚持细节人。所有，当我听到流行的但是还存在误解的术语“自执行匿名函数”多次时，我最终决定将我的想法写进这篇文章里。</p><p>除了提供关于这种模式事实上是如何工作的一些全面的信息，更进一步的，实际上我建议我们应该知道我们应该叫它什么。而且，如果你想跳过这里，你可以直接跳到<strong>立即调用函数表达式</strong>进行阅读，但是我建议你读完整篇文章。</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>在 JavaScript 里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数是唯一在内部被访问的变量，而不是在外部被访问的变量，当调用函数时，函数提供的上下文提供了一个非常简单的方法创建私有变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter() &#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(++i);</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记住：&#96;counter&#96;和&#96;counter2&#96;都有他们自己的变量 &#96;i&#96;</span><br><span class="line"></span><br><span class="line">var counter &#x3D; makeCounter();</span><br><span class="line">counter();&#x2F;&#x2F;1</span><br><span class="line">counter();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">var counter2 &#x3D; makeCounter();</span><br><span class="line">counter2();&#x2F;&#x2F;1</span><br><span class="line">counter2();&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">i;&#x2F;&#x2F;ReferenceError: i is not defined(它只存在于makeCounter里)</span><br></pre></td></tr></table></figure><p>在许多情况下，你可能并不需要<code>makeWhatever</code>这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。</p><h3 id="它的核心"><a href="#它的核心" class="headerlink" title="它的核心"></a>它的核心</h3><p>现在，无论你定义一个函数像这样<code>function foo()&#123;&#125;</code>或者<code>var foo = function()&#123;&#125;</code>，调用时，你都需要在后面加上一对圆括号，像这样<code>foo()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样&#96;foo()&#96;，</span><br><span class="line">&#x2F;&#x2F;因为foo相对于函数表达式&#96;function()&#123;&#x2F;* code *&#x2F;&#125;&#96;只是一个引用变量</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？</span><br><span class="line"></span><br><span class="line">function()&#123; &#x2F;* code *&#x2F;&#125;(); &#x2F;&#x2F;SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure><p>正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的<code>function</code>关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。</p><p><strong>问题1：</strong>这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数 <code>var foo = function()&#123;console.log(1)&#125;()</code>，答案是可以的。<br><strong>问题2：</strong>同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。</p><h3 id="函数，圆括号，错误"><a href="#函数，圆括号，错误" class="headerlink" title="函数，圆括号，错误"></a>函数，圆括号，错误</h3><p>有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span><br><span class="line"></span><br><span class="line">function foo()&#123; &#x2F;* code *&#x2F; &#125;();&#x2F;&#x2F;SyntaxError: Unexpected token</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span><br><span class="line"></span><br><span class="line">function foo()&#123;&#x2F;* code *&#x2F;&#125;</span><br><span class="line">(1);</span><br></pre></td></tr></table></figure><h2 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h2><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能<strong>包含</strong>声明。因为这点，当圆括号为了包裹函数碰上了 <code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。<strong>注意理解</strong>这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p><ul><li>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</li><li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量</span><br><span class="line"></span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;());&#x2F;&#x2F;Crockford recommends this one，括号内的表达式代表函数立即调用表达式</span><br><span class="line">(function()&#123;&#x2F;* code *&#x2F;&#125;)();&#x2F;&#x2F;But this one works just as well，括号内的表达式代表函数表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Because the point of the parens or coercing operators is to disambiguate</span><br><span class="line">&#x2F;&#x2F; between function expressions and function declarations, they can be</span><br><span class="line">&#x2F;&#x2F; omitted when the parser already expects an expression (but please see the</span><br><span class="line">&#x2F;&#x2F; &quot;important note&quot; below).</span><br><span class="line"></span><br><span class="line">var i &#x3D; function()&#123;return 10;&#125;();</span><br><span class="line">true &amp;&amp; function()&#123;&#x2F;*code*&#x2F;&#125;();</span><br><span class="line">0,function()&#123;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节</span><br><span class="line"></span><br><span class="line">!function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">~function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">-function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line">+function()&#123;&#x2F;* code *&#x2F;&#125;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Here&#39;s another variation, from @kuvos - I&#39;m not sure of the performance</span><br><span class="line">&#x2F;&#x2F; implications, if any, of using the &#96;new&#96; keyword, but it works.</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;twitter.com&#x2F;kuvos&#x2F;status&#x2F;18209252090847232</span><br><span class="line"></span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;</span><br><span class="line">new function()&#123; &#x2F;* code *&#x2F; &#125;() &#x2F;&#x2F; Only need parens if passing arguments</span><br></pre></td></tr></table></figure><h3 id="关于括号的重要笔记"><a href="#关于括号的重要笔记" class="headerlink" title="关于括号的重要笔记"></a>关于括号的重要笔记</h3><p>在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意。</p><p>这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。</p><p>作为规则，当你书写清楚明晰的代码时，有必要阻止 JavaScript 抛出错误的，同样也有必要阻止其他开发者对你抛出错误 <code>WTFError</code>!</p><h3 id="保存闭包的状态"><a href="#保存闭包的状态" class="headerlink" title="保存闭包的状态"></a>保存闭包的状态</h3><p>就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 它的运行原理可能并不像你想的那样，因为&#96;i&#96;的值从来没有被锁定。</span><br><span class="line">&#x2F;&#x2F; 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，</span><br><span class="line">&#x2F;&#x2F; 因为这是 &#96;i&#96; 此时的真实值。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(&#39;I am link #&#39; + i)</span><br><span class="line">        &#125;,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 而像下面这样改写，便可以了，因为在IIFE里，&#96;i&#96;值被锁定在了&#96;lockedInIndex&#96;里。</span><br><span class="line">&#x2F;&#x2F; 在循环结束执行时，尽管&#96;i&#96;值的数值是所有元素的总和，但每一次函数表达式被调用时，</span><br><span class="line">&#x2F;&#x2F; IIFE 里的 &#96;lockedInIndex&#96; 值都是&#96;i&#96;传给它的值,所以当链接被点击时，正确的值被弹出。</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName(&#39;a&#39;);</span><br><span class="line">for(var i &#x3D; 0;i &lt; elems.length;i++) &#123;</span><br><span class="line">    (function(lockedInIndex)&#123;</span><br><span class="line">        elems[i].addEventListener(&#39;click&#39;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(&#39;I am link #&#39; + lockedInIndex);</span><br><span class="line">            &#125;,false)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个&#96;addEventListener&#96;。</span><br><span class="line">&#x2F;&#x2F;无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读</span><br><span class="line"></span><br><span class="line">var elems &#x3D; document.getElementsByTagName( &#39;a&#39; );</span><br><span class="line"></span><br><span class="line">for ( var i &#x3D; 0; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[ i ].addEventListener( &#39;click&#39;, (function( lockedInIndex )&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( &#39;I am link #&#39; + lockedInIndex );</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;)( i ),false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>记住，在这最后两个例子里，<code>lockedInIndex</code>可以没有任何问题的访问<code>i</code>,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。</p><p>立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。</p><h4 id="自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？"><a href="#自执行匿名函数-“Self-executing-anonymous-function”-有什么问题呢？" class="headerlink" title="自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？"></a>自执行匿名函数(“Self-executing anonymous function”)有什么问题呢？</h4><p>你看到它已经被提到好几次了，但是它仍然不是那么清楚的被解释，我提议将术语改成**”Immediately-Invoked Function Expression”<strong>，或者，</strong>IIFE**，如果你喜欢缩写的话。</p><p>什么是<strong>Immediately-Invoked Function Expression</strong>呢？它使一个被立即调用的函数表达式。就像引导你去调用的函数表达式。</p><p>我想Javascript社区的成员应该可以在他们的文章里或者陈述里接受术语，<strong>Immediately-Invoked Function Expression</strong>和 <strong>IIFE</strong>，因为我感觉这样更容易让这个概念被理解，并且术语”self-executing anonymous function”真的也不够精确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下面是个自执行函数，递归的调用自己本身</span><br><span class="line"></span><br><span class="line">function foo()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是一个自执行匿名函数。因为它没有标识符，它必须是使用&#96;arguments.callee&#96;属性来调用它自己</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;arguments.callee();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这也许算是一个自执行匿名函数，但是仅仅当&#96;foo&#96;标识符作为它的引用时，如果你将它换成用&#96;foo&#96;来调用同样可行</span><br><span class="line"></span><br><span class="line">var foo &#x3D; function()&#123;foo();&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有些人像这样叫&#39;self-executing anonymous function&#39;下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。</span><br><span class="line"></span><br><span class="line">(function()&#123; &#x2F;*code*&#x2F; &#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。</span><br><span class="line"></span><br><span class="line">(function foo()&#123;&#x2F;* code *&#x2F;&#125;());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IIFEs同样也可以自执行，尽管，也许他不是最有用的模式</span><br><span class="line"></span><br><span class="line">(function()&#123;arguments.callee();&#125;())</span><br><span class="line">(function foo()&#123;foo();&#125;())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; One last thing to note: this will cause an error in BlackBerry 5, because</span><br><span class="line">&#x2F;&#x2F; inside a named function expression, that name is undefined. Awesome, huh?</span><br><span class="line"></span><br><span class="line">(function foo()&#123; foo(); &#125;());</span><br></pre></td></tr></table></figure><p>希望上面的例子可以让你更加清楚的知道术语’self-executing’是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，<strong>Immediately Invoked Function Expression</strong>，既可以是命名函数也可以匿名函数。</p><h2 id="最后：模块模式"><a href="#最后：模块模式" class="headerlink" title="最后：模块模式"></a>最后：模块模式</h2><p>当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不属性 JavaScript 里的模块模式，它和我下面的例子很像，但是返回值用对象代替了函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; (function()&#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            i &#x3D; val;</span><br><span class="line">        &#125;,</span><br><span class="line">        increment: function()&#123;</span><br><span class="line">            return ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;());</span><br><span class="line">    counter.get();&#x2F;&#x2F;0</span><br><span class="line">    counter.set(3);</span><br><span class="line">    counter.increment();&#x2F;&#x2F;4</span><br><span class="line">    counter.increment();&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    conuter.i;&#x2F;&#x2F;undefined (&#96;i&#96; is not a property of the returned object)</span><br><span class="line">    i;&#x2F;&#x2F;ReferenceError: i is not defined (it only exists inside the closure)</span><br></pre></td></tr></table></figure><p>模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了使用变量。</p><h1 id="8-instanceof-和-typeof-的实现原理"><a href="#8-instanceof-和-typeof-的实现原理" class="headerlink" title="8.instanceof 和 typeof 的实现原理"></a>8.instanceof 和 typeof 的实现原理</h1><h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>,  <code>string</code>,  <code>object</code>,  <code>boolean</code>,  <code>function</code>, <code>undefined</code>,  <code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">typeof s &#x3D;&#x3D;&#x3D; &#39;object&#39;&#x2F;&#x2F; true</span><br><span class="line">s instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><p><code>null</code>：所有机器码均为0</p><p><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null instanceof null &#x2F;&#x2F; TypeError: Right-hand side of &#39;instanceof&#39; is not an object</span><br></pre></td></tr></table></figure><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>。</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(1) &#x2F;&#x2F; &quot;[object Number]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#39;hi&#39;) &#x2F;&#x2F; &quot;[object String]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;a:&#39;hi&#39;&#125;) &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call([1,&#39;a&#39;]) &#x2F;&#x2F; &quot;[object Array]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(true) &#x2F;&#x2F; &quot;[object Boolean]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(() &#x3D;&gt; &#123;&#125;) &#x2F;&#x2F; &quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(null) &#x2F;&#x2F; &quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(undefined) &#x2F;&#x2F; &quot;[object Undefined]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(Symbol(1)) &#x2F;&#x2F; &quot;[object Symbol]&quot;</span><br></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let nicole &#x3D; new person()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; function () &#123;&#125;</span><br><span class="line">let programmer &#x3D; function () &#123;&#125;</span><br><span class="line">programmer.prototype &#x3D; new person()</span><br><span class="line">let nicole &#x3D; new programmer()</span><br><span class="line">nicole instanceof person &#x2F;&#x2F; true</span><br><span class="line">nicole instanceof programmer &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function new_instance_of(leftVaule, rightVaule) &#123; </span><br><span class="line">    let rightProto &#x3D; rightVaule.prototype; &#x2F;&#x2F; 取右表达式的 prototype 值</span><br><span class="line">    leftVaule &#x3D; leftVaule.__proto__; &#x2F;&#x2F; 取左表达式的__proto__值</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    if (leftVaule &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftVaule &#x3D;&#x3D;&#x3D; rightProto) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule &#x3D; leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p><p>看几个很有趣的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Function &#x2F;&#x2F; true</span><br><span class="line">Function instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Foo &#x2F;&#x2F; false</span><br><span class="line">Foo instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Foo instanceof Function &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p><p>关于原型继承的原理，我简单用一张图来表示</p><p><img data-src="https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p><ul><li><p><code>Object instanceof Object</code></p><p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Object.__proto__ &#x3D; Function.prototype;</span><br><span class="line">rightValue &#x3D; Object.prototype;</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p></li><li><p><code>Foo instanceof Foo</code></p><p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p><p>我们用代码简单的表示一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Foo</span><br><span class="line">leftValue &#x3D; Foo.__proto &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Foo.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Object.prototype &#x3D; null</span><br><span class="line">&#x2F;&#x2F; 第三次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; null</span><br><span class="line">&#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Object</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Object</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue !&#x3D; rightValue</span><br><span class="line">leftValue &#x3D; Function.prototype.__proto__ &#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; 第二次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Function</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftValue &#x3D; Foo, rightValue &#x3D; Function</span><br><span class="line">leftValue &#x3D; Foo.__proto__ &#x3D; Function.prototype</span><br><span class="line">rightValue &#x3D; Function.prototype</span><br><span class="line">&#x2F;&#x2F; 第一次判断</span><br><span class="line">leftValue &#x3D;&#x3D;&#x3D; rightValue</span><br><span class="line">&#x2F;&#x2F; 返回 true </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p><h1 id="9-bind实现"><a href="#9-bind实现" class="headerlink" title="9.bind实现"></a>9.bind实现</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 bind:</p><blockquote><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p></blockquote><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回了一个函数</span><br><span class="line">var bindFoo &#x3D; bar.bind(foo); </span><br><span class="line"></span><br><span class="line">bindFoo(); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，来写第一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，之所以 <code>return self.apply(context)</code>，是考虑到绑定函数可能是有返回值的，依然是这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">return this.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo);</span><br><span class="line">console.log(bindFoo()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line">bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 获取bind2函数从第二个参数到最后一个参数</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个时候的arguments是指bind返回的函数传入的参数</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    this.habit &#x3D; &#39;shopping&#39;;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend &#x3D; &#39;kevin&#39;;</span><br><span class="line"></span><br><span class="line">var bindFoo &#x3D; bar.bind(foo, &#39;daisy&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new bindFoo(&#39;18&#39;);</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; daisy</span><br><span class="line">&#x2F;&#x2F; 18</span><br><span class="line">console.log(obj.habit);</span><br><span class="line">console.log(obj.friend);</span><br><span class="line">&#x2F;&#x2F; shopping</span><br><span class="line">&#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        &#x2F;&#x2F; 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span><br><span class="line">        &#x2F;&#x2F; 以上面的是 demo 为例，如果改成 &#96;this instanceof fBound ? null : context&#96;，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span><br><span class="line">        &#x2F;&#x2F; 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span><br><span class="line">        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span><br><span class="line">    fBound.prototype &#x3D; this.prototype;</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第四版</span><br><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p><h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p><p><strong>1.apply 这段代码跟 MDN 上的稍有不同</strong></p><p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> self ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, args.concat(bindArgs))</span><br></pre></td></tr></table></figure><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 2;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    bar: bar.bind(null)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p><p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p><p><strong>2.调用 bind 的不是函数咋办？</strong></p><p>不行，我们要报错！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.我要在线上用</strong></p><p>那别忘了做个兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; Function.prototype.bind || function () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然最好是用 <a href="https://github.com/es-shims/es5-shim">es5-shim</a> 啦。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 &#x3D; function (context) &#123;</span><br><span class="line"></span><br><span class="line">    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line"></span><br><span class="line">    var fNOP &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var fBound &#x3D; function () &#123;</span><br><span class="line">        var bindArgs &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype &#x3D; this.prototype;</span><br><span class="line">    fBound.prototype &#x3D; new fNOP();</span><br><span class="line">    return fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试够用版"><a href="#面试够用版" class="headerlink" title="面试够用版"></a>面试够用版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function (context, ...args) &#123;</span><br><span class="line">&#x2F;&#x2F; 环境</span><br><span class="line">    context &#x3D; context || window;</span><br><span class="line">    &#x2F;&#x2F; 创建一个Symbol变量，让当前环境指向当前位置</span><br><span class="line">    const fnSymbol &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">    &#x2F;&#x2F; 配置环境</span><br><span class="line">    context[fnSymbol] &#x3D; this;</span><br><span class="line">&#x2F;&#x2F; 返回闭包函数</span><br><span class="line">    return function (..._args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 与当前参数组合</span><br><span class="line">        args &#x3D; args.concat(_args);</span><br><span class="line">&#x2F;&#x2F; 执行函数</span><br><span class="line">        context[fnSymbol](...args);</span><br><span class="line">        &#x2F;&#x2F; 避免闭包的内存泄露</span><br><span class="line">        delete context[fnSymbol];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-call和apply"><a href="#10-call和apply" class="headerlink" title="10.call和apply"></a>10.call和apply</h1><h2 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h2><p>它们的共同点是，都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p><p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p><p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p><h2 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h2><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p><h4 id="call-的写法"><a href="#call-的写法" class="headerlink" title="call 的写法"></a>call 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.call(obj,[param1[,param2[,…[,paramN]]]])</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>调用 call 的对象，必须是个函数 Function。</li><li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li><li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func (a,b,c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, 1,2,3)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.call(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure><h4 id="apply-的写法"><a href="#apply-的写法" class="headerlink" title="apply 的写法"></a>apply 的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [1,2,3])</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">func.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure><h4 id="什么是类数组？"><a href="#什么是类数组？" class="headerlink" title="什么是类数组？"></a>什么是类数组？</h4><p>先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。</p><p>那么，类数组是什么呢？顾名思义，就是<strong>具备与数组特征类似的对象</strong>。比如，下面的这个对象，就是一个类数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。</p><p>类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。</p><p>但是需要注意的是：<strong>类数组无法使用 forEach、splice、push 等数组原型链上的方法</strong>，毕竟它不是真正的数组。</p><h2 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h2><p>下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。</p><h4 id="call-的使用场景"><a href="#call-的使用场景" class="headerlink" title="call 的使用场景"></a>call 的使用场景</h4><p><strong>1、对象的继承</strong>。如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function superClass () &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">    this.print &#x3D; function () &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subClass () &#123;</span><br><span class="line">    superClass.call(this);</span><br><span class="line">    this.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass();</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p><p><strong>2、借用方法</strong>。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</span><br></pre></td></tr></table></figure><p>这样，domNodes 就可以应用 Array 下的所有方法了。</p><h4 id="apply-的一些妙用"><a href="#apply-的一些妙用" class="headerlink" title="apply 的一些妙用"></a>apply 的一些妙用</h4><p><strong>1、Math.max</strong>。用它来获取数组中最大的一项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let max &#x3D; Math.max.apply(null, array);</span><br></pre></td></tr></table></figure><p>同理，要获取数组中最小的一项，可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let min &#x3D; Math.min.apply(null, array);</span><br></pre></td></tr></table></figure><p><strong>2、实现两个数组合并</strong>。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 &#x3D; [1, 2, 3];</span><br><span class="line">let arr2 &#x3D; [4, 5, 6];</span><br><span class="line"></span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line">console.log(arr1); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h2 id="手写apply和bind"><a href="#手写apply和bind" class="headerlink" title="手写apply和bind"></a>手写apply和bind</h2><p>call的手写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">  context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply的手写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; apply</span><br><span class="line">Function.prototype.myApply &#x3D; function (context &#x3D; window, argsArr) &#123;</span><br><span class="line">  const fn &#x3D; Symbol(&quot;fn&quot;);</span><br><span class="line">  context[fn] &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 重点代码，利用this指向，相当于context.caller(...args)</span><br><span class="line">  context[fn](...argsArr);</span><br><span class="line">  delete context[fn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-函数柯里化"><a href="#11-函数柯里化" class="headerlink" title="11.函数柯里化"></a>11.函数柯里化</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对柯里化 (Currying) 的定义为：</p><blockquote><p>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.</p></blockquote><p>翻译成中文：</p><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行 add 函数，一次传入两个参数即可</span><br><span class="line">add(1, 2) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设有一个 curry 函数可以做到柯里化</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1)(2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>我们会讲到如何写出这个 curry 函数，并且会将这个 curry 函数写的很强大，但是在编写之前，我们需要知道柯里化到底有什么用？</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示意而已</span><br><span class="line">function ajax(type, url, data) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(type, url, true);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 虽然 ajax 这个函数非常通用，但在重复调用的时候参数冗余</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test2.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line">ajax(&#39;POST&#39;, &#39;www.test3.com&#39;, &quot;name&#x3D;kevin&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用 curry</span><br><span class="line">var ajaxCurry &#x3D; curry(ajax);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求数据</span><br><span class="line">var post &#x3D; ajaxCurry(&#39;POST&#39;);</span><br><span class="line">post(&#39;www.test.com&#39;, &quot;name&#x3D;kevin&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以 POST 类型请求来自于 www.test.com 的数据</span><br><span class="line">var postFromTest &#x3D; post(&#39;www.test.com&#39;);</span><br><span class="line">postFromTest(&quot;name&#x3D;kevin&quot;);</span><br></pre></td></tr></table></figure><p>想想 jQuery 虽然有 $.ajax 这样通用的方法，但是也有 $.get 和 $.post 的语法糖。</p><p>curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</p><p>可是即便如此，是不是依然感觉没什么用呢？</p><p>如果我们仅仅是把参数一个一个传进去，意义可能不大，但是如果我们是把柯里化后的函数传给其他函数比如 map 呢？</p><p>举个例子：</p><p>比如我们有这样一段数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; [&#123;name: &#39;kevin&#39;&#125;, &#123;name: &#39;daisy&#39;&#125;]</span><br></pre></td></tr></table></figure><p>如果我们要获取所有的 name 值，我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; person.map(function (item) &#123;</span><br><span class="line">    return item.name;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过如果我们有 curry 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var prop &#x3D; curry(function (key, obj) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var name &#x3D; person.map(prop(&#39;name&#39;))</span><br></pre></td></tr></table></figure><p>我们为了获取 name 属性还要再编写一个 prop 函数，是不是又麻烦了些？</p><p>但是要注意，prop 函数编写一次后，以后可以多次使用，实际上代码从原本的三行精简成了一行，而且你看代码是不是更加易懂了？</p><p><code>person.map(prop(&#39;name&#39;))</code> 就好像直白的告诉你：person 对象遍历(map)获取(prop) name 属性。</p><p>是不是感觉有点意思了呢？</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>未来我们会接触到更多有关柯里化的应用，不过那是未来的事情了，现在我们该编写这个 curry 函数了。</p><p>一个经常会看到的 curry 函数的实现为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        return fn.apply(this, newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var addCurry &#x3D; curry(add, 1, 2);</span><br><span class="line">addCurry() &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add, 1);</span><br><span class="line">addCurry(2) &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">var addCurry &#x3D; curry(add);</span><br><span class="line">addCurry(1, 2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。</p><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版</span><br><span class="line">function sub_curry(fn) &#123;</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return fn.apply(this, args.concat([].slice.call(arguments)));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length) &#123;</span><br><span class="line"></span><br><span class="line">    length &#x3D; length || fn.length;</span><br><span class="line"></span><br><span class="line">    var slice &#x3D; Array.prototype.slice;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        if (arguments.length &lt; length) &#123;</span><br><span class="line">            var combined &#x3D; [fn].concat(slice.call(arguments));</span><br><span class="line">            return curry(sub_curry.apply(this, combined), length - arguments.length);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们验证下这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    return [a, b, c];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>效果已经达到我们的预期，然而这个 curry 函数的实现好难理解呐……</p><p>为了让大家更好的理解这个 curry 函数，我给大家写个极简版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sub_curry(fn)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry(fn, length)&#123;</span><br><span class="line">    length &#x3D; length || 4;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if (length &gt; 1) &#123;</span><br><span class="line">            return curry(sub_curry(fn), --length)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn0 &#x3D; function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0)</span><br><span class="line"></span><br><span class="line">fn1()()()() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><p>大家先从理解这个 curry 函数开始。</p><p>当执行 fn1() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(fn0))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return (function()&#123;</span><br><span class="line">        return fn0()</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()() 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跟 fn1()() 的分析过程一样</span><br><span class="line">curry(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1()()()() 时，因为此时 length &gt; 2 为 false，所以执行 fn()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">(function()&#123;</span><br><span class="line">    return fn0()</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0()</span><br><span class="line">&#x2F;&#x2F; 执行 fn0 函数，打印 1</span><br></pre></td></tr></table></figure><p>再回到真正的 curry 函数，我们以下面的例子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var fn0 &#x3D; function(a, b, c, d) &#123;</span><br><span class="line">    return [a, b, c, d];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 &#x3D; curry(fn0);</span><br><span class="line"></span><br><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;)(&quot;d&quot;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”) 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(fn0)(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(sub_curry(fn0, &quot;a&quot;, &quot;b&quot;))</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">&#x2F;&#x2F; 注意 ... 只是一个示意，表示该函数执行时传入的参数会作为 fn0 后面的参数传入</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”) 时，函数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curry(sub_curry(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, ...)</span><br><span class="line">&#125;), &quot;c&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">    return (function(...) &#123;return fn0(&quot;a&quot;, &quot;b&quot;, ...)&#125;)(&quot;c&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">curry(function(...)&#123;</span><br><span class="line">     return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行 fn1(“a”, “b”)(“c”)(“d”) 时，此时 arguments.length &lt; length 为 false ，执行 fn(arguments)，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(...)&#123;</span><br><span class="line">    return fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, ...)</span><br><span class="line">&#125;)(&quot;d&quot;)</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">fn0(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br></pre></td></tr></table></figure><p>函数执行结束。</p><p>所以，其实整段代码又很好理解：</p><p>sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(…)(…) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。</p><p>如果要明白 curry 函数的运行原理，大家还是要动手写一遍，尝试着分析执行步骤。</p><h2 id="更易懂的实现"><a href="#更易懂的实现" class="headerlink" title="更易懂的实现"></a>更易懂的实现</h2><p>当然了，如果你觉得还是无法理解，你可以选择下面这种实现方式，可以实现同样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">    var length &#x3D; fn.length;</span><br><span class="line"></span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line"></span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line"></span><br><span class="line">            arg, i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line"></span><br><span class="line">            _args.push(arg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>或许大家觉得这种方式更好理解，又能实现一样的效果，为什么不直接就讲这种呢？</p><p>因为想给大家介绍各种实现的方法嘛，不能因为难以理解就不给大家介绍呐~</p><h2 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h2><p>curry 函数写到这里其实已经很完善了，但是注意这个函数的传参顺序必须是从左到右，根据形参的顺序依次传入，如果我不想根据这个顺序传呢？</p><p>我们可以创建一个占位符，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn &#x3D; curry(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, _, &quot;c&quot;)(&quot;b&quot;) &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure><p>我们直接看第三版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function curry(fn, args, holes) &#123;</span><br><span class="line">    length &#x3D; fn.length;</span><br><span class="line">    args &#x3D; args || [];</span><br><span class="line">    holes &#x3D; holes || [];</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args &#x3D; args.slice(0),</span><br><span class="line">            _holes &#x3D; holes.slice(0),</span><br><span class="line">            argsLen &#x3D; args.length,</span><br><span class="line">            holesLen &#x3D; holes.length,</span><br><span class="line">            arg, i, index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            arg &#x3D; arguments[i];</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1, _, _, 4)(_, 3) 这种情况，index 需要指向 holes 正确的下标</span><br><span class="line">            if (arg &#x3D;&#x3D;&#x3D; _ &amp;&amp; holesLen) &#123;</span><br><span class="line">                index++</span><br><span class="line">                if (index &gt; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                    _holes.push(argsLen - 1 + index - holesLen)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(1)(_) 这种情况</span><br><span class="line">            else if (arg &#x3D;&#x3D;&#x3D; _) &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">                _holes.push(argsLen + i);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 处理类似 fn(_, 2)(1) 这种情况</span><br><span class="line">            else if (holesLen) &#123;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(_, 3)</span><br><span class="line">                if (index &gt;&#x3D; holesLen) &#123;</span><br><span class="line">                    _args.push(arg);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; fn(_, 2)(1) 用参数 1 替换占位符</span><br><span class="line">                else &#123;</span><br><span class="line">                    _args.splice(_holes[index], 1, arg);</span><br><span class="line">                    _holes.splice(index, 1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                _args.push(arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (_holes.length || _args.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, _args, _holes);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return fn.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; curry(function(a, b, c, d, e) &#123;</span><br><span class="line">    console.log([a, b, c, d, e]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证 输出全部都是 [1, 2, 3, 4, 5]</span><br><span class="line">fn(1, 2, 3, 4, 5);</span><br><span class="line">fn(_, 2, 3, 4, 5)(1);</span><br><span class="line">fn(1, _, 3, 4, 5)(2);</span><br><span class="line">fn(1, _, 3)(_, 4)(2)(5);</span><br><span class="line">fn(1, _, _, 4)(_, 3)(2)(5);</span><br><span class="line">fn(_, 2)(_, _, 4)(1)(3)(5)</span><br></pre></td></tr></table></figure><h2 id="面试够用版-1"><a href="#面试够用版-1" class="headerlink" title="面试够用版"></a>面试够用版</h2><p>就是第二版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版</span><br><span class="line">var curry &#x3D; function (fn) &#123;</span><br><span class="line">&#x2F;&#x2F; 保存当前参数，参数是类数组</span><br><span class="line">    var args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">    &#x2F;&#x2F; 返回闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 拼接新的参数</span><br><span class="line">        var newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">        &#x2F;&#x2F; 调用函数</span><br><span class="line">        if (newArgs.length &lt; fn.length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="12-V8引擎的垃圾回收"><a href="#12-V8引擎的垃圾回收" class="headerlink" title="12.V8引擎的垃圾回收"></a>12.V8引擎的垃圾回收</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>作为目前最流行的JavaScript引擎，V8引擎从出现的那一刻起便广泛受到人们的关注，我们知道，JavaScript可以高效地运行在浏览器和Nodejs这两大宿主环境中，也是因为背后有强大的V8引擎在为其保驾护航，甚至成就了Chrome在浏览器中的霸主地位。不得不说，V8引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多，从原始的<code>Full-codegen</code>和<code>Crankshaft</code>编译器升级为<code>Ignition</code>解释器和<code>TurboFan</code>编译器的强强组合，到隐藏类，内联缓存和<code>HotSpot</code>热点代码收集等一系列强有力的优化策略，V8引擎正在努力降低整体的内存占用和提升到更高的运行性能。</p><p>本篇主要是从V8引擎的垃圾回收机制入手，讲解一下在JavaScript代码执行的整个生命周期中V8引擎是采取怎样的垃圾回收策略来减少内存占比的，当然这部分的知识并不太影响我们写代码的流程，毕竟在一般情况下我们很少会遇到浏览器端出现内存溢出而导致程序崩溃的情况，但是至少我们对这方面有一定的了解之后，能增强我们在写代码过程中对减少内存占用，避免内存泄漏的主观意识，也许能够帮助你写出更加健壮和对V8引擎更加友好的代码。本文也是笔者在查阅资料巩固复习的过程中慢慢总结和整理出来的，若文中有错误的地方，还请指正。</p><h3 id="1、为何需要垃圾回收"><a href="#1、为何需要垃圾回收" class="headerlink" title="1、为何需要垃圾回收"></a>1、为何需要垃圾回收</h3><p>我们知道，在V8引擎逐行执行JavaScript代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。</p><blockquote><p>这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。</p></blockquote><p>但是JavaScript作为一门高级编程语言，并不像C语言或C++语言中需要手动地申请分配和释放内存，V8引擎已经帮我们自动进行了内存的分配和管理，好让我们有更多的精力去专注于业务层面的复杂逻辑，这对于我们前端开发人员来说是一项福利，但是随之带来的问题也是显而易见的，那就是由于不用去手动管理内存，导致写代码的过程中不够严谨从而容易引发内存泄漏(毕竟这是别人对你的好，你没有付出过，又怎能体会得到？)。</p><h3 id="2、V8引擎的内存限制"><a href="#2、V8引擎的内存限制" class="headerlink" title="2、V8引擎的内存限制"></a>2、V8引擎的内存限制</h3><p>虽然V8引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但V8引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8引擎在<code>64</code>位系统下最多只能使用约<code>1.4GB</code>的内存，在<code>32</code>位系统下最多只能使用约<code>0.7GB</code>的内存，在这样的限制下，必然会导致在node中无法直接操作大内存对象，比如将一个<code>2GB</code>大小的文件全部读入内存进行字符串分析处理，即使物理内存高达<code>32GB</code>也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？这个要回到V8引擎的设计之初，起初只是作为浏览器端JavaScript的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：</p><ul><li><code>JS单线程机制</code>：作为浏览器的脚本语言，JS的主要用途是与用户交互以及操作DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。试想如果JS是多线程的，一个线程在删除DOM元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。既然JS是单线程的，那么也就意味着在V8执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行JS逻辑。因此，由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。</li></ul><blockquote><p>虽然JS是单线程的，但是为了能够充分利用操作系统的多核CPU计算能力，在HTML5中引入了新的Web Worker标准，其作用就是为JS创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker在后台运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被Worker线程负担，主线程(通常负责UI交互)就会很流畅，不会被阻塞或者拖慢。Web Worker不是JS的一部分，而是通过JS访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的API，例如操作DOM，因此这个新标准并没有改变JS单线程的本质。</p></blockquote><ul><li><code>垃圾回收机制</code>：垃圾回收本身也是一件非常耗时的操作，假设V8的堆内存为<code>1.5G</code>，那么V8做一次小的垃圾回收需要50ms以上，而做一次非增量式回收甚至需要1s以上，可见其耗时之久，而在这1s的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。</li></ul><p>基于以上两点，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景。但是在node端，涉及到的<code>I/O</code>操作可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，V8为我们提供了可配置项来让我们手动地调整内存大小，但是需要在node初始化的时候进行配置，我们可以通过如下方式来手动设置。</p><p>我们尝试在node命令行中输入以下命令：</p><blockquote><p>笔者本地安装的node版本为<code>v10.14.2</code>，可通过<code>node -v</code>查看本地node的版本号，不同版本可能会导致下面的命令会有所差异。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该命令可以用来查看node中可用的V8引擎的选项及其含义</span><br><span class="line">node --v8-options</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后我们会在命令行窗口中看到大量关于V8的选项，这里我们暂且只关注图中红色选框中的几个选项：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edeb6f141feaac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最小值，单位MB</span><br><span class="line">node --min-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置新生代内存中单个半空间的内存最大值，单位MB</span><br><span class="line">node --max-semi-space-size&#x3D;1024 xxx.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置老生代内存最大值，单位MB</span><br><span class="line">node --max-old-space-size&#x3D;2048 xxx.js</span><br></pre></td></tr></table></figure><p>通过以上方法便可以手动放宽V8引擎所使用的内存限制，同时node也为我们提供了<code>process.memoryUsage()</code>方法来让我们可以查看当前node进程所占用的实际内存大小。</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/7/16edf18bb16af64d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在上图中，包含的几个字段的含义分别如下所示，单位均为字节：</p><ul><li><code>heapTotal</code>：表示V8当前申请到的堆内存总大小。</li><li><code>heapUsed</code>：表示当前内存使用量。</li><li><code>external</code>：表示V8内部的C++对象所占用的内存。</li><li><code>rss(resident set size)</code>：表示驻留集大小，是给这个node进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的JavaScript源代码存于代码段内存。使用Worker线程时，<code>rss</code>将会是一个对整个进程有效的值，而其他字段则只针对当前线程。</li></ul><blockquote><p>在JS中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过V8的限制为止。</p></blockquote><h3 id="3、V8的垃圾回收策略"><a href="#3、V8的垃圾回收策略" class="headerlink" title="3、V8的垃圾回收策略"></a>3、V8的垃圾回收策略</h3><p>V8的垃圾回收策略主要是基于<code>分代式垃圾回收机制</code>，其根据<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h4 id="3-1-V8的内存结构"><a href="#3-1-V8的内存结构" class="headerlink" title="3.1 V8的内存结构"></a>3.1 V8的内存结构</h4><p>在V8引擎的堆结构组成中，其实除了<code>新生代</code>和<code>老生代</code>外，还包含其他几个部分，但是垃圾回收的过程主要出现在新生代和老生代，所以对于其他的部分我们没必要做太多的深入，有兴趣的小伙伴儿可以查阅下相关资料，V8的内存结构主要由以下几个部分组成：</p><ul><li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。</li><li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为<code>老生代指针区</code>和<code>老生代数据区</code>，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。</li><li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。</li><li><code>代码区(code_space)</code>：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。</li><li><code>map区(map_space)</code>：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。</li></ul><p>内存结构图如下所示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee12280b78399d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>上图中的带斜纹的区域代表暂未使用的内存，新生代(new_space)被划分为了两个部分，其中一部分叫做inactive new space，表示暂未激活的内存区域，另一部分为激活状态，为什么会划分为两个部分呢，在下一小节我们会讲到。</p><h4 id="3-2-新生代"><a href="#3-2-新生代" class="headerlink" title="3.2 新生代"></a>3.2 新生代</h4><p>在V8引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个<code>semispace(半空间)</code>构成的，内存最大值在<code>64</code>位系统和<code>32</code>位系统上分别为<code>32MB</code>和<code>16MB</code>，在新生代的垃圾回收过程中主要采用了<code>Scavenge</code>算法。</p><p><code>Scavenge</code>算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。</p><blockquote><p>在<code>Scavenge</code>算法的具体实现中，主要采用了<code>Cheney</code>算法，它将新生代内存一分为二，每一个部分的空间称为<code>semispace</code>，也就是我们在上图中看见的new_space中划分的两个区域，其中处于激活状态的区域我们称为<code>From</code>空间，未激活(inactive new space)的区域我们称为<code>To</code>空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到<code>From</code>空间，当进行垃圾回收时，如果<code>From</code>空间中尚有存活对象，则会被复制到<code>To</code>空间进行保存，非存活的对象会被自动回收。当复制完成后，<code>From</code>空间和<code>To</code>空间完成一次角色互换，<code>To</code>空间会变为新的<code>From</code>空间，原来的<code>From</code>空间则变为<code>To</code>空间。</p></blockquote><p>基于以上算法，我们可以画出如下的流程图：</p><ul><li>假设我们在<code>From</code>空间中分配了三个对象A、B、C</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee172cf1a23c9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象A已经没有其他引用，则表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17a2fda2c461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，因此会被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee17decd1d9ed2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>接下来将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1819dd9f5999?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>此时<code>From</code>空间中的内存已经清空，开始和<code>To</code>空间完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18439a76a3eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>当程序主线程在执行第二个任务时，在<code>From</code>空间中分配了一个新对象D</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee1874b4c441d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>任务执行完毕后再次进入垃圾回收，发现对象D已经没有其他引用，表示可以对其进行回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18969e114bc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>对象B和对象C此时依旧处于活跃状态，再次被复制到<code>To</code>空间中进行保存</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18cd2bff353c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>再次将<code>From</code>空间中的所有非存活对象全部清除</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee18f4a21c517e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><code>From</code>空间和<code>To</code>空间继续完成一次角色互换</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee191560b716c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>通过以上的流程图，我们可以很清楚地看到，<code>Scavenge</code>算法的垃圾回收过程主要就是将存活对象在<code>From</code>空间和<code>To</code>空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。</p><h4 id="3-3-对象晋升"><a href="#3-3-对象晋升" class="headerlink" title="3.3 对象晋升"></a>3.3 对象晋升</h4><p>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为<code>晋升</code>。<br> 对象晋升的条件主要有以下两个：</p><ul><li>对象是否经历过一次<code>Scavenge</code>算法</li><li><code>To</code>空间的内存占比是否已经超过<code>25%</code></li></ul><p>默认情况下，我们创建的对象都会分配在<code>From</code>空间中，当进行垃圾回收时，在将对象从<code>From</code>空间复制到<code>To</code>空间之前，会先检查该对象的内存地址来判断是否已经经历过一次<code>Scavenge</code>算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到<code>To</code>空间，可以用以下的流程图来表示：</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c5634e61f9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如果对象没有经历过<code>Scavenge</code>算法，会被复制到<code>To</code>空间，但是如果此时<code>To</code>空间的内存占比已经超过<code>25%</code>，则该对象依旧会被转移到老生代，如下图所示:</p><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee3c90fedad146?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>之所以有<code>25%</code>的内存限制是因为<code>To</code>空间在经历过一次<code>Scavenge</code>算法后会和<code>From</code>空间完成角色互换，会变为<code>From</code>空间，后续的内存分配都是在<code>From</code>空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。</p><h4 id="3-4-老生代"><a href="#3-4-老生代" class="headerlink" title="3.4 老生代"></a>3.4 老生代</h4><p>在老生代中，因为管理着大量的存活对象，如果依旧使用<code>Scavenge</code>算法的话，很明显会浪费一半的内存，因此已经不再使用<code>Scavenge</code>算法，而是采用新的算法<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>来进行管理。</p><p>在早前我们可能听说过一种算法叫做<code>引用计数</code>，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建了两个对象obj1和obj2，其中obj2作为obj1的属性被obj1引用，因此不会被垃圾回收</span><br><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">    obj2: &#123;</span><br><span class="line">        a: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj3并将obj1赋值给obj3，让两个对象指向同一个内存地址</span><br><span class="line">let obj3 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj1重新赋值，此时原来obj1指向的对象现在只由obj3来表示</span><br><span class="line">obj1 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建obj4并将obj3.obj2赋值给obj4</span><br><span class="line">&#x2F;&#x2F; 此时obj2所指向的对象有两个引用：一个是作为obj3的属性，另一个是变量obj4</span><br><span class="line">let obj4 &#x3D; obj3.obj2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将obj3重新赋值，此时本可以对obj3指向的对象进行回收，但是因为obj3.obj2被obj4所引用，因此依旧不能被回收</span><br><span class="line">obj3 &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此时obj3.obj2已经没有指向它的引用，因此obj3指向的对象在此时可以被回收</span><br><span class="line">obj4 &#x3D; null;</span><br></pre></td></tr></table></figure><p>上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到<code>循环引用</code>的场景，就会出现问题，我们看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let a &#x3D; &#123;&#125;;</span><br><span class="line">    let b &#x3D; &#123;&#125;;</span><br><span class="line">    a.a1 &#x3D; b;</span><br><span class="line">    b.b1 &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这个例子中我们将对象<code>a</code>的<code>a1</code>属性指向对象<code>b</code>，将对象<code>b</code>的<code>b1</code>属性指向对象<code>a</code>，形成两个对象相互引用，在<code>foo</code>函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量<code>a</code>和<code>b</code>本应该可以被回收，但是因为采用了<code>引用计数</code>的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。</p><p>因此为了避免循环引用导致的内存泄漏问题，截至2012年所有的现代浏览器均放弃了这种算法，转而采用新的<code>Mark-Sweep(标记清除)</code>和<code>Mark-Compact(标记整理)</code>算法。在上面循环引用的例子中，因为变量<code>a</code>和变量<code>b</code>无法从<code>window</code>全局对象访问到，因此无法对其进行标记，所以最终会被回收。</p><p><code>Mark-Sweep(标记清除)</code>分为<code>标记</code>和<code>清除</code>两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。<code>Mark-Sweep</code>算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：</p><ul><li>垃圾回收器会在内部构建一个<code>根列表</code>，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，<code>window</code>全局对象可以看成一个根节点。</li><li>然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。</li><li>最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。</li></ul><blockquote><p>以下几种情况都可以作为根节点：</p><ol><li>全局对象</li><li>本地函数的局部变量和参数</li><li>当前嵌套调用链上的其他函数的变量和参数</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee468e85a1084d?imageslim" alt="img"></p><p>但是<code>Mark-Sweep</code>算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。</p><p>为了解决这种内存碎片的问题，<code>Mark-Compact(标记整理)</code>算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示：</p><ul><li>假设在老生代中有A、B、C、D四个对象</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee47d9f933bfc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>标记</code>阶段，将对象A和对象C标记为活动的</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee486ece5fda42?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>整理</code>阶段，将活动的对象往堆内存的一端移动</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee48f23fe98d7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li>在垃圾回收的<code>清除</code>阶段，将活动对象左侧的内存全部回收</li></ul><p><img data-src="https://user-gold-cdn.xitu.io/2019/12/8/16ee490a8b9bf0af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>至此就完成了一次老生代垃圾回收的全部过程，我们在前文中说过，由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为<code>全停顿(stop-the-world)</code>。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿。</p><p>因此，为了减少垃圾回收带来的停顿时间，V8引擎又引入了<code>Incremental Marking(增量标记)</code>的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像<code>React</code>框架中的<code>Fiber</code>架构，只有在浏览器的空闲时间才会去遍历<code>Fiber Tree</code>执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>得益于增量标记的好处，V8引擎后续继续引入了<code>延迟清理(lazy sweeping)</code>和<code>增量式整理(incremental compaction)</code>，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入<code>并行标记</code>和<code>并行清理</code>，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p><h3 id="4、如何避免内存泄漏"><a href="#4、如何避免内存泄漏" class="headerlink" title="4、如何避免内存泄漏"></a>4、如何避免内存泄漏</h3><p>在我们写代码的过程中，基本上都不太会关注写出怎样的代码才能有效地避免内存泄漏，或者说浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏问题，但是我们还是有必要了解一下常见的几种避免内存泄漏的方式，毕竟在面试过程中也是经常考察的要点。</p><h4 id="4-1-尽可能少地创建全局变量"><a href="#4-1-尽可能少地创建全局变量" class="headerlink" title="4.1 尽可能少地创建全局变量"></a>4.1 尽可能少地创建全局变量</h4><p>在ES5中以<code>var</code>声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到<code>window</code>全局对象上，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1; &#x2F;&#x2F; 等价于 window.a &#x3D; 1;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    window.a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>foo</code>函数中创建了一个变量<code>a</code>但是忘记使用<code>var</code>来声明，此时会意想不到地创建一个全局变量并挂载到window对象上，另外还有一种比较隐蔽的方式来创建全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">foo(); &#x2F;&#x2F; 相当于 window.foo()</span><br></pre></td></tr></table></figure><p>当<code>foo</code>函数在调用时，它所指向的运行上下文环境为<code>window</code>全局对象，因此函数中的<code>this</code>指向的其实是<code>window</code>，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为<code>window</code>对象可以作为根节点，在<code>window</code>上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为<code>null</code>从而触发回收机制。</p><h4 id="4-2-手动清除定时器"><a href="#4-2-手动清除定时器" class="headerlink" title="4.2 手动清除定时器"></a>4.2 手动清除定时器</h4><p>在我们的应用中经常会有使用<code>setTimeout</code>或者<code>setInterval</code>等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [];</span><br><span class="line">const foo &#x3D; function() &#123;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; 100000;i++) &#123;</span><br><span class="line">        numbers.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">window.setInterval(foo, 1000);</span><br></pre></td></tr></table></figure><p>在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的<code>numbers</code>变量也不会被垃圾回收，最终导致<code>numbers</code>数组长度无限递增，从而引发内存泄漏。</p><h4 id="4-3-少用闭包"><a href="#4-3-少用闭包" class="headerlink" title="4.3 少用闭包"></a>4.3 少用闭包</h4><p>闭包是JS中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    let local &#x3D; 123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return local;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const bar &#x3D; foo();</span><br><span class="line">console.log(bar()); &#x2F;&#x2F; -&gt; 123</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>foo</code>函数执行完毕后会返回一个匿名函数，该函数内部引用了<code>foo</code>函数中的局部变量<code>local</code>，并且通过变量<code>bar</code>来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在<code>foo</code>函数的外部作用域中访问到它的局部变量<code>local</code>。一般情况下，当<code>foo</code>函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致<code>local</code>变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。</p><h4 id="4-4-清除DOM引用"><a href="#4-4-清除DOM引用" class="headerlink" title="4.4 清除DOM引用"></a>4.4 清除DOM引用</h4><p>以往我们在操作DOM元素时，为了避免多次获取DOM元素，我们会将DOM元素存储在一个数据字典中，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;button&#39;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们想调用<code>removeButton</code>方法来清除<code>button</code>元素，但是由于在<code>elements</code>字典中存在对<code>button</code>元素的引用，所以即使我们通过<code>removeChild</code>方法移除了<code>button</code>元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对<code>button</code>元素的引用才会被垃圾回收。</p><h4 id="4-5-弱引用"><a href="#4-5-弱引用" class="headerlink" title="4.5 弱引用"></a>4.5 弱引用</h4><p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在ES6中为我们新增了两个有效的数据结构<code>WeakMap</code>和<code>WeakSet</code>，就是为了解决内存泄漏的问题而诞生的。其表示<code>弱引用</code>，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心<code>WeakMap</code>中键名对其他对象的引用，也不需要手动地进行引用清除，我们尝试在node中演示一下过程(参考阮一峰ES6标准入门中的示例，自己手动实现了一遍)。</p><p>首先打开node命令行，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --expose-gc &#x2F;&#x2F; --expose-gc 表示允许手动执行垃圾回收机制</span><br></pre></td></tr></table></figure><p>然后我们执行下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收保证内存数据准确</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看当前占用的内存，主要关心heapUsed字段，大小约为4.4MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 21626880,</span><br><span class="line">  heapTotal: 7585792,</span><br><span class="line">  heapUsed: 4708440,</span><br><span class="line">  external: 8710 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个WeakMap</span><br><span class="line">&gt; let wm &#x3D; new WeakMap();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个数组并赋值给变量key</span><br><span class="line">&gt; let key &#x3D; new Array(1000000);</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将WeakMap的键名指向该数组</span><br><span class="line">&#x2F;&#x2F; 此时该数组存在两个引用，一个是key，一个是WeakMap的键名</span><br><span class="line">&#x2F;&#x2F; 注意WeakMap是弱引用</span><br><span class="line">&gt; wm.set(key, 1);</span><br><span class="line">WeakMap &#123; [items unknown] &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行一次垃圾回收</span><br><span class="line">&gt; global.gc();</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次查看内存占用大小，heapUsed已经增加到约12MB</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 30232576,</span><br><span class="line">  heapTotal: 17694720,</span><br><span class="line">  heapUsed: 13068464,</span><br><span class="line">  external: 8688 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动清除变量key对数组的引用</span><br><span class="line">&#x2F;&#x2F; 注意这里并没有清除WeakMap中键名对数组的引用</span><br><span class="line">&gt; key &#x3D; null;</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再次执行垃圾回收</span><br><span class="line">&gt; global.gc()</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看内存占用大小，发现heapUsed已经回到了之前的大小(这里约为4.8M，原来为4.4M，稍微有些浮动)</span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; rss: 22110208,</span><br><span class="line">  heapTotal: 9158656,</span><br><span class="line">  heapUsed: 5089752,</span><br><span class="line">  external: 8698 &#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们发现虽然我们没有手动清除<code>WeakMap</code>中的键名对数组的引用，但是内存依旧已经回到原始的大小，说明该数组已经被回收，那么这个也就是弱引用的具体含义了。</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>本文中主要讲解了一下V8引擎的垃圾回收机制，并分别从新生代和老生代讲述了不同分代中的垃圾回收策略以及对应的回收算法，之后列出了几种常见的避免内存泄漏的方式来帮助我们写出更加优雅的代码。如果你已经了解过垃圾回收相关的内容，那么这篇文章可以帮助你简单复习加深印象，如果没有了解过，那么笔者也希望这篇文章能够帮助到你了解一些代码层面之外的底层知识点，由于V8引擎的源码是用C++实现的，所以笔者也就没有做这方面的深入了，有兴趣的小伙伴儿可以自行探究，文中有错误的地方，还希望能够在评论区指正。</p><h1 id="13-浮点数精度"><a href="#13-浮点数精度" class="headerlink" title="13.浮点数精度"></a>13.浮点数精度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。</p><p>在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。</p><h2 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h2><p>我们来看下 1020 用十进制的表示：</p><blockquote><p>1020 = <strong>1</strong> * 10^3 + <strong>0</strong> * 10^2 + <strong>2</strong> * 10^1 + <strong>0</strong> * 10^0</p></blockquote><p>所以 1020 用十进制表示就是 1020……(哈哈)</p><p>如果 1020 用二进制来表示呢？</p><blockquote><p>1020 = <strong>1</strong> * 2^9 + <strong>1</strong> * 2^8 + <strong>1</strong> * 2^7 + <strong>1</strong> * 2^6 + <strong>1</strong> * 2^5 + <strong>1</strong> * 2^4 + <strong>1</strong> * 2^3 + <strong>1</strong> * 2^2 + <strong>0</strong> * 2^1 + <strong>0</strong> * 2^0</p></blockquote><p>所以 1020 的二进制为 <code>1111111100</code></p><p>那如果是 0.75 用二进制表示呢？同理应该是：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p></blockquote><p>因为使用的是二进制，这里的 abcd……的值的要么是 0 要么是 1。</p><p>那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：</p><blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4…</p></blockquote><p>两边同时乘以 2</p><blockquote><p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3… (所以 a = 1)</p></blockquote><p>剩下的：</p><blockquote><p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3…</p></blockquote><p>再同时乘以 2</p><blockquote><p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3… (所以 b = 1)</p></blockquote><p>所以 0.75 用二进制表示就是 0.ab，也就是 0.11</p><p>然而不是所有的数都像 0.75 这么好算，我们来算下 0.1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.1 &#x3D; a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...</span><br><span class="line"></span><br><span class="line">0 + 0.2 &#x3D; a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a &#x3D; 0)</span><br><span class="line">0 + 0.4 &#x3D; b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d &#x3D; 1)</span><br><span class="line">1 + 0.2 &#x3D; e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e &#x3D; 1)</span><br><span class="line">0 + 0.4 &#x3D; f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f &#x3D; 0)</span><br><span class="line">0 + 0.8 &#x3D; g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g &#x3D; 0)</span><br><span class="line">1 + 0.6 &#x3D; h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h &#x3D; 1)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……</p><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><p>虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式。</p><p>这个标准认为，一个浮点数 (Value) 可以这样表示：</p><blockquote><p>Value = sign * exponent * fraction</p></blockquote><p>看起来很抽象的样子，简单理解就是科学计数法……</p><p>比如 -1020，用科学计数法表示就是:</p><blockquote><p>-1 * 10^3 * 1.02</p></blockquote><p>sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02</p><p>对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：</p><p>可以表示为：</p><blockquote><p>1 * 2^-4 * 1.1001100110011……</p></blockquote><p>其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……</p><p>而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：</p><blockquote><p>V = (-1)^S * (1 + Fraction) * 2^E</p></blockquote><p>(如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了)</p><p>我们来一点点看：</p><p><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。</p><p>再看 <code>(1 + Fraction)</code>，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。</p><p>最后再看 <code>2^E</code></p><p>如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？</p><p>我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。</p><p>所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。</p><p>所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：</p><p><a href="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067"><img data-src="https://camo.githubusercontent.com/8a1cc45ff11a176af57f5cec9998addda44ebc193b2d19e7d103a37b6036686d/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067" alt="IEEE754"></a></p><p>在这个标准下：</p><p>我们会用 1 位存储 S，0 表示正数，1 表示负数。</p><p>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。</p><p>用 52 位存储 Fraction。</p><p>举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……</p><p>对应 64 个字节位的完整表示就是：</p><blockquote><p>0 01111111011 1001100110011001100110011001100110011001100110011010</p></blockquote><p>同理, 0.2 表示的完整表示是：</p><blockquote><p>0 01111111100 1001100110011001100110011001100110011001100110011010</p></blockquote><p>所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。</p><h2 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h2><p>关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。</p><p>首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 <code>1.1001100110011…… * 2^-4</code>，阶码是 -4，而 0.2 就是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 <code>0.11001100110011…… * 2^-3</code></p><p>接下来是尾数计算:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0.1100110011001100110011001100110011001100110011001101</span><br><span class="line">+ 1.1001100110011001100110011001100110011001100110011010</span><br><span class="line">————————————————————————————————————————————————————————</span><br><span class="line"> 10.0110011001100110011001100110011001100110011001100111</span><br></pre></td></tr></table></figure><p>我们得到结果为 <code>10.0110011001100110011001100110011001100110011001100111 * 2^-3</code></p><p>将这个结果处理一下，即结果规格化，变成 <code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code></p><p>括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。</p><p>再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0011001100110011001100110011001100110011001100110100 * 2^-2</span><br></pre></td></tr></table></figure><p>本来还有一个溢出判断，因为这里不涉及，就不讲了。</p><p>所以最终的结果存成 64 位就是</p><blockquote><p>0 01111111101 0011001100110011001100110011001100110011001100110100</p></blockquote><p>将它转换为10进制数就得到 <code>0.30000000000000004440892098500626</code></p><p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 十进制转二进制</span><br><span class="line">parseFloat(0.1).toString(2);</span><br><span class="line">&#x3D;&gt; &quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二进制转十进制</span><br><span class="line">parseInt(1100100,2)</span><br><span class="line">&#x3D;&gt; 100</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以指定的精度返回该数值对象的字符串表示</span><br><span class="line">(0.1 + 0.2).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.300000000000000044409&quot;</span><br><span class="line">(0.3).toPrecision(21)</span><br><span class="line">&#x3D;&gt; &quot;0.299999999999999988898&quot;</span><br></pre></td></tr></table></figure><h1 id="14-new"><a href="#14-new" class="headerlink" title="14.new"></a>14.new</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>一句话介绍 new:</p><blockquote><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p></blockquote><p>也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Otaku 御宅族，简称宅</span><br><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为缺乏锻炼的缘故，身体强度让人担忧</span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><p>从这个例子中，我们可以看到，实例 person 可以：</p><ol><li>访问到 Otaku 构造函数里的属性</li><li>访问到 Otaku.prototype 中的属性</li></ol><p>接下来，我们可以尝试着模拟一下了。</p><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Otaku () &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 new</span><br><span class="line">var person &#x3D; new Otaku(……);</span><br><span class="line">&#x2F;&#x2F; 使用 objectFactory</span><br><span class="line">var person &#x3D; objectFactory(Otaku, ……)</span><br></pre></td></tr></table></figure><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>分析：</p><p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。</p><p>在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 <strong>proto</strong> 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。</p><p>现在，我们可以尝试着写第一版了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一版代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">&#x2F;&#x2F; 新建对象</span><br><span class="line">    var obj &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 移除参数首个</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    &#x2F;&#x2F; 实例的 __proto__ 属性会指向构造函数的 prototype</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    &#x2F;&#x2F; 调用对象</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这一版中，我们：</p><ol><li>用new Object() 的方式新建了一个对象 obj</li><li>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数</li><li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li><li>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</li><li>返回 obj</li></ol><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">https://github.com/mqyqingfeng/Blog/issues/16</a>)</p><p>复制以下的代码，到浏览器中，我们可以做一下测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    this.habit &#x3D; &#39;Games&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength &#x3D; 60;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;I am &#39; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; objectFactory(Otaku, &#39;Kevin&#39;, &#39;18&#39;)</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line"></span><br><span class="line">person.sayYourName(); &#x2F;&#x2F; I am Kevin</span><br></pre></td></tr></table></figure><h2 id="返回值效果实现"><a href="#返回值效果实现" class="headerlink" title="返回值效果实现"></a>返回值效果实现</h2><p>接下来我们再来看一种情况，假如构造函数有返回值，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        habit: &#39;Games&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; Games</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p><p>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？</p><p>再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Otaku (name, age) &#123;</span><br><span class="line">    this.strength &#x3D; 60;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    return &#39;handsome boy&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Otaku(&#39;Kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(person.name) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.habit) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(person.strength) &#x2F;&#x2F; 60</span><br><span class="line">console.log(person.age) &#x2F;&#x2F; 18</span><br></pre></td></tr></table></figure><p>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p><p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p><p>再来看第二版的代码，也是最后一版的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二版的代码</span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">    var obj &#x3D; new Object(),</span><br><span class="line">    Constructor &#x3D; [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ &#x3D; Constructor.prototype;</span><br><span class="line">    var ret &#x3D; Constructor.apply(obj, arguments);</span><br><span class="line">    return typeof ret &#x3D;&#x3D;&#x3D; &#39;object&#39; ? ret : obj;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="15-Event-Loop（事件循环）机制"><a href="#15-Event-Loop（事件循环）机制" class="headerlink" title="15.Event Loop（事件循环）机制"></a>15.Event Loop（事件循环）机制</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p><p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p><p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><p>话说回来，前面提到javascript的另一个特点是“非阻塞”，那么javascript引擎到底是如何实现的这一点呢？答案就是今天这篇文章的主角——event loop（事件循环）。</p><p><em>注：虽然nodejs中的也存在与传统浏览器环境下的相似的事件循环。然而两者间却有着诸多不同，故把两者分开，单独解释。</em></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="浏览器环境下js引擎的事件循环机制"><a href="#浏览器环境下js引擎的事件循环机制" class="headerlink" title="浏览器环境下js引擎的事件循环机制"></a><strong>浏览器环境下js引擎的事件循环机制</strong></h2><h2 id="1-执行栈与事件队列"><a href="#1-执行栈与事件队列" class="headerlink" title="1.执行栈与事件队列"></a><strong>1.执行栈与事件队列</strong></h2><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p><p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p><p>下面这个图片非常直观的展示了这个过程，其中的global就是初次运行脚本时向执行栈中加入的代码：</p><p><img data-src="https://pic2.zhimg.com/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.jpg" alt="img"></p><p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——事件队列（Task Queue）。</p><p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p><p>这里还有一张图来展示这个过程：</p><p><img data-src="https://pic4.zhimg.com/80/v2-da078fa3eadf3db4bf455904ae06f84b_720w.jpg" alt="img"></p><p>图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即事件队列。</p><h2 id="2-macro-task与micro-task"><a href="#2-macro-task与micro-task" class="headerlink" title="2.macro task与micro task"></a><strong>2.macro task与micro task</strong></h2><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li><code>setInterval()</code></li><li><code>setTimeout()</code></li></ul><p>以下事件属于微任务</p><ul><li><code>new Promise()</code></li><li><code>new MutaionObserver()</code></li></ul><p>前面我们介绍过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><p>我们只需记住<strong>当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p><p>这样就能解释下面这段代码的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).then(function(val)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 </span><br></pre></td></tr></table></figure><h2 id="node环境下的事件循环机制"><a href="#node环境下的事件循环机制" class="headerlink" title="node环境下的事件循环机制"></a><strong>node环境下的事件循环机制</strong></h2><h2 id="1-与浏览器环境有何不同"><a href="#1-与浏览器环境有何不同" class="headerlink" title="1.与浏览器环境有何不同?"></a><strong>1.与浏览器环境有何不同?</strong></h2><p>在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。</p><h2 id="2-事件循环模型"><a href="#2-事件循环模型" class="headerlink" title="2.事件循环模型"></a><strong>2.事件循环模型</strong></h2><p>下面是一个libuv引擎中的事件循环的模型:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><em>注：模型中的每一个方块代表事件循环的一个阶段</em></p><p>这个模型是node官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自与看看原文。</p><h2 id="3-事件循环各阶段详解"><a href="#3-事件循环各阶段详解" class="headerlink" title="3.事件循环各阶段详解"></a><strong>3.事件循环各阶段详解</strong></h2><p>从上面这个模型中，我们可以大致分析出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段…</p><p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p><p>这些阶段大致的功能如下：</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和<code>setImmediate()</code>的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li><li>close callbacks: 例如<code>socket.on(&#39;close&#39;, ...)</code>这种close事件的回调。</li></ul><p>下面我们来按照代码第一次进入libuv引擎后的顺序来详细解说这些阶段：</p><h2 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a><strong>poll阶段</strong></h2><p>当个v8引擎将js代码解析后传入libuv引擎后，循环首先进入poll阶段。poll阶段的执行逻辑如下： 先查看poll queue中是否有事件，有任务就按先进先出的顺序依次执行回调。 当queue为空时，会检查是否有setImmediate()的callback，如果有就进入check阶段执行这些callback。但同时也会检查是否有到期的timer，如果有，就把这些到期的timer的callback按照调用顺序放到timer queue中，之后循环会进入timer阶段执行queue中的 callback。 这两者的顺序是不固定的，收到代码运行的环境的影响。如果两者的queue都是空的，那么loop会在poll阶段停留，直到有一个i/o事件返回，循环会进入i/o callback阶段并立即执行这个事件的callback。</p><p>值得注意的是，poll阶段在执行poll queue中的回调时实际上不会无限的执行下去。有两种情况poll阶段会终止执行poll queue中的下一个回调：1.所有回调执行完毕。2.执行数超过了node的限制。</p><h2 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a><strong>check阶段</strong></h2><p>check阶段专门用来执行<code>setImmediate()</code>方法的回调，当poll阶段进入空闲状态，并且setImmediate queue中有callback时，事件循环进入这个阶段。</p><h2 id="close阶段"><a href="#close阶段" class="headerlink" title="close阶段"></a><strong>close阶段</strong></h2><p>当一个socket连接或者一个handle被突然关闭时（例如调用了<code>socket.destroy()</code>方法），close事件会被发送到这个阶段执行回调。否则事件会用<code>process.nextTick（）</code>方法发送出去。</p><h2 id="timer阶段"><a href="#timer阶段" class="headerlink" title="timer阶段"></a><strong>timer阶段</strong></h2><p>这个阶段以先进先出的方式执行所有到期的timer加入timer队列里的callback，一个timer callback指得是一个通过setTimeout或者setInterval函数设置的回调函数。</p><h2 id="I-O-callback阶段"><a href="#I-O-callback阶段" class="headerlink" title="I/O callback阶段"></a><strong>I/O callback阶段</strong></h2><p>如上文所言，这个阶段主要执行大部分I/O事件的回调，包括一些为操作系统执行的回调。例如一个TCP连接生错误时，系统需要执行回调来获得这个错误的报告。</p><h2 id="4-process-nextTick-setTimeout与setImmediate的区别与使用场景"><a href="#4-process-nextTick-setTimeout与setImmediate的区别与使用场景" class="headerlink" title="4.process.nextTick,setTimeout与setImmediate的区别与使用场景"></a><strong>4.process.nextTick,setTimeout与setImmediate的区别与使用场景</strong></h2><p>在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate</p><p>这三者间存在着一些非常不同的区别：</p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><strong>process.nextTick()</strong></h2><p>尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用<code>process.nextTick()</code>方法会导致node进入一个死循环。。直到内存泄漏。</p><p>那么合适使用这个方法比较合适呢？下面有一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(() =&gt; &#123;&#125;).listen(8080);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;listening&#x27;, () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这个例子中当，当listen方法被调用时，除非端口被占用，否则会立刻绑定在对应的端口上。这意味着此时这个端口可以立刻触发listening事件并执行其回调。然而，这时候<code>on(&#39;listening)</code>还没有将callback设置好，自然没有callback可以执行。为了避免出现这种情况，node会在listen事件中使用<code>process.nextTick()</code>方法，确保事件在回调函数绑定后被触发。</p><h2 id="setTimeout-和setImmediate"><a href="#setTimeout-和setImmediate" class="headerlink" title="setTimeout()和setImmediate()"></a><strong>setTimeout()和setImmediate()</strong></h2><p>在三个方法中，这两个方法最容易被弄混。实际上，某些情况下这两个方法的表现也非常相似。然而实际上，这两个方法的意义却大为不同。</p><p><code>setTimeout()</code>方法是定义一个回调，并且希望这个回调在我们所指定的时间间隔后第一时间去执行。注意这个“第一时间执行”，这意味着，受到操作系统和当前执行任务的诸多影响，该回调并不会在我们预期的时间间隔后精准的执行。执行的时间存在一定的延迟和误差，这是不可避免的。node会在可以执行timer回调的第一时间去执行你所设定的任务。</p><p><code>setImmediate()</code>方法从意义上将是立刻执行的意思，但是实际上它却是在一个固定的阶段才会执行回调，即poll阶段之后。有趣的是，这个名字的意义和之前提到过的<code>process.nextTick()</code>方法才是最匹配的。node的开发者们也清楚这两个方法的命名上存在一定的混淆，他们表示不会把这两个方法的名字调换过来—因为有大量的node程序使用着这两个方法，调换命名所带来的好处与它的影响相比不值一提。</p><p><code>setTimeout()</code>和不设置时间间隔的<code>setImmediate()</code>表现上及其相似。猜猜下面这段代码的结果是什么？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timeout&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;immediate&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实际上，答案是不一定。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;timeout&#x27;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;immediate&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>答案永远是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。</p><p><strong>尾声</strong></p><p>javascrit的事件循环是这门语言中非常重要且基础的概念。清楚的了解了事件循环的执行顺序和每一个阶段的特点，可以使我们对一段异步代码的执行顺序有一个清晰的认识，从而减少代码运行的不确定性。合理的使用各种延迟事件的方法，有助于代码更好的按照其优先级去执行。这篇文章期望用最易理解的方式和语言准确描述事件循环这个复杂过程，但由于作者自己水平有限，文章中难免出现疏漏。如果您发现了文章中的一些问题，欢迎在留言中提出，我会尽量回复这些评论，把错误更正。</p><h1 id="16-Promise-原理"><a href="#16-Promise-原理" class="headerlink" title="16.Promise 原理"></a>16.Promise 原理</h1><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        reject(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">&#125;,(data1)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;result2&#39;,data1)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result3&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3 undefined</span><br></pre></td></tr></table></figure><p>显然这里输出了不同的 data。由此可以看出几点：</p><ol><li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li><li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li><li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li></ol><p>基于以上几点，我们先写个基于 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123; &#x2F;&#x2F;桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span><br><span class="line">                onFulfilled, </span><br><span class="line">                resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            if(!callback.onFulfilled)&#123;</span><br><span class="line">                callback.resolve(value)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const ret &#x3D; callback.onFulfilled(value) &#x2F;&#x2F;处理回调</span><br><span class="line">            callback.resolve(ret) &#x2F;&#x2F;处理下一个 promise 的resolve</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0) &#x2F;&#x2F;基于 PromiseA+ 规范</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fulfiledFn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fulfiledFn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p><p>但是如果仅仅是例子中的情况，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    console.log(&#39;result3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3</span><br></pre></td></tr></table></figure><p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#123; test: 1 &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result1&#39;, data)</span><br><span class="line">  &#x2F;&#x2F;dosomething</span><br><span class="line">  return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">  return new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;基于第一个 Promise 模型，执行后的输出</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 Promise &#123;then: ƒ&#125;</span><br></pre></td></tr></table></figure><p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个模型，再测试我们的例子，就得到了正确的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F; result2 &#123; test: 2 &#125;</span><br></pre></td></tr></table></figure><p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p><p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p><p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p><p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p><table><thead><tr><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>P1</td><td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td></tr><tr><td>P2 (P1 调用 then 时产生)</td><td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td></tr><tr><td>P3 (P2 调用 then 时产生)</td><td>[]</td></tr><tr><td>P4 (执行c1中产生[调用 test ])</td><td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td></tr><tr><td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td><td>[]</td></tr></tbody></table><p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p><p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p><p>以上就是链式调用的原理了。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p><p>完整代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">        const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">        if(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(error)&#123;</span><br><span class="line"></span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; error</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    then.call(error,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;rejected&#39;;</span><br><span class="line">            value &#x3D; error</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p><p>handle代码改造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handle(callback)&#123;</span><br><span class="line">    if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        callbacks.push(callback)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve : callback.reject;</span><br><span class="line"></span><br><span class="line">    if(!cb)&#123;</span><br><span class="line">        next(value)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        callback.reject(e);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).catch((ex) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;error&#39;, ex)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled, </span><br><span class="line">                onRejected,</span><br><span class="line">                resolve, </span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finally方法"><a href="#Finally方法" class="headerlink" title="Finally方法"></a>Finally方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    this.finally &#x3D; function (onDone)&#123;</span><br><span class="line">        this.then(onDone,onDone)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">Promise.reject(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">new Promise((resolve,reject) &#x3D;&gt; reject(&#123;name:&#39;winty&#39;&#125;))</span><br></pre></td></tr></table></figure><p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p><ul><li>无参数 [直接返回一个resolved状态的 Promise 对象]</li><li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li><li>一个Promise实例 [直接返回当前实例]</li><li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li></ul><p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.resolve &#x3D; function (value)&#123;</span><br><span class="line">        if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; else if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">            let then &#x3D; value.then;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">                then(resolve);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (value) &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve(value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Promise(fn)&#123; </span><br><span class="line">     ...</span><br><span class="line">     this.reject &#x3D; function (value)&#123;</span><br><span class="line">         return new Promise(function(resolve, reject) &#123;</span><br><span class="line">reject(value);</span><br><span class="line">&#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.all &#x3D; function (arr)&#123;</span><br><span class="line">        var args &#x3D; Array.prototype.slice.call(arr);</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        &#x2F;&#x2F; 长度为0返回结果</span><br><span class="line">            if(args.length &#x3D;&#x3D;&#x3D; 0) return resolve([]);</span><br><span class="line">            &#x2F;&#x2F; 剩余参数数组长度</span><br><span class="line">            var remaining &#x3D; args.length;</span><br><span class="line">&#x2F;&#x2F; 参数和值</span><br><span class="line">            function res(i, val) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">                        var then &#x3D; val.then;</span><br><span class="line">                        &#x2F;&#x2F; 进行参数分析</span><br><span class="line">                        if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                            then.call(val, function(val) &#123;</span><br><span class="line">                                res(i, val);</span><br><span class="line">                            &#125;, reject);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    args[i] &#x3D; val;</span><br><span class="line">                    if(--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        resolve(args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(ex) &#123;</span><br><span class="line">                    reject(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 遍历数组中的每个元素</span><br><span class="line">            for(var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                res(i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.race &#x3D; function(values) &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            for(var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://promisesaplus.com/">PromiseA+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li><li><a href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30分钟，让你彻底明白Promise原理</a></li></ul><h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  let state &#x3D; &#39;pending&#39;</span><br><span class="line">  let value &#x3D; null</span><br><span class="line">  const callbacks &#x3D; []</span><br><span class="line"></span><br><span class="line">  this.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.catch &#x3D; function (onError) &#123;</span><br><span class="line">    return this.then(null, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.finally &#x3D; function (onDone) &#123;</span><br><span class="line">    this.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">      return value</span><br><span class="line">    &#125; if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const &#123; then &#125; &#x3D; value</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; if (value) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.reject &#x3D; function (value) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.all &#x3D; function (arr) &#123;</span><br><span class="line">    const args &#x3D; Array.prototype.slice.call(arr)</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      if (args.length &#x3D;&#x3D;&#x3D; 0) return resolve([])</span><br><span class="line">      let remaining &#x3D; args.length</span><br><span class="line"></span><br><span class="line">      function res(i, val) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">            const &#123; then &#125; &#x3D; val</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">              then.call(val, (val) &#x3D;&gt; &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] &#x3D; val</span><br><span class="line">          if (--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.race &#x3D; function (values) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      for (let i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handle(callback) &#123;</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    if (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let ret;</span><br><span class="line">    try &#123;</span><br><span class="line">     ret &#x3D; cb(value)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  function resolve(newValue) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; newValue</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">          &#x2F;&#x2F; 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;fulfilled&#39;</span><br><span class="line">      value &#x3D; newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(error) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; error</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;rejected&#39;</span><br><span class="line">      value &#x3D; error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function handelCb() &#123;</span><br><span class="line">    while (callbacks.length) &#123;</span><br><span class="line">      const fn &#x3D; callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; catch(ex) &#123;</span><br><span class="line">reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-Generators原理"><a href="#17-Generators原理" class="headerlink" title="17.Generators原理"></a>17.Generators原理</h1><p>随着 Javascript 语言的发展，ES6 规范为我们带来了许多新的内容，其中生成器 Generators 是一项重要的特性。利用这一特性，我们可以简化迭代器的创建，更加令人兴奋的，是 Generators 允许我们在函数执行过程中暂停、并在将来某一时刻恢复执行。这一特性改变了以往函数必须执行完成才返回的特点，将这一特性应用到异步代码编写中，可以有效的简化异步方法的写法，同时避免陷入回调地狱。</p><p>本重点探讨 Generators 运行机制及在 ES5 的实现原理。</p><h2 id="1-Generators-简单介绍"><a href="#1-Generators-简单介绍" class="headerlink" title="1.Generators 简单介绍"></a><strong>1.Generators 简单介绍</strong></h2><p>一个简单的 Generator 函数示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter=example();</span><br><span class="line">iter.next();<span class="comment">//&#123;value:1，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:2，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:3，done:false&#125;</span></span><br><span class="line">iter.next();<span class="comment">//&#123;value:undefined，done:true&#125;</span></span><br></pre></td></tr></table></figure><p>​    上述代码中定义了一个生成器函数，当调用生成器函数 example() 时，并非立即执行该函数，而是返回一个生成器对象。每当调用生成器对象的.next() 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身。当抵达生成器函数的末尾时，返回结果中 done 的值为 true，value 的值为 undefined。我们将上述 example() 函数称之为生成器函数，与普通函数相比二者有如下区别</p><ul><li>普通函数使用 function 声明，生成器函数用 function*声明</li><li>普通函数使用 return 返回值，生成器函数使用 yield 返回值</li><li>普通函数是 run to completion 模式，即普通函数开始执行后，会一直执行到该函数所有语句完成，在此期间别的代码语句是不会被执行的；生成器函数是 run-pause-run 模式，即生成器函数可以在函数运行中被暂停一次或多次，并且在后面再恢复执行，在暂停期间允许其他代码语句被执行</li></ul><h2 id="2-Generators-in-C"><a href="#2-Generators-in-C" class="headerlink" title="2.Generators in C#"></a><strong>2.Generators in C#</strong></h2><p>生成器不是一个新的概念，我最初接触这一概念是在学习使用 C#时。C#从 2.0 版本便引入了 yield 关键字，使得我们可以更简单的创建枚举数和可枚举类型。不同的是 C#中未将其命名为生成器 Generators，而将其称之为迭代器。</p><p>本文不会介绍 C#中可枚举类 IEnumerable 和枚举数 IEnumerator 内容，如需了解推荐阅读《C#4.0 图解教程》相关章节。</p><p>2.1 C#迭代器介绍</p><p>让我们先看一个示例，下面方法声明实现了一个产生和返回枚举数的迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerable &lt;int&gt; Example()</span><br><span class="line">&#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法定义与 ES6 Generators 定义很接近，定义中声明返回了一个 int 类型的泛型可枚举类型，方法体内通过 yield return 语句返回值并将自身暂停执行。</p><p>使用迭代器来创建可枚举类型的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class YieldClass</span><br><span class="line">&#123;</span><br><span class="line">    public IEnumerable&lt;int&gt; Example()&#x2F;&#x2F;迭代器</span><br><span class="line">    &#123;</span><br><span class="line">yield return 1;</span><br><span class="line">yield return 2;</span><br><span class="line">yield return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">YieldClass yc&#x3D;new YieldClass ();</span><br><span class="line">foreach(var a in yc.Example())</span><br><span class="line">Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会产生如下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>2.2 C#迭代器原理</p><p>在.Net 中，yield 并不是.Net runtime 的特性，而是一个语法糖，代码编译时，这一语法糖会被 C#编译器编译成简单的 IL 代码。</p><p>继续研究上述示例，通过 Reflector 反编译工具可以看到，编译器为我们生成了一个带有如下声明的内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[CompilerGenerated]</span><br><span class="line">private sealed class YieldEnumerator : </span><br><span class="line">   IEnumerable&lt;object&gt;, IEnumerator&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Fields字段</span><br><span class="line">    private int state;</span><br><span class="line">    private int current;</span><br><span class="line">    public YieldClass owner;</span><br><span class="line">    private int initialThreadId;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Methods方法</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    public YieldEnumerator(int state);</span><br><span class="line">    private bool MoveNext();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator&lt;int&gt; IEnumerable&lt;int&gt;.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator();</span><br><span class="line">    [DebuggerHidden]</span><br><span class="line">    void IEnumerator.Reset();</span><br><span class="line">    void IDisposable.Dispose();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Properties属性</span><br><span class="line">    object IEnumerator&lt;object&gt;.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line"> </span><br><span class="line">    object IEnumerator.Current </span><br><span class="line">    &#123; [DebuggerHidden] get; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始的 Example() 方法仅返回一个 YieldEnumerator 的实例，并将初始状态-2 传递给它自身和其引用者，每一个迭代器保存一个状态指示</p><ul><li>-2：初始化为可迭代类 Enumerable</li><li>-1: 迭代结束</li><li>0: 初始化为迭代器 Enumerator</li><li>1-n: 原始 Example() 方法中的 yield return 索引值</li></ul><p>Example() 方法中代码被转换为 YieldingEnumerator.MoveNext()，在我们的示例中转换后代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool MoveNext()</span><br><span class="line">&#123;</span><br><span class="line">    switch (state)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 1;</span><br><span class="line">            state &#x3D; 1;</span><br><span class="line">            return true;</span><br><span class="line">        case 1:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 2;</span><br><span class="line">            state &#x3D; 2;</span><br><span class="line">            return true;</span><br><span class="line">        case 2:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            current &#x3D; 3;</span><br><span class="line">            state &#x3D; 3;</span><br><span class="line">            return true;</span><br><span class="line">        case 3:</span><br><span class="line">            state &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述的代码转换，编译器为我们生成了一个状态机，正是基于这一状态机模型，实现了 yield 关键字的特性。</p><p>迭代器状态机模型可如下图所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/statemachine.png" alt="statemachine"></a></p><ul><li>Before 为迭代器初始状态</li><li>Running 为调用 MoveNext 后进入这个状态。在这个状态，枚举数检测并设置下一项的位置。遇到 yield return、yield break 或者迭代结束时，退出该状态</li><li>Suspended 为状态机等待下次调用 MoveNext 的状态</li><li>After 为迭代结束的状态</li></ul><p><strong>3.Generators in Javascript</strong></p><p>通过阅读上文，我们了解了 Generator 在 C#中的使用，并且通过查看编译器生成的 IL 代码，得知编译器会生成一个内部类来保存上下文信息，然后将 yield return 表达式转换成 switch case，通过状态机模式实现 yield 关键字的特性。</p><p>3.1 Javascript Generators 原理浅析</p><p>yield 关键字在 Javascript 中如何实现呢？</p><p>首先，生成器不是线程。支持线程的语言中，多段不同的代码可以在同一时候运行，这经常会导致资源竞争，使用得当会有不错的性能提升。生成器则完全不同，Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。</p><p>既然生成器并非由引擎从底层提供额外的支持，我们可以沿用上文在 C#中对 yield 特性的原理探究的经验，将生成器视为一个语法糖，用一个辅助工具将生成器函数转换为普通的 Javascript 代码，在经过转换的代码中，有两个关键点，一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。</p><p>3.2 How Generators work in ES5</p><p><a href="https://facebook.github.io/regenerator/">Regenerator</a> 工具已经实现了上述思路，借助 Regenerator 工具，我们已经可以在原生 ES5 中使用生成器函数，本节我们来分析 Regenerator 实现方式以深入理解 Generators 运行原理。</p><p>通过<a href="http://babeljs.io/repl/">这个在线地址</a>可以方便的查看经过转换后的代码，仍然以文章初始为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* example() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">var iter&#x3D;example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>经过转换后为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var marked0$0 &#x3D; [example].map(regeneratorRuntime.mark);</span><br><span class="line">function example() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function example$(context$1$0) &#123;</span><br><span class="line">    while (1) switch (context$1$0.prev &#x3D; context$1$0.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        context$1$0.next &#x3D; 2;</span><br><span class="line">        return 1;</span><br><span class="line"> </span><br><span class="line">      case 2:</span><br><span class="line">        context$1$0.next &#x3D; 4;</span><br><span class="line">        return 2;</span><br><span class="line"> </span><br><span class="line">      case 4:</span><br><span class="line">        context$1$0.next &#x3D; 6;</span><br><span class="line">        return 3;</span><br><span class="line"> </span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return context$1$0.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, marked0$0[0], this);</span><br><span class="line">&#125;</span><br><span class="line">var iter &#x3D; example();</span><br><span class="line">iter.next();</span><br></pre></td></tr></table></figure><p>从转换后的代码中可以看到，与 C#编译器对 yield return 表达式的转换相似，Regenerator 将生成器函数中的 yield 表达式重写为 switch case，同时，在每个 case 中使用 context$1$0 来保存函数当前的上下文状态。</p><p>switch case 之外，迭代器函数 example 被 regeneratorRuntime.mark 包装，返回一个被 regeneratorRuntime.wrap 包装的迭代器对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  if (Object.setPrototypeOf) &#123;</span><br><span class="line">    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  &#125;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 mark 包装，将 example 包装成如下对象</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/example.png" alt="example"></a></p><p>当调用生成器函数 example() 时，返回一个被 wrap 函数包装后的迭代器对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runtime.wrap&#x3D;function (innerFn, outerFn, self, tryLocsList) &#123;</span><br><span class="line">  &#x2F;&#x2F; If outerFn provided, then outerFn.prototype instanceof Generator.</span><br><span class="line">  var generator &#x3D; Object.create((outerFn || Generator).prototype);</span><br><span class="line">  var context &#x3D; new Context(tryLocsList || []);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; The ._invoke method unifies the implementations of the .next,</span><br><span class="line">  &#x2F;&#x2F; .throw, and .return methods.</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"> </span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的迭代器对象如下所示</p><p><a href="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png"><img data-src="http://www.alloyteam.com/wp-content/uploads/2016/02/iter.png" alt="iter"></a></p><p>当调用迭代器对象 iter.next() 方法时，因为有如下代码，所以会执行_invoke 方法，而根据前面 wrap 方法代码可知，最终是调用了迭代器对象的 makeInvokeMethod (innerFn, self, context); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">  [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">    prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">      return this._invoke(method, arg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 方法内容较多，这里选取部分分析。首先，我们发现生成器将自身状态初始化为“Suspended Start”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function makeInvokeMethod(innerFn, self, context) &#123;</span><br><span class="line">  var state &#x3D; GenStateSuspendedStart;</span><br><span class="line"> </span><br><span class="line">  return function invoke(method, arg) &#123;</span><br></pre></td></tr></table></figure><p>makeInvokeMethod 返回 invoke 函数，当我们执行.next 方法时，实际调用的是 invoke 方法中的下面语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br></pre></td></tr></table></figure><p>这里 tryCatch 方法中 fn 为经过转换后的 example$方法，arg 为上下文对象 context, 因为 invoke 函数内部对 context 的引用形成闭包引用，所以 context 上下文得以在迭代期间一直保持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tryCatch(fn, obj, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    return &#123; type: &quot;throw&quot;, arg: err &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryCatch 方法会实际调用 example$方法，进入转换后的 switch case, 执行代码逻辑。如果得到的结果是一个普通类型的值，我们将它包装成一个可迭代对象格式，并且更新生成器状态至 GenStateCompleted 或者 GenStateSuspendedYield</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var record &#x3D; tryCatch(innerFn, self, context);</span><br><span class="line">        if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">          &#x2F;&#x2F; If an exception is thrown from innerFn, we leave state &#x3D;&#x3D;&#x3D;</span><br><span class="line">          &#x2F;&#x2F; GenStateExecuting and loop back for another invocation.</span><br><span class="line">          state &#x3D; context.done</span><br><span class="line">            ? GenStateCompleted</span><br><span class="line">            : GenStateSuspendedYield;</span><br><span class="line"> </span><br><span class="line">          var info &#x3D; &#123;</span><br><span class="line">            value: record.arg,</span><br><span class="line">            done: context.done</span><br><span class="line">          &#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 总结</strong></p><p>通过对 Regenerator 转换后的生成器代码及工具源码分析，我们探究了生成器的运行原理。Regenerator 通过工具函数将生成器函数包装，为其添加如 next/return 等方法。同时也对返回的生成器对象进行包装，使得对 next 等方法的调用，最终进入由 switch case 组成的状态机模型中。除此之外，利用闭包技巧，保存生成器函数上下文信息。</p><p>上述过程与 C#中 yield 关键字的实现原理基本一致，都采用了编译转换思路，运用状态机模型，同时保存函数上下文信息，最终实现了新的 yield 关键字带来的新的语言特性。</p><p>参考文章</p><p>1.<a href="https://davidwalsh.name/es6-generators">ES6 Generators:Complete Series 系列文章</a></p><p>\2. <a href="http://www.infoq.com/cn/articles/es6-in-depth-generators">深入浅出 ES6 Generators</a></p><p>3.<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">《深入掌握 ECMAScript 6 异步编程》系列文章</a></p><p>4.<a href="http://x-team.com/2015/04/generators-work/">ES6 Generators:How do they work?</a></p><p>5.<a href="https://startbigthinksmall.wordpress.com/2008/06/09/behind-the-scenes-of-the-c-yield-keyword/">Behind the scenes of the C# yield keyword</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读，开始准备面试吧，初战不利，更应该多刷面经，多背基础，毕竟是实习和校招，基础要夯实，推荐观看  &lt;a href=&quot;https://github.com/mqyqingfeng/Blog&quot;&gt;冴羽的博客&lt;/a&gt; ，内容丰富，适合有一定JS基础的人进行阅读&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    <category term="面试" scheme="https://hxy1997.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Promise async Generator实现原理解析</title>
    <link href="https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-28T03:40:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://juejin.im/post/6844904096525189128">https://juejin.im/post/6844904096525189128</a> </p><p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：</p><ol><li><p><code>Promise</code>的实现原理</p></li><li><p><code>async/await</code>的实现原理</p></li><li><p><code>Generator</code>的实现原理</p></li></ol><a id="more"></a><h1 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h1><p>在成文过程中，笔者查阅了很多讲解Promise实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段Promise规范翻译，有的在Promise基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p><p>回归正题，文章开头我们先点一下Promise为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个Promise：</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Promise实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入resolve, reject函数参数</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>观察这个例子，我们分析Promise的调用流程：</p><ul><li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个executor回调</li><li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li><li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li><li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li></ul><p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在Promise里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出Promise的大致形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// then收集的执行成功的回调队列</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// then收集的执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 从成功队列里取出回调依次执行</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._resolveQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._rejectQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// 一秒后输出result</span></span><br></pre></td></tr></table></figure><p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在then方法的回调里取得异步操作的返回值，但我们这个Promise离最终实现还有很长的距离，下面我们来一步步补充这个Promise：</p><h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版Promise，但我们会看到很多文章和我们写的不一样，他们的Promise实现中还引入了各种状态控制，这是由于ES6的Promise实现需要遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对Promise的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p><blockquote><ol><li>Promise本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li><li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/2/26/161d2454e68ff07b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>根据规范，我们补充一下Promise的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">            <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._resolveQueue.length</span>)</span> &#123;    </span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._rejectQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-then的链式调用"><a href="#3-then的链式调用" class="headerlink" title="3. then的链式调用"></a>3. then的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是Promise实现的重点和难点，我们先来看一下then是如何链式调用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(2)</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">     &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">        return 3</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们思考一下如何实现这种链式调用：</p><ol><li>显然<code>.then()</code>需要返回一个Promise，这样才能找到then方法，所以我们会把then方法的返回值包装成Promise。</li><li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li><li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间return了一个Promise，但执行顺序仍要保证是1-&gt;2-&gt;3。我们要等待当前Promise状态变更后，再执行下一个then收集的回调，这就要求我们对then的返回值分类讨论</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法改进</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                <span class="comment">//这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span></span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reject同理</span></span><br><span class="line">        <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能测试一下链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p><ol><li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是function，那么我们应该忽略它。如果没有忽略，当then()回调不为function时将会抛出异常，导致链式调用中断</li><li><strong>处理状态为resolve/reject的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把then()回调push进resolve/reject的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行then回调：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span>? reason.message:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">            <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">            <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">            <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了then的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor是异步任务</strong>的前提上的，如果executor是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve的执行跑到then之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个setTimeout，让它异步执行。</p><blockquote><p>这里插一句，有关这个setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实Promise的默认实现是放进了微任务队列，我们的实现（包括大多数Promise手动实现和polyfill的转化）都是使用setTimeout放入了宏任务队列（当然我们也可以用MutationObserver模拟微任务）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">        this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">        this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">        this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">        let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">                &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">                while(this._resolveQueue.length) &#123;    </span><br><span class="line">                    const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 实现同resolve</span><br><span class="line">        let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">                while(this._rejectQueue.length) &#123;</span><br><span class="line">                    const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">    then(resolveFn, rejectFn) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">        typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">        typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">        throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">        &#125; : null</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return一个新的promise</span><br><span class="line">        return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">        const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">                let x &#x3D; resolveFn(value)</span><br><span class="line">                &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">                x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; reject同理</span><br><span class="line">            const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; rejectFn(error)</span><br><span class="line">                    x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (this._status) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">                case PENDING:</span><br><span class="line">                    this._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    this._rejectQueue.push(rejectedFn)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">                case FULFILLED:</span><br><span class="line">                    fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">                    break;</span><br><span class="line">                case REJECTED:</span><br><span class="line">                    rejectedFn(this._value)</span><br><span class="line">                    break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下这个Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)          <span class="comment">//同步executor测试</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>          <span class="comment">//链式调用测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then()             <span class="comment">//值穿透测试</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">3</span>)      <span class="comment">//返回Promise测试</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;reject测试&#x27;</span>)   <span class="comment">//reject测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// Error: reject测试</span></span><br></pre></td></tr></table></figure><p>到这里，我们已经实现了Promise的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="function"><span class="title">catch</span>(<span class="params">rejectFn</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote><p><code>finally()方法</code>返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">        value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">        reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变Promise状态，在finally()没有返回reject态Promise或throw错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对Promise的理解，大家可以在各个交流群里直接@我）</p><blockquote><p>参考资料：<a href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p></blockquote><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote><p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    result[i] = val</span><br><span class="line">                    <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                    <span class="function"><span class="title">if</span>(<span class="params">index === promiseArr.length</span>)</span> &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                value =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._value = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> FULFILLED:</span><br><span class="line">                    fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                    rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="function"><span class="title">catch</span>(<span class="params">rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            value =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">            reason =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> result = []</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    val =&gt; &#123;</span><br><span class="line">                        index++</span><br><span class="line">                        result[i] = val</span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的race方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒150多行的代码，到这里，我们终于可以给Promise的实现做一个结尾了。我们从一个最简单的Promise使用实例开始，通过对调用流程的分析，根据观察者模式实现了Promise的大致骨架，然后依据Promise/A+规范填充代码，重点实现了then 的链式调用，最后完成了Promise的静态/实例方法。其实Promise实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多Promise细节，因而很难写出一个符合规范的Promise实现，源码的实现过程，其实也是对Promise使用细节重新学习的过程。</p><h1 id="async-await实现"><a href="#async-await实现" class="headerlink" title="async/await实现"></a>async/await实现</h1><p>虽然前边花了这么多篇幅讲Promise的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下async/await的使用意义。 在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p><blockquote><p>设想一个这样的场景，异步任务a-&gt;b-&gt;c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b不往下执行到c，那么也不是很方便控制</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(a)</span><br><span class="line">    .then(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是如果通过async/await来实现这个场景，可读性和流程控制都会方便不少。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(a);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(b);</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要如何实现一个async/await呢，首先我们要知道，<strong>async/await实际上是对Generator（生成器）的封装</strong>，是一个语法糖。由于Generator出现不久就被async/await取代了，很多同学对Generator比较陌生，因此我们先来看看Generator的用法：</p><blockquote><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();  <span class="comment">// 获取迭代器</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>也可以通过给<code>next()</code>传参, 让yield具有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 输出test1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>)  <span class="comment">// 输出test2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>)  <span class="comment">// 输出test3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(<span class="string">&#x27;test1&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test2&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们看到Generator的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用next()就能自动执行下一步</li><li><code>async</code>函数返回值是Promise对象，而Generator返回的是生成器对象</li><li><code>await</code>能够返回Promise的resolve/reject的值</li></ul><p><strong>我们对async/await的实现，其实也就是对应以上三点封装Generator</strong></p><h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">        gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出1 2 3</span></span><br></pre></td></tr></table></figure><p>我们也可以通过给<code>gen.next()</code>传值的方式，让yield能返回resolve的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(val)</span></span><br><span class="line">    gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(val)</span></span><br><span class="line">        gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(val)</span></span><br><span class="line">            gen.next(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen()                     <span class="comment">// 由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;             <span class="comment">// 封装一个方法, 递归执行g.next()</span></span><br><span class="line">        <span class="keyword">var</span> res = g.next(val)           <span class="comment">// 获取迭代器对象，并返回resolve的值</span></span><br><span class="line">        <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">// 递归终止条件</span></span><br><span class="line">            res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">// Promise的then方法是实现自动迭代的前提</span></span><br><span class="line">            _next(val)                    <span class="comment">// 等待Promise完成就自动执行下一个next，并传入resolve的值</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    _next()  <span class="comment">//第一次执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们之前的例子，我们就能这样执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure><p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成<code>_next()</code>，每次Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入<code>gen.next()</code>，使得yield得以返回Promise的resolve的值</p><blockquote><p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接<code>thunk函数</code>，thunk函数不是一个新东西，所谓thunk函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰Thunk 函数的含义和用法</a>，无论是Promise还是thunk函数，其核心都是通过<strong>传入回调</strong>的方式来实现Generator的自动执行。thunk函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p></blockquote><h2 id="2-返回Promise-amp-异常处理"><a href="#2-返回Promise-amp-异常处理" class="headerlink" title="2.返回Promise &amp; 异常处理"></a>2.返回Promise &amp; 异常处理</h2><p>虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：</p><ol><li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li><li><strong>缺少错误处理</strong>：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的try-catch捕获到</li><li><strong>返回值是Promise</strong>：<code>async/await</code>的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise</li></ol><p>我们改造一下run方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把返回值包装成promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> res = g.next(val) </span><br><span class="line">                &#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err); </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">res.done</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(res.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// res.value包装为promise，以兼容yield后面跟基本类型的情况</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(res.value).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    _next(val);</span><br><span class="line">                &#125;, </span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 抛出错误</span></span><br><span class="line">                    g.throw(err)</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        _next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)) </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = run(myGenerator)     <span class="comment">// result是一个Promise</span></span><br><span class="line"><span class="comment">// 输出 1 2 error</span></span><br></pre></td></tr></table></figure><p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下babel对async/await的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于我们的run()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> gen = fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于我们的_next()</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;next&#x27;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;throw&#x27;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">            _next(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">        <span class="keyword">var</span> value = info.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(value).then(_next, _throw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)                          <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道await到底是如何暂停执行的，有关await暂停执行的秘密，我们还要到Generator的实现中去寻找答案</p><h1 id="Generator实现"><a href="#Generator实现" class="headerlink" title="Generator实现"></a>Generator实现</h1><p>我们从一个简单的Generator使用实例开始，一步步探究Generator的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> gen = foo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br></pre></td></tr></table></figure><p>我们可以在<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel官网</a>上在线转化这段代码，看看ES5环境下是如何实现Generator的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _marked =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">foo$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    _context.next = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    _context.next = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    _context.next = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> _context.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = foo();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br></pre></td></tr></table></figure><p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自facebook的 regenerator 模块，完整代码在<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个runtime有700多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p><blockquote><p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p></blockquote><h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下runtime里mark()方法的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line">runtime.mark = <span class="function"><span class="keyword">function</span>(<span class="params">genFun</span>) </span>&#123;</span><br><span class="line">    genFun.__proto__ = GeneratorFunctionPrototype;</span><br><span class="line">    genFun.prototype = <span class="built_in">Object</span>.create(Gp);</span><br><span class="line">    <span class="keyword">return</span> genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在runtime里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p><h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面babel转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看wrap方法的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">innerFn, outerFn, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = <span class="built_in">Object</span>.create(outerFn.prototype);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> Context([]);</span><br><span class="line">    generator._invoke = makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrap方法先是创建了一个generator，并继承<code>outerFn.prototype</code>；然后new了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后return了generator。<strong>其实wrap()相当于是给generator增加了一个_invoke方法</strong></p><p>这段代码肯定让人产生很多疑问，outerFn.prototype是什么，Context又是什么，makeInvokeMethod又做了哪些操作。下面我们就来一一解答：</p><blockquote><p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p></blockquote><p>这个我们结合一下上面的代码就能知道</p><blockquote><p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ContinueSentinel = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    method: <span class="string">&quot;next&quot;</span>,</span><br><span class="line">    next: <span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    abrupt: <span class="function"><span class="keyword">function</span>(<span class="params">type, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> record = &#123;&#125;;</span><br><span class="line">        record.type = type;</span><br><span class="line">        record.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.complete(record);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span>(<span class="params">record, afterLoc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (record.type === <span class="string">&quot;return&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rval = <span class="built_in">this</span>.arg = record.arg;</span><br><span class="line">            <span class="built_in">this</span>.method = <span class="string">&quot;return&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ContinueSentinel;</span><br><span class="line">    &#125;,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>makeInvokeMethod<code>的定义如下，它return了一个</code>invoke方法<code>，invoke用于判断当前状态和执行下一步，其实就是我们调用的</code>next()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInvokeMethod</span>(<span class="params">innerFn, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态置为start</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">method, arg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已完成</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">&quot;completed&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.method = method;</span><br><span class="line">        context.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            state = <span class="string">&quot;executing&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> record = &#123;</span><br><span class="line">                type: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                arg: innerFn.call(self, context)    <span class="comment">// 执行下一步,并获取状态(其实就是switch里边return的值)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.type === <span class="string">&quot;normal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否已经执行完成</span></span><br><span class="line">                state = context.done ? <span class="string">&quot;completed&quot;</span> : <span class="string">&quot;yield&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ContinueSentinel其实是一个空对象,record.arg === &#123;&#125;则跳过return进入下一个循环</span></span><br><span class="line">                <span class="comment">// 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span></span><br><span class="line">                <span class="keyword">if</span> (record.arg === ContinueSentinel) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// next()的返回值</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: record.arg,</span><br><span class="line">                    done: context.done</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在runtime对于next()的定义中，next()其实就return了_invoke方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for defining the .next, .throw, and .return methods of the</span></span><br><span class="line"><span class="comment">// Iterator interface in terms of a single ._invoke method.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineIteratorMethods</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">    [<span class="string">&quot;next&quot;</span>, <span class="string">&quot;throw&quot;</span>, <span class="string">&quot;return&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">        prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._invoke(method, arg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure><h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的Generator，然后再回过头看源码，会得到更清晰的认识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.next = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                _context.next = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                _context.next = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版context  </span></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    next:<span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span> <span class="title">stop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.done = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版invoke</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            value = context.done ? <span class="literal">undefined</span>: gen$(context)</span><br><span class="line">            done = context.done</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试使用</span></span><br><span class="line"><span class="keyword">var</span> g = gen() </span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result1&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result2&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result3&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码并不难理解，我们分析一下调用流程：</p><ol><li>我们定义的<code>function*</code>生成器函数被转化为以上代码</li><li>转化后的代码分为三大块：<ul><li><code>gen$(_context)</code>由yield分割生成器函数代码而来</li><li><code>context对象</code>用于储存函数执行上下文</li><li><code>invoke()方法</code>定义next()，用于执行gen$(_context)来跳到下一步</li></ul></li><li>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果</li><li>当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></li></ol><p>从中我们可以看出，<strong>Generator实现的核心在于<code>上下文的保存</code>，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p><h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关Promise、async/await、Generator的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近9千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对await挂起机制的好奇，后来，从一个 “await是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p><p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在Generator机制上给予的解惑~</p><blockquote><p>前端技匠：<a href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a><br> 神三元：<a href="https://juejin.im/post/6844903702457925640">我如何实现Promise</a><br> winty：<a href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a><br> 冴羽：<a href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator   编译成了什么样子</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自 &lt;a href=&quot;https://juejin.im/post/6844904096525189128&quot;&gt;https://juejin.im/post/6844904096525189128&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;笔者刚接触&lt;code&gt;async/await&lt;/code&gt;时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Promise" scheme="https://hxy1997.xyz/tags/Promise/"/>
    
    <category term="async" scheme="https://hxy1997.xyz/tags/async/"/>
    
    <category term="Generator" scheme="https://hxy1997.xyz/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>JS基础</title>
    <link href="https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/"/>
    <id>https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-26T09:14:39.000Z</published>
    <updated>2020-10-26T13:44:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。</p><a id="more"></a><h2 id="1-如何在ES5环境下实现let"><a href="#1-如何在ES5环境下实现let" class="headerlink" title="1. 如何在ES5环境下实现let"></a>1. 如何在ES5环境下实现let</h2><blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageslim" alt="img"></p><p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数（闭包）来模拟块级作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  for(var i &#x3D; 0; i &lt; 5; i ++)&#123;</span><br><span class="line">    console.log(i)  &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(i)      &#x2F;&#x2F; Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p><ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li><li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li><li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li><li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ul><p>babel的转化，其实只实现了第2、3、5点</p><h2 id="2-如何在ES5环境下实现const"><a href="#2-如何在ES5环境下实现const" class="headerlink" title="2. 如何在ES5环境下实现const"></a>2. 如何在ES5环境下实现const</h2><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p><blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">obj</td><td align="center">要在其上定义属性的对象</td></tr><tr><td align="center">prop</td><td align="center">要定义或修改的属性的名称</td></tr><tr><td align="center">descriptor</td><td align="center">将被定义或修改的属性描述符</td></tr></tbody></table><table><thead><tr><th align="center">属性描述符</th><th align="left">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">value</td><td align="left">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">get</td><td align="left">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">set</td><td align="left">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td><td align="center">undefined</td></tr><tr><td align="center">writable</td><td align="left">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td><td align="center">false</td></tr><tr><td align="center">enumerable</td><td align="left">enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td><td align="center">false</td></tr><tr><td align="center">Configurable</td><td align="left">configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td><td align="center">false</td></tr></tbody></table><p>对于const不可修改的特性，我们通过设置writable属性来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var __const &#x3D; function __const (data, value) &#123;</span><br><span class="line">    window.data &#x3D; value &#x2F;&#x2F; 把要定义的data挂载到window下，并赋值value</span><br><span class="line">    Object.defineProperty(window, data, &#123; &#x2F;&#x2F; 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: false,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">        return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (data) &#123;</span><br><span class="line">            if (data !&#x3D;&#x3D; value) &#123; &#x2F;&#x2F; 当要对当前属性进行赋值时，则抛出错误！</span><br><span class="line">            throw new TypeError(&#39;Assignment to constant variable.&#39;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">_const(&#39;obj&#39;, &#123;a: 1&#125;)   &#x2F;&#x2F; 定义obj</span><br><span class="line">obj.b &#x3D; 2               &#x2F;&#x2F; 可以正常给obj的属性赋值</span><br><span class="line">obj &#x3D; &#123;&#125;                &#x2F;&#x2F; 无法赋值新对象 报错</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://juejin.im/post/6844903848008482824">如何在 ES5 环境下实现一个const ？</a></p><h2 id="3-模拟实现call"><a href="#3-模拟实现call" class="headerlink" title="3. 模拟实现call"></a>3. 模拟实现call</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call() 方法&#96;使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</span><br><span class="line"> 语法：&#96;function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></blockquote><p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行当前函数</span></span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟实现apply"><a href="#4-模拟实现apply" class="headerlink" title="4. 模拟实现apply"></a>4. 模拟实现apply</h2><blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br> 语法：func.apply(thisArg, [argsArray])</p></blockquote><p><code>apply()</code>和<code>call()</code>类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-模拟实现bind"><a href="#5-模拟实现bind" class="headerlink" title="5. 模拟实现bind"></a>5. 模拟实现bind</h2><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br> 语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><p>从用法上看，似乎给call/apply包一层function就实现了bind()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function(context &#x3D; window, ...args) &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">    this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但我们忽略了三点：</p><ol><li><p>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</p></li><li><p>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</p></li><li><p>没有保留原函数在原型链上的属性和方法</p></li></ol><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-手写一个防抖函数-debounce"><a href="#6-手写一个防抖函数-debounce" class="headerlink" title="6. 手写一个防抖函数(debounce)"></a>6. 手写一个防抖函数(debounce)</h2><p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p><blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function debounce (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存一个定时器id</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">    &#x2F;&#x2F; 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">    &#x2F;&#x2F; 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-手写一个节流函数-throttle"><a href="#7-手写一个节流函数-throttle" class="headerlink" title="7. 手写一个节流函数(throttle)"></a>7. 手写一个节流函数(throttle)</h2><blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle(func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if (!lastTime) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                lastTime &#x3D; null</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; 0;</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前时间</span><br><span class="line">        let now &#x3D; +new Date()</span><br><span class="line">        &#x2F;&#x2F; 将当前时间和上一次执行函数时间对比</span><br><span class="line">        &#x2F;&#x2F; 如果差值大于设置的等待时间就执行函数</span><br><span class="line">        if (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime &#x3D; now</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8. 数组扁平化"></a>8. 数组扁平化</h2><blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>这样的一维数组呢：</p></blockquote><p><strong>1.直接调用ES6的flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">arr.flat(Infinity)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>2.序列化后正则</strong></p><p>把所有<code>[</code>和<code>]</code>去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">const str &#x3D; &#96;[$&#123;JSON.stringify(arr).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;)&#125;]&#96;</span><br><span class="line">JSON.parse(str)   &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>3.递归</strong><br> 对于树状结构的数据，最直接的处理方式就是递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr) &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>4.reduce()递归</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; &#123;</span><br><span class="line">    return prev.concat(cur instanceof Array ? flat(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>5.迭代+展开运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]</span><br><span class="line">&#x2F;&#x2F; 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并</span><br><span class="line">let arr &#x3D; [1, [1,2], [1,2,3,[4,4,4]]]</span><br><span class="line">while (arr.some(Array.isArray)) &#123;</span><br><span class="line">  arr &#x3D; [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3, 4, 4, 4]</span><br></pre></td></tr></table></figure><h2 id="9-手写一个Promise"><a href="#9-手写一个Promise" class="headerlink" title="9. 手写一个Promise"></a>9. 手写一个Promise</h2><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现一个符合规范的Promise篇幅比较长，建议阅读文章：<a href="https://juejin.im/post/6844904096525189128">异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-24T16:02:39.000Z</published>
    <updated>2020-10-26T06:17:51.766Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。</p><a id="more"></a><h1 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h1><h2 id="1-1-本地安装hexo"><a href="#1-1-本地安装hexo" class="headerlink" title="1.1.本地安装hexo"></a>1.1.本地安装hexo</h2><p>首先保证你电脑上有node环境，这个不懂的可以自定百度。</p><p>控制台输入node -v出现版本号说明安装成功。</p><p>有了node就可以安装hexo了，控制台输入如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure><p>同样控制台输入hexo -v出现版本号说明安装成功。</p><p>然后开始初始化项目，控制台输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>生成的目录：</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules：是依赖包</span><br><span class="line">public：存放的是生成的页面</span><br><span class="line">scaffolds：命令生成文章等的模板</span><br><span class="line">source：用命令创建的各种文章</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml：整个博客的配置</span><br><span class="line">db.json：source解析所得到的</span><br><span class="line">package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-本地运行"><a href="#1-2-本地运行" class="headerlink" title="1.2.本地运行"></a>1.2.本地运行</h2><p>首先在本地跑起来你的代码</p><p>控制台安装hexo-server</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-server</span><br></pre></td></tr></table></figure><p>然后运行 hexo-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<a href="http://localhost:4000/">http://localhost:4000</a>  就可以看到你本定运行的页面了</p><p>这时你可以在本地调试一下你的blog。</p><h2 id="1-3-github配置"><a href="#1-3-github配置" class="headerlink" title="1.3.github配置"></a>1.3.github配置</h2><p>首先要创建一个github账号</p><p>并配置好ssh</p><p>这些不懂的可以自行百度。</p><p>创建一个repo，名称为yourname.github.io, 其中 yourname 是你的github名称，按照这个规则创建github page才会生效。</p><p>修改_config.yml中的git配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:  https:<span class="comment">//github.com/yourname/yourname.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="1-4-部署上传"><a href="#1-4-部署上传" class="headerlink" title="1.4.部署上传"></a>1.4.部署上传</h2><p>在本地安装上传工具</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>依次执行如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean     //删除上次打包</span><br><span class="line">hexo generate   //打包</span><br><span class="line">hexo deploy    /上传</span><br></pre></td></tr></table></figure><p>这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。</p><p>在浏览器中输入 <a href="https://yourname.github.io/">https://yourname.github.io/</a> 就可以看到你的个人博客了！</p><h2 id="1-5-README-md配置"><a href="#1-5-README-md配置" class="headerlink" title="1.5 README.md配置"></a>1.5 README.md配置</h2><p>1.首先在source文件夹下建立一个README.md</p><p>2.修改_config.yml</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><h1 id="二、绑定二人域名"><a href="#二、绑定二人域名" class="headerlink" title="二、绑定二人域名"></a>二、绑定二人域名</h1><h2 id="2-1购买一个域名"><a href="#2-1购买一个域名" class="headerlink" title="2.1购买一个域名"></a>2.1购买一个域名</h2><p>这里我选择的是阿里云，挑选一个自己喜欢的域名购买。</p><h2 id="2-2域名解析"><a href="#2-2域名解析" class="headerlink" title="2.2域名解析"></a>2.2域名解析</h2><p>进入控制台添加域名解析。</p><p>按照如下规则添加两条记录。</p><p>解析好的域名404，说明域名解析没有问题，接下来进入github进行配置</p><h2 id="2-3-hexo配置"><a href="#2-3-hexo配置" class="headerlink" title="2.3 hexo配置"></a>2.3 hexo配置</h2><p>在本地的博客目录中找到source文件夹。</p><p>新建一个没有后缀名的文件CNAME</p><p>在文件中添加你的域名，如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisq.xyz</span><br></pre></td></tr></table></figure><p>保存后重新生成，并提交你的博客。</p><h2 id="2-4-github配置"><a href="#2-4-github配置" class="headerlink" title="2.4 github配置"></a>2.4 github配置</h2><p>在github中找到你的博客仓库。</p><p>点击<code>Setting</code></p><p>找到<code>Custom domain</code></p><p>输入你的域名点击save</p><p>然后你就可以在浏览器用你的域名愉快的访问啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Github" scheme="https://hxy1997.xyz/tags/Github/"/>
    
    <category term="博客" scheme="https://hxy1997.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://hxy1997.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-25T06:02:29.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><h2 id="1-为什么要学习设计模式？"><a href="#1-为什么要学习设计模式？" class="headerlink" title="1.为什么要学习设计模式？"></a>1.为什么要学习设计模式？</h2><p>在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。</p><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="2-什么是设计模式。"><a href="#2-什么是设计模式。" class="headerlink" title="2.什么是设计模式。"></a>2.什么是设计模式。</h2><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p><p>设计模式主要是为了解决对象的生成和整合问题。</p><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p><h2 id="3-设计模式的发展历史"><a href="#3-设计模式的发展历史" class="headerlink" title="3.设计模式的发展历史"></a>3.设计模式的发展历史</h2><p>设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。</p><p>四人帮把这本书分成两部分：</p><p>第一部分解释面向对象编程的优缺点。</p><p>第二部分是关于 23 个经典设计模式的演变。</p><p>自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。</p><h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.设计模式分类"></a>4.设计模式分类</h2><p>根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p>接下来将概述属于这三种类型的 23 种设计模式的主要概念。</p><a id="more"></a><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="this、new、bind、call、apply"><a href="#this、new、bind、call、apply" class="headerlink" title="this、new、bind、call、apply"></a>this、new、bind、call、apply</h2><h3 id="1-this-指向的类型"><a href="#1-this-指向的类型" class="headerlink" title="1. this 指向的类型"></a><strong>1. this 指向的类型</strong></h3><h4 id="this-在函数的指向有以下几种场景："><a href="#this-在函数的指向有以下几种场景：" class="headerlink" title="this 在函数的指向有以下几种场景："></a><strong>this 在函数的指向有以下几种场景：</strong></h4><ul><li>作为构造函数被 new 调用；</li><li>作为对象的方法使用；</li><li>作为函数直接调用；</li><li>被 <code>call</code>、<code>apply</code>、<code>bind</code> 调用；</li><li>箭头函数中的 <code>this</code>；</li></ul><h4 id="1-1-new-绑定"><a href="#1-1-new-绑定" class="headerlink" title="1.1 new 绑定"></a><strong>1.1 new 绑定</strong></h4><blockquote><p>函数如果作为构造函数使用 <code>new</code> 调用时， <code>this</code> 绑定的是新创建的构造函数的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()       <span class="comment">// 输出: Foo 实例，this 就是 bar</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上使用 <code>new</code> 调用构造函数时，会依次执行下面的操作：</p></blockquote><ul><li>创建一个新对象；</li><li>构造函数的 <code>prototype</code> 被赋值给这个新对象的 <code>__proto__</code>；</li><li>将新对象赋给当前的 <code>this</code>；</li><li>执行构造函数；</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象，如果返回的不是对象将被忽略；</li></ul><h4 id="1-2-显式绑定"><a href="#1-2-显式绑定" class="headerlink" title="1.2 显式绑定"></a><strong>1.2 显式绑定</strong></h4><blockquote><p>通过 <code>call</code>、<code>apply</code>、<code>bind</code> 我们可以修改函数绑定的 <code>this</code>，使其成为我们指定的对象。通过这些方法的第一个参数我们可以显式地绑定 <code>this</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">category, name, price</span>) </span>&#123;</span><br><span class="line">    foo.call(<span class="built_in">this</span>, name, price)       <span class="comment">// call 方式调用</span></span><br><span class="line">    <span class="comment">// foo.apply(this, [name, price])    // apply 方式调用</span></span><br><span class="line">    <span class="built_in">this</span>.category = category</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Food(<span class="string">&#x27;食品&#x27;</span>, <span class="string">&#x27;汉堡&#x27;</span>, <span class="string">&#x27;5块钱&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &#123;name: &quot;汉堡&quot;, price: &quot;5块钱&quot;, category: &quot;食品&quot;&#125;</span></span><br><span class="line">call 和 apply 的区别是 call 方法接受的是参数列表，而 apply 方法接受的是一个参数数组。</span><br><span class="line"></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)        <span class="comment">// call 用法</span></span><br><span class="line">func.apply(thisArg, [arg1, arg2, ...])     <span class="comment">// apply 用法</span></span><br></pre></td></tr></table></figure><blockquote><p>而 <code>bind</code> 方法是设置 <code>this</code> 为给定的值，并返回一个新的函数，且在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])    <span class="comment">// bind 用法</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> food = &#123;</span><br><span class="line">    name: <span class="string">&#x27;汉堡&#x27;</span>,</span><br><span class="line">    price: <span class="string">&#x27;5块钱&#x27;</span>,</span><br><span class="line">    getPrice: <span class="function"><span class="keyword">function</span>(<span class="params">place</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(place + <span class="built_in">this</span>.price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">food.getPrice(<span class="string">&#x27;KFC &#x27;</span>)   <span class="comment">// 浏览器中输出: &quot;KFC 5块钱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice1 = food.getPrice.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;鸡腿&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;7块钱&#x27;</span> &#125;, <span class="string">&#x27;肯打鸡 &#x27;</span>)</span><br><span class="line">getPrice1()       <span class="comment">// 浏览器中输出: &quot;肯打鸡 7块钱&quot;</span></span><br><span class="line">关于 bind 的原理，我们可以使用 apply 方法自己实现一个 bind 看一下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params">...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, [...rest1, ...rest2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ES6</code> 方式用了一些 <code>ES6</code> 的知识比如 <code>rest</code> 参数、数组解构</p></blockquote><p><strong>注意：</strong> 如果你把 <code>null</code> 或 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code>、<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="literal">null</span>)         <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind(this)</code>链式调用，实际上后几项未执行，实质上 <code>this</code> 指向第一个绑定</p><h4 id="1-3-隐式绑定"><a href="#1-3-隐式绑定" class="headerlink" title="1.3 隐式绑定"></a>1.3 隐式绑定</h4><blockquote><p>函数是否在某个上下文对象中调用，如果是的话 <code>this</code> 绑定的是那个上下文对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()       <span class="comment">// 浏览器中输出: &quot;world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>foo</code> 方法是作为对象的属性调用的，那么此时 <code>foo</code> 方法执行时，<code>this</code> 指向 <code>obj</code> 对象。也就是说，此时 <code>this</code> 指向调用这个方法的对象，如果嵌套了多个对象，那么指向最后一个调用这个方法的对象：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">        foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.b.foo()      <span class="comment">// 浏览器中输出: &quot;China&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>最后一个对象是 <code>obj</code> 上的 <code>b</code>，那么此时 <code>foo</code> 方法执行时，其中的 <code>this</code> 指向的就是 <code>b</code> 对象。</p></blockquote><h4 id="1-4-默认绑定"><a href="#1-4-默认绑定" class="headerlink" title="1.4 默认绑定"></a><strong>1.4 默认绑定</strong></h4><blockquote><p>函数独立调用，直接使用不带任何修饰的函数引用进行调用，也是上面几种绑定途径之外的方式。非严格模式下 this 绑定到全局对象（浏览器下是 <code>winodw</code>，<code>node</code> 环境是 <code>global</code>），严格模式下 <code>this</code> 绑定到 <code>undefined</code> （因为严格模式不允许 <code>this</code> 指向全局对象）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()             <span class="comment">// 相当于执行 window.foo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 浏览器中输出: Window 对象</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 <code>a</code> 被声明在全局作用域，成为全局对象 <code>window</code> 的一个同名属性。函数 <code>foo</code> 被执行时，<code>this</code> 此时指向的是全局对象，因此打印出来的 <code>a</code> 是全局对象的属性。</p></blockquote><p>注意有一种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"></span><br><span class="line">bar()              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时 <code>bar</code> 函数，也就是 <code>obj</code> 上的 <code>foo</code> 方法为什么又指向了全局对象呢，是因为 <code>bar</code> 方法此时是作为函数独立调用的，所以此时的场景属于默认绑定，而不是隐式绑定。这种情况和把方法作为回调函数的场景类似：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(obj.foo)              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数传递实际上也是一种隐式的赋值，只不过这里 <code>obj.foo</code> 方法是被隐式赋值给了函数 <code>func</code> 的形参 <code>fn</code>，而之前的情景是自己赋值，两种情景实际上类似。这种场景我们遇到的比较多的是 <code>setTimeout</code> 和 <code>setInterval</code>，如果回调函数不是箭头函数，那么其中的 <code>this</code> 指向的就是全局对象.</li><li>其实我们可以把默认绑定当作是隐式绑定的特殊情况，比如上面的 <code>bar()</code>，我们可以当作是使用 <code>window.bar()</code> 的方式调用的，此时 bar 中的 <code>this</code> 根据隐式绑定的情景指向的就是 <code>window</code>。</li></ul><h3 id="2-this-绑定的优先级"><a href="#2-this-绑定的优先级" class="headerlink" title="2. this 绑定的优先级"></a><strong>2. this 绑定的优先级</strong></h3><blockquote><p><code>this</code> 存在多个使用场景，那么多个场景同时出现的时候，<code>this</code> 到底应该如何指向呢。这里存在一个优先级的概念，<code>this</code> 根据优先级来确定指向。<strong>优先级：new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p></blockquote><p><strong>所以 this 的判断顺序：</strong></p><ul><li><code>new</code> 绑定： 函数是否在 <code>new</code> 中调用？如果是的话 <code>this</code> 绑定的是新创建的对象；</li><li>显式绑定： 函数是否是通过 <code>bind</code>、<code>call</code>、<code>apply</code> 调用？如果是的话，<code>this</code> 绑定的是指定的对象；</li><li>隐式绑定： 函数是否在某个上下文对象中调用？如果是的话，<code>this</code> 绑定的是那个上下文对象；</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象；</li></ul><h3 id="3-箭头函数中的-this"><a href="#3-箭头函数中的-this" class="headerlink" title="3. 箭头函数中的 this"></a><strong>3. 箭头函数中的 this</strong></h3><ul><li>箭头函数 是根据其声明的地方来决定 <code>this</code> 的</li><li>箭头函数的 <code>this</code> 绑定是无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 被修改的，且因为箭头函数没有构造函数 <code>constructor</code>，所以也不可以使用 new 调用，即不能作为构造函数，否则会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()             <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-一个-this-的小练习"><a href="#4-一个-this-的小练习" class="headerlink" title="4. 一个 this 的小练习"></a><strong>4. 一个 this 的小练习</strong></h3><p>用一个小练习来实战一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 20</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li><code>var a = 20</code> 这句在全局变量 <code>window</code> 上创建了个属性 <code>a</code> 并赋值为 <code>20</code>；</li><li>首先执行的是 <code>obj.foo()</code>，这是一个箭头函数，箭头函数不创建新的函数作用域直接沿用语句外部的作用域，因此 <code>obj.foo()</code> 执行时箭头函数中 <code>this</code> 是全局 <code>window</code>，首先打印出 window 上的属性 a 的值 20，箭头函数返回了一个原型上有个值为 <code>50</code> 的属性 <code>a</code> 的函数对象 <code>func</code> 给 <code>bar</code>；</li><li>继续执行的是 <code>bar()</code>，这里执行的是刚刚箭头函数返回的闭包 <code>func</code>，其内部的 <code>this</code> 指向 <code>window</code>，因此 <code>this.a</code> 修改了 <code>window.a</code> 的值为 <code>60</code> 并打印出来；</li><li>然后执行的是 <code>new bar()</code>，根据之前的表述，<code>new</code> 操作符会在 <code>func</code> 函数中创建一个继承了 <code>func</code> 原型的实例对象并用 <code>this</code> 指向它，随后 <code>this.a = 60</code> 又在实例对象上创建了一个属性 <code>a</code>，在之后的打印中已经在实例上找到了属性 <code>a</code>，因此就不继续往对象原型上查找了，所以打印出第三个 <code>60</code>；</li><li>如果把上面例子的箭头函数换成普通函数呢，结果会是什么样？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 40</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><h2 id="闭包与高阶函数"><a href="#闭包与高阶函数" class="headerlink" title="闭包与高阶函数"></a>闭包与高阶函数</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a><strong>1. 闭包</strong></h3><h4 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a><strong>1.1 什么是闭包</strong></h4><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>我们首先来看一个闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line"></span><br><span class="line">baz()            <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><ul><li><code>foo</code> 函数传递出了一个函数 <code>bar</code>，传递出来的 <code>bar</code> 被赋值给 <code>baz</code> 并调用，虽然这时 <code>baz</code> 是在 <code>foo</code> 作用域外执行的，但 <code>baz</code> 在调用的时候可以访问到前面的 <code>bar</code> 函数所在的 <code>foo</code> 的内部作用域。</li><li>由于 <code>bar</code> 声明在 <code>foo</code> 函数内部，<code>bar</code> 拥有涵盖 <code>foo</code> 内部作用域的闭包，使得 <code>foo</code> 的内部作用域一直存活不被回收。一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 <code>JavaScript</code> 的 <code>GC</code>（Garbage Collection）垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 <code>GC</code>，比如本例中 <code>foo()</code> 执行完，因为返回的 <code>bar</code> 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。</li><li>注意： 如果不是必须使用闭包，那么尽量避免创建它，因为闭包在处理速度和内存消耗方面对性能具有负面影响。</li></ul><h4 id="1-2-利用闭包实现结果缓存（备忘模式）"><a href="#1-2-利用闭包实现结果缓存（备忘模式）" class="headerlink" title="1.2 利用闭包实现结果缓存（备忘模式）"></a><strong>1.2 利用闭包实现结果缓存（备忘模式）</strong></h4><blockquote><p>备忘模式就是应用闭包的特点的一个典型应用。比如有个函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多次运行 <code>add()</code> 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。</li><li>所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>ES6</code> 的方式会更优雅一些：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li>备忘函数中用 <code>JSON.stringify</code> 把传给 <code>adder</code> 函数的参数序列化成字符串，把它当做 <code>cache</code> 的索引，将 <code>add</code> 函数运行的结果当做索引的值传递给 <code>cache</code>，这样 <code>adder</code> 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 <code>fn.apply(fn, args)</code>，再返回计算的结果。</li><li>当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：</li><li>缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 <code>n</code> 个；</li><li>在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 <code>cookie</code>、<code>localStorage</code> 等；</li><li>这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。</li><li>复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。</li></ul><blockquote><p>注意： <code>cache</code> 不可以是 <code>Map</code>，因为 <code>Map</code> 的键是使用 <code>===</code> 比较的，因此当传入引用类型值作为键时，虽然它们看上去是相等的，但实际并不是，比如 <code>[1]!==[1]</code>，所以还是被存为不同的键。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  X 错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(args) || cache.set(args, fn.apply(fn, args)).get(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)    <span class="comment">// 3    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2, [ 2 ] =&gt; 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a><strong>2. 高阶函数</strong></h3><blockquote><p>高阶函数就是输入参数里有函数，或者输出是函数的函数。</p></blockquote><h4 id="2-1-函数作为参数"><a href="#2-1-函数作为参数" class="headerlink" title="2.1 函数作为参数"></a><strong>2.1 函数作为参数</strong></h4><blockquote><p>如果你用过 <code>setTimeout</code>、<code>setInterval</code>、<code>ajax</code> 请求，那么你已经用过高阶函数了，这是我们最常看到的场景：回调函数，因为它将函数作为参数传递给另一个函数。</p></blockquote><blockquote><p>比如 <code>ajax</code> 请求中，我们通常使用回调函数来定义请求成功或者失败时的操作逻辑：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">&quot;/request/url&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Array</code>、<code>Object</code>、<code>String</code> 等等基本对象的原型上有很多操作方法，可以接受回调函数来方便地进行对象操作。这里举一个很常用的 <code>Array.prototype.filter()</code> 方法，这个方法返回一个新创建的数组，包含所有回调函数执行后返回 <code>true</code> 或真值的数组元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word.length &gt; <span class="number">6</span></span><br><span class="line">&#125;)  <span class="comment">// 输出: [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数还有一个应用就是钩子，如果你用过 Vue 或者 React 等框架，那么你应该对钩子很熟悉了，它的形式是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 一些操作</span></span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-函数作为返回值"><a href="#2-2-函数作为返回值" class="headerlink" title="2.2 函数作为返回值"></a><strong>2.2 函数作为返回值</strong></h4><blockquote><p>另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要是利用闭包来保持着作用域：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num = num + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder = add()</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)     <span class="comment">// 输出: 1</span></span><br><span class="line">adder(<span class="number">2</span>)     <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h5 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a><strong>1. 柯里化</strong></h5><ul><li>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的原函数变换成接受一个单一参数（原函数的第一个参数）的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。</li><li>核心思想是把多参数传入的函数拆成单（或部分）参数函数，内部再返回调用下一个单（或部分）参数函数，依次处理剩余的参数。</li></ul><p><strong>柯里化有 3 个常见作用：</strong></p><ul><li>参数复用</li><li>提前返回</li><li>延迟计算/运行</li></ul><p>先来看看柯里化的通用实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要记住 ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把剩余参数与当前参数拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用它将一个 <code>sayHello</code> 函数柯里化试试：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg1 = currying(sayHello, <span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">curryingShowMsg1(<span class="number">22</span>, <span class="string">&#x27;苹果&#x27;</span>)           <span class="comment">// 输出: 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg2 = currying(sayHello, <span class="string">&#x27;小衰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">curryingShowMsg2(<span class="string">&#x27;西瓜&#x27;</span>)               <span class="comment">// 输出: 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br></pre></td></tr></table></figure><blockquote><p>更高阶的用法参见：JavaScript 函数式编程技巧 - 柯里化</p></blockquote><h5 id="2-反柯里化"><a href="#2-反柯里化" class="headerlink" title="2. 反柯里化"></a><strong>2. 反柯里化</strong></h5><ul><li>柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</li><li>而反柯里化，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</li></ul><p>先来看看反柯里化的通用实现吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你觉得把函数放在 Function 的原型上不太好，也可以这样：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tar</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        rest.shift()</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">tar, ...argu</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, argu)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单说，函数柯里化就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)              // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3</span>)        // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3, arg4</span>)  // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)(<span class="params">arg4</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argn</span>)   // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)…(<span class="params">argn</span>)</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>而反柯里化就是反过来，增加适用范围，让方法使用场景更大。使用反柯里化, 可以把原生方法借出来，让任何对象拥有原生对象的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(arg1, arg2)        <span class="comment">// =&gt; func(obj, arg1, arg2)</span></span><br></pre></td></tr></table></figure><p><strong>可以这样理解柯里化和反柯里化的区别：</strong></p><ul><li>柯里化是在运算前提前传参，可以传递多个参数；</li><li>反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</li><li>更高阶的用法参见：JavaScript 函数式编程技巧 - 反柯里化</li></ul><h5 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3. 偏函数"></a><strong>3. 偏函数</strong></h5><blockquote><p>偏函数是创建一个调用另外一个部分（参数或变量已预制的函数）的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的逻辑代码，只是根据传入的参数返回其他的函数，返回的函数中才有真正的处理逻辑比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">&#x27;Function&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样就用偏函数快速创建了一组判断对象类型的方法~</p></blockquote><p><strong>偏函数和柯里化的区别：</strong></p><ul><li>柯里化是把一个接受 <code>n</code> 个参数的函数，由原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行，例如：<code>add = (x, y, z) =&gt; x + y + z→curryAdd = x =&gt; y =&gt; z =&gt; x + y + z；</code></li><li>偏函数固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个；</li><li>当一个柯里化函数只接受两次参数时，比如 <code>curry()()</code>，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote><p>在前文我们介绍了面向对象三大特性之继承，本文将主要介绍面向对象六大原则中的单一职责原则（SRP）、开放封闭原则（OCP）、最少知识原则（LKP）。</p></blockquote><blockquote><p>设计原则是指导思想，从思想上给我们指明程序设计的正确方向，是我们在开发设计过程中应该尽力遵守的准则。而设计模式是实现手段，因此设计模式也应该遵守这些原则，或者说，设计模式就是这些设计原则的一些具体体现。要达到的目标就是高内聚低耦合，高内聚是说模块内部要高度聚合，是模块内部的关系，低耦合是说模块与模块之间的耦合度要尽量低，是模块与模块间的关系。</p></blockquote><p><strong>注意</strong>，遵守设计原则是好，但是过犹不及，在实际项目中我们不要刻板遵守，需要根据实际情况灵活运用</p><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1. 单一职责原则 SRP"></a><strong>1. 单一职责原则 SRP</strong></h3><ul><li>单一职责原则 （Single Responsibility Principle, SRP）是指对一个类（方法、对象，下文统称对象）来说，应该仅有一个引起它变化的原因。也就是说，一个对象只做一件事。</li><li>单一职责原则可以让我们对对象的维护变得简单，如果一个对象具有多个职责的话，那么如果一个职责的逻辑需要修改，那么势必会影响到其他职责的代码。如果一个对象具有多种职责，职责之间相互耦合，对一个职责的修改会影响到其他职责的实现，这就是属于模块内低内聚高耦合的情况。负责的职责越多，耦合越强，对模块的修改就越来越危险。</li></ul><p><strong>优点：</strong></p><ul><li>降低单个类（方法、对象）的复杂度，提高可读性和可维护性，功能之间的界限更清晰； 类（方法、对象）之间根据功能被分为更小的粒度，有助于代码的复用；</li><li>缺点： 增加系统中类（方法、对象）的个数，实际上也增加了这些对象之间相互联系的难度，同时也引入了额外的复杂度。</li></ul><h3 id="2-开放封闭原则-OCP"><a href="#2-开放封闭原则-OCP" class="headerlink" title="2. 开放封闭原则 OCP"></a><strong>2. 开放封闭原则 OCP</strong></h3><blockquote><p>开放封闭原则 （Open－Close Principle, OCP）是指一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的，也就是对扩展开放，对修改封闭。</p></blockquote><blockquote><p>当需要增加需求的时候，则尽量通过扩展新代码的方式，而不是修改已有代码。因为修改已有代码，则会给依赖原有代码的模块带来隐患，因此修改之后需要把所有依赖原有代码的模块都测试一遍，修改一遍测试一遍，带来的成本很大，如果是上线的大型项目，那么代价和风险可能更高。</p></blockquote><p><strong>优点</strong>：</p><ul><li>增加可维护性，避免因为修改给系统带来的不稳定性。</li></ul><h3 id="3-最少知识原则-LKP"><a href="#3-最少知识原则-LKP" class="headerlink" title="3. 最少知识原则 LKP"></a><strong>3. 最少知识原则 LKP</strong></h3><ul><li>最少知识原则 （Least Knowledge Principle, LKP）又称为迪米特原则 （Law of Demeter, LOD），一个对象应该对其他对象有最少的了解。</li><li>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li><li>通常为了减少对象之间的联系，是通过引入一个第三者来帮助进行通信，阻隔对象之间的直接通信，从而减少耦合。</li></ul><p><strong>优点：</strong></p><ul><li>降低类（方法、对象）之间不必要的依赖，减少耦合。</li></ul><p><strong>缺点：</strong></p><ul><li>类（方法、对象）之间不直接通信也会经过一个第三者来通信，那么就要权衡引入第三者带来的复杂度是否值得。</li></ul><h1 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到，本节我们一起来学习一下。</li><li>单例模式 （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</li></ul><p>经营游戏单例示例代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ManageGame() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    ManageGame._schedule &#x3D; this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ManageGame.getInstance &#x3D; function() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    return ManageGame._schedule &#x3D; new ManageGame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const schedule1 &#x3D; new ManageGame()</span><br><span class="line">const schedule2 &#x3D; ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line">console.log(schedule1 &#x3D;&#x3D;&#x3D; schedule2)</span><br></pre></td></tr></table></figure><blockquote><p>稍微解释一下，这个构造函数在内部维护（或者直接挂载自己身上）一个实例，第一次执行 new 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。我们可以用 <code>ES6</code> 的 <code>class</code> 语法改造一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> _schedule = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        <span class="keyword">return</span> ManageGame._schedule = <span class="keyword">new</span> ManageGame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        ManageGame._schedule = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schedule1 = <span class="keyword">new</span> ManageGame()</span><br><span class="line"><span class="keyword">const</span> schedule2 = ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(schedule1 === schedule2)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面方法的缺点在于维护的实例作为静态属性直接暴露，外部可以直接修改。</p><p>可以使用闭包或块状作用域隐藏内部变量：</p><p><strong>单例模式赋能</strong></p><blockquote><p>之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据单一职责原则，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p></blockquote><p><strong>惰性单例、懒汉式-饿汉式</strong></p><ul><li>有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用惰性创建，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</li></ul><p><strong>单例模式的优缺点</strong></p><p>单例模式主要解决的问题就是节约资源，保持访问一致性。</p><p><strong>简单分析一下它的优点：</strong></p><ul><li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li><li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li><li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li></ul><p><strong>单例模式也是有缺点的</strong></p><ul><li>单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；</li><li>与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li></ul><p><strong>单例模式的使用场景</strong></p><p>那我们应该在什么场景下使用单例模式呢：</p><ul><li>当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；</li><li>当项目中需要一个公共的状态，那么需要使用单例模式来保证访问一致性；</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>访问者只需要知道产品名，就可以从工厂获得对应实例；</li><li>访问者不关心实例创建过程；</li></ul><p><strong>代码实现</strong></p><blockquote><p>如果你使用过 <code>document.createElement</code> 方法创建过 <code>DOM</code> 元素，那么你已经使用过工厂方法了，虽然这个方法实际上很复杂，但其使用的就是工厂方法的思想：访问者只需提供标签名（如 <code>div</code>、<code>img</code>），那么这个方法就会返回对应的 DOM 元素。</p></blockquote><p>我们可以使用 JavaScript 将上面饭馆例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restaurant</span>(<span class="params">menu</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDin</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDin.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法中这里使用 <code>switch-case</code> 语法，你也可以用 <code>if-else</code>，都可以。</p></blockquote><p>下面使用 ES6 的 class 语法改写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.getMenu(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.getMenu(<span class="string">&#x27;红烧排骨&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>这样就完成了一个工厂模式，但是这个实现有一个问题：工厂方法中包含了很多与创建产品相关的过程，如果产品种类很多的话，这个工厂方法中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应修改在工厂方法，违反了开闭原则，也导致这个工厂方法变得臃肿、高耦合。</li><li>严格上这种实现在面向对象语言中叫做简单工厂模式。适用于产品种类比较少，创建逻辑不复杂的时候使用。</li><li>工厂模式的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类，所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。关于抽象类的有关内容，可以参看抽象工厂模式。</li><li>然而作为灵活的 JavaScript，我们不必如此较真，可以把易变的参数提取出来：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.menuData = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu])</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; type, message &#125; = <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Menu(type, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加菜品种类 */</span></span><br><span class="line">    <span class="function"><span class="title">addMenu</span>(<span class="params">menu, type, message</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.menuData[menu]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.Info(<span class="string">&#x27;已经有这个菜了!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.menuData[menu] = &#123; type, message &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移除菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">removeMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu]) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="built_in">this</span>.message) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restaurant = <span class="keyword">new</span> Restaurant()</span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>, <span class="string">&#x27;鱼香肉丝&#x27;</span>, <span class="string">&#x27; 真香~&#x27;</span>)<span class="comment">// 注册菜品</span></span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;GongBaoJiDin&#x27;</span>, <span class="string">&#x27;宫保鸡丁&#x27;</span>, <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant.getMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant.getMenu(<span class="string">&#x27;HongSaoPaiGu&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li><p>我们还给 Restaurant 类增加了 <code>addMenu/removeMenu</code> 私有方法，以便于扩展。</p></li><li><p>当然这里如果菜品参数不太一致，可以在 <code>addMenu</code> 时候注册构造函数或者类，创建的时候返回 <code>new</code> 出的对应类实例，灵活变通即可。</p><p><strong>工厂模式的优缺点</strong></p></li></ul><p>工厂模式将对象的创建和实现分离，这带来了优点：</p><ul><li>良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下；</li><li>扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则；</li><li>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</li><li>工厂模式的缺点：带来了额外的系统复杂度，增加了抽象性；</li></ul><p><strong>工厂模式的使用场景</strong></p><p>那么什么时候使用工厂模式呢：</p><ul><li>对象的创建比较复杂，而访问者无需知道创建的具体流程；</li><li>处理大量具有相同属性的小对象；</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>抽象工厂 （Abstract Factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。</li><li>我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA、C#、C++ 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。</li></ul><p><strong>代码实现</strong></p><blockquote><p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 <code>new.target</code> 来判断 new 的类，在父类方法中 <code>throw new Error()</code>，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 抽象类，ES6 class 方式 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">operate</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象类，ES5 构造函数方式 */</span></span><br><span class="line"><span class="keyword">var</span> AbstractClass2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 抽象方法，使用原型方式添加 */</span></span><br><span class="line">AbstractClass2.prototype.operate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>下面用 JavaScript 将上面介绍的饭店例子实现一下。</p><p>首先使用原型方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Restaurant</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Restaurant.orderDish = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDing()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;紫菜蛋汤&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZiCaiDanTang()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dish</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象方法 */</span></span><br><span class="line">Dish.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDing</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br><span class="line">使用 <span class="class"><span class="keyword">class</span> 语法改写一下：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">orderDish</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Dish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish0 = <span class="keyword">new</span> Dish()  <span class="comment">// 输出: Error 抽象方法不能调用!</span></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br></pre></td></tr></table></figure><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>抽象模式的优点：</strong></p><blockquote><p>抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；</p></blockquote><p><strong>抽象模式的缺点：</strong></p><ul><li>扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；</li><li>带来了系统复杂度，增加了新的类，和新的继承关系；</li></ul><p><strong>抽象工厂模式的使用场景</strong></p><blockquote><p>如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。</p></blockquote><p> <strong>抽象工厂模式与工厂模式</strong></p><p>工厂模式和抽象工厂模式的区别：</p><ul><li>工厂模式 主要关注单独的产品实例的创建；</li><li>抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；根据场景灵活使用即可。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>建造者模式（Builder Pattern）又称生成器模式，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的构建层与其表示层分离。</p></blockquote><ul><li>在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。</li></ul><p>汽车装配代码模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">function CarBuilder(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">    this.color &#x3D; color</span><br><span class="line">    this.weight &#x3D; weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，轮胎</span><br><span class="line">CarBuilder.prototype.buildTyre &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，发动机</span><br><span class="line">CarBuilder.prototype.buildEngine &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 奔驰厂家，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">function benChiDirector(tyre, engine, param) &#123;</span><br><span class="line">    var _car &#x3D; new CarBuilder(param)</span><br><span class="line">    _car.buildTyre(tyre)</span><br><span class="line">    _car.buildEngine(engine)</span><br><span class="line">    return _car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">var benchi1 &#x3D; benChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>ES6写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">class CarBuilder &#123;</span><br><span class="line">    constructor(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">        this.weight &#x3D; weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，轮胎 *&#x2F;</span><br><span class="line">    buildTyre(type) &#123;</span><br><span class="line">        const tyre &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.tyre &#x3D; tyre</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，发动机 *&#x2F;</span><br><span class="line">    buildEngine(type) &#123;</span><br><span class="line">        const engine &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.engine &#x3D; engine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 指挥者，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">class BenChiDirector &#123;</span><br><span class="line">    constructor(tyre, engine, param) &#123;</span><br><span class="line">        const _car &#x3D; new CarBuilder(param)</span><br><span class="line">        _car.buildTyre(tyre)</span><br><span class="line">        _car.buildEngine(engine)</span><br><span class="line">        return _car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">const benchi1 &#x3D; new BenChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来完成部件的装配</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者，汽车部件厂家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">&#123; color = <span class="string">&#x27;white&#x27;</span>, weight = <span class="string">&#x27;0&#x27;</span> &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，轮胎 */</span></span><br><span class="line">    <span class="function"><span class="title">buildTyre</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tyre = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;小号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用小号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;中号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用中号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;大号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用大号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.tyre = tyre</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，发动机 */</span></span><br><span class="line">    <span class="function"><span class="title">buildEngine</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> engine = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;小马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用小马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;中马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用中马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;大马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用大马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车装配，获得产品实例</span></span><br><span class="line"><span class="keyword">const</span> benchi1 = <span class="keyword">new</span> CarBuilder(&#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">weight</span>: <span class="string">&#x27;1600kg&#x27;</span> &#125;)</span><br><span class="line">    .buildTyre(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    .buildEngine(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(benchi1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line"><span class="comment">//   weight: &quot;1600kg&quot;</span></span><br><span class="line"><span class="comment">//   tyre: Tyre &#123;tyre: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span></span><br><span class="line"><span class="comment">//   engine: Engine &#123;engine: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这样将最终产品的创建流程使用链模式来实现，相当于将指挥者退化，指挥的过程通过链模式让用户自己实现，这样既增加了灵活性，装配过程也一目了然。如果希望扩展产品的部件，那么在建造者上增加部件实现方法，再适当修改链模式即可。</p></blockquote><p><strong>建造者模式的优点：</strong></p><ul><li>使用建造者模式可以使产品的构建流程和产品的表现分离，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节；</li><li>扩展方便，如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；</li><li>更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性；</li></ul><p><strong>建造者模式的缺点：</strong></p><ul><li><p>建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；</p></li><li><p>实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；</p><p><strong>建造者模式的适用场景</strong></p></li><li><p>相同的方法，不同的执行顺序，产生不一样的产品时，可以采用建造者模式；</p></li><li><p>产品的组成部件类似，通过组装不同的组件获得不同产品时，可以采用建造者模式；</p></li></ul><p><strong>建造者模式与工厂模式</strong></p><ul><li>建造者模式和工厂模式最终都是创建一个完整的产品，但是在建造者模式中我们更关心对象创建的过程，将创建对象的方法模块化，从而更好地复用这些模块。</li><li>当然建造者模式与工厂模式也是可以组合使用的，比如建造者中一般会提供不同的部件实现，那么这里就可以使用工厂模式来提供具体的部件对象，再通过指挥者来进行装配。</li></ul><p>** 建造者模式与模版方法模式**</p><ul><li>指挥者的实现可以和模版方法模式相结合。也就是说，指挥者中部件的装配过程，可以使用模版方法模式来固定装配算法，把部件实现方法分为模板方法和基本方法，进一步提取公共代码，扩展可变部分。</li><li>是否采用模版方法模式看具体场景，如果产品的部件装配顺序很明确，但是具体的实现是未知的、灵活的，那么你可以适当考虑是否应该将算法骨架提取出来。</li></ul><h1 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a><strong>三、结构型模式</strong></h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理模式 （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。</p></blockquote><ul><li>代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。</li></ul><p><strong>实例的代码实现</strong></p><p>我们使用 JavaScript 来将上面的明星例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">var</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">ad</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">var</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">reward, ad</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            SuperStar.playAdvertisement(ad)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br></pre></td></tr></table></figure><ul><li>我们可以升级一下，比如如果明星没有档期的话，可以通过经纪人安排档期，当明星有空的时候才让明星来拍广告。这里通过 <code>Promise</code> 的方式来实现档期的安排：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">const</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">ad</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">const</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">scheduleTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;小鲜鲜有空了&#x27;</span>)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;, <span class="number">2000</span>)                        <span class="comment">// 发现明星有空了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">reward, ad</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            ProxyAssistant.scheduleTime()   <span class="comment">// 安排上了</span></span><br><span class="line">                .then(<span class="function">() =&gt;</span> SuperStar.playAdvertisement(ad))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">1000001</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没问题，我们小鲜鲜最喜欢拍广告了！</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line"><span class="comment">// 输出： 小鲜鲜有空了</span></span><br><span class="line"><span class="comment">// 输出： 纯蒸酸牛奶，味道纯纯，尽享纯蒸</span></span><br></pre></td></tr></table></figure><p>这里就简单实现了经纪人对请求的过滤，对明星档期的安排，实现了一个代理对象的基本功能。</p><p><strong>代理模式的优缺点</strong></p><p><strong>代理模式的主要优点有：</strong></p><ul><li>代理对象在访问者与目标对象之间可以起到中介和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将访问者与目标对象分离，在一定程度上降低了系统的耦合度，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则；</li><li>代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（十八线明星就别请经纪人了）</li></ul><p><strong>其他相关模式</strong></p><p>很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。</p><p><strong>代理模式与适配器模式</strong></p><p>代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：</p><ul><li>适配器模式： 主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口；</li><li>代理模式： 提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口；</li></ul><p><strong>代理模式与装饰者模式</strong></p><p>装饰者模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p><ul><li>装饰者模式： 目的是为了方便地给目标对象添加功能，也就是动态地添加功能；</li><li>代理模式： 主要目的是控制其他访问者对目标对象的访问；</li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。</p></blockquote><blockquote><p>享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。</p></blockquote><p>Fly 意为苍蝇，Flyweight 指轻蝇量级，指代对象粒度很小。</p><p><strong>代码实现</strong></p><p>首先假设考生的 ID 为奇数则考的是手动档，为偶数则考的是自动档。如果给所有考生都 new 一个驾考车，那么这个系统中就会创建了和考生数量一致的驾考车对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = <span class="keyword">new</span> ExamCar(candidateId % <span class="number">2</span>)</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 10</span></span><br></pre></td></tr></table></figure><blockquote><p>如果考生很多，那么系统中就会存在更多个驾考车对象实例，假如驾考车对象比较复杂，那么这些新建的驾考车实例就会占用大量内存。这时我们将同种类型的驾考车实例进行合并，手动档和自动档档驾考车分别引用同一个实例，就可以节约大量内存：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manualExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> autoExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = candidateId % <span class="number">2</span> ? manualExamCar : autoExamCar</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 2</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到我们使用 2 个驾考车实例就实现了刚刚 10 个驾考车实例实现的功能。这是仅有 10 个考生的情况，如果有几百上千考生，这时我们节约的内存就比较可观了，这就是享元模式要达到的目的。</p></blockquote><p><strong>享元模式的优缺点</strong></p><p><strong>享元模式的优点：</strong></p><ul><li>由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度；</li><li>外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；</li></ul><p><strong>享元模式的缺点：</strong></p><ul><li>引入了共享对象，使对象结构变得复杂；</li><li>共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；</li></ul><p><strong>享元模式的适用场景</strong></p><ul><li>如果一个程序中大量使用了相同或相似对象，那么可以考虑引入享元模式；</li><li>如果使用了大量相同或相似对象，并造成了比较大的内存开销；</li><li>对象的大多数状态可以被转变为外部状态；</li><li>剥离出对象的外部状态后，可以使用相对较少的共享对象取代大量对象；</li><li>在一些程序中，如果引入享元模式对系统的性能和内存的占用影响不大时，比如目标对象不多，或者场景比较简单，则不需要引入，以免适得其反。</li></ul><p><strong>其他相关模式</strong></p><ul><li>享元模式和单例模式、工厂模式、组合模式、策略模式、状态模式等等经常会一起使用。</li></ul><p><strong>享元模式和工厂模式、单例模式</strong></p><ul><li><p>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</p><p><strong>享元模式和组合模式</strong></p></li><li><p>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</p></li></ul><p><strong>享元模式和策略模式</strong></p><blockquote><p>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p></blockquote><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>适配器模式（Adapter Pattern）又称包装器模式，将一个类（对象）的接口（方法、属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。</li><li>主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说，访问者需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已。</li></ul><p><strong>代码实现</strong></p><p>我们可以实现一下电源适配器的例子，一开始我们使用的中国插头标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chinaPlug.chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><blockquote><p>但是我们出国旅游了，到了日本，需要增加一个日本插头到中国插头的电源适配器，来将我们原来的电源线用起来：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> japanPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;日本插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">japanInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日本插头电源适配器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">japanPlugAdapter</span>(<span class="params">plug</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> plug.japanInPlug()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">japanPlugAdapter(japanPlug).chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><p><strong>适配器模式的优缺点</strong></p><p><strong>适配器模式的优点：</strong></p><ul><li>已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</li><li>可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；</li><li>灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；</li><li>适配器模式的缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。</li></ul><p><strong>适配器模式的适用场景</strong></p><ul><li>当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。</li><li>如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；</li><li>如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；</li></ul><p><strong>其他相关模式</strong></p><blockquote><p>适配器模式和代理模式、装饰者模式看起来比较类似，都是属于包装模式，也就是用一个对象来包装另一个对象的模式，他们之间的异同在代理模式中已经详细介绍了，这里再简单对比一下。</p></blockquote><p><strong>适配器模式与代理模式</strong></p><ul><li>适配器模式： 提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；</li><li>代理模式： 提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；</li></ul><p><strong>适配器模式、装饰者模式与代理模式</strong></p><ul><li>适配器模式： 功能不变，只转换了原有接口访问格式；</li><li>装饰者模式： 扩展功能，原有功能不变且可直接使用；</li><li>代理模式： 原有功能不变，但一般是经过限制访问的；</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>装饰者模式 （Decorator Pattern）又称装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能。</p></blockquote><blockquote><p>本质是功能动态组合，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。</p></blockquote><p>我们可以使用 JavaScript 来将装修房子的例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OriginHouse</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">OriginHouse.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Furniture</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Furniture.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Painting</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Painting.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> house = <span class="keyword">new</span> OriginHouse() <span class="comment">// 毛坯房</span></span><br><span class="line">house = <span class="keyword">new</span> Furniture(house) <span class="comment">// 搬入家具</span></span><br><span class="line">house = <span class="keyword">new</span> Painting(house) <span class="comment">// 墙壁刷漆</span></span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br><span class="line">使用 ES6 的 Class 语法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> house = <span class="keyword">new</span> OriginHouse()</span><br><span class="line">house = <span class="keyword">new</span> Furniture(house)</span><br><span class="line">house = <span class="keyword">new</span> Painting(house)</span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><blockquote><p>是不是感觉很麻烦，装饰个功能这么复杂？我们 JSer 大可不必走这一套面向对象花里胡哨的，毕竟 JavaScript 的优点就是灵活：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="keyword">var</span> originHouse = &#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">furniture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">painting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 搬入家具 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        furniture()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 墙壁刷漆 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        painting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">originHouse.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><p>简洁明了，且更符合前端日常使用的场景。</p><p><strong>装饰者模式的优缺点</strong></p><p><strong>装饰者模式的优点：</strong></p><ul><li>我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下动态地修饰对象，添加功能，装饰者和被装饰者之间松耦合，可维护性好；</li><li>被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；</li><li>装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；</li><li>可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；</li></ul><p><strong>装饰者模式的缺点：</strong></p><ul><li>使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；</li><li>由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐；</li></ul><p><strong>装饰者模式的适用场景</strong></p><ul><li>如果不希望系统中增加很多子类，那么可以考虑使用装饰者模式；</li><li>需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，这时采用装饰者模式可以很好实现；</li><li>当对象的功能要求可以动态地添加，也可以动态地撤销，可以考虑使用装饰者模式；</li></ul><p><strong>其他相关模式</strong> </p><p>** 装饰者模式与适配器模式**</p><blockquote><p>装饰者模式和适配器模式都是属于包装模式，然而他们的意图有些不一样：</p></blockquote><ul><li>装饰者模式： 扩展功能，原有功能还可以直接使用，一般可以给目标对象多次叠加使用多个装饰者；</li><li>适配器模式： 功能不变，但是转换了原有接口的访问格式，一般只给目标对象使用一次；</li></ul><p><strong>装饰者模式与组合模式</strong></p><p>这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰者模式看做是只有一个组件的组合模式。</p><ul><li>装饰者模式： 动态地给对象增加功能；</li><li>组合模式： 管理组合对象和叶子对象，为它们提供一致的操作接口给客户端，方便客户端的使用；</li></ul><p><strong>装饰者模式与策略模式</strong></p><p>装饰者模式和策略模式都包含有许多细粒度的功能模块，但是他们的使用思路不同：</p><ul><li>装饰者模式： 可以递归调用，使用多个功能模式，功能之间可以叠加组合使用；</li><li>策略模式： 只有一层选择，选择某一个功能；</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>外观模式 （Facade Pattern）又叫门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。</p></blockquote><p>外观模式在源码中使用很多，具体可以参考后文中源码阅读部分。</p><p><strong>简化版本的代码： 无人机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uav = &#123;</span><br><span class="line">    <span class="comment">/* 电子调速器 */</span></span><br><span class="line">    diantiao1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 电机 */</span></span><br><span class="line">    dianji1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遥控器 */</span></span><br><span class="line">    controller: &#123;</span><br><span class="line">        <span class="comment">/* 上升 */</span></span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.up()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 前进 */</span></span><br><span class="line">        <span class="function"><span class="title">forward</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 下降 */</span></span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.down()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 左转 */</span></span><br><span class="line">        <span class="function"><span class="title">left</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操纵无人机 */</span></span><br><span class="line">uav.controller.down()    <span class="comment">// 发送下降指令</span></span><br><span class="line">uav.controller.left()    <span class="comment">// 发送左转指令</span></span><br></pre></td></tr></table></figure><p>无人机系统是比较复杂，但是可以看到无人机的操纵却比较简单，正是因为有遥控器这个外观的存在。</p><p><strong>外观模式的优点：</strong></p><ul><li>访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；</li><li>减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；</li><li>通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；</li></ul><p><strong>外观模式的缺点：</strong></p><ul><li>不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；</li><li>不需要或不合理的使用外观会让人迷惑，过犹不及；</li></ul><p><strong>外观模式的适用场景</strong></p><ul><li>维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可；</li><li>你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能；</li><li>团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间；</li><li>如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>外观模式与中介者模式</strong></p><ul><li>外观模式： 封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用；</li><li>中介者模式： 封装子系统间各模块之间的直接交互，松散模块间的耦合；</li></ul><p><strong>外观模式与单例模式</strong></p><blockquote><p>有时候一个系统只需要一个外观，比如之前举的 <code>Axios</code> 的 <code>HTTP</code> 模块例子。这时我们可以将外观模式和单例模式可以一起使用，把外观实现为单例。</p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>组合模式 （Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象</p></blockquote><p><strong>你曾见过的组合模式</strong></p><p>大家电脑里的文件夹结构相比很熟悉了，文件夹下面可以有子文件夹，也可以有文件，子文件夹下面还可以有文件夹和文件，以此类推，共同组成了一个文件树，结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Folder <span class="number">1</span></span><br><span class="line">├── Folder <span class="number">2</span></span><br><span class="line">│   ├── File <span class="number">1.</span>txt</span><br><span class="line">│   ├── File <span class="number">2.</span>txt</span><br><span class="line">│   └── File <span class="number">3.</span>txt</span><br><span class="line">└── Folder <span class="number">3</span></span><br><span class="line">    ├── File <span class="number">4.</span>txt</span><br><span class="line">    ├── File <span class="number">5.</span>txt</span><br><span class="line">    └── File <span class="number">6.</span>txt</span><br></pre></td></tr></table></figure><blockquote><p>文件夹是树形结构的容器节点，容器节点可以继续包含其他容器节点，像树枝上还可以有其他树枝一样；也可以包含文件，不再增加新的层级，就像树的叶子一样处于末端，因此被称为叶节点。本文中，叶节点又称为叶对象，容器节点因为可以包含容器节点和非容器节点，又称为组合对象。</p></blockquote><p><strong>代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的文件夹例子实现一下。</p><p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">var</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(fileOrFolder)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">                child.scan(cb)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">var</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子文件夹，并放入根文件夹</span></span><br><span class="line"><span class="keyword">var</span> foldMarvelMovies = createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldMarvelMovies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldDCMovies = createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldDCMovies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个子文件夹分别添加电影</span></span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>))</span><br><span class="line"></span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line">foldMovies.scan(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + item.name + <span class="string">&#x27; size:&#x27;</span> + item.size + <span class="string">&#x27;GB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来进行改造一下，让我们添加子文件更加直观和方便。对链模式还不熟悉的同学可以看一下后面有一篇单独介绍链模式的文章～</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">const</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹  */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(...fileOrFolder)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">const</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line">  .add(</span><br><span class="line">    createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)),</span><br><span class="line">    createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码比较 JavaScript 特色，如果我们使用传统的类呢，也是可以实现的，下面使用 ES6 的 class 语法来改写一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件夹类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, children</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.children = children</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.push(...fileOrFolder)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        cb(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = <span class="keyword">new</span> Folder(<span class="string">&#x27;电影&#x27;</span>, [</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;漫威英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)]),</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;DC英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><p>在传统的语言中，为了保证叶对象和组合对象的外观一致，还会让他们实现同一个抽象类或接口。</p><p><strong>组合模式的优缺点</strong> <strong>组合模式的优点：</strong></p><ul><li>由于组合对象和叶对象具有同样的接口，因此调用的是组合对象还是叶对象对使用者来说没有区别，使得使用者面向接口编程；</li><li>如果想在组合模式的树中增加一个节点比较容易，在目标组合对象中添加即可，不会影响到其他对象，对扩展友好，符合开闭原则，利于维护；</li></ul><p><strong>组合模式的缺点：</strong></p><ul><li>增加了系统复杂度，如果树中对象不多，则不一定需要使用；</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起；</li></ul><p><strong>组合模式的适用场景</strong></p><ul><li>如果对象组织呈树形结构就可以考虑使用组合模式，特别是如果操作树中对象的方法比较类似时；</li><li>使用者希望统一对待树形结构中的对象，比如用户不想写一堆 if-else 来处理树中的节点时，可以使用组合模式；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>组合模式和职责链模式</strong></p><p>正如前文所说，组合模式是天生实现了职责链模式的。</p><ul><li>组合模式： 请求在组合对象上传递，被深度遍历到组合对象的所有子孙叶节点具体执行；</li><li>职责链模式： 实现请求的发送者和接受者之间的解耦，把多个接受者组合起来形成职责链，请求在链上传递，直到有接受者处理请求为止；</li></ul><p><strong>组合模式和迭代器模式</strong></p><p>组合模式可以结合迭代器模式一起使用，在遍历组合对象的叶节点的时候，可以使用迭代器模式来遍历。</p><p><strong>组合模式和命令模式</strong></p><blockquote><p>命令模式里有一个用法「宏命令」，宏命令就是组合模式和命令模式一起使用的结果，是组合模式组装而成</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li>桥接模式（Bridge Pattern）又称桥梁模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。</li><li>抽象部分和实现部分可能不太好理解，举个例子，香蕉、苹果、西瓜，它们共同的抽象部分就是水果，可以吃，实现部分就是不同的水果实体。再比如黑色手提包、红色钱包、蓝色公文包，它们共同的抽象部分是包和颜色，这部分的共性就可以被作为抽象提取出来。</li></ul><p><strong>实例的代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的变频洗衣机例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Washer</span>(<span class="params">motorType, rollerType, transducerType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">    <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">    <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Washer.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor.run()</span><br><span class="line">    <span class="built_in">this</span>.roller.run()</span><br><span class="line">    <span class="built_in">this</span>.transducer.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Motor</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Motor.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Roller</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Roller.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Transducer</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transducer.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建洗衣机</span></span><br><span class="line"><span class="keyword">var</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br><span class="line">由于产品部件可以独立变化，所以创建新的洗衣机产品就非常容易：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> washerD = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;中功率&#x27;</span>)</span><br><span class="line">washerD.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      中功率变频器开始工作</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到由于洗衣机的结构被分别抽象为几个部件的组合，部件的实例化是在部件类各自的构造函数中完成，因此部件之间的实例化不会相互影响，新产品的创建也变得容易，这就是桥接模式的好处。</p></blockquote><p>下面我们用 ES6 的 Class 语法实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">motorType, rollerType, transducerType</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">        <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">        <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始使用 */</span></span><br><span class="line">    <span class="function"><span class="title">work</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor.run()</span><br><span class="line">        <span class="built_in">this</span>.roller.run()</span><br><span class="line">        <span class="built_in">this</span>.transducer.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Roller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br></pre></td></tr></table></figure><ul><li>如果再精致一点，可以让电机、滚筒、变频器等部件实例继承自各自的抽象类，将面向抽象进行到底，但是桥接模式在 JavaScript 中应用不多，适当了解即可，不用太死扣。</li><li>有时候为了更复用部件，可以将部件的实例化拿出来，对于洗衣机来说一个实体部件当然不能用两次，这里使用皮包的例子：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 皮包 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 展示 */</span></span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="built_in">this</span>.color.show() + <span class="built_in">this</span>.type.show()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.typeType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.typeType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包颜色 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colorType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.colorType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象实例化 */</span></span><br><span class="line"><span class="keyword">const</span> redColor = <span class="keyword">new</span> Color(<span class="string">&#x27;红色&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> walletType = <span class="keyword">new</span> Type(<span class="string">&#x27;钱包&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> briefcaseType = <span class="keyword">new</span> Type(<span class="string">&#x27;公文包&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagA = <span class="keyword">new</span> Bag(walletType, redColor)</span><br><span class="line">bagA.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色钱包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagB = <span class="keyword">new</span> Bag(briefcaseType, redColor)</span><br><span class="line">bagB.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色公文包</span></span><br></pre></td></tr></table></figure><h1 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a><strong>四、行为型模式</strong></h1><p>暂时搞不懂，后续理解</p><h1 id="五、其他模式"><a href="#五、其他模式" class="headerlink" title="五、其他模式"></a><strong>五、其他模式</strong></h1><h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><blockquote><p>在下文中，如果某些内容和你看的某本书或者某个帖子上的不一样，不要惊慌，多看几本书，多打开几个帖子，你会发现每个都不一样，所以模式具体是如何表现并不重要，重要的是，了解这三个模式主要的目的和思想是什么：</p></blockquote><ul><li><code>MVC</code> 模式： 从大锅烩时代进化，引入了分层的概念，但是层与层之间耦合明显，维护起来不容易；</li><li><code>MVP</code> 模式： 在 MVC 基础上进一步解耦，视图层和模型层完全隔离，交互只能通过管理层来进行，问题是更新视图需要管理层手动来进行；</li><li><code>MVVM</code> 模式： 引入双向绑定机制，帮助实现一些更新视图层和模型层的工作，让开发者可以更专注于业务逻辑，相比于之前的模式，可以使用更少的代码量完成更复杂的交互； MVC、MVP、MVVM 模式是我们经常遇到的概念，其中 MVVM 是最常用到的，在实际项目中往往没有严格按照模式的定义来设计的系统，开发中也不一定要纠结自己用的到底是哪个模式，合适的才是最好的。</li></ul><h3 id="1-MVC-（Model-View-Controller）"><a href="#1-MVC-（Model-View-Controller）" class="headerlink" title="1. MVC （Model View Controller）"></a><strong>1. MVC （Model View Controller）</strong></h3><blockquote><p><code>MVC</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、控制器（<code>Controller</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 业务数据的处理和存储，数据更新后更新；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Controller</code> 控制器层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，接受并处理 <code>View</code> 层触发的事件，并在 <code>Model</code> 层的数据状态变动时更新 <code>View</code> 层；</li><li><code>MVC</code> 模式的目的是通过引入 <code>Controller</code> 层来将 <code>Model</code> 层和 <code>View</code> 层分离，分层的引入是原来大锅烩方式的改进，使得系统在可维护性和可读性上有了进步。</li><li><code>MVC</code> 模式提出已经有四十余年，<code>MVC</code> 模式在各个书、各个教程、<code>WIKI</code> 的解释有各种版本，甚至 <code>MVC</code> 模式在不同系统中的具体表现也不同，这里只介绍典型 <code>MVC</code> 模式的思路。</li></ul><blockquote><p>典型思路是 <code>View</code> 层通过事件通知到 <code>Controller</code> 层，<code>Controller</code> 层经过对事件的处理完成相关业务逻辑，要求 <code>Model</code> 层改变数据状态，<code>Model</code> 层再将新数据更新到 <code>View</code>层。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，以通过事件通知 <code>Controller</code> 层，经过处理后修改 <code>Model</code> 层的数据，<code>Model</code> 层使用最新数据更新 <code>View</code>。</p><p>用户也可以直接触发 <code>Controller</code> 去更新 <code>Model</code> 层状态，再更新 View 层</p><p>某些场景下，<code>View</code> 层直接采用观察者/发布订阅模式监听 <code>Model</code> 层的变化，这样 <code>View</code>层和 <code>Model</code> 层相互持有、相互操作，导致紧密耦合，在可维护性上有待提升。由此，<code>MVP</code> 模式应运而生 。</p><h3 id="2-MVP-（Model-View-Presenter）"><a href="#2-MVP-（Model-View-Presenter）" class="headerlink" title="2. MVP （Model View Presenter）"></a><strong>2. MVP （Model View Presenter）</strong></h3><blockquote><p><code>MVP</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、管理层（<code>Presenter</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 只负责存储数据，与 <code>View</code> 呈现无关，也与 <code>UI</code> 处理逻辑无关，发生更新也不用主动通知 <code>View</code>；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Presenter</code> 管理层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，处理 <code>View</code> 层的事件，负责获取数据并将获取的数据经过处理后更新 <code>View</code>；</li><li><code>MVC</code> 模式的 <code>View</code> 层和 <code>Model</code> 层存在耦合，为了解决这个问题，<code>MVP</code> 模式将 <code>View</code> 层和 <code>Model</code> 层解耦，之间的交互只能通过 <code>Presenter</code> 层，实际上，<code>MVP</code> 模式的目的就是将 <code>View</code> 层和 Model 层完全解耦，使得对 <code>View</code> 层的修改不会影响到 <code>Model</code> 层，而对 <code>Model</code> 层的数据改动也不会影响到<code>View</code> 层。</li></ul><blockquote><p>典型流程是 <code>View</code> 层触发的事件传递到 <code>Presenter</code> 层中处理，<code>Presenter</code> 层去操作 <code>Model</code> 层，并且将数据返回给 <code>View</code>层，这个过程中，<code>View</code> 层和 <code>Model</code> 层没有直接联系。而 <code>View</code> 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 <code>Presenter</code> 层来更新自己，被称为「被动视图」。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，<code>View</code> 层通知 <code>Presenter</code> 层，<code>Presenter</code> 层操作 <code>Model</code> 层的数据，<code>Presenter</code> 层获取到数据之后更新 <code>View</code>。</p><ul><li>由于 <code>Presenter</code> 层负责了数据获取、数据处理、交互逻辑、<code>UI</code> 效果等等功能，所以 <code>Presenter</code> 层就变得强大起来，相应的，<code>Model</code> 层只负责数据存储，而 <code>View</code> 层只负责视图，<code>Model</code> 和 <code>View</code> 层的责任纯粹而单一，如果我们需要添加或修改功能模块，只需要修改 <code>Presenter</code> 层就够了。由于 <code>Presenter</code> 层需要调用 <code>View</code> 层的方法更新视图，<code>Presenter</code> 层直接持有 <code>View</code> 层导致了 <code>Presenter</code> 对 <code>View</code> 的依赖。</li></ul><blockquote><p>正如上所说，更新视图需要 <code>Presenter</code> 层直接持有 <code>View</code> 层，并通过调用 <code>View</code> 层中的方法来实现，还是需要一系列复杂操作，有没有什么机制自动去更新视图而不用我们手动去更新呢，所以，<code>MVVM</code> 模式应运而生。</p></blockquote><h3 id="3-MVVM-（Model-View-ViewModel）"><a href="#3-MVVM-（Model-View-ViewModel）" class="headerlink" title="3. MVVM （Model View ViewModel）"></a><strong>3. MVVM （Model View ViewModel）</strong></h3><blockquote><p><code>MVVM</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、视图模型（<code>View-Model</code>）。</p></blockquote><p>和 <code>MVP</code> 模式类似，<code>Model</code> 层和 <code>View</code> 层也被隔离开，彻底解耦，<code>ViewModel</code> 层相当于 <code>Presenter</code> 层，负责绑定 <code>Model</code> 层和 <code>View</code> 层，相比于 <code>MVP</code> 增加了双向绑定机制。</p><blockquote><p><code>MVVM</code> 模式的特征是 <code>ViewModel</code> 层和 <code>View</code> 层采用双向绑定的形式（Binding），<code>View</code> 层的变动，将自动反映在 <code>ViewModel</code> 层，反之亦然。</p></blockquote><ul><li>但是双向绑定给调试和错误定位带来困难，<code>View</code> 层的异常可能是 <code>View</code> 的代码有问题，也有可能是 <code>Model</code> 层的问题。数据绑定使得一个位置的 <code>Bug</code> 被传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li><li>对简单<code>UI</code> 来说，实现 <code>MVVM</code> 模式的开销是不必要的，而对于大型应用来说，引入 MVVM 模式则会节约大量手动更新视图的复杂过程，是否使用，还是看使用场景。</li></ul><p>这是为什么呢，因为 <code>MVVM</code> 模式要求 <code>Model</code> 层和 <code>View</code> 层完全解耦，但是由于 <code>Vue</code> 还提供了 <code>ref</code> 这样的 <code>API</code>，使得 <code>Model</code> 也可以直接持有 <code>View</code>：</p><p>但是大多数帖子都说直接称呼 <code>Vue</code> 为 <code>MVVM</code> 框架，可见这些模式的划分也不是那么严格。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见设计模式&quot;&gt;&lt;a href=&quot;#常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式&quot;&gt;&lt;/a&gt;常见设计模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#1-为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要学习设计模式？&quot;&gt;&lt;/a&gt;1.为什么要学习设计模式？&lt;/h2&gt;&lt;p&gt;在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。&lt;/p&gt;
&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;2-什么是设计模式。&quot;&gt;&lt;a href=&quot;#2-什么是设计模式。&quot; class=&quot;headerlink&quot; title=&quot;2.什么是设计模式。&quot;&gt;&lt;/a&gt;2.什么是设计模式。&lt;/h2&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;h2 id=&quot;3-设计模式的发展历史&quot;&gt;&lt;a href=&quot;#3-设计模式的发展历史&quot; class=&quot;headerlink&quot; title=&quot;3.设计模式的发展历史&quot;&gt;&lt;/a&gt;3.设计模式的发展历史&lt;/h2&gt;&lt;p&gt;设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。&lt;/p&gt;
&lt;p&gt;四人帮把这本书分成两部分：&lt;/p&gt;
&lt;p&gt;第一部分解释面向对象编程的优缺点。&lt;/p&gt;
&lt;p&gt;第二部分是关于 23 个经典设计模式的演变。&lt;/p&gt;
&lt;p&gt;自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。&lt;/p&gt;
&lt;h2 id=&quot;4-设计模式分类&quot;&gt;&lt;a href=&quot;#4-设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;4.设计模式分类&quot;&gt;&lt;/a&gt;4.设计模式分类&lt;/h2&gt;&lt;p&gt;根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来将概述属于这三种类型的 23 种设计模式的主要概念。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>js函数手写</title>
    <link href="https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/"/>
    <id>https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2021-03-04T01:42:38.511Z</updated>
    
    <content type="html"><![CDATA[<p>手写常见js函数，面试必备，多练几遍，争取手撕</p><a id="more"></a><h1 id="手动实现call-apply-bind"><a href="#手动实现call-apply-bind" class="headerlink" title="手动实现call,apply,bind"></a>手动实现call,apply,bind</h1><h2 id="模拟实现call"><a href="#模拟实现call" class="headerlink" title="模拟实现call"></a>模拟实现call</h2><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>r5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h2><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>获取函数中的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    fn(...args);</span><br><span class="line">    fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以广泛应用于异步编程，它可以代替我们传统的回调函数</li><li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li><li>取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。</li><li>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</li></ul><h2 id="Nodejs的EventEmitter"><a href="#Nodejs的EventEmitter" class="headerlink" title="Nodejs的EventEmitter"></a>Nodejs的EventEmitter</h2><p><code>Nodejs</code>的<code>EventEmitter</code>就是观察者模式的典型实现，<code>Nodejs</code>的<code>events</code>模块只提供了一个对象： <code>events.EventEmitter``。EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。</p><blockquote><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p></blockquote><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p><strong>addListener(event, listener)</strong></p><p>为指定事件添加一个监听器，默认添加到监听器数组的尾部。</p><p><strong>removeListener(event, listener)</strong></p><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><p><strong>setMaxListeners(n)</strong></p><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p><p><strong>once(event, listener)</strong></p><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p><p><strong>emit(event, [arg1], [arg2], […])</strong></p><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，调用一次，处理函数为 listener2</span></span><br><span class="line">eventEmitter.once(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="手动实现EventEmitter"><a href="#手动实现EventEmitter" class="headerlink" title="手动实现EventEmitter"></a>手动实现EventEmitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件</span></span><br><span class="line"><span class="comment">// prepend为true表示向事件队列头部添加事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, prepend</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].unshift(listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type] = [listener];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某个事件</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>._events[type]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type] = <span class="built_in">this</span>._events[type].filter(<span class="function"><span class="params">e</span> =&gt;</span> e !== listener &amp;&amp; e.origin !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件，只执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> only = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="built_in">this</span>.addListener(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某类事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大事件监听个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.maxListeners = count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceListener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我只能被执行一次&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我是一个listener&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">&#x27;click&#x27;</span>, onceListener);</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">emitter.removeListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JavaScript自定义事件"><a href="#JavaScript自定义事件" class="headerlink" title="JavaScript自定义事件"></a>JavaScript自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建事件</span></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;myEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册事件监听器</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;myEvent&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、触发事件</span></span><br><span class="line">elem.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><blockquote><p>按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</p></blockquote><h1 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><ul><li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器<code>resize</code></li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="简单版："><a href="#简单版：" class="headerlink" title="简单版："></a>简单版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a><strong>局限性：</strong></h3><ul><li>他无法实现对函数 、RegExp等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用,会报错</li></ul><h3 id="面试版-递归"><a href="#面试版-递归" class="headerlink" title="面试版:递归"></a>面试版:递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">let res </span><br><span class="line">&#x2F;&#x2F; 判断是否是简单数据类型</span><br><span class="line">if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">&#x2F;&#x2F; 复杂数据类型</span><br><span class="line">res &#x3D; object.constructor &#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">res[i] &#x3D; typeof obj[i] &#x3D;&#x3D; &quot;object&quot; ? deepCopy(obj[i]) : obj[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 简单数据类型 直接 &#x3D;&#x3D; 赋值</span><br><span class="line">res &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组去重、扁平、最值"><a href="#数组去重、扁平、最值" class="headerlink" title="数组去重、扁平、最值"></a>数组去重、扁平、最值</h1><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique (array) &#123;</span><br><span class="line">    let container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-filter"><a href="#indexOf-filter" class="headerlink" title="indexOf + filter"></a>indexOf + filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return  [...new Set(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>递归调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用reduce简化"><a href="#使用reduce简化" class="headerlink" title="使用reduce简化"></a>使用reduce简化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(</span><br><span class="line">        (target, current) =&gt; <span class="built_in">Array</span>.isArray(current) ? target.concat(flatten(current)) : target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_flat = arr.flat(<span class="literal">Infinity</span>);</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ary &#x3D; arr.toSting()).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;).split(&#39;,&#39;);</span><br></pre></td></tr></table></figure><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n));</span><br></pre></td></tr></table></figure><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null, array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">        target.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组乱序-洗牌算法"><a href="#数组乱序-洗牌算法" class="headerlink" title="数组乱序-洗牌算法"></a>数组乱序-洗牌算法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disorder</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> current = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> random;</span><br><span class="line">    <span class="keyword">while</span> (current &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">        [array[current], array[random]] = [array[random], array[current]];</span><br><span class="line">        current--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args &#x3D; []) &#123;</span><br><span class="line">    let length &#x3D; fn.length;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        newArgs &#x3D; args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">        if (newArgs.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function multiFn(a, b, c) &#123;</span><br><span class="line">    return a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var multi &#x3D; curry(multiFn);</span><br><span class="line"></span><br><span class="line">multi(2)(3)(4);</span><br><span class="line">multi(2,3,4);</span><br><span class="line">multi(2)(3,4);</span><br><span class="line">multi(2,3)(4)</span><br></pre></td></tr></table></figure><h3 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const curry &#x3D; (fn, arr &#x3D; []) &#x3D;&gt; (...args) &#x3D;&gt; (</span><br><span class="line">  arg &#x3D;&gt; arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, arg)</span><br><span class="line">)([...arr, ...args])</span><br><span class="line"></span><br><span class="line">let curryTest&#x3D;curry((a,b,c,d) &#x3D;&gt; a + b + c + d)</span><br><span class="line">curryTest(1,2,3)(4) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(4)(3) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(3,4) &#x2F;&#x2F; 返回10</span><br></pre></td></tr></table></figure><h3 id="简单写法版"><a href="#简单写法版" class="headerlink" title="简单写法版"></a>简单写法版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, ...args) &#123;</span><br><span class="line">    if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span><br><span class="line">    return fn(...args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回currying函数</span><br><span class="line">    return (...args2) &#x3D;&gt; currying(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手动实现JSONP"><a href="#手动实现JSONP" class="headerlink" title="手动实现JSONP"></a>手动实现JSONP</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p><ul><li>1.将传入的data数据转化为url字符串形式</li><li>2.处理url中的回调函数</li><li>3.创建一个script标签并插入到页面中</li><li>4.挂载回调函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp &#x3D; function (url, data, callback) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        &#x2F;&#x2F; 例子&#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">        var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">        &#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">        dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.$jsonp &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用script属性</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">&#x27;http://xxx&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="模拟实现promise"><a href="#模拟实现promise" class="headerlink" title="模拟实现promise"></a>模拟实现promise</h1><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="手动实现ES5继承"><a href="#手动实现ES5继承" class="headerlink" title="手动实现ES5继承"></a>手动实现ES5继承</h1><p>Child继承Parent</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote><p>子类的原型指向父类。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p><h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><blockquote><p>在子类构造函数中调用父类构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>使用构造继承继承父类参数，使用原型继承继承父类函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><blockquote><p>将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure><h2 id="寄生组合继承优化"><a href="#寄生组合继承优化" class="headerlink" title="寄生组合继承优化"></a>寄生组合继承优化</h2><p>父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>最推荐的一种方式，接近完美的继承。</p><h1 id="手动实现instanceof"><a href="#手动实现instanceof" class="headerlink" title="手动实现instanceof"></a>手动实现instanceof</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>按照target原型链的向上查找，直到找到 origin 或 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = target.__proto__;</span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.prototype == proto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myInstanceof(proto, origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Promise的ajax封装"><a href="#基于Promise的ajax封装" class="headerlink" title="基于Promise的ajax封装"></a>基于Promise的ajax封装</h1><p>基于把原生<code>ajax</code>封装为<code>Promise</code>形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">const</span> paramString = getStringParam(param);</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;get&#x27;</span> &amp;&amp; paramString) &#123;</span><br><span class="line">        url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? url += paramString : url += <span class="string">`?<span class="subst">$&#123;paramString&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = &#123;</span><br><span class="line">                status: xhr.status,</span><br><span class="line">                statusText: xhr.statusText,</span><br><span class="line">                headers: xhr.getAllResponseHeaders(),</span><br><span class="line">                data: xhr.response || xhr.responseText</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="comment">// 跨域携带cookie</span></span><br><span class="line">        xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求出错&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.timeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求超时&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求被终止&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        xhr.send(paramString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringParam</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> param) &#123;</span><br><span class="line">    dataString += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;param[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在合适的时候才创建对像，并且只创建唯一的一个。创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。使用闭包实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Singleton (name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Single.getInstance &#x3D; (function(name) &#123;</span><br><span class="line">let instance;</span><br><span class="line">return function(name) &#123;</span><br><span class="line">if (!instance) &#123;</span><br><span class="line">instance &#x3D; new Singleton(name);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a &#x3D; Singleton.getInstance(&#39;ConardLi&#39;);</span><br><span class="line">var b &#x3D; Singleton.getInstance(&#39;ConardLi2&#39;);</span><br><span class="line"></span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><blockquote><p>另一种实现方式，核心要点: 用闭包和Proxy属性拦截</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">      <span class="title">constructor</span> (<span class="params">target, args</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="built_in">Reflect</span>.constructor(fun, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步循环打印"><a href="#异步循环打印" class="headerlink" title="异步循环打印"></a>异步循环打印</h1><p>使用<code>promise + async await</code>实现异步循环打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(i);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><h2 id="监听图片高度"><a href="#监听图片高度" class="headerlink" title="监听图片高度"></a>监听图片高度</h2><p>图片，用一个其他属性存储真正的图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="built_in">window</span>.innerHeight; <span class="comment">//可见区域高度</span></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; img.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">        <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><blockquote><p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">    <span class="keyword">let</span> lazyImageObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> lazyImage = entry.target;</span><br><span class="line">            <span class="comment">// 如果元素可见            </span></span><br><span class="line">            <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyImage.getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                    lazyImage.src = lazyImage.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; img.length; i++) &#123;</span><br><span class="line">        lazyImageObserver.observe(img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟Object-create"><a href="#模拟Object-create" class="headerlink" title="模拟Object.create"></a>模拟Object.create</h1><blockquote><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个JSON-stringify"><a href="#实现一个JSON-stringify" class="headerlink" title="实现一个JSON.stringify"></a>实现一个JSON.stringify</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是字符串 undefined 和 function 类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">            obj = <span class="string">&#x27;&quot;&#x27;</span> + obj + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// JSON为空数组</span></span><br><span class="line">        <span class="keyword">let</span> json = []</span><br><span class="line">        <span class="comment">// 是否为数组</span></span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">let</span> v = obj[k];</span><br><span class="line">            <span class="keyword">let</span> type = <span class="keyword">typeof</span> v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">                v = <span class="string">&#x27;&quot;&#x27;</span> + v + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                v = jsonStringify(v);</span><br><span class="line">            &#125;</span><br><span class="line">            json.push((arr ? <span class="string">&quot;&quot;</span> : <span class="string">&#x27;&quot;&#x27;</span> + k + <span class="string">&#x27;&quot;:&#x27;</span>) + <span class="built_in">String</span>(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonStringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;) <span class="comment">// &quot;&#123;&quot;x&quot;:5&#125;&quot;</span></span><br><span class="line">jsonStringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]) <span class="comment">// &quot;[1,&quot;false&quot;,false]&quot;</span></span><br><span class="line">jsonStringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;) <span class="comment">// &quot;&#123;&quot;b&quot;:&quot;undefined&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="实现一个JSON-parse"><a href="#实现一个JSON-parse" class="headerlink" title="实现一个JSON.parse"></a>实现一个JSON.parse</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text[, reviver])</span><br></pre></td></tr></table></figure><blockquote><p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p></blockquote><h2 id="方法1：直接调用-eval"><a href="#方法1：直接调用-eval" class="headerlink" title="方法1：直接调用 eval"></a>方法1：直接调用 eval</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function jsonParse(opt) &#123;</span><br><span class="line">    return eval(&#39;(&#39; + opt + &#39;)&#39;);</span><br><span class="line">&#125;</span><br><span class="line">jsonParse(jsonStringify(&#123;x : 5&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; x: 5&#125;</span><br><span class="line">jsonParse(jsonStringify([1, &quot;false&quot;, false]))</span><br><span class="line">&#x2F;&#x2F; [1, &quot;false&quot;, falsr]</span><br><span class="line">jsonParse(jsonStringify(&#123;b: undefined&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; b: &quot;undefined&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p></blockquote><p>如果你只想记这个方法，就得对参数json做校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json</span><br><span class="line">            .replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：Function"><a href="#方法2：Function" class="headerlink" title="方法2：Function"></a>方法2：Function</h2><blockquote><p>核心：Function与eval有相同的字符串参数特性</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var func = new Function(arg1, arg2, ..., functionBody);</span><br></pre></td></tr></table></figure><p>在转换JSON的实际应用中，只需要这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> json = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))();</span><br></pre></td></tr></table></figure><blockquote><p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p></blockquote><h1 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line">parseParam(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">        <span class="comment">// 分割 key 和 value</span></span><br><span class="line">        <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 递归调用解码</span></span><br><span class="line">        val = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="comment">// 判断是否转为数字</span></span><br><span class="line">        val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">            paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">        paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板引擎实现"><a href="#模板引擎实现" class="headerlink" title="模板引擎实现"></a>模板引擎实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template &#x3D; &#39;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;姓名&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); &#x2F;&#x2F; 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">     <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        template = template.replace(reg, data[name]);</span><br><span class="line">        <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="转化为驼峰命名"><a href="#转化为驼峰命名" class="headerlink" title="转化为驼峰命名"></a>转化为驼峰命名</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span></span><br><span class="line"><span class="comment">// 转化为 getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 首字母大写</span></span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找字符串中出现最多的字符和个数"><a href="#查找字符串中出现最多的字符和个数" class="headerlink" title="查找字符串中出现最多的字符和个数"></a>查找字符串中出现最多的字符和个数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 自己用哈希表</span></span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.replace(re, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">num &lt; $<span class="number">0.</span>length</span>)</span>&#123;</span><br><span class="line">        num = $<span class="number">0.</span>length;</span><br><span class="line">        char = $<span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><blockquote><p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p></blockquote><p>暴力解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var strStr &#x3D; function(haystack, needle) &#123;</span><br><span class="line">    let m &#x3D;  haystack.length;</span><br><span class="line">    let n &#x3D; needle.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt;&#x3D; m - n; i++) &#123;</span><br><span class="line">        let j;</span><br><span class="line">        for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (needle[j] !&#x3D;&#x3D; haystack[i + j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; needle子串全都匹配了</span><br><span class="line">        if (j &#x3D;&#x3D;&#x3D; n) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; haystack中不存在needle</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = -<span class="number">1</span>, n = haystack.length, p = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="built_in">Array</span>(p).fill(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算next数组</span></span><br><span class="line">    calNext(needle, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; -<span class="number">1</span> &amp;&amp; needle[k + <span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">            <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] == haystack[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == p - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数- 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calNext</span>(<span class="params">needle, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>, p = -<span class="number">1</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; -<span class="number">1</span> &amp;&amp; needle[p + <span class="number">1</span>] != needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p + <span class="number">1</span>] == needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 位置j处更新最长前缀</span></span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>马拉车水平不够</p><h1 id="实现千位分隔符"><a href="#实现千位分隔符" class="headerlink" title="实现千位分隔符"></a>实现千位分隔符</h1><p>正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    return (n + &#39;&#39;).replace(&#x2F;(?!^)(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g, &#39;.&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    let ans &#x3D; &quot;&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        let cur &#x3D; n % 10;</span><br><span class="line">        n &#x3D; Math.floor(n &#x2F; 10);</span><br><span class="line">        ans +&#x3D; cur;</span><br><span class="line">        count++;</span><br><span class="line">        if (count % 3 &#x3D;&#x3D; 0 &amp;&amp; n) &#123;</span><br><span class="line">            ans +&#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (n);</span><br><span class="line">    return ans.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断是否是电话号码"><a href="#判断是否是电话号码" class="headerlink" title="判断是否是电话号码"></a>判断是否是电话号码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isPhone(tel) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;</span><br><span class="line">    return regx.test(tel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证是否是邮箱"><a href="#验证是否是邮箱" class="headerlink" title="验证是否是邮箱"></a>验证是否是邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEmail(email) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^([a-zA-Z0-9_\-]+@([a-zA-Z0-9_\-]+)+$&#x2F;;</span><br><span class="line">    return regx.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用ES5实现数组的map方法"><a href="#用ES5实现数组的map方法" class="headerlink" title="用ES5实现数组的map方法"></a>用ES5实现数组的map方法</h1><ul><li>回调函数的参数有哪些，返回值如何处理</li><li>不修改原来的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.MyMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 由于是ES5所以就不用...展开符了</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> mappedArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        mappedArr.push(fn.call(context, arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用ES5实现数组的reduce方法"><a href="#用ES5实现数组的reduce方法" class="headerlink" title="用ES5实现数组的reduce方法"></a>用ES5实现数组的reduce方法</h1><ul><li>初始值不传怎么处理</li><li>回调函数的参数有哪些，返回值如何处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce &#x3D; function(fn, initialValue) &#123;</span><br><span class="line">    let arr &#x3D; Array.prototpye.slice.call(this);</span><br><span class="line">    let res, startIndex;</span><br><span class="line">    res &#x3D; initialValue ? initialValue : arr[0];</span><br><span class="line">    startIndex &#x3D; initialValue ? 0 : 1;</span><br><span class="line">    for (let i &#x3D; startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res &#x3D; fn.call(null, res, arr[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于普通函数，绑定this指向</li><li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li></ul><h1 id="请实现一个-add-函数，满足以下功能"><a href="#请实现一个-add-函数，满足以下功能" class="headerlink" title="请实现一个 add 函数，满足以下功能"></a>请实现一个 add 函数，满足以下功能</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> fn_args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">returm args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒"><a href="#实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒" class="headerlink" title="实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒"></a>实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sleep &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">return new Promise(resolve &#x3D;&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(1000).then(() &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 这里写你的函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="实现-5-add-3-minus-2-功能"><a href="#实现-5-add-3-minus-2-功能" class="headerlink" title="实现 (5).add(3).minus(2) 功能"></a>实现 (5).add(3).minus(2) 功能</h1><blockquote><p>例： 5 + 3 - 2，结果为 6</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个双向绑定"><a href="#实现一个双向绑定" class="headerlink" title="实现一个双向绑定"></a>实现一个双向绑定</h1><p><strong>defineProperty 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">Object.defineProperty(data, &#39;text&#39;, &#123;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">set(newVal) &#123;</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">data.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>proxy 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">set(target, key, value) &#123;</span><br><span class="line">target[key] &#x3D; value;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(data, handler);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图更改 --&gt; 数据变化</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">proxy.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Array-isArray-实现"><a href="#Array-isArray-实现" class="headerlink" title="Array.isArray 实现"></a>Array.isArray 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.myIsArray &#x3D; function(o) &#123;</span><br><span class="line">return Object.prototype.toString.call(Object(o)) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Array.myIsArray([])); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="实现一个函数判断数据类型"><a href="#实现一个函数判断数据类型" class="headerlink" title="实现一个函数判断数据类型"></a>实现一个函数判断数据类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    <span class="comment">// 对象类型 &quot;[object XXX]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="string">&#x27;[object &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase() : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getType(<span class="literal">null</span>); <span class="comment">// -&gt; null</span></span><br><span class="line">getType(<span class="literal">undefined</span>); <span class="comment">// -&gt; undefined</span></span><br><span class="line">getType(&#123;&#125;); <span class="comment">// -&gt; object</span></span><br><span class="line">getType([]); <span class="comment">// -&gt; array</span></span><br><span class="line">getType(<span class="number">123</span>); <span class="comment">// -&gt; number</span></span><br><span class="line">getType(<span class="literal">true</span>); <span class="comment">// -&gt; boolean</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// -&gt; string</span></span><br><span class="line">getType(<span class="regexp">/123/</span>); <span class="comment">// -&gt; regexp</span></span><br><span class="line">getType(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// -&gt; date</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;手写常见js函数，面试必备，多练几遍，争取手撕&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
</feed>
