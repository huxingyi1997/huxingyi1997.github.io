<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hxy的博客</title>
  
  <subtitle>Mia san Mia!</subtitle>
  <link href="https://hxy1997.xyz/atom.xml" rel="self"/>
  
  <link href="https://hxy1997.xyz/"/>
  <updated>2020-10-28T03:40:37.811Z</updated>
  <id>https://hxy1997.xyz/</id>
  
  <author>
    <name>hxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise async Generator实现原理解析</title>
    <link href="https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://hxy1997.xyz/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-10-29T16:00:00.000Z</published>
    <updated>2020-10-28T03:40:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://juejin.im/post/6844904096525189128">https://juejin.im/post/6844904096525189128</a> </p><p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：</p><ol><li><p><code>Promise</code>的实现原理</p></li><li><p><code>async/await</code>的实现原理</p></li><li><p><code>Generator</code>的实现原理</p></li></ol><a id="more"></a><h1 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h1><p>在成文过程中，笔者查阅了很多讲解Promise实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段Promise规范翻译，有的在Promise基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p><p>回归正题，文章开头我们先点一下Promise为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个Promise：</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个Promise实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入resolve, reject函数参数</span></span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>观察这个例子，我们分析Promise的调用流程：</p><ul><li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个executor回调</li><li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li><li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li><li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li></ul><p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在Promise里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出Promise的大致形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// then收集的执行成功的回调队列</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// then收集的执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 从成功队列里取出回调依次执行</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._resolveQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._rejectQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码我们可以测试一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// 一秒后输出result</span></span><br></pre></td></tr></table></figure><p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在then方法的回调里取得异步操作的返回值，但我们这个Promise离最终实现还有很长的距离，下面我们来一步步补充这个Promise：</p><h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版Promise，但我们会看到很多文章和我们写的不一样，他们的Promise实现中还引入了各种状态控制，这是由于ES6的Promise实现需要遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对Promise的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p><blockquote><ol><li>Promise本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li><li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。</li></ol></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2018/2/26/161d2454e68ff07b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>根据规范，我们补充一下Promise的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规范的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">            <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._resolveQueue.length</span>)</span> &#123;    </span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">            <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">            <span class="function"><span class="title">while</span>(<span class="params"><span class="built_in">this</span>._rejectQueue.length</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                callback(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-then的链式调用"><a href="#3-then的链式调用" class="headerlink" title="3. then的链式调用"></a>3. then的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是Promise实现的重点和难点，我们先来看一下then是如何链式调用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">        return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(2)</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">     &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">        return 3</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们思考一下如何实现这种链式调用：</p><ol><li>显然<code>.then()</code>需要返回一个Promise，这样才能找到then方法，所以我们会把then方法的返回值包装成Promise。</li><li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li><li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间return了一个Promise，但执行顺序仍要保证是1-&gt;2-&gt;3。我们要等待当前Promise状态变更后，再执行下一个then收集的回调，这就要求我们对then的返回值分类讨论</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法改进</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                <span class="comment">//分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                <span class="comment">//这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span></span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reject同理</span></span><br><span class="line">        <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就能测试一下链式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p><ol><li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是function，那么我们应该忽略它。如果没有忽略，当then()回调不为function时将会抛出异常，导致链式调用中断</li><li><strong>处理状态为resolve/reject的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把then()回调push进resolve/reject的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行then回调：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span>? reason.message:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">            <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">            <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reject同理</span></span><br><span class="line">    <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">            <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">            <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">            fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了then的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor是异步任务</strong>的前提上的，如果executor是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve的执行跑到then之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个setTimeout，让它异步执行。</p><blockquote><p>这里插一句，有关这个setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实Promise的默认实现是放进了微任务队列，我们的实现（包括大多数Promise手动实现和polyfill的转化）都是使用setTimeout放入了宏任务队列（当然我们也可以用MutationObserver模拟微任务）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">        this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">        this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">        this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">        let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">                &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">                while(this._resolveQueue.length) &#123;    </span><br><span class="line">                    const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 实现同resolve</span><br><span class="line">        let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">            const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">                if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">                this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">                this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">                while(this._rejectQueue.length) &#123;</span><br><span class="line">                    const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(run)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">    then(resolveFn, rejectFn) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">        typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">        typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">        throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">        &#125; : null</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return一个新的promise</span><br><span class="line">        return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">        const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">                let x &#x3D; resolveFn(value)</span><br><span class="line">                &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">                x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; reject同理</span><br><span class="line">            const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x &#x3D; rejectFn(error)</span><br><span class="line">                    x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (this._status) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">                case PENDING:</span><br><span class="line">                    this._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    this._rejectQueue.push(rejectedFn)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">                case FULFILLED:</span><br><span class="line">                    fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">                    break;</span><br><span class="line">                case REJECTED:</span><br><span class="line">                    rejectedFn(this._value)</span><br><span class="line">                    break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下这个Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)          <span class="comment">//同步executor测试</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>          <span class="comment">//链式调用测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then()             <span class="comment">//值穿透测试</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">3</span>)      <span class="comment">//返回Promise测试</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;reject测试&#x27;</span>)   <span class="comment">//reject测试</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// Error: reject测试</span></span><br></pre></td></tr></table></figure><p>到这里，我们已经实现了Promise的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote><p><code>catch()方法</code>返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="function"><span class="title">catch</span>(<span class="params">rejectFn</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote><p><code>finally()方法</code>返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。在finally之后，还可以继续then。并且会将值原封不动的传递给后面的then</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">        value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">        reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果return了一个reject状态的Promise，将会改变当前Promise的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变Promise状态，在finally()没有返回reject态Promise或throw错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对Promise的理解，大家可以在各个交流群里直接@我）</p><blockquote><p>参考资料：<a href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p></blockquote><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的resolve方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的reject方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote><p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的all方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    result[i] = val</span><br><span class="line">                    <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                    <span class="function"><span class="title">if</span>(<span class="params">index === promiseArr.length</span>)</span> &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 有一个Promise被reject时，MyPromise的状态变为reject</span></span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                value =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="built_in">this</span>._value = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="built_in">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="built_in">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._resolveQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="built_in">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="built_in">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">this</span>._rejectQueue.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectQueue.shift()</span><br><span class="line">                    callback(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        executor(_resolve, _reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> PENDING:</span><br><span class="line">                    <span class="built_in">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">                    <span class="built_in">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> FULFILLED:</span><br><span class="line">                    fulfilledFn(<span class="built_in">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                    rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="function"><span class="title">catch</span>(<span class="params">rejectFn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">            value =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),             <span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">            reason =&gt; MyPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value <span class="comment">//根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> result = []</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                MyPromise.resolve(p).then(</span><br><span class="line">                    val =&gt; &#123;</span><br><span class="line">                        index++</span><br><span class="line">                        result[i] = val</span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">                            resolve(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的race方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                MyPromise.resolve(p).then(  <span class="comment">//Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                    value =&gt; &#123;</span><br><span class="line">                        resolve(value)        <span class="comment">//注意这个resolve是上边new MyPromise的</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    err =&gt; &#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洋洋洒洒150多行的代码，到这里，我们终于可以给Promise的实现做一个结尾了。我们从一个最简单的Promise使用实例开始，通过对调用流程的分析，根据观察者模式实现了Promise的大致骨架，然后依据Promise/A+规范填充代码，重点实现了then 的链式调用，最后完成了Promise的静态/实例方法。其实Promise实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多Promise细节，因而很难写出一个符合规范的Promise实现，源码的实现过程，其实也是对Promise使用细节重新学习的过程。</p><h1 id="async-await实现"><a href="#async-await实现" class="headerlink" title="async/await实现"></a>async/await实现</h1><p>虽然前边花了这么多篇幅讲Promise的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下async/await的使用意义。 在多个回调依赖的场景中，尽管Promise通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p><blockquote><p>设想一个这样的场景，异步任务a-&gt;b-&gt;c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b不往下执行到c，那么也不是很方便控制</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(a)</span><br><span class="line">    .then(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是如果通过async/await来实现这个场景，可读性和流程控制都会方便不少。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(a);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(b);</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们要如何实现一个async/await呢，首先我们要知道，<strong>async/await实际上是对Generator（生成器）的封装</strong>，是一个语法糖。由于Generator出现不久就被async/await取代了，很多同学对Generator比较陌生，因此我们先来看看Generator的用法：</p><blockquote><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();  <span class="comment">// 获取迭代器</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">gen.next()  <span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>也可以通过给<code>next()</code>传参, 让yield具有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 输出test1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>)  <span class="comment">// 输出test2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>)  <span class="comment">// 输出test3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(<span class="string">&#x27;test1&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test2&#x27;</span>)</span><br><span class="line">gen.next(<span class="string">&#x27;test3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们看到Generator的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用next()就能自动执行下一步</li><li><code>async</code>函数返回值是Promise对象，而Generator返回的是生成器对象</li><li><code>await</code>能够返回Promise的resolve/reject的值</li></ul><p><strong>我们对async/await的实现，其实也就是对应以上三点封装Generator</strong></p><h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个Generator，手动执行是怎样一个流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">        gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出1 2 3</span></span><br></pre></td></tr></table></figure><p>我们也可以通过给<code>gen.next()</code>传值的方式，让yield能返回resolve的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行迭代器</span></span><br><span class="line"><span class="keyword">const</span> gen = myGenerator()</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(val)</span></span><br><span class="line">    gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(val)</span></span><br><span class="line">        gen.next(val).value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(val)</span></span><br><span class="line">            gen.next(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且yield能返回resolve的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen()                     <span class="comment">// 由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;             <span class="comment">// 封装一个方法, 递归执行g.next()</span></span><br><span class="line">        <span class="keyword">var</span> res = g.next(val)           <span class="comment">// 获取迭代器对象，并返回resolve的值</span></span><br><span class="line">        <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value   <span class="comment">// 递归终止条件</span></span><br><span class="line">            res.value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;         <span class="comment">// Promise的then方法是实现自动迭代的前提</span></span><br><span class="line">            _next(val)                    <span class="comment">// 等待Promise完成就自动执行下一个next，并传入resolve的值</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    _next()  <span class="comment">//第一次执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们之前的例子，我们就能这样执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>))   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>))   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure><p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个run方法，run方法里我们把执行下一步的操作封装成<code>_next()</code>，每次Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把resolve的值传入<code>gen.next()</code>，使得yield得以返回Promise的resolve的值</p><blockquote><p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield后边除了接Promise，还可以接<code>thunk函数</code>，thunk函数不是一个新东西，所谓thunk函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰Thunk 函数的含义和用法</a>，无论是Promise还是thunk函数，其核心都是通过<strong>传入回调</strong>的方式来实现Generator的自动执行。thunk函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p></blockquote><h2 id="2-返回Promise-amp-异常处理"><a href="#2-返回Promise-amp-异常处理" class="headerlink" title="2.返回Promise &amp; 异常处理"></a>2.返回Promise &amp; 异常处理</h2><p>虽然我们实现了Generator的自动执行以及让yield返回resolve的值，但上边的代码还存在着几点问题：</p><ol><li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟Promise，为了兼容后面跟着基本类型值的情况，我们需要把yield跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li><li><strong>缺少错误处理</strong>：上边代码里的Promise如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的try-catch捕获到</li><li><strong>返回值是Promise</strong>：<code>async/await</code>的返回值是一个Promise，我们这里也需要保持一致，给返回值包一个Promise</li></ol><p>我们改造一下run方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把返回值包装成promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> res = g.next(val) </span><br><span class="line">                &#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err); </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">res.done</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(res.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// res.value包装为promise，以兼容yield后面跟基本类型的情况</span></span><br><span class="line">            <span class="built_in">Promise</span>.resolve(res.value).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    _next(val);</span><br><span class="line">                &#125;, </span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 抛出错误</span></span><br><span class="line">                    g.throw(err)</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        _next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)) </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = run(myGenerator)     <span class="comment">// result是一个Promise</span></span><br><span class="line"><span class="comment">// 输出 1 2 error</span></span><br></pre></td></tr></table></figure><p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下babel对async/await的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于我们的run()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> gen = fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相当于我们的_next()</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;next&#x27;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">&#x27;throw&#x27;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">            _next(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGeneratorStep</span>(<span class="params">gen, resolve, reject, _next, _throw, key, arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">        <span class="keyword">var</span> value = info.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(value).then(_next, _throw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>))   <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>)                    <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)                          <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道await到底是如何暂停执行的，有关await暂停执行的秘密，我们还要到Generator的实现中去寻找答案</p><h1 id="Generator实现"><a href="#Generator实现" class="headerlink" title="Generator实现"></a>Generator实现</h1><p>我们从一个简单的Generator使用实例开始，一步步探究Generator的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result2&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;result3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> gen = foo()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value)</span><br></pre></td></tr></table></figure><p>我们可以在<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel官网</a>上在线转化这段代码，看看ES5环境下是如何实现Generator的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _marked =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">foo$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    _context.next = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    _context.next = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    _context.next = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> _context.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = foo();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br></pre></td></tr></table></figure><p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自facebook的 regenerator 模块，完整代码在<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个runtime有700多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p><blockquote><p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p></blockquote><h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下runtime里mark()方法的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line">runtime.mark = <span class="function"><span class="keyword">function</span>(<span class="params">genFun</span>) </span>&#123;</span><br><span class="line">    genFun.__proto__ = GeneratorFunctionPrototype;</span><br><span class="line">    genFun.prototype = <span class="built_in">Object</span>.create(Gp);</span><br><span class="line">    <span class="keyword">return</span> genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在runtime里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p><h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面babel转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看wrap方法的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">innerFn, outerFn, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = <span class="built_in">Object</span>.create(outerFn.prototype);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> Context([]);</span><br><span class="line">    generator._invoke = makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrap方法先是创建了一个generator，并继承<code>outerFn.prototype</code>；然后new了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后return了generator。<strong>其实wrap()相当于是给generator增加了一个_invoke方法</strong></p><p>这段代码肯定让人产生很多疑问，outerFn.prototype是什么，Context又是什么，makeInvokeMethod又做了哪些操作。下面我们就来一一解答：</p><blockquote><p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p></blockquote><p>这个我们结合一下上面的代码就能知道</p><blockquote><p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ContinueSentinel = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    method: <span class="string">&quot;next&quot;</span>,</span><br><span class="line">    next: <span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    abrupt: <span class="function"><span class="keyword">function</span>(<span class="params">type, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> record = &#123;&#125;;</span><br><span class="line">        record.type = type;</span><br><span class="line">        record.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.complete(record);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span>(<span class="params">record, afterLoc</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (record.type === <span class="string">&quot;return&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.rval = <span class="built_in">this</span>.arg = record.arg;</span><br><span class="line">            <span class="built_in">this</span>.method = <span class="string">&quot;return&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ContinueSentinel;</span><br><span class="line">    &#125;,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.rval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>makeInvokeMethod<code>的定义如下，它return了一个</code>invoke方法<code>，invoke用于判断当前状态和执行下一步，其实就是我们调用的</code>next()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是编译后的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInvokeMethod</span>(<span class="params">innerFn, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态置为start</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">method, arg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已完成</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">&quot;completed&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.method = method;</span><br><span class="line">        context.arg = arg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行中</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            state = <span class="string">&quot;executing&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> record = &#123;</span><br><span class="line">                type: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">                arg: innerFn.call(self, context)    <span class="comment">// 执行下一步,并获取状态(其实就是switch里边return的值)</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.type === <span class="string">&quot;normal&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否已经执行完成</span></span><br><span class="line">                state = context.done ? <span class="string">&quot;completed&quot;</span> : <span class="string">&quot;yield&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ContinueSentinel其实是一个空对象,record.arg === &#123;&#125;则跳过return进入下一个循环</span></span><br><span class="line">                <span class="comment">// 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span></span><br><span class="line">                <span class="keyword">if</span> (record.arg === ContinueSentinel) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// next()的返回值</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: record.arg,</span><br><span class="line">                    done: context.done</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在runtime对于next()的定义中，next()其实就return了_invoke方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for defining the .next, .throw, and .return methods of the</span></span><br><span class="line"><span class="comment">// Iterator interface in terms of a single ._invoke method.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineIteratorMethods</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">    [<span class="string">&quot;next&quot;</span>, <span class="string">&quot;throw&quot;</span>, <span class="string">&quot;return&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">        prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._invoke(method, arg);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure><h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的Generator，然后再回过头看源码，会得到更清晰的认识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.next = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                _context.next = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                _context.next = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版context  </span></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    next:<span class="number">0</span>,</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span> <span class="title">stop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.done = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版invoke</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            value = context.done ? <span class="literal">undefined</span>: gen$(context)</span><br><span class="line">            done = context.done</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value,</span><br><span class="line">                done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试使用</span></span><br><span class="line"><span class="keyword">var</span> g = gen() </span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result1&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result2&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: &quot;result3&quot;, done: false&#125;</span></span><br><span class="line">g.next()  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码并不难理解，我们分析一下调用流程：</p><ol><li>我们定义的<code>function*</code>生成器函数被转化为以上代码</li><li>转化后的代码分为三大块：<ul><li><code>gen$(_context)</code>由yield分割生成器函数代码而来</li><li><code>context对象</code>用于储存函数执行上下文</li><li><code>invoke()方法</code>定义next()，用于执行gen$(_context)来跳到下一步</li></ul></li><li>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果</li><li>当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></li></ol><p>从中我们可以看出，<strong>Generator实现的核心在于<code>上下文的保存</code>，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p><h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关Promise、async/await、Generator的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近9千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对await挂起机制的好奇，后来，从一个 “await是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p><p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在Generator机制上给予的解惑~</p><blockquote><p>前端技匠：<a href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a><br> 神三元：<a href="https://juejin.im/post/6844903702457925640">我如何实现Promise</a><br> winty：<a href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a><br> 冴羽：<a href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator   编译成了什么样子</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自 &lt;a href=&quot;https://juejin.im/post/6844904096525189128&quot;&gt;https://juejin.im/post/6844904096525189128&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;笔者刚接触&lt;code&gt;async/await&lt;/code&gt;时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;的实现原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Promise" scheme="https://hxy1997.xyz/tags/Promise/"/>
    
    <category term="async" scheme="https://hxy1997.xyz/tags/async/"/>
    
    <category term="Generator" scheme="https://hxy1997.xyz/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>JS基础</title>
    <link href="https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/"/>
    <id>https://hxy1997.xyz/2020/10/26/JS%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-26T09:14:39.000Z</published>
    <updated>2020-10-26T13:44:05.898Z</updated>
    
    <content type="html"><![CDATA[<p>这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。</p><a id="more"></a><h2 id="1-如何在ES5环境下实现let"><a href="#1-如何在ES5环境下实现let" class="headerlink" title="1. 如何在ES5环境下实现let"></a>1. 如何在ES5环境下实现let</h2><blockquote><p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p></blockquote><p><img data-src="https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageslim" alt="img"></p><p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数（闭包）来模拟块级作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  for(var i &#x3D; 0; i &lt; 5; i ++)&#123;</span><br><span class="line">    console.log(i)  &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(i)      &#x2F;&#x2F; Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure><p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p><ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li><li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li><li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li><li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li></ul><p>babel的转化，其实只实现了第2、3、5点</p><h2 id="2-如何在ES5环境下实现const"><a href="#2-如何在ES5环境下实现const" class="headerlink" title="2. 如何在ES5环境下实现const"></a>2. 如何在ES5环境下实现const</h2><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p><blockquote><p>Object.defineProperty(obj, prop, desc)</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">obj</td><td align="center">要在其上定义属性的对象</td></tr><tr><td align="center">prop</td><td align="center">要定义或修改的属性的名称</td></tr><tr><td align="center">descriptor</td><td align="center">将被定义或修改的属性描述符</td></tr></tbody></table><table><thead><tr><th align="center">属性描述符</th><th align="left">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">value</td><td align="left">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">get</td><td align="left">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td><td align="center">undefined</td></tr><tr><td align="center">set</td><td align="left">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td><td align="center">undefined</td></tr><tr><td align="center">writable</td><td align="left">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td><td align="center">false</td></tr><tr><td align="center">enumerable</td><td align="left">enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td><td align="center">false</td></tr><tr><td align="center">Configurable</td><td align="left">configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td><td align="center">false</td></tr></tbody></table><p>对于const不可修改的特性，我们通过设置writable属性来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var __const &#x3D; function __const (data, value) &#123;</span><br><span class="line">    window.data &#x3D; value &#x2F;&#x2F; 把要定义的data挂载到window下，并赋值value</span><br><span class="line">    Object.defineProperty(window, data, &#123; &#x2F;&#x2F; 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span><br><span class="line">        enumerable: false,</span><br><span class="line">        configurable: false,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">        return value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (data) &#123;</span><br><span class="line">            if (data !&#x3D;&#x3D; value) &#123; &#x2F;&#x2F; 当要对当前属性进行赋值时，则抛出错误！</span><br><span class="line">            throw new TypeError(&#39;Assignment to constant variable.&#39;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            return value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">_const(&#39;obj&#39;, &#123;a: 1&#125;)   &#x2F;&#x2F; 定义obj</span><br><span class="line">obj.b &#x3D; 2               &#x2F;&#x2F; 可以正常给obj的属性赋值</span><br><span class="line">obj &#x3D; &#123;&#125;                &#x2F;&#x2F; 无法赋值新对象 报错</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://juejin.im/post/6844903848008482824">如何在 ES5 环境下实现一个const ？</a></p><h2 id="3-模拟实现call"><a href="#3-模拟实现call" class="headerlink" title="3. 模拟实现call"></a>3. 模拟实现call</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call() 方法&#96;使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</span><br><span class="line"> 语法：&#96;function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></blockquote><p><code>call()</code>的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：</p><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 执行当前函数</span></span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-模拟实现apply"><a href="#4-模拟实现apply" class="headerlink" title="4. 模拟实现apply"></a>4. 模拟实现apply</h2><blockquote><p>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。<br> 语法：func.apply(thisArg, [argsArray])</p></blockquote><p><code>apply()</code>和<code>call()</code>类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-模拟实现bind"><a href="#5-模拟实现bind" class="headerlink" title="5. 模拟实现bind"></a>5. 模拟实现bind</h2><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br> 语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><p>从用法上看，似乎给call/apply包一层function就实现了bind()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind &#x3D; function(context &#x3D; window, ...args) &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">    this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但我们忽略了三点：</p><ol><li><p>bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数</p></li><li><p>new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例</p></li><li><p>没有保留原函数在原型链上的属性和方法</p></li></ol><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-手写一个防抖函数-debounce"><a href="#6-手写一个防抖函数-debounce" class="headerlink" title="6. 手写一个防抖函数(debounce)"></a>6. 手写一个防抖函数(debounce)</h2><p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p><blockquote><p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function debounce (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存一个定时器id</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">    &#x2F;&#x2F; 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">    &#x2F;&#x2F; 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-手写一个节流函数-throttle"><a href="#7-手写一个节流函数-throttle" class="headerlink" title="7. 手写一个节流函数(throttle)"></a>7. 手写一个节流函数(throttle)</h2><blockquote><p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle(func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; null;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if (!lastTime) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                lastTime &#x3D; null</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>实现方式2：使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">function throttle (func, wait &#x3D; 50) &#123;</span><br><span class="line">    &#x2F;&#x2F; 上一次执行该函数的时间</span><br><span class="line">    let lastTime &#x3D; 0;</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前时间</span><br><span class="line">        let now &#x3D; +new Date()</span><br><span class="line">        &#x2F;&#x2F; 将当前时间和上一次执行函数时间对比</span><br><span class="line">        &#x2F;&#x2F; 如果差值大于设置的等待时间就执行函数</span><br><span class="line">        if (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime &#x3D; now</span><br><span class="line">            func.apply(this, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法：定时器</span><br><span class="line">setInterval(</span><br><span class="line">    throttle(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;, 500),</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="8-数组扁平化"><a href="#8-数组扁平化" class="headerlink" title="8. 数组扁平化"></a>8. 数组扁平化</h2><blockquote><p>对于<code>[1, [1,2], [1,2,3]]</code>这样多层嵌套的数组，我们如何将其扁平化为<code>[1, 1, 2, 1, 2, 3]</code>这样的一维数组呢：</p></blockquote><p><strong>1.直接调用ES6的flat()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">arr.flat(Infinity)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>2.序列化后正则</strong></p><p>把所有<code>[</code>和<code>]</code>去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">const str &#x3D; &#96;[$&#123;JSON.stringify(arr).replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;)&#125;]&#96;</span><br><span class="line">JSON.parse(str)   &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>3.递归</strong><br> 对于树状结构的数据，最直接的处理方式就是递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr) &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>4.reduce()递归</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, [1,2], [1,2,3]]</span><br><span class="line">function flat(arr) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) &#x3D;&gt; &#123;</span><br><span class="line">    return prev.concat(cur instanceof Array ? flat(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3]</span><br></pre></td></tr></table></figure><p><strong>5.迭代+展开运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]</span><br><span class="line">&#x2F;&#x2F; 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并</span><br><span class="line">let arr &#x3D; [1, [1,2], [1,2,3,[4,4,4]]]</span><br><span class="line">while (arr.some(Array.isArray)) &#123;</span><br><span class="line">  arr &#x3D; [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)  &#x2F;&#x2F; [1, 1, 2, 1, 2, 3, 4, 4, 4]</span><br></pre></td></tr></table></figure><h2 id="9-手写一个Promise"><a href="#9-手写一个Promise" class="headerlink" title="9. 手写一个Promise"></a>9. 手写一个Promise</h2><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现一个符合规范的Promise篇幅比较长，建议阅读文章：<a href="https://juejin.im/post/6844904096525189128">异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个部分用来介绍JS基础知识中经常遇到的问题，手写call函数，加深对JS及ES6的理解和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hxy1997.xyz/2020/10/25/hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-24T16:02:39.000Z</published>
    <updated>2020-10-26T06:17:51.766Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。</p><a id="more"></a><h1 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h1><h2 id="1-1-本地安装hexo"><a href="#1-1-本地安装hexo" class="headerlink" title="1.1.本地安装hexo"></a>1.1.本地安装hexo</h2><p>首先保证你电脑上有node环境，这个不懂的可以自定百度。</p><p>控制台输入node -v出现版本号说明安装成功。</p><p>有了node就可以安装hexo了，控制台输入如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure><p>同样控制台输入hexo -v出现版本号说明安装成功。</p><p>然后开始初始化项目，控制台输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>生成的目录：</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node_modules：是依赖包</span><br><span class="line">public：存放的是生成的页面</span><br><span class="line">scaffolds：命令生成文章等的模板</span><br><span class="line">source：用命令创建的各种文章</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml：整个博客的配置</span><br><span class="line">db.json：source解析所得到的</span><br><span class="line">package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure></blockquote><h2 id="1-2-本地运行"><a href="#1-2-本地运行" class="headerlink" title="1.2.本地运行"></a>1.2.本地运行</h2><p>首先在本地跑起来你的代码</p><p>控制台安装hexo-server</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-server</span><br></pre></td></tr></table></figure><p>然后运行 hexo-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<a href="http://localhost:4000/">http://localhost:4000</a>  就可以看到你本定运行的页面了</p><p>这时你可以在本地调试一下你的blog。</p><h2 id="1-3-github配置"><a href="#1-3-github配置" class="headerlink" title="1.3.github配置"></a>1.3.github配置</h2><p>首先要创建一个github账号</p><p>并配置好ssh</p><p>这些不懂的可以自行百度。</p><p>创建一个repo，名称为yourname.github.io, 其中 yourname 是你的github名称，按照这个规则创建github page才会生效。</p><p>修改_config.yml中的git配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:  https:<span class="comment">//github.com/yourname/yourname.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="1-4-部署上传"><a href="#1-4-部署上传" class="headerlink" title="1.4.部署上传"></a>1.4.部署上传</h2><p>在本地安装上传工具</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>依次执行如下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean     //删除上次打包</span><br><span class="line">hexo generate   //打包</span><br><span class="line">hexo deploy    /上传</span><br></pre></td></tr></table></figure><p>这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。</p><p>在浏览器中输入 <a href="https://yourname.github.io/">https://yourname.github.io/</a> 就可以看到你的个人博客了！</p><h2 id="1-5-README-md配置"><a href="#1-5-README-md配置" class="headerlink" title="1.5 README.md配置"></a>1.5 README.md配置</h2><p>1.首先在source文件夹下建立一个README.md</p><p>2.修改_config.yml</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><h1 id="二、绑定二人域名"><a href="#二、绑定二人域名" class="headerlink" title="二、绑定二人域名"></a>二、绑定二人域名</h1><h2 id="2-1购买一个域名"><a href="#2-1购买一个域名" class="headerlink" title="2.1购买一个域名"></a>2.1购买一个域名</h2><p>这里我选择的是阿里云，挑选一个自己喜欢的域名购买。</p><h2 id="2-2域名解析"><a href="#2-2域名解析" class="headerlink" title="2.2域名解析"></a>2.2域名解析</h2><p>进入控制台添加域名解析。</p><p>按照如下规则添加两条记录。</p><p>解析好的域名404，说明域名解析没有问题，接下来进入github进行配置</p><h2 id="2-3-hexo配置"><a href="#2-3-hexo配置" class="headerlink" title="2.3 hexo配置"></a>2.3 hexo配置</h2><p>在本地的博客目录中找到source文件夹。</p><p>新建一个没有后缀名的文件CNAME</p><p>在文件中添加你的域名，如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisq.xyz</span><br></pre></td></tr></table></figure><p>保存后重新生成，并提交你的博客。</p><h2 id="2-4-github配置"><a href="#2-4-github配置" class="headerlink" title="2.4 github配置"></a>2.4 github配置</h2><p>在github中找到你的博客仓库。</p><p>点击<code>Setting</code></p><p>找到<code>Custom domain</code></p><p>输入你的域名点击save</p><p>然后你就可以在浏览器用你的域名愉快的访问啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建一个博客不难，但是网上资料好多坑。我也是一个刚入门小白，可能有些会写错，请在评论指出。但是有经过实战测试的。 我用的博客框架是 hexo，采用 NexT 主题 ，使用 Github 托管页面。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Github" scheme="https://hxy1997.xyz/tags/Github/"/>
    
    <category term="博客" scheme="https://hxy1997.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="https://hxy1997.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hxy1997.xyz/2020/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-25T06:02:29.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><h2 id="1-为什么要学习设计模式？"><a href="#1-为什么要学习设计模式？" class="headerlink" title="1.为什么要学习设计模式？"></a>1.为什么要学习设计模式？</h2><p>在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。</p><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="2-什么是设计模式。"><a href="#2-什么是设计模式。" class="headerlink" title="2.什么是设计模式。"></a>2.什么是设计模式。</h2><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p><p>设计模式主要是为了解决对象的生成和整合问题。</p><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p><h2 id="3-设计模式的发展历史"><a href="#3-设计模式的发展历史" class="headerlink" title="3.设计模式的发展历史"></a>3.设计模式的发展历史</h2><p>设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。</p><p>四人帮把这本书分成两部分：</p><p>第一部分解释面向对象编程的优缺点。</p><p>第二部分是关于 23 个经典设计模式的演变。</p><p>自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。</p><h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.设计模式分类"></a>4.设计模式分类</h2><p>根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p>接下来将概述属于这三种类型的 23 种设计模式的主要概念。</p><a id="more"></a><h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="this、new、bind、call、apply"><a href="#this、new、bind、call、apply" class="headerlink" title="this、new、bind、call、apply"></a>this、new、bind、call、apply</h2><h3 id="1-this-指向的类型"><a href="#1-this-指向的类型" class="headerlink" title="1. this 指向的类型"></a><strong>1. this 指向的类型</strong></h3><h4 id="this-在函数的指向有以下几种场景："><a href="#this-在函数的指向有以下几种场景：" class="headerlink" title="this 在函数的指向有以下几种场景："></a><strong>this 在函数的指向有以下几种场景：</strong></h4><ul><li>作为构造函数被 new 调用；</li><li>作为对象的方法使用；</li><li>作为函数直接调用；</li><li>被 <code>call</code>、<code>apply</code>、<code>bind</code> 调用；</li><li>箭头函数中的 <code>this</code>；</li></ul><h4 id="1-1-new-绑定"><a href="#1-1-new-绑定" class="headerlink" title="1.1 new 绑定"></a><strong>1.1 new 绑定</strong></h4><blockquote><p>函数如果作为构造函数使用 <code>new</code> 调用时， <code>this</code> 绑定的是新创建的构造函数的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()       <span class="comment">// 输出: Foo 实例，this 就是 bar</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上使用 <code>new</code> 调用构造函数时，会依次执行下面的操作：</p></blockquote><ul><li>创建一个新对象；</li><li>构造函数的 <code>prototype</code> 被赋值给这个新对象的 <code>__proto__</code>；</li><li>将新对象赋给当前的 <code>this</code>；</li><li>执行构造函数；</li><li>如果函数没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象，如果返回的不是对象将被忽略；</li></ul><h4 id="1-2-显式绑定"><a href="#1-2-显式绑定" class="headerlink" title="1.2 显式绑定"></a><strong>1.2 显式绑定</strong></h4><blockquote><p>通过 <code>call</code>、<code>apply</code>、<code>bind</code> 我们可以修改函数绑定的 <code>this</code>，使其成为我们指定的对象。通过这些方法的第一个参数我们可以显式地绑定 <code>this</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">category, name, price</span>) </span>&#123;</span><br><span class="line">    foo.call(<span class="built_in">this</span>, name, price)       <span class="comment">// call 方式调用</span></span><br><span class="line">    <span class="comment">// foo.apply(this, [name, price])    // apply 方式调用</span></span><br><span class="line">    <span class="built_in">this</span>.category = category</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Food(<span class="string">&#x27;食品&#x27;</span>, <span class="string">&#x27;汉堡&#x27;</span>, <span class="string">&#x27;5块钱&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &#123;name: &quot;汉堡&quot;, price: &quot;5块钱&quot;, category: &quot;食品&quot;&#125;</span></span><br><span class="line">call 和 apply 的区别是 call 方法接受的是参数列表，而 apply 方法接受的是一个参数数组。</span><br><span class="line"></span><br><span class="line">func.call(thisArg, arg1, arg2, ...)        <span class="comment">// call 用法</span></span><br><span class="line">func.apply(thisArg, [arg1, arg2, ...])     <span class="comment">// apply 用法</span></span><br></pre></td></tr></table></figure><blockquote><p>而 <code>bind</code> 方法是设置 <code>this</code> 为给定的值，并返回一个新的函数，且在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])    <span class="comment">// bind 用法</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> food = &#123;</span><br><span class="line">    name: <span class="string">&#x27;汉堡&#x27;</span>,</span><br><span class="line">    price: <span class="string">&#x27;5块钱&#x27;</span>,</span><br><span class="line">    getPrice: <span class="function"><span class="keyword">function</span>(<span class="params">place</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(place + <span class="built_in">this</span>.price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">food.getPrice(<span class="string">&#x27;KFC &#x27;</span>)   <span class="comment">// 浏览器中输出: &quot;KFC 5块钱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice1 = food.getPrice.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;鸡腿&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;7块钱&#x27;</span> &#125;, <span class="string">&#x27;肯打鸡 &#x27;</span>)</span><br><span class="line">getPrice1()       <span class="comment">// 浏览器中输出: &quot;肯打鸡 7块钱&quot;</span></span><br><span class="line">关于 bind 的原理，我们可以使用 apply 方法自己实现一个 bind 看一下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span>(<span class="params">...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> context = rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, [...rest1, ...rest2])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ES6</code> 方式用了一些 <code>ES6</code> 的知识比如 <code>rest</code> 参数、数组解构</p></blockquote><p><strong>注意：</strong> 如果你把 <code>null</code> 或 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code>、<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="literal">null</span>)         <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind(this)</code>链式调用，实际上后几项未执行，实质上 <code>this</code> 指向第一个绑定</p><h4 id="1-3-隐式绑定"><a href="#1-3-隐式绑定" class="headerlink" title="1.3 隐式绑定"></a>1.3 隐式绑定</h4><blockquote><p>函数是否在某个上下文对象中调用，如果是的话 <code>this</code> 绑定的是那个上下文对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()       <span class="comment">// 浏览器中输出: &quot;world&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，<code>foo</code> 方法是作为对象的属性调用的，那么此时 <code>foo</code> 方法执行时，<code>this</code> 指向 <code>obj</code> 对象。也就是说，此时 <code>this</code> 指向调用这个方法的对象，如果嵌套了多个对象，那么指向最后一个调用这个方法的对象：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="string">&#x27;China&#x27;</span>,</span><br><span class="line">        foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.b.foo()      <span class="comment">// 浏览器中输出: &quot;China&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>最后一个对象是 <code>obj</code> 上的 <code>b</code>，那么此时 <code>foo</code> 方法执行时，其中的 <code>this</code> 指向的就是 <code>b</code> 对象。</p></blockquote><h4 id="1-4-默认绑定"><a href="#1-4-默认绑定" class="headerlink" title="1.4 默认绑定"></a><strong>1.4 默认绑定</strong></h4><blockquote><p>函数独立调用，直接使用不带任何修饰的函数引用进行调用，也是上面几种绑定途径之外的方式。非严格模式下 this 绑定到全局对象（浏览器下是 <code>winodw</code>，<code>node</code> 环境是 <code>global</code>），严格模式下 <code>this</code> 绑定到 <code>undefined</code> （因为严格模式不允许 <code>this</code> 指向全局对象）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()             <span class="comment">// 相当于执行 window.foo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 浏览器中输出: Window 对象</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 <code>a</code> 被声明在全局作用域，成为全局对象 <code>window</code> 的一个同名属性。函数 <code>foo</code> 被执行时，<code>this</code> 此时指向的是全局对象，因此打印出来的 <code>a</code> 是全局对象的属性。</p></blockquote><p>注意有一种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line"></span><br><span class="line">bar()              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此时 <code>bar</code> 函数，也就是 <code>obj</code> 上的 <code>foo</code> 方法为什么又指向了全局对象呢，是因为 <code>bar</code> 方法此时是作为函数独立调用的，所以此时的场景属于默认绑定，而不是隐式绑定。这种情况和把方法作为回调函数的场景类似：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(obj.foo)              <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参数传递实际上也是一种隐式的赋值，只不过这里 <code>obj.foo</code> 方法是被隐式赋值给了函数 <code>func</code> 的形参 <code>fn</code>，而之前的情景是自己赋值，两种情景实际上类似。这种场景我们遇到的比较多的是 <code>setTimeout</code> 和 <code>setInterval</code>，如果回调函数不是箭头函数，那么其中的 <code>this</code> 指向的就是全局对象.</li><li>其实我们可以把默认绑定当作是隐式绑定的特殊情况，比如上面的 <code>bar()</code>，我们可以当作是使用 <code>window.bar()</code> 的方式调用的，此时 bar 中的 <code>this</code> 根据隐式绑定的情景指向的就是 <code>window</code>。</li></ul><h3 id="2-this-绑定的优先级"><a href="#2-this-绑定的优先级" class="headerlink" title="2. this 绑定的优先级"></a><strong>2. this 绑定的优先级</strong></h3><blockquote><p><code>this</code> 存在多个使用场景，那么多个场景同时出现的时候，<code>this</code> 到底应该如何指向呢。这里存在一个优先级的概念，<code>this</code> 根据优先级来确定指向。<strong>优先级：new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p></blockquote><p><strong>所以 this 的判断顺序：</strong></p><ul><li><code>new</code> 绑定： 函数是否在 <code>new</code> 中调用？如果是的话 <code>this</code> 绑定的是新创建的对象；</li><li>显式绑定： 函数是否是通过 <code>bind</code>、<code>call</code>、<code>apply</code> 调用？如果是的话，<code>this</code> 绑定的是指定的对象；</li><li>隐式绑定： 函数是否在某个上下文对象中调用？如果是的话，<code>this</code> 绑定的是那个上下文对象；</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 <code>undefined</code>，否则绑定到全局对象；</li></ul><h3 id="3-箭头函数中的-this"><a href="#3-箭头函数中的-this" class="headerlink" title="3. 箭头函数中的 this"></a><strong>3. 箭头函数中的 this</strong></h3><ul><li>箭头函数 是根据其声明的地方来决定 <code>this</code> 的</li><li>箭头函数的 <code>this</code> 绑定是无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 被修改的，且因为箭头函数没有构造函数 <code>constructor</code>，所以也不可以使用 new 调用，即不能作为构造函数，否则会报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">    foo: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo()             <span class="comment">// 浏览器中输出: &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-一个-this-的小练习"><a href="#4-一个-this-的小练习" class="headerlink" title="4. 一个 this 的小练习"></a><strong>4. 一个 this 的小练习</strong></h3><p>用一个小练习来实战一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 20</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li><code>var a = 20</code> 这句在全局变量 <code>window</code> 上创建了个属性 <code>a</code> 并赋值为 <code>20</code>；</li><li>首先执行的是 <code>obj.foo()</code>，这是一个箭头函数，箭头函数不创建新的函数作用域直接沿用语句外部的作用域，因此 <code>obj.foo()</code> 执行时箭头函数中 <code>this</code> 是全局 <code>window</code>，首先打印出 window 上的属性 a 的值 20，箭头函数返回了一个原型上有个值为 <code>50</code> 的属性 <code>a</code> 的函数对象 <code>func</code> 给 <code>bar</code>；</li><li>继续执行的是 <code>bar()</code>，这里执行的是刚刚箭头函数返回的闭包 <code>func</code>，其内部的 <code>this</code> 指向 <code>window</code>，因此 <code>this.a</code> 修改了 <code>window.a</code> 的值为 <code>60</code> 并打印出来；</li><li>然后执行的是 <code>new bar()</code>，根据之前的表述，<code>new</code> 操作符会在 <code>func</code> 函数中创建一个继承了 <code>func</code> 原型的实例对象并用 <code>this</code> 指向它，随后 <code>this.a = 60</code> 又在实例对象上创建了一个属性 <code>a</code>，在之后的打印中已经在实例上找到了属性 <code>a</code>，因此就不继续往对象原型上查找了，所以打印出第三个 <code>60</code>；</li><li>如果把上面例子的箭头函数换成普通函数呢，结果会是什么样？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a = <span class="number">60</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        func.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo()        <span class="comment">// 浏览器中输出: 40</span></span><br><span class="line">bar()                      <span class="comment">// 浏览器中输出: 60</span></span><br><span class="line"><span class="keyword">new</span> bar()                  <span class="comment">// 浏览器中输出: 60</span></span><br></pre></td></tr></table></figure><h2 id="闭包与高阶函数"><a href="#闭包与高阶函数" class="headerlink" title="闭包与高阶函数"></a>闭包与高阶函数</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a><strong>1. 闭包</strong></h3><h4 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a><strong>1.1 什么是闭包</strong></h4><blockquote><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><p>我们首先来看一个闭包的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo()</span><br><span class="line"></span><br><span class="line">baz()            <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><ul><li><code>foo</code> 函数传递出了一个函数 <code>bar</code>，传递出来的 <code>bar</code> 被赋值给 <code>baz</code> 并调用，虽然这时 <code>baz</code> 是在 <code>foo</code> 作用域外执行的，但 <code>baz</code> 在调用的时候可以访问到前面的 <code>bar</code> 函数所在的 <code>foo</code> 的内部作用域。</li><li>由于 <code>bar</code> 声明在 <code>foo</code> 函数内部，<code>bar</code> 拥有涵盖 <code>foo</code> 内部作用域的闭包，使得 <code>foo</code> 的内部作用域一直存活不被回收。一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 <code>JavaScript</code> 的 <code>GC</code>（Garbage Collection）垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 <code>GC</code>，比如本例中 <code>foo()</code> 执行完，因为返回的 <code>bar</code> 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。</li><li>注意： 如果不是必须使用闭包，那么尽量避免创建它，因为闭包在处理速度和内存消耗方面对性能具有负面影响。</li></ul><h4 id="1-2-利用闭包实现结果缓存（备忘模式）"><a href="#1-2-利用闭包实现结果缓存（备忘模式）" class="headerlink" title="1.2 利用闭包实现结果缓存（备忘模式）"></a><strong>1.2 利用闭包实现结果缓存（备忘模式）</strong></h4><blockquote><p>备忘模式就是应用闭包的特点的一个典型应用。比如有个函数：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多次运行 <code>add()</code> 时，每次得到的结果都是重新计算得到的，如果是开销很大的计算操作的话就比较消耗性能了，这里可以对已经计算过的输入做一个缓存。</li><li>所以这里可以利用闭包的特点来实现一个简单的缓存，在函数内部用一个对象存储输入的参数，如果下次再输入相同的参数，那就比较一下对象的属性，如果有缓存，就直接把值从这个对象里面取出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>ES6</code> 的方式会更优雅一些：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 备忘函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">        <span class="keyword">return</span> cache[key] || (cache[key] = fn.apply(fn, args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复杂计算函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)            <span class="comment">// 输出: 2    当前: cache: &#123; &#x27;[1]&#x27;: 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)            <span class="comment">// 输出: 3    当前: cache: &#123; &#x27;[1]&#x27;: 2, &#x27;[2]&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下：</p><ul><li>备忘函数中用 <code>JSON.stringify</code> 把传给 <code>adder</code> 函数的参数序列化成字符串，把它当做 <code>cache</code> 的索引，将 <code>add</code> 函数运行的结果当做索引的值传递给 <code>cache</code>，这样 <code>adder</code> 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 <code>fn.apply(fn, args)</code>，再返回计算的结果。</li><li>当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：</li><li>缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 <code>n</code> 个；</li><li>在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 <code>cookie</code>、<code>localStorage</code> 等；</li><li>这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。</li><li>复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。</li></ul><blockquote><p>注意： <code>cache</code> 不可以是 <code>Map</code>，因为 <code>Map</code> 的键是使用 <code>===</code> 比较的，因此当传入引用类型值作为键时，虽然它们看上去是相等的，但实际并不是，比如 <code>[1]!==[1]</code>，所以还是被存为不同的键。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  X 错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(args) || cache.set(args, fn.apply(fn, args)).get(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adder = memorize(add)</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">1</span>)    <span class="comment">// 2    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2 &#125;</span></span><br><span class="line">adder(<span class="number">2</span>)    <span class="comment">// 3    cache: &#123; [ 1 ] =&gt; 2, [ 1 ] =&gt; 2, [ 2 ] =&gt; 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2. 高阶函数"></a><strong>2. 高阶函数</strong></h3><blockquote><p>高阶函数就是输入参数里有函数，或者输出是函数的函数。</p></blockquote><h4 id="2-1-函数作为参数"><a href="#2-1-函数作为参数" class="headerlink" title="2.1 函数作为参数"></a><strong>2.1 函数作为参数</strong></h4><blockquote><p>如果你用过 <code>setTimeout</code>、<code>setInterval</code>、<code>ajax</code> 请求，那么你已经用过高阶函数了，这是我们最常看到的场景：回调函数，因为它将函数作为参数传递给另一个函数。</p></blockquote><blockquote><p>比如 <code>ajax</code> 请求中，我们通常使用回调函数来定义请求成功或者失败时的操作逻辑：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">&quot;/request/url&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请求成功！&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Array</code>、<code>Object</code>、<code>String</code> 等等基本对象的原型上有很多操作方法，可以接受回调函数来方便地进行对象操作。这里举一个很常用的 <code>Array.prototype.filter()</code> 方法，这个方法返回一个新创建的数组，包含所有回调函数执行后返回 <code>true</code> 或真值的数组元素。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word.length &gt; <span class="number">6</span></span><br><span class="line">&#125;)  <span class="comment">// 输出: [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数还有一个应用就是钩子，如果你用过 Vue 或者 React 等框架，那么你应该对钩子很熟悉了，它的形式是这样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 一些操作</span></span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-函数作为返回值"><a href="#2-2-函数作为返回值" class="headerlink" title="2.2 函数作为返回值"></a><strong>2.2 函数作为返回值</strong></h4><blockquote><p>另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要是利用闭包来保持着作用域：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num = num + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder = add()</span><br><span class="line"></span><br><span class="line">adder(<span class="number">1</span>)     <span class="comment">// 输出: 1</span></span><br><span class="line">adder(<span class="number">2</span>)     <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h5 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a><strong>1. 柯里化</strong></h5><ul><li>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的原函数变换成接受一个单一参数（原函数的第一个参数）的函数，并且返回一个新函数，新函数能够接受余下的参数，最后返回同原函数一样的结果。</li><li>核心思想是把多参数传入的函数拆成单（或部分）参数函数，内部再返回调用下一个单（或部分）参数函数，依次处理剩余的参数。</li></ul><p><strong>柯里化有 3 个常见作用：</strong></p><ul><li>参数复用</li><li>提前返回</li><li>延迟计算/运行</li></ul><p>先来看看柯里化的通用实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rest1 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    rest1.shift()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要记住 ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...rest1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把剩余参数与当前参数拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, rest1.concat(rest2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用它将一个 <code>sayHello</code> 函数柯里化试试：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name, age, fruit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123;name&#125;</span>,我 <span class="subst">$&#123;age&#125;</span> 岁了, 我喜欢吃 <span class="subst">$&#123;fruit&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg1 = currying(sayHello, <span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">curryingShowMsg1(<span class="number">22</span>, <span class="string">&#x27;苹果&#x27;</span>)           <span class="comment">// 输出: 我叫 小明,我 22 岁了, 我喜欢吃 苹果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curryingShowMsg2 = currying(sayHello, <span class="string">&#x27;小衰&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">curryingShowMsg2(<span class="string">&#x27;西瓜&#x27;</span>)               <span class="comment">// 输出: 我叫 小衰,我 20 岁了, 我喜欢吃 西瓜</span></span><br></pre></td></tr></table></figure><blockquote><p>更高阶的用法参见：JavaScript 函数式编程技巧 - 柯里化</p></blockquote><h5 id="2-反柯里化"><a href="#2-反柯里化" class="headerlink" title="2. 反柯里化"></a><strong>2. 反柯里化</strong></h5><ul><li>柯里化是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了缩小适用范围，创建一个针对性更强的函数。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</li><li>而反柯里化，从字面讲，意义和用法跟函数柯里化相比正好相反，扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。</li></ul><p>先来看看反柯里化的通用实现吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你觉得把函数放在 Function 的原型上不太好，也可以这样：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tar</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        rest.shift()</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">tar, ...argu</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(tar, argu)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>简单说，函数柯里化就是对高阶函数的降阶处理，缩小适用范围，创建一个针对性更强的函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)              // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3</span>)        // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, arg3, arg4</span>)  // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)(<span class="params">arg3</span>)(<span class="params">arg4</span>)</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argn</span>)   // =&gt; <span class="function"><span class="keyword">function</span>(<span class="params">arg1</span>)(<span class="params">arg2</span>)…(<span class="params">argn</span>)</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><blockquote><p>而反柯里化就是反过来，增加适用范围，让方法使用场景更大。使用反柯里化, 可以把原生方法借出来，让任何对象拥有原生对象的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func(arg1, arg2)        <span class="comment">// =&gt; func(obj, arg1, arg2)</span></span><br></pre></td></tr></table></figure><p><strong>可以这样理解柯里化和反柯里化的区别：</strong></p><ul><li>柯里化是在运算前提前传参，可以传递多个参数；</li><li>反柯里化是延迟传参，在运算时把原来已经固定的参数或者 this 上下文等当作参数延迟到未来传递。</li><li>更高阶的用法参见：JavaScript 函数式编程技巧 - 反柯里化</li></ul><h5 id="3-偏函数"><a href="#3-偏函数" class="headerlink" title="3. 偏函数"></a><strong>3. 偏函数</strong></h5><blockquote><p>偏函数是创建一个调用另外一个部分（参数或变量已预制的函数）的函数，函数可以根据传入的参数来生成一个真正执行的函数。其本身不包括我们真正需要的逻辑代码，只是根据传入的参数返回其他的函数，返回的函数中才有真正的处理逻辑比如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">&#x27;String&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">&#x27;Function&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这样就用偏函数快速创建了一组判断对象类型的方法~</p></blockquote><p><strong>偏函数和柯里化的区别：</strong></p><ul><li>柯里化是把一个接受 <code>n</code> 个参数的函数，由原本的一次性传递所有参数并执行变成了可以分多次接受参数再执行，例如：<code>add = (x, y, z) =&gt; x + y + z→curryAdd = x =&gt; y =&gt; z =&gt; x + y + z；</code></li><li>偏函数固定了函数的某个部分，通过传入的参数或者方法返回一个新的函数来接受剩余的参数，数量可能是一个也可能是多个；</li><li>当一个柯里化函数只接受两次参数时，比如 <code>curry()()</code>，这时的柯里化函数和偏函数概念类似，可以认为偏函数是柯里化函数的退化版</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote><p>在前文我们介绍了面向对象三大特性之继承，本文将主要介绍面向对象六大原则中的单一职责原则（SRP）、开放封闭原则（OCP）、最少知识原则（LKP）。</p></blockquote><blockquote><p>设计原则是指导思想，从思想上给我们指明程序设计的正确方向，是我们在开发设计过程中应该尽力遵守的准则。而设计模式是实现手段，因此设计模式也应该遵守这些原则，或者说，设计模式就是这些设计原则的一些具体体现。要达到的目标就是高内聚低耦合，高内聚是说模块内部要高度聚合，是模块内部的关系，低耦合是说模块与模块之间的耦合度要尽量低，是模块与模块间的关系。</p></blockquote><p><strong>注意</strong>，遵守设计原则是好，但是过犹不及，在实际项目中我们不要刻板遵守，需要根据实际情况灵活运用</p><h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1. 单一职责原则 SRP"></a><strong>1. 单一职责原则 SRP</strong></h3><ul><li>单一职责原则 （Single Responsibility Principle, SRP）是指对一个类（方法、对象，下文统称对象）来说，应该仅有一个引起它变化的原因。也就是说，一个对象只做一件事。</li><li>单一职责原则可以让我们对对象的维护变得简单，如果一个对象具有多个职责的话，那么如果一个职责的逻辑需要修改，那么势必会影响到其他职责的代码。如果一个对象具有多种职责，职责之间相互耦合，对一个职责的修改会影响到其他职责的实现，这就是属于模块内低内聚高耦合的情况。负责的职责越多，耦合越强，对模块的修改就越来越危险。</li></ul><p><strong>优点：</strong></p><ul><li>降低单个类（方法、对象）的复杂度，提高可读性和可维护性，功能之间的界限更清晰； 类（方法、对象）之间根据功能被分为更小的粒度，有助于代码的复用；</li><li>缺点： 增加系统中类（方法、对象）的个数，实际上也增加了这些对象之间相互联系的难度，同时也引入了额外的复杂度。</li></ul><h3 id="2-开放封闭原则-OCP"><a href="#2-开放封闭原则-OCP" class="headerlink" title="2. 开放封闭原则 OCP"></a><strong>2. 开放封闭原则 OCP</strong></h3><blockquote><p>开放封闭原则 （Open－Close Principle, OCP）是指一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的，也就是对扩展开放，对修改封闭。</p></blockquote><blockquote><p>当需要增加需求的时候，则尽量通过扩展新代码的方式，而不是修改已有代码。因为修改已有代码，则会给依赖原有代码的模块带来隐患，因此修改之后需要把所有依赖原有代码的模块都测试一遍，修改一遍测试一遍，带来的成本很大，如果是上线的大型项目，那么代价和风险可能更高。</p></blockquote><p><strong>优点</strong>：</p><ul><li>增加可维护性，避免因为修改给系统带来的不稳定性。</li></ul><h3 id="3-最少知识原则-LKP"><a href="#3-最少知识原则-LKP" class="headerlink" title="3. 最少知识原则 LKP"></a><strong>3. 最少知识原则 LKP</strong></h3><ul><li>最少知识原则 （Least Knowledge Principle, LKP）又称为迪米特原则 （Law of Demeter, LOD），一个对象应该对其他对象有最少的了解。</li><li>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li><li>通常为了减少对象之间的联系，是通过引入一个第三者来帮助进行通信，阻隔对象之间的直接通信，从而减少耦合。</li></ul><p><strong>优点：</strong></p><ul><li>降低类（方法、对象）之间不必要的依赖，减少耦合。</li></ul><p><strong>缺点：</strong></p><ul><li>类（方法、对象）之间不直接通信也会经过一个第三者来通信，那么就要权衡引入第三者带来的复杂度是否值得。</li></ul><h1 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到，本节我们一起来学习一下。</li><li>单例模式 （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</li></ul><p>经营游戏单例示例代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ManageGame() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    ManageGame._schedule &#x3D; this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ManageGame.getInstance &#x3D; function() &#123;</span><br><span class="line">    if (ManageGame._schedule) &#123;        &#x2F;&#x2F; 判断是否已经有单例了</span><br><span class="line">    return ManageGame._schedule</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有单例，进行创建</span><br><span class="line">    return ManageGame._schedule &#x3D; new ManageGame()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const schedule1 &#x3D; new ManageGame()</span><br><span class="line">const schedule2 &#x3D; ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line">console.log(schedule1 &#x3D;&#x3D;&#x3D; schedule2)</span><br></pre></td></tr></table></figure><blockquote><p>稍微解释一下，这个构造函数在内部维护（或者直接挂载自己身上）一个实例，第一次执行 new 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。我们可以用 <code>ES6</code> 的 <code>class</code> 语法改造一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManageGame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> _schedule = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        <span class="keyword">return</span> ManageGame._schedule = <span class="keyword">new</span> ManageGame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有单例了</span></span><br><span class="line">        <span class="keyword">if</span> (ManageGame._schedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> ManageGame._schedule</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有单例，进行创建</span></span><br><span class="line">        ManageGame._schedule = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schedule1 = <span class="keyword">new</span> ManageGame()</span><br><span class="line"><span class="keyword">const</span> schedule2 = ManageGame.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(schedule1 === schedule2)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面方法的缺点在于维护的实例作为静态属性直接暴露，外部可以直接修改。</p><p>可以使用闭包或块状作用域隐藏内部变量：</p><p><strong>单例模式赋能</strong></p><blockquote><p>之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据单一职责原则，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p></blockquote><p><strong>惰性单例、懒汉式-饿汉式</strong></p><ul><li>有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用惰性创建，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</li></ul><p><strong>单例模式的优缺点</strong></p><p>单例模式主要解决的问题就是节约资源，保持访问一致性。</p><p><strong>简单分析一下它的优点：</strong></p><ul><li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li><li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li><li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li></ul><p><strong>单例模式也是有缺点的</strong></p><ul><li>单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；</li><li>与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li></ul><p><strong>单例模式的使用场景</strong></p><p>那我们应该在什么场景下使用单例模式呢：</p><ul><li>当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；</li><li>当项目中需要一个公共的状态，那么需要使用单例模式来保证访问一致性；</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>访问者只需要知道产品名，就可以从工厂获得对应实例；</li><li>访问者不关心实例创建过程；</li></ul><p><strong>代码实现</strong></p><blockquote><p>如果你使用过 <code>document.createElement</code> 方法创建过 <code>DOM</code> 元素，那么你已经使用过工厂方法了，虽然这个方法实际上很复杂，但其使用的就是工厂方法的思想：访问者只需提供标签名（如 <code>div</code>、<code>img</code>），那么这个方法就会返回对应的 DOM 元素。</p></blockquote><p>我们可以使用 JavaScript 将上面饭馆例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restaurant</span>(<span class="params">menu</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDin</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDin.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法中这里使用 <code>switch-case</code> 语法，你也可以用 <code>if-else</code>，都可以。</p></blockquote><p>下面使用 ES6 的 class 语法改写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.getMenu(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.getMenu(<span class="string">&#x27;红烧排骨&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li>这样就完成了一个工厂模式，但是这个实现有一个问题：工厂方法中包含了很多与创建产品相关的过程，如果产品种类很多的话，这个工厂方法中就会罗列很多产品的创建逻辑，每次新增或删除产品种类，不仅要增加产品类，还需要对应修改在工厂方法，违反了开闭原则，也导致这个工厂方法变得臃肿、高耦合。</li><li>严格上这种实现在面向对象语言中叫做简单工厂模式。适用于产品种类比较少，创建逻辑不复杂的时候使用。</li><li>工厂模式的本意是将实际创建对象的过程推迟到子类中，一般用抽象类来作为父类，创建过程由抽象类的子类来具体实现。JavaScript 中没有抽象类，所以我们可以简单地将工厂模式看做是一个实例化对象的工厂类即可。关于抽象类的有关内容，可以参看抽象工厂模式。</li><li>然而作为灵活的 JavaScript，我们不必如此较真，可以把易变的参数提取出来：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.menuData = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">getMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu])</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;这个菜本店没有 -。-&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; type, message &#125; = <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Menu(type, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加菜品种类 */</span></span><br><span class="line">    <span class="function"><span class="title">addMenu</span>(<span class="params">menu, type, message</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.menuData[menu]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.Info(<span class="string">&#x27;已经有这个菜了!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.menuData[menu] = &#123; type, message &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移除菜品 */</span></span><br><span class="line">    <span class="function"><span class="title">removeMenu</span>(<span class="params">menu</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.menuData[menu]) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.menuData[menu]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="built_in">this</span>.message) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restaurant = <span class="keyword">new</span> Restaurant()</span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>, <span class="string">&#x27;鱼香肉丝&#x27;</span>, <span class="string">&#x27; 真香~&#x27;</span>)<span class="comment">// 注册菜品</span></span><br><span class="line">restaurant.addMenu(<span class="string">&#x27;GongBaoJiDin&#x27;</span>, <span class="string">&#x27;宫保鸡丁&#x27;</span>, <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = restaurant.getMenu(<span class="string">&#x27;YuXiangRouSi&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = restaurant.getMenu(<span class="string">&#x27;HongSaoPaiGu&#x27;</span>)<span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure><ul><li><p>我们还给 Restaurant 类增加了 <code>addMenu/removeMenu</code> 私有方法，以便于扩展。</p></li><li><p>当然这里如果菜品参数不太一致，可以在 <code>addMenu</code> 时候注册构造函数或者类，创建的时候返回 <code>new</code> 出的对应类实例，灵活变通即可。</p><p><strong>工厂模式的优缺点</strong></p></li></ul><p>工厂模式将对象的创建和实现分离，这带来了优点：</p><ul><li>良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下；</li><li>扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则；</li><li>解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流；</li><li>工厂模式的缺点：带来了额外的系统复杂度，增加了抽象性；</li></ul><p><strong>工厂模式的使用场景</strong></p><p>那么什么时候使用工厂模式呢：</p><ul><li>对象的创建比较复杂，而访问者无需知道创建的具体流程；</li><li>处理大量具有相同属性的小对象；</li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>工厂模式 （Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。</p></blockquote><ul><li>抽象工厂 （Abstract Factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。</li><li>我们知道 JavaScript 并不是强面向对象语言，所以使用传统编译型语言比如 JAVA、C#、C++ 等实现的设计模式和 JavaScript 不太一样，比如 JavaScript 中没有原生的类和接口等（不过 ES6+ 渐渐提供类似的语法糖），我们可以用变通的方式来解决。最重要的是设计模式背后的核心思想，和它所要解决的问题。</li></ul><p><strong>代码实现</strong></p><blockquote><p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 <code>new.target</code> 来判断 new 的类，在父类方法中 <code>throw new Error()</code>，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 抽象类，ES6 class 方式 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">operate</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象类，ES5 构造函数方式 */</span></span><br><span class="line"><span class="keyword">var</span> AbstractClass2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractClass2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 抽象方法，使用原型方式添加 */</span></span><br><span class="line">AbstractClass2.prototype.operate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br></pre></td></tr></table></figure><p>下面用 JavaScript 将上面介绍的饭店例子实现一下。</p><p>首先使用原型方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 饭店方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Restaurant</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Restaurant.orderDish = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDing()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;紫菜蛋汤&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZiCaiDanTang()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dish</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象方法 */</span></span><br><span class="line">Dish.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YuXiangRouSi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">YuXiangRouSi.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GongBaoJiDing</span>(<span class="params"></span>) </span>&#123; <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype = <span class="keyword">new</span> Dish()</span><br><span class="line"></span><br><span class="line">GongBaoJiDing.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()</span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br><span class="line">使用 <span class="class"><span class="keyword">class</span> 语法改写一下：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* 饭店方法 */</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">orderDish</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;鱼香肉丝&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;宫保鸡丁&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;本店没有这个 -。-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 菜品抽象类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Dish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象类不能直接实例化!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.kind = <span class="string">&#x27;菜&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象方法不能调用!&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鱼香肉丝类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;鱼香肉丝&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 真香~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宫保鸡丁类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;宫保鸡丁&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.kind + <span class="string">&#x27; - &#x27;</span> + <span class="built_in">this</span>.type + <span class="string">&#x27; 让我想起了外婆做的菜~&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dish0 = <span class="keyword">new</span> Dish()  <span class="comment">// 输出: Error 抽象方法不能调用!</span></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">&#x27;鱼香肉丝&#x27;</span>)</span><br><span class="line">dish1.eat()<span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">&#x27;红烧排骨&#x27;</span>) <span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br></pre></td></tr></table></figure><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>抽象模式的优点：</strong></p><blockquote><p>抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；</p></blockquote><p><strong>抽象模式的缺点：</strong></p><ul><li>扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；</li><li>带来了系统复杂度，增加了新的类，和新的继承关系；</li></ul><p><strong>抽象工厂模式的使用场景</strong></p><blockquote><p>如果一组实例都有相同的结构，那么就可以使用抽象工厂模式。</p></blockquote><p> <strong>抽象工厂模式与工厂模式</strong></p><p>工厂模式和抽象工厂模式的区别：</p><ul><li>工厂模式 主要关注单独的产品实例的创建；</li><li>抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；根据场景灵活使用即可。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><blockquote><p>建造者模式（Builder Pattern）又称生成器模式，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的构建层与其表示层分离。</p></blockquote><ul><li>在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。</li></ul><p>汽车装配代码模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">function CarBuilder(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">    this.color &#x3D; color</span><br><span class="line">    this.weight &#x3D; weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，轮胎</span><br><span class="line">CarBuilder.prototype.buildTyre &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">            this.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生产部件，发动机</span><br><span class="line">CarBuilder.prototype.buildEngine &#x3D; function(type) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#39;small&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;normal&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">        case &#39;big&#39;:</span><br><span class="line">            this.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">            this.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 奔驰厂家，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">function benChiDirector(tyre, engine, param) &#123;</span><br><span class="line">    var _car &#x3D; new CarBuilder(param)</span><br><span class="line">    _car.buildTyre(tyre)</span><br><span class="line">    _car.buildEngine(engine)</span><br><span class="line">    return _car</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">var benchi1 &#x3D; benChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>ES6写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建造者，汽车部件厂家，提供具体零部件的生产</span><br><span class="line">class CarBuilder &#123;</span><br><span class="line">    constructor(&#123; color &#x3D; &#39;white&#39;, weight &#x3D; 0 &#125;) &#123;</span><br><span class="line">        this.color &#x3D; color</span><br><span class="line">        this.weight &#x3D; weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，轮胎 *&#x2F;</span><br><span class="line">    buildTyre(type) &#123;</span><br><span class="line">        const tyre &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;小号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用小号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;中号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用中号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                tyre.tyreType &#x3D; &#39;大号轮胎&#39;</span><br><span class="line">                tyre.tyreIntro &#x3D; &#39;正在使用大号轮胎&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.tyre &#x3D; tyre</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* 生产部件，发动机 *&#x2F;</span><br><span class="line">    buildEngine(type) &#123;</span><br><span class="line">        const engine &#x3D; &#123;&#125;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &#39;small&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;小马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用小马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;normal&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;中马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用中马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">            case &#39;big&#39;:</span><br><span class="line">                engine.engineType &#x3D; &#39;大马力发动机&#39;</span><br><span class="line">                engine.engineIntro &#x3D; &#39;正在使用大马力发动机&#39;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">        this.engine &#x3D; engine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 指挥者，负责最终汽车产品的装配 *&#x2F;</span><br><span class="line">class BenChiDirector &#123;</span><br><span class="line">    constructor(tyre, engine, param) &#123;</span><br><span class="line">        const _car &#x3D; new CarBuilder(param)</span><br><span class="line">        _car.buildTyre(tyre)</span><br><span class="line">        _car.buildEngine(engine)</span><br><span class="line">        return _car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得产品实例</span><br><span class="line">const benchi1 &#x3D; new BenChiDirector(&#39;small&#39;, &#39;big&#39;, &#123; color: &#39;red&#39;, weight: &#39;1600kg&#39; &#125;)</span><br><span class="line"></span><br><span class="line">console.log(benchi1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出：</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F;   color: &quot;red&quot;</span><br><span class="line">&#x2F;&#x2F;   weight: &quot;1600kg&quot;</span><br><span class="line">&#x2F;&#x2F;   tyre: Tyre &#123;tyreType: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span><br><span class="line">&#x2F;&#x2F;   engine: Engine &#123;engineType: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来完成部件的装配</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造者，汽车部件厂家</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">&#123; color = <span class="string">&#x27;white&#x27;</span>, weight = <span class="string">&#x27;0&#x27;</span> &#125;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，轮胎 */</span></span><br><span class="line">    <span class="function"><span class="title">buildTyre</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tyre = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;小号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用小号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;中号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用中号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                tyre.tyreType = <span class="string">&#x27;大号轮胎&#x27;</span></span><br><span class="line">                tyre.tyreIntro = <span class="string">&#x27;正在使用大号轮胎&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.tyre = tyre</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生产部件，发动机 */</span></span><br><span class="line">    <span class="function"><span class="title">buildEngine</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> engine = &#123;&#125;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;小马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用小马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;中马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用中马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                engine.engineType = <span class="string">&#x27;大马力发动机&#x27;</span></span><br><span class="line">                engine.engineIntro = <span class="string">&#x27;正在使用大马力发动机&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车装配，获得产品实例</span></span><br><span class="line"><span class="keyword">const</span> benchi1 = <span class="keyword">new</span> CarBuilder(&#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">weight</span>: <span class="string">&#x27;1600kg&#x27;</span> &#125;)</span><br><span class="line">    .buildTyre(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line">    .buildEngine(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(benchi1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line"><span class="comment">//   weight: &quot;1600kg&quot;</span></span><br><span class="line"><span class="comment">//   tyre: Tyre &#123;tyre: &quot;小号轮胎&quot;, tyreIntro: &quot;正在使用小号轮胎&quot;&#125;</span></span><br><span class="line"><span class="comment">//   engine: Engine &#123;engine: &quot;大马力发动机&quot;, engineIntro: &quot;正在使用大马力发动机&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这样将最终产品的创建流程使用链模式来实现，相当于将指挥者退化，指挥的过程通过链模式让用户自己实现，这样既增加了灵活性，装配过程也一目了然。如果希望扩展产品的部件，那么在建造者上增加部件实现方法，再适当修改链模式即可。</p></blockquote><p><strong>建造者模式的优点：</strong></p><ul><li>使用建造者模式可以使产品的构建流程和产品的表现分离，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节；</li><li>扩展方便，如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；</li><li>更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性；</li></ul><p><strong>建造者模式的缺点：</strong></p><ul><li><p>建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；</p></li><li><p>实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；</p><p><strong>建造者模式的适用场景</strong></p></li><li><p>相同的方法，不同的执行顺序，产生不一样的产品时，可以采用建造者模式；</p></li><li><p>产品的组成部件类似，通过组装不同的组件获得不同产品时，可以采用建造者模式；</p></li></ul><p><strong>建造者模式与工厂模式</strong></p><ul><li>建造者模式和工厂模式最终都是创建一个完整的产品，但是在建造者模式中我们更关心对象创建的过程，将创建对象的方法模块化，从而更好地复用这些模块。</li><li>当然建造者模式与工厂模式也是可以组合使用的，比如建造者中一般会提供不同的部件实现，那么这里就可以使用工厂模式来提供具体的部件对象，再通过指挥者来进行装配。</li></ul><p>** 建造者模式与模版方法模式**</p><ul><li>指挥者的实现可以和模版方法模式相结合。也就是说，指挥者中部件的装配过程，可以使用模版方法模式来固定装配算法，把部件实现方法分为模板方法和基本方法，进一步提取公共代码，扩展可变部分。</li><li>是否采用模版方法模式看具体场景，如果产品的部件装配顺序很明确，但是具体的实现是未知的、灵活的，那么你可以适当考虑是否应该将算法骨架提取出来。</li></ul><h1 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a><strong>三、结构型模式</strong></h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理模式 （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。</p></blockquote><ul><li>代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。</li></ul><p><strong>实例的代码实现</strong></p><p>我们使用 JavaScript 来将上面的明星例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">var</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">ad</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">var</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    playAdvertisement: <span class="function"><span class="keyword">function</span>(<span class="params">reward, ad</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            SuperStar.playAdvertisement(ad)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br></pre></td></tr></table></figure><ul><li>我们可以升级一下，比如如果明星没有档期的话，可以通过经纪人安排档期，当明星有空的时候才让明星来拍广告。这里通过 <code>Promise</code> 的方式来实现档期的安排：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 明星 */</span></span><br><span class="line"><span class="keyword">const</span> SuperStar = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小鲜肉&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">ad</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ad)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经纪人 */</span></span><br><span class="line"><span class="keyword">const</span> ProxyAssistant = &#123;</span><br><span class="line">    name: <span class="string">&#x27;经纪人张某&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">scheduleTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;小鲜鲜有空了&#x27;</span>)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;, <span class="number">2000</span>)                        <span class="comment">// 发现明星有空了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">playAdvertisement</span>(<span class="params">reward, ad</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reward &gt; <span class="number">1000000</span>) &#123;             <span class="comment">// 如果报酬超过100w</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没问题，我们小鲜鲜最喜欢拍广告了！&#x27;</span>)</span><br><span class="line">            ProxyAssistant.scheduleTime()   <span class="comment">// 安排上了</span></span><br><span class="line">                .then(<span class="function">() =&gt;</span> SuperStar.playAdvertisement(ad))</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;没空，滚！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">10000</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没空，滚</span></span><br><span class="line"></span><br><span class="line">ProxyAssistant.playAdvertisement(<span class="number">1000001</span>, <span class="string">&#x27;纯蒸酸牛奶，味道纯纯，尽享纯蒸&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出： 没问题，我们小鲜鲜最喜欢拍广告了！</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line"><span class="comment">// 输出： 小鲜鲜有空了</span></span><br><span class="line"><span class="comment">// 输出： 纯蒸酸牛奶，味道纯纯，尽享纯蒸</span></span><br></pre></td></tr></table></figure><p>这里就简单实现了经纪人对请求的过滤，对明星档期的安排，实现了一个代理对象的基本功能。</p><p><strong>代理模式的优缺点</strong></p><p><strong>代理模式的主要优点有：</strong></p><ul><li>代理对象在访问者与目标对象之间可以起到中介和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将访问者与目标对象分离，在一定程度上降低了系统的耦合度，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则；</li><li>代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（十八线明星就别请经纪人了）</li></ul><p><strong>其他相关模式</strong></p><p>很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。</p><p><strong>代理模式与适配器模式</strong></p><p>代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：</p><ul><li>适配器模式： 主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口；</li><li>代理模式： 提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口；</li></ul><p><strong>代理模式与装饰者模式</strong></p><p>装饰者模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：</p><ul><li>装饰者模式： 目的是为了方便地给目标对象添加功能，也就是动态地添加功能；</li><li>代理模式： 主要目的是控制其他访问者对目标对象的访问；</li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。</p></blockquote><blockquote><p>享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。</p></blockquote><p>Fly 意为苍蝇，Flyweight 指轻蝇量级，指代对象粒度很小。</p><p><strong>代码实现</strong></p><p>首先假设考生的 ID 为奇数则考的是手动档，为偶数则考的是自动档。如果给所有考生都 new 一个驾考车，那么这个系统中就会创建了和考生数量一致的驾考车对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = <span class="keyword">new</span> ExamCar(candidateId % <span class="number">2</span>)</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 10</span></span><br></pre></td></tr></table></figure><blockquote><p>如果考生很多，那么系统中就会存在更多个驾考车对象实例，假如驾考车对象比较复杂，那么这些新建的驾考车实例就会占用大量内存。这时我们将同种类型的驾考车实例进行合并，手动档和自动档档驾考车分别引用同一个实例，就可以节约大量内存：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> candidateNum = <span class="number">10</span>   <span class="comment">// 考生数量</span></span><br><span class="line"><span class="keyword">var</span> examCarNum = <span class="number">0</span>      <span class="comment">// 驾考车的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驾考车构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExamCar</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">    examCarNum++</span><br><span class="line">    <span class="built_in">this</span>.carId = examCarNum</span><br><span class="line">    <span class="built_in">this</span>.carType = carType ? <span class="string">&#x27;手动档&#x27;</span> : <span class="string">&#x27;自动档&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExamCar.prototype.examine = <span class="function"><span class="keyword">function</span>(<span class="params">candidateId</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;考生- &#x27;</span> + candidateId + <span class="string">&#x27; 在&#x27;</span> + <span class="built_in">this</span>.carType + <span class="string">&#x27;驾考车- &#x27;</span> + <span class="built_in">this</span>.carId + <span class="string">&#x27; 上考试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manualExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> autoExamCar = <span class="keyword">new</span> ExamCar(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> candidateId = <span class="number">1</span>; candidateId &lt;= candidateNum; candidateId++) &#123;</span><br><span class="line">    <span class="keyword">var</span> examCar = candidateId % <span class="number">2</span> ? manualExamCar : autoExamCar</span><br><span class="line">    examCar.examine(candidateId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;驾考车总数 - &#x27;</span> + examCarNum)</span><br><span class="line"><span class="comment">// 输出: 驾考车总数 - 2</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到我们使用 2 个驾考车实例就实现了刚刚 10 个驾考车实例实现的功能。这是仅有 10 个考生的情况，如果有几百上千考生，这时我们节约的内存就比较可观了，这就是享元模式要达到的目的。</p></blockquote><p><strong>享元模式的优缺点</strong></p><p><strong>享元模式的优点：</strong></p><ul><li>由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度；</li><li>外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；</li></ul><p><strong>享元模式的缺点：</strong></p><ul><li>引入了共享对象，使对象结构变得复杂；</li><li>共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；</li></ul><p><strong>享元模式的适用场景</strong></p><ul><li>如果一个程序中大量使用了相同或相似对象，那么可以考虑引入享元模式；</li><li>如果使用了大量相同或相似对象，并造成了比较大的内存开销；</li><li>对象的大多数状态可以被转变为外部状态；</li><li>剥离出对象的外部状态后，可以使用相对较少的共享对象取代大量对象；</li><li>在一些程序中，如果引入享元模式对系统的性能和内存的占用影响不大时，比如目标对象不多，或者场景比较简单，则不需要引入，以免适得其反。</li></ul><p><strong>其他相关模式</strong></p><ul><li>享元模式和单例模式、工厂模式、组合模式、策略模式、状态模式等等经常会一起使用。</li></ul><p><strong>享元模式和工厂模式、单例模式</strong></p><ul><li><p>在区分出不同种类的外部状态后，创建新对象时需要选择不同种类的共享对象，这时就可以使用工厂模式来提供共享对象，在共享对象的维护上，经常会采用单例模式来提供单实例的共享对象。</p><p><strong>享元模式和组合模式</strong></p></li><li><p>在使用工厂模式来提供共享对象时，比如某些时候共享对象中的某些状态就是对象不需要的，可以引入组合模式来提升自定义共享对象的自由度，对共享对象的组成部分进一步归类、分层，来实现更复杂的多层次对象结构，当然系统也会更难维护。</p></li></ul><p><strong>享元模式和策略模式</strong></p><blockquote><p>策略模式中的策略属于一系列功能单一、细粒度的细粒度对象，可以作为目标对象来考虑引入享元模式进行优化，但是前提是这些策略是会被频繁使用的，如果不经常使用，就没有必要了。</p></blockquote><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>适配器模式（Adapter Pattern）又称包装器模式，将一个类（对象）的接口（方法、属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。</li><li>主要功能是进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说，访问者需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已。</li></ul><p><strong>代码实现</strong></p><p>我们可以实现一下电源适配器的例子，一开始我们使用的中国插头标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chinaPlug.chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><blockquote><p>但是我们出国旅游了，到了日本，需要增加一个日本插头到中国插头的电源适配器，来将我们原来的电源线用起来：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chinaPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;中国插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> japanPlug = &#123;</span><br><span class="line">    type: <span class="string">&#x27;日本插头&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">japanInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始供电&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日本插头电源适配器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">japanPlugAdapter</span>(<span class="params">plug</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">chinaInPlug</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> plug.japanInPlug()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">japanPlugAdapter(japanPlug).chinaInPlug()</span><br><span class="line"><span class="comment">// 输出：开始供电</span></span><br></pre></td></tr></table></figure><p><strong>适配器模式的优缺点</strong></p><p><strong>适配器模式的优点：</strong></p><ul><li>已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；</li><li>可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；</li><li>灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；</li><li>适配器模式的缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。</li></ul><p><strong>适配器模式的适用场景</strong></p><ul><li>当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。</li><li>如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；</li><li>如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；</li></ul><p><strong>其他相关模式</strong></p><blockquote><p>适配器模式和代理模式、装饰者模式看起来比较类似，都是属于包装模式，也就是用一个对象来包装另一个对象的模式，他们之间的异同在代理模式中已经详细介绍了，这里再简单对比一下。</p></blockquote><p><strong>适配器模式与代理模式</strong></p><ul><li>适配器模式： 提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；</li><li>代理模式： 提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；</li></ul><p><strong>适配器模式、装饰者模式与代理模式</strong></p><ul><li>适配器模式： 功能不变，只转换了原有接口访问格式；</li><li>装饰者模式： 扩展功能，原有功能不变且可直接使用；</li><li>代理模式： 原有功能不变，但一般是经过限制访问的；</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>装饰者模式 （Decorator Pattern）又称装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能。</p></blockquote><blockquote><p>本质是功能动态组合，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。</p></blockquote><p>我们可以使用 JavaScript 来将装修房子的例子实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OriginHouse</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">OriginHouse.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Furniture</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Furniture.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Painting</span>(<span class="params">house</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house = house</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Painting.prototype.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> house = <span class="keyword">new</span> OriginHouse() <span class="comment">// 毛坯房</span></span><br><span class="line">house = <span class="keyword">new</span> Furniture(house) <span class="comment">// 搬入家具</span></span><br><span class="line">house = <span class="keyword">new</span> Painting(house) <span class="comment">// 墙壁刷漆</span></span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br><span class="line">使用 ES6 的 Class 语法：</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">house</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house.getDesc()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> house = <span class="keyword">new</span> OriginHouse()</span><br><span class="line">house = <span class="keyword">new</span> Furniture(house)</span><br><span class="line">house = <span class="keyword">new</span> Painting(house)</span><br><span class="line"></span><br><span class="line">house.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><blockquote><p>是不是感觉很麻烦，装饰个功能这么复杂？我们 JSer 大可不必走这一套面向对象花里胡哨的，毕竟 JavaScript 的优点就是灵活：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 毛坯房 - 目标对象 */</span></span><br><span class="line"><span class="keyword">var</span> originHouse = &#123;</span><br><span class="line">    <span class="function"><span class="title">getDesc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;毛坯房 &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 搬入家具 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">furniture</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;搬入家具 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 墙壁刷漆 - 装饰者 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">painting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;墙壁刷漆 &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 搬入家具 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        furniture()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加装饰 - 墙壁刷漆 */</span></span><br><span class="line">originHouse.getDesc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getDesc = originHouse.getDesc</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        getDesc()</span><br><span class="line">        painting()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">originHouse.getDesc()</span><br><span class="line"><span class="comment">// 输出： 毛坯房  搬入家具  墙壁刷漆</span></span><br></pre></td></tr></table></figure><p>简洁明了，且更符合前端日常使用的场景。</p><p><strong>装饰者模式的优缺点</strong></p><p><strong>装饰者模式的优点：</strong></p><ul><li>我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下动态地修饰对象，添加功能，装饰者和被装饰者之间松耦合，可维护性好；</li><li>被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；</li><li>装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；</li><li>可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；</li></ul><p><strong>装饰者模式的缺点：</strong></p><ul><li>使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；</li><li>由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐；</li></ul><p><strong>装饰者模式的适用场景</strong></p><ul><li>如果不希望系统中增加很多子类，那么可以考虑使用装饰者模式；</li><li>需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，这时采用装饰者模式可以很好实现；</li><li>当对象的功能要求可以动态地添加，也可以动态地撤销，可以考虑使用装饰者模式；</li></ul><p><strong>其他相关模式</strong> </p><p>** 装饰者模式与适配器模式**</p><blockquote><p>装饰者模式和适配器模式都是属于包装模式，然而他们的意图有些不一样：</p></blockquote><ul><li>装饰者模式： 扩展功能，原有功能还可以直接使用，一般可以给目标对象多次叠加使用多个装饰者；</li><li>适配器模式： 功能不变，但是转换了原有接口的访问格式，一般只给目标对象使用一次；</li></ul><p><strong>装饰者模式与组合模式</strong></p><p>这两个模式有相似之处，都涉及到对象的递归调用，从某个角度来说，可以把装饰者模式看做是只有一个组件的组合模式。</p><ul><li>装饰者模式： 动态地给对象增加功能；</li><li>组合模式： 管理组合对象和叶子对象，为它们提供一致的操作接口给客户端，方便客户端的使用；</li></ul><p><strong>装饰者模式与策略模式</strong></p><p>装饰者模式和策略模式都包含有许多细粒度的功能模块，但是他们的使用思路不同：</p><ul><li>装饰者模式： 可以递归调用，使用多个功能模式，功能之间可以叠加组合使用；</li><li>策略模式： 只有一层选择，选择某一个功能；</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote><p>外观模式 （Facade Pattern）又叫门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。</p></blockquote><p>外观模式在源码中使用很多，具体可以参考后文中源码阅读部分。</p><p><strong>简化版本的代码： 无人机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uav = &#123;</span><br><span class="line">    <span class="comment">/* 电子调速器 */</span></span><br><span class="line">    diantiao1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调1发送指令：电机1减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调2发送指令：电机2减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji2.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调3发送指令：电机3减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji3.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4增大转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;电调4发送指令：电机4减小转速&#x27;</span>)</span><br><span class="line">            uav.dianji4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 电机 */</span></span><br><span class="line">    dianji1: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机1减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji2: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机2减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji3: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机3减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji4: &#123;</span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4增大转速&#x27;</span>) &#125;,</span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;电机4减小转速&#x27;</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遥控器 */</span></span><br><span class="line">    controller: &#123;</span><br><span class="line">        <span class="comment">/* 上升 */</span></span><br><span class="line">        <span class="function"><span class="title">up</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.up()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 前进 */</span></span><br><span class="line">        <span class="function"><span class="title">forward</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 下降 */</span></span><br><span class="line">        <span class="function"><span class="title">down</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.down()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 左转 */</span></span><br><span class="line">        <span class="function"><span class="title">left</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操纵无人机 */</span></span><br><span class="line">uav.controller.down()    <span class="comment">// 发送下降指令</span></span><br><span class="line">uav.controller.left()    <span class="comment">// 发送左转指令</span></span><br></pre></td></tr></table></figure><p>无人机系统是比较复杂，但是可以看到无人机的操纵却比较简单，正是因为有遥控器这个外观的存在。</p><p><strong>外观模式的优点：</strong></p><ul><li>访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；</li><li>减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；</li><li>通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；</li></ul><p><strong>外观模式的缺点：</strong></p><ul><li>不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；</li><li>不需要或不合理的使用外观会让人迷惑，过犹不及；</li></ul><p><strong>外观模式的适用场景</strong></p><ul><li>维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可；</li><li>你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能；</li><li>团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间；</li><li>如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>外观模式与中介者模式</strong></p><ul><li>外观模式： 封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用；</li><li>中介者模式： 封装子系统间各模块之间的直接交互，松散模块间的耦合；</li></ul><p><strong>外观模式与单例模式</strong></p><blockquote><p>有时候一个系统只需要一个外观，比如之前举的 <code>Axios</code> 的 <code>HTTP</code> 模块例子。这时我们可以将外观模式和单例模式可以一起使用，把外观实现为单例。</p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote><p>组合模式 （Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象</p></blockquote><p><strong>你曾见过的组合模式</strong></p><p>大家电脑里的文件夹结构相比很熟悉了，文件夹下面可以有子文件夹，也可以有文件，子文件夹下面还可以有文件夹和文件，以此类推，共同组成了一个文件树，结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Folder <span class="number">1</span></span><br><span class="line">├── Folder <span class="number">2</span></span><br><span class="line">│   ├── File <span class="number">1.</span>txt</span><br><span class="line">│   ├── File <span class="number">2.</span>txt</span><br><span class="line">│   └── File <span class="number">3.</span>txt</span><br><span class="line">└── Folder <span class="number">3</span></span><br><span class="line">    ├── File <span class="number">4.</span>txt</span><br><span class="line">    ├── File <span class="number">5.</span>txt</span><br><span class="line">    └── File <span class="number">6.</span>txt</span><br></pre></td></tr></table></figure><blockquote><p>文件夹是树形结构的容器节点，容器节点可以继续包含其他容器节点，像树枝上还可以有其他树枝一样；也可以包含文件，不再增加新的层级，就像树的叶子一样处于末端，因此被称为叶节点。本文中，叶节点又称为叶对象，容器节点因为可以包含容器节点和非容器节点，又称为组合对象。</p></blockquote><p><strong>代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的文件夹例子实现一下。</p><p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">var</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(fileOrFolder)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">                child.scan(cb)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">var</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子文件夹，并放入根文件夹</span></span><br><span class="line"><span class="keyword">var</span> foldMarvelMovies = createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldMarvelMovies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldDCMovies = createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">foldMovies.add(foldDCMovies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个子文件夹分别添加电影</span></span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>))</span><br><span class="line"></span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">foldDCMovies.add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line">foldMovies.scan(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + item.name + <span class="string">&#x27; size:&#x27;</span> + item.size + <span class="string">&#x27;GB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>作为灵活的 JavaScript，我们还可以使用链模式来进行改造一下，让我们添加子文件更加直观和方便。对链模式还不熟悉的同学可以看一下后面有一篇单独介绍链模式的文章～</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">const</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹  */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.push(...fileOrFolder)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">const</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">            cb(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = createFolder(<span class="string">&#x27;电影&#x27;</span>)</span><br><span class="line">  .add(</span><br><span class="line">    createFolder(<span class="string">&#x27;漫威英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)),</span><br><span class="line">    createFolder(<span class="string">&#x27;DC英雄电影&#x27;</span>)</span><br><span class="line">      .add(createFile(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>))</span><br><span class="line">      .add(createFile(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码比较 JavaScript 特色，如果我们使用传统的类呢，也是可以实现的，下面使用 ES6 的 class 语法来改写一下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件夹类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, children</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.children = children</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.push(...fileOrFolder)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> child.scan(cb))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...fileOrFolder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        cb(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foldMovies = <span class="keyword">new</span> Folder(<span class="string">&#x27;电影&#x27;</span>, [</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;漫威英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;钢铁侠.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蜘蛛侠.mp4&#x27;</span>, <span class="number">2.1</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;金刚狼.mp4&#x27;</span>, <span class="number">2.3</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;黑寡妇.mp4&#x27;</span>, <span class="number">1.9</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;美国队长.mp4&#x27;</span>, <span class="number">1.4</span>)]),</span><br><span class="line">    <span class="keyword">new</span> Folder(<span class="string">&#x27;DC英雄电影&#x27;</span>, [</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;蝙蝠侠.mp4&#x27;</span>, <span class="number">2.4</span>),</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;超人.mp4&#x27;</span>, <span class="number">1.6</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;size 大于2G的文件有：&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foldMovies.scan(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name:<span class="subst">$&#123; item.name &#125;</span> size:<span class="subst">$&#123; item.size &#125;</span>GB`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure><p>在传统的语言中，为了保证叶对象和组合对象的外观一致，还会让他们实现同一个抽象类或接口。</p><p><strong>组合模式的优缺点</strong> <strong>组合模式的优点：</strong></p><ul><li>由于组合对象和叶对象具有同样的接口，因此调用的是组合对象还是叶对象对使用者来说没有区别，使得使用者面向接口编程；</li><li>如果想在组合模式的树中增加一个节点比较容易，在目标组合对象中添加即可，不会影响到其他对象，对扩展友好，符合开闭原则，利于维护；</li></ul><p><strong>组合模式的缺点：</strong></p><ul><li>增加了系统复杂度，如果树中对象不多，则不一定需要使用；</li><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起；</li></ul><p><strong>组合模式的适用场景</strong></p><ul><li>如果对象组织呈树形结构就可以考虑使用组合模式，特别是如果操作树中对象的方法比较类似时；</li><li>使用者希望统一对待树形结构中的对象，比如用户不想写一堆 if-else 来处理树中的节点时，可以使用组合模式；</li></ul><p><strong>其他相关模式</strong> </p><p><strong>组合模式和职责链模式</strong></p><p>正如前文所说，组合模式是天生实现了职责链模式的。</p><ul><li>组合模式： 请求在组合对象上传递，被深度遍历到组合对象的所有子孙叶节点具体执行；</li><li>职责链模式： 实现请求的发送者和接受者之间的解耦，把多个接受者组合起来形成职责链，请求在链上传递，直到有接受者处理请求为止；</li></ul><p><strong>组合模式和迭代器模式</strong></p><p>组合模式可以结合迭代器模式一起使用，在遍历组合对象的叶节点的时候，可以使用迭代器模式来遍历。</p><p><strong>组合模式和命令模式</strong></p><blockquote><p>命令模式里有一个用法「宏命令」，宏命令就是组合模式和命令模式一起使用的结果，是组合模式组装而成</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li>桥接模式（Bridge Pattern）又称桥梁模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。</li><li>抽象部分和实现部分可能不太好理解，举个例子，香蕉、苹果、西瓜，它们共同的抽象部分就是水果，可以吃，实现部分就是不同的水果实体。再比如黑色手提包、红色钱包、蓝色公文包，它们共同的抽象部分是包和颜色，这部分的共性就可以被作为抽象提取出来。</li></ul><p><strong>实例的代码实现</strong></p><p>我们可以使用 JavaScript 来将之前的变频洗衣机例子实现一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Washer</span>(<span class="params">motorType, rollerType, transducerType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">    <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">    <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Washer.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motor.run()</span><br><span class="line">    <span class="built_in">this</span>.roller.run()</span><br><span class="line">    <span class="built_in">this</span>.transducer.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Motor</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Motor.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Roller</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Roller.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Transducer</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transducer.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建洗衣机</span></span><br><span class="line"><span class="keyword">var</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br><span class="line">由于产品部件可以独立变化，所以创建新的洗衣机产品就非常容易：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> washerD = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;中功率&#x27;</span>)</span><br><span class="line">washerD.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      中功率变频器开始工作</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到由于洗衣机的结构被分别抽象为几个部件的组合，部件的实例化是在部件类各自的构造函数中完成，因此部件之间的实例化不会相互影响，新产品的创建也变得容易，这就是桥接模式的好处。</p></blockquote><p>下面我们用 ES6 的 Class 语法实现一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组装洗衣机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">motorType, rollerType, transducerType</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor = <span class="keyword">new</span> Motor(motorType)</span><br><span class="line">        <span class="built_in">this</span>.roller = <span class="keyword">new</span> Roller(rollerType)</span><br><span class="line">        <span class="built_in">this</span>.transducer = <span class="keyword">new</span> Transducer(transducerType)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始使用 */</span></span><br><span class="line">    <span class="function"><span class="title">work</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motor.run()</span><br><span class="line">        <span class="built_in">this</span>.roller.run()</span><br><span class="line">        <span class="built_in">this</span>.transducer.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Motor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.motorType = type + <span class="string">&#x27;电机&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.motorType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滚筒 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Roller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rollerType = type + <span class="string">&#x27;滚筒&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.rollerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变频器 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transducerType = type + <span class="string">&#x27;变频器&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.transducerType + <span class="string">&#x27;开始工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> washerA = <span class="keyword">new</span> Washer(<span class="string">&#x27;小功率&#x27;</span>, <span class="string">&#x27;直立&#x27;</span>, <span class="string">&#x27;小功率&#x27;</span>)</span><br><span class="line">washerA.work()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：小功率电机开始工作</span></span><br><span class="line"><span class="comment">//      直立滚筒开始工作</span></span><br><span class="line"><span class="comment">//      小功率变频器开始工作</span></span><br></pre></td></tr></table></figure><ul><li>如果再精致一点，可以让电机、滚筒、变频器等部件实例继承自各自的抽象类，将面向抽象进行到底，但是桥接模式在 JavaScript 中应用不多，适当了解即可，不用太死扣。</li><li>有时候为了更复用部件，可以将部件的实例化拿出来，对于洗衣机来说一个实体部件当然不能用两次，这里使用皮包的例子：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 皮包 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type, color</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type</span><br><span class="line">        <span class="built_in">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 展示 */</span></span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="built_in">this</span>.color.show() + <span class="built_in">this</span>.type.show()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.typeType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.typeType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 皮包颜色 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colorType = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.colorType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 抽象实例化 */</span></span><br><span class="line"><span class="keyword">const</span> redColor = <span class="keyword">new</span> Color(<span class="string">&#x27;红色&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> walletType = <span class="keyword">new</span> Type(<span class="string">&#x27;钱包&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> briefcaseType = <span class="keyword">new</span> Type(<span class="string">&#x27;公文包&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagA = <span class="keyword">new</span> Bag(walletType, redColor)</span><br><span class="line">bagA.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色钱包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bagB = <span class="keyword">new</span> Bag(briefcaseType, redColor)</span><br><span class="line">bagB.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：红色公文包</span></span><br></pre></td></tr></table></figure><h1 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a><strong>四、行为型模式</strong></h1><p>暂时搞不懂，后续理解</p><h1 id="五、其他模式"><a href="#五、其他模式" class="headerlink" title="五、其他模式"></a><strong>五、其他模式</strong></h1><h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><blockquote><p>在下文中，如果某些内容和你看的某本书或者某个帖子上的不一样，不要惊慌，多看几本书，多打开几个帖子，你会发现每个都不一样，所以模式具体是如何表现并不重要，重要的是，了解这三个模式主要的目的和思想是什么：</p></blockquote><ul><li><code>MVC</code> 模式： 从大锅烩时代进化，引入了分层的概念，但是层与层之间耦合明显，维护起来不容易；</li><li><code>MVP</code> 模式： 在 MVC 基础上进一步解耦，视图层和模型层完全隔离，交互只能通过管理层来进行，问题是更新视图需要管理层手动来进行；</li><li><code>MVVM</code> 模式： 引入双向绑定机制，帮助实现一些更新视图层和模型层的工作，让开发者可以更专注于业务逻辑，相比于之前的模式，可以使用更少的代码量完成更复杂的交互； MVC、MVP、MVVM 模式是我们经常遇到的概念，其中 MVVM 是最常用到的，在实际项目中往往没有严格按照模式的定义来设计的系统，开发中也不一定要纠结自己用的到底是哪个模式，合适的才是最好的。</li></ul><h3 id="1-MVC-（Model-View-Controller）"><a href="#1-MVC-（Model-View-Controller）" class="headerlink" title="1. MVC （Model View Controller）"></a><strong>1. MVC （Model View Controller）</strong></h3><blockquote><p><code>MVC</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、控制器（<code>Controller</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 业务数据的处理和存储，数据更新后更新；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Controller</code> 控制器层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，接受并处理 <code>View</code> 层触发的事件，并在 <code>Model</code> 层的数据状态变动时更新 <code>View</code> 层；</li><li><code>MVC</code> 模式的目的是通过引入 <code>Controller</code> 层来将 <code>Model</code> 层和 <code>View</code> 层分离，分层的引入是原来大锅烩方式的改进，使得系统在可维护性和可读性上有了进步。</li><li><code>MVC</code> 模式提出已经有四十余年，<code>MVC</code> 模式在各个书、各个教程、<code>WIKI</code> 的解释有各种版本，甚至 <code>MVC</code> 模式在不同系统中的具体表现也不同，这里只介绍典型 <code>MVC</code> 模式的思路。</li></ul><blockquote><p>典型思路是 <code>View</code> 层通过事件通知到 <code>Controller</code> 层，<code>Controller</code> 层经过对事件的处理完成相关业务逻辑，要求 <code>Model</code> 层改变数据状态，<code>Model</code> 层再将新数据更新到 <code>View</code>层。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，以通过事件通知 <code>Controller</code> 层，经过处理后修改 <code>Model</code> 层的数据，<code>Model</code> 层使用最新数据更新 <code>View</code>。</p><p>用户也可以直接触发 <code>Controller</code> 去更新 <code>Model</code> 层状态，再更新 View 层</p><p>某些场景下，<code>View</code> 层直接采用观察者/发布订阅模式监听 <code>Model</code> 层的变化，这样 <code>View</code>层和 <code>Model</code> 层相互持有、相互操作，导致紧密耦合，在可维护性上有待提升。由此，<code>MVP</code> 模式应运而生 。</p><h3 id="2-MVP-（Model-View-Presenter）"><a href="#2-MVP-（Model-View-Presenter）" class="headerlink" title="2. MVP （Model View Presenter）"></a><strong>2. MVP （Model View Presenter）</strong></h3><blockquote><p><code>MVP</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、管理层（<code>Presenter</code>）。</p></blockquote><ul><li><code>Model</code> 模型层： 只负责存储数据，与 <code>View</code> 呈现无关，也与 <code>UI</code> 处理逻辑无关，发生更新也不用主动通知 <code>View</code>；</li><li><code>View</code> 视图层： 人机交互接口，一般为展示给用户的界面；</li><li><code>Presenter</code> 管理层 ： 负责连接 <code>Model</code> 层和 <code>View</code> 层，处理 <code>View</code> 层的事件，负责获取数据并将获取的数据经过处理后更新 <code>View</code>；</li><li><code>MVC</code> 模式的 <code>View</code> 层和 <code>Model</code> 层存在耦合，为了解决这个问题，<code>MVP</code> 模式将 <code>View</code> 层和 <code>Model</code> 层解耦，之间的交互只能通过 <code>Presenter</code> 层，实际上，<code>MVP</code> 模式的目的就是将 <code>View</code> 层和 Model 层完全解耦，使得对 <code>View</code> 层的修改不会影响到 <code>Model</code> 层，而对 <code>Model</code> 层的数据改动也不会影响到<code>View</code> 层。</li></ul><blockquote><p>典型流程是 <code>View</code> 层触发的事件传递到 <code>Presenter</code> 层中处理，<code>Presenter</code> 层去操作 <code>Model</code> 层，并且将数据返回给 <code>View</code>层，这个过程中，<code>View</code> 层和 <code>Model</code> 层没有直接联系。而 <code>View</code> 层不部署业务逻辑，除了展示数据和触发事件之外，其它时间都在等着 <code>Presenter</code> 层来更新自己，被称为「被动视图」。</p></blockquote><p>在实际操作时，用户可以直接对 <code>View</code> 层的 <code>UI</code> 进行操作，<code>View</code> 层通知 <code>Presenter</code> 层，<code>Presenter</code> 层操作 <code>Model</code> 层的数据，<code>Presenter</code> 层获取到数据之后更新 <code>View</code>。</p><ul><li>由于 <code>Presenter</code> 层负责了数据获取、数据处理、交互逻辑、<code>UI</code> 效果等等功能，所以 <code>Presenter</code> 层就变得强大起来，相应的，<code>Model</code> 层只负责数据存储，而 <code>View</code> 层只负责视图，<code>Model</code> 和 <code>View</code> 层的责任纯粹而单一，如果我们需要添加或修改功能模块，只需要修改 <code>Presenter</code> 层就够了。由于 <code>Presenter</code> 层需要调用 <code>View</code> 层的方法更新视图，<code>Presenter</code> 层直接持有 <code>View</code> 层导致了 <code>Presenter</code> 对 <code>View</code> 的依赖。</li></ul><blockquote><p>正如上所说，更新视图需要 <code>Presenter</code> 层直接持有 <code>View</code> 层，并通过调用 <code>View</code> 层中的方法来实现，还是需要一系列复杂操作，有没有什么机制自动去更新视图而不用我们手动去更新呢，所以，<code>MVVM</code> 模式应运而生。</p></blockquote><h3 id="3-MVVM-（Model-View-ViewModel）"><a href="#3-MVVM-（Model-View-ViewModel）" class="headerlink" title="3. MVVM （Model View ViewModel）"></a><strong>3. MVVM （Model View ViewModel）</strong></h3><blockquote><p><code>MVVM</code> 模式将程序分为三个部分：模型（<code>Model</code>）、视图（<code>View</code>）、视图模型（<code>View-Model</code>）。</p></blockquote><p>和 <code>MVP</code> 模式类似，<code>Model</code> 层和 <code>View</code> 层也被隔离开，彻底解耦，<code>ViewModel</code> 层相当于 <code>Presenter</code> 层，负责绑定 <code>Model</code> 层和 <code>View</code> 层，相比于 <code>MVP</code> 增加了双向绑定机制。</p><blockquote><p><code>MVVM</code> 模式的特征是 <code>ViewModel</code> 层和 <code>View</code> 层采用双向绑定的形式（Binding），<code>View</code> 层的变动，将自动反映在 <code>ViewModel</code> 层，反之亦然。</p></blockquote><ul><li>但是双向绑定给调试和错误定位带来困难，<code>View</code> 层的异常可能是 <code>View</code> 的代码有问题，也有可能是 <code>Model</code> 层的问题。数据绑定使得一个位置的 <code>Bug</code> 被传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</li><li>对简单<code>UI</code> 来说，实现 <code>MVVM</code> 模式的开销是不必要的，而对于大型应用来说，引入 MVVM 模式则会节约大量手动更新视图的复杂过程，是否使用，还是看使用场景。</li></ul><p>这是为什么呢，因为 <code>MVVM</code> 模式要求 <code>Model</code> 层和 <code>View</code> 层完全解耦，但是由于 <code>Vue</code> 还提供了 <code>ref</code> 这样的 <code>API</code>，使得 <code>Model</code> 也可以直接持有 <code>View</code>：</p><p>但是大多数帖子都说直接称呼 <code>Vue</code> 为 <code>MVVM</code> 框架，可见这些模式的划分也不是那么严格。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见设计模式&quot;&gt;&lt;a href=&quot;#常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式&quot;&gt;&lt;/a&gt;常见设计模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#1-为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要学习设计模式？&quot;&gt;&lt;/a&gt;1.为什么要学习设计模式？&lt;/h2&gt;&lt;p&gt;在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。&lt;/p&gt;
&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;2-什么是设计模式。&quot;&gt;&lt;a href=&quot;#2-什么是设计模式。&quot; class=&quot;headerlink&quot; title=&quot;2.什么是设计模式。&quot;&gt;&lt;/a&gt;2.什么是设计模式。&lt;/h2&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;h2 id=&quot;3-设计模式的发展历史&quot;&gt;&lt;a href=&quot;#3-设计模式的发展历史&quot; class=&quot;headerlink&quot; title=&quot;3.设计模式的发展历史&quot;&gt;&lt;/a&gt;3.设计模式的发展历史&lt;/h2&gt;&lt;p&gt;设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。&lt;/p&gt;
&lt;p&gt;四人帮把这本书分成两部分：&lt;/p&gt;
&lt;p&gt;第一部分解释面向对象编程的优缺点。&lt;/p&gt;
&lt;p&gt;第二部分是关于 23 个经典设计模式的演变。&lt;/p&gt;
&lt;p&gt;自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。&lt;/p&gt;
&lt;h2 id=&quot;4-设计模式分类&quot;&gt;&lt;a href=&quot;#4-设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;4.设计模式分类&quot;&gt;&lt;/a&gt;4.设计模式分类&lt;/h2&gt;&lt;p&gt;根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来将概述属于这三种类型的 23 种设计模式的主要概念。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>js函数手写</title>
    <link href="https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/"/>
    <id>https://hxy1997.xyz/2020/10/18/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2021-02-25T03:45:42.945Z</updated>
    
    <content type="html"><![CDATA[<p>手写常见js函数，面试必备，多练几遍，争取手撕</p><a id="more"></a><h1 id="手动实现call-apply-bind"><a href="#手动实现call-apply-bind" class="headerlink" title="手动实现call,apply,bind"></a>手动实现call,apply,bind</h1><h2 id="模拟实现call"><a href="#模拟实现call" class="headerlink" title="模拟实现call"></a>模拟实现call</h2><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p><p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p><p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p><p>4.处理参数，传入第一个参数后的其余参数</p><p>r5.调用函数后即删除该<code>Symbol</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// context = context || window;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">context[fn] = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line"><span class="keyword">delete</span> context[fn];</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h2><p>1.处理参数，返回一个闭包</p><p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p><p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>获取函数中的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    fn(...args);</span><br><span class="line">    fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以广泛应用于异步编程，它可以代替我们传统的回调函数</li><li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li><li>取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。</li><li>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</li></ul><h2 id="Nodejs的EventEmitter"><a href="#Nodejs的EventEmitter" class="headerlink" title="Nodejs的EventEmitter"></a>Nodejs的EventEmitter</h2><p><code>Nodejs</code>的<code>EventEmitter</code>就是观察者模式的典型实现，<code>Nodejs</code>的<code>events</code>模块只提供了一个对象： <code>events.EventEmitter``。EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。</p><blockquote><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p></blockquote><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p><strong>addListener(event, listener)</strong></p><p>为指定事件添加一个监听器，默认添加到监听器数组的尾部。</p><p><strong>removeListener(event, listener)</strong></p><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><p><strong>setMaxListeners(n)</strong></p><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p><p><strong>once(event, listener)</strong></p><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p><p><strong>emit(event, [arg1], [arg2], […])</strong></p><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，调用一次，处理函数为 listener2</span></span><br><span class="line">eventEmitter.once(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="手动实现EventEmitter"><a href="#手动实现EventEmitter" class="headerlink" title="手动实现EventEmitter"></a>手动实现EventEmitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件</span></span><br><span class="line"><span class="comment">// prepend为true表示向事件队列头部添加事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, prepend</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>._events) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].unshift(listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type] = [listener];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某个事件</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>._events[type]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type] = <span class="built_in">this</span>._events[type].filter(<span class="function"><span class="params">e</span> =&gt;</span> e !== listener &amp;&amp; e.origin !== listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件，只执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> only = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        listener.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        <span class="built_in">this</span>.removeListener(type, listener);</span><br><span class="line">    &#125;</span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="built_in">this</span>.addListener(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某类事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">        <span class="built_in">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大事件监听个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.maxListeners = count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceListener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我只能被执行一次&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我是一个listener&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">&#x27;click&#x27;</span>, onceListener);</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">emitter.removeListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JavaScript自定义事件"><a href="#JavaScript自定义事件" class="headerlink" title="JavaScript自定义事件"></a>JavaScript自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建事件</span></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;myEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册事件监听器</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;myEvent&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、触发事件</span></span><br><span class="line">elem.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure><h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime = now</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="简单版："><a href="#简单版：" class="headerlink" title="简单版："></a>简单版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure><h3 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a><strong>局限性：</strong></h3><ul><li>他无法实现对函数 、RegExp等特殊对象的克隆</li><li>会抛弃对象的constructor,所有的构造函数会指向Object</li><li>对象有循环引用,会报错</li></ul><h3 id="面试版-递归"><a href="#面试版-递归" class="headerlink" title="面试版:递归"></a>面试版:递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">let res </span><br><span class="line">&#x2F;&#x2F; 判断是否是简单数据类型</span><br><span class="line">if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">&#x2F;&#x2F; 复杂数据类型</span><br><span class="line">res &#x3D; object.constructor &#x3D;&#x3D; Array ? [] : &#123;&#125;;</span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line">res[i] &#x3D; typeof obj[i] &#x3D;&#x3D; &quot;object&quot; ? deepCopy(obj[i]) : obj[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 简单数据类型 直接 &#x3D;&#x3D; 赋值</span><br><span class="line">res &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组去重、扁平、最值"><a href="#数组去重、扁平、最值" class="headerlink" title="数组去重、扁平、最值"></a>数组去重、扁平、最值</h1><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function unique (array) &#123;</span><br><span class="line">    let container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-filter"><a href="#indexOf-filter" class="headerlink" title="indexOf + filter"></a>indexOf + filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return arr.filter((e,i) &#x3D;&gt; arr.indexOf(e) &#x3D;&#x3D;&#x3D; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique (arr) &#123;</span><br><span class="line">return  [...new Set(arr)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>递归调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flat (array) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (Array.isArray(array[i])) &#123;</span><br><span class="line">        result &#x3D; result.concat(flat(array[i]));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        result.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用reduce简化"><a href="#使用reduce简化" class="headerlink" title="使用reduce简化"></a>使用reduce简化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(</span><br><span class="line">        (target, current) =&gt; <span class="built_in">Array</span>.isArray(current) ? target.concat(flatten(current)) : target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_flat = arr.flat(<span class="literal">Infinity</span>);</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ary &#x3D; str.replace(&#x2F;(\[|\])&#x2F;g, &#39;&#39;).split(&#39;,&#39;);</span><br></pre></td></tr></table></figure><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n));</span><br></pre></td></tr></table></figure><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null, array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">        target.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组乱序-洗牌算法"><a href="#数组乱序-洗牌算法" class="headerlink" title="数组乱序-洗牌算法"></a>数组乱序-洗牌算法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disorder</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">let</span> current = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> random;</span><br><span class="line">    <span class="keyword">while</span> (current &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">        [array[current], array[random]] = [array[random], array[current]];</span><br><span class="line">        current--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args &#x3D; []) &#123;</span><br><span class="line">    let length &#x3D; fn.length;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        newArgs &#x3D; args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">        if (newArgs.length &lt; length) &#123;</span><br><span class="line">            return curry.call(this, fn, newArgs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return fn.apply(this, newArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function multiFn(a, b, c) &#123;</span><br><span class="line">    return a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var multi &#x3D; curry(multiFn);</span><br><span class="line"></span><br><span class="line">multi(2)(3)(4);</span><br><span class="line">multi(2,3,4);</span><br><span class="line">multi(2)(3,4);</span><br><span class="line">multi(2,3)(4)</span><br></pre></td></tr></table></figure><h3 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const curry &#x3D; (fn, arr &#x3D; []) &#x3D;&gt; (...args) &#x3D;&gt; (</span><br><span class="line">  arg &#x3D;&gt; arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, arg)</span><br><span class="line">)([...arr, ...args])</span><br><span class="line"></span><br><span class="line">let curryTest&#x3D;curry((a,b,c,d) &#x3D;&gt; a + b + c + d)</span><br><span class="line">curryTest(1,2,3)(4) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(4)(3) &#x2F;&#x2F; 返回10</span><br><span class="line">curryTest(1,2)(3,4) &#x2F;&#x2F; 返回10</span><br></pre></td></tr></table></figure><h3 id="简单写法版"><a href="#简单写法版" class="headerlink" title="简单写法版"></a>简单写法版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, ...args) &#123;</span><br><span class="line">    if (args.length &gt;&#x3D; fn.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span><br><span class="line">    return fn(...args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回currying函数</span><br><span class="line">    return (...args2) &#x3D;&gt; currying(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手动实现JSONP"><a href="#手动实现JSONP" class="headerlink" title="手动实现JSONP"></a>手动实现JSONP</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p><ul><li>1.将传入的data数据转化为url字符串形式</li><li>2.处理url中的回调函数</li><li>3.创建一个script标签并插入到页面中</li><li>4.挂载回调函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(function (window,document) &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    var jsonp &#x3D; function (url, data, callback) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">        &#x2F;&#x2F; 例子&#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">        var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">        for(var key in data)&#123;</span><br><span class="line">            dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">        &#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">        var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">        dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">        var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">        window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">            document.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        document.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.$jsonp &#x3D; jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure><p>简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用script属性</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">&#x27;http://xxx&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="模拟实现promise"><a href="#模拟实现promise" class="headerlink" title="模拟实现promise"></a>模拟实现promise</h1><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p><p>Promise有三种状态.，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中),它接受两个参数分别是resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去.</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.status = <span class="string">&quot;pending&quot;</span>   <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;   <span class="comment">// 定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;  <span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">self.status === <span class="string">&quot;pending&quot;</span></span>)</span> &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">    &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加 then 方法</span><br><span class="line">myPromise.prototype.then &#x3D; function(onFullfilled, onRejected) &#123;</span><br><span class="line">   let self &#x3D; this;</span><br><span class="line">   switch(self.status) &#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new myPromise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(x) &#123;</span><br><span class="line">    console.log(x) &#x2F;&#x2F; 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.catch &#x3D; function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally &#x3D; function(fn) &#123;</span><br><span class="line">    return this.then(value &#x3D;&gt; &#123;</span><br><span class="line">       fn();</span><br><span class="line">       return value;</span><br><span class="line">    &#125;, reason &#x3D;&gt; &#123;</span><br><span class="line">        fn();</span><br><span class="line">        throw reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="手动实现ES5继承"><a href="#手动实现ES5继承" class="headerlink" title="手动实现ES5继承"></a>手动实现ES5继承</h1><p>Child继承Parent</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote><p>子类的原型指向父类。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p><h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><blockquote><p>在子类构造函数中调用父类构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>使用构造继承继承父类参数，使用原型继承继承父类函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><blockquote><p>将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure><h2 id="寄生组合继承优化"><a href="#寄生组合继承优化" class="headerlink" title="寄生组合继承优化"></a>寄生组合继承优化</h2><p>父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>最推荐的一种方式，接近完美的继承。</p><h1 id="手动实现instanceof"><a href="#手动实现instanceof" class="headerlink" title="手动实现instanceof"></a>手动实现instanceof</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>按照target原型链的向上查找，直到找到 origin 或 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = target.__proto__;</span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (origin.prototype == proto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myInstanceof(proto, origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Promise的ajax封装"><a href="#基于Promise的ajax封装" class="headerlink" title="基于Promise的ajax封装"></a>基于Promise的ajax封装</h1><p>基于把原生<code>ajax</code>封装为<code>Promise</code>形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">const</span> paramString = getStringParam(param);</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;get&#x27;</span> &amp;&amp; paramString) &#123;</span><br><span class="line">        url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span> ? url += paramString : url += <span class="string">`?<span class="subst">$&#123;paramString&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> result = &#123;</span><br><span class="line">                status: xhr.status,</span><br><span class="line">                statusText: xhr.statusText,</span><br><span class="line">                headers: xhr.getAllResponseHeaders(),</span><br><span class="line">                data: xhr.response || xhr.responseText</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="comment">// 跨域携带cookie</span></span><br><span class="line">        xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求出错&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.timeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求超时&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;请求被终止&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        xhr.send(paramString);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringParam</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> param) &#123;</span><br><span class="line">    dataString += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;param[key]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在合适的时候才创建对像，并且只创建唯一的一个。创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。使用闭包实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Singleton (name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Single.getInstance &#x3D; (function(name) &#123;</span><br><span class="line">let instance;</span><br><span class="line">return function(name) &#123;</span><br><span class="line">if (!instance) &#123;</span><br><span class="line">instance &#x3D; new Singleton(name);</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a &#x3D; Singleton.getInstance(&#39;ConardLi&#39;);</span><br><span class="line">var b &#x3D; Singleton.getInstance(&#39;ConardLi2&#39;);</span><br><span class="line"></span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; b);   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><blockquote><p>另一种实现方式，核心要点: 用闭包和Proxy属性拦截</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">      <span class="title">constructor</span> (<span class="params">target, args</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="built_in">Reflect</span>.constructor(fun, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(func, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异步循环打印"><a href="#异步循环打印" class="headerlink" title="异步循环打印"></a>异步循环打印</h1><p>使用<code>promise + async await</code>实现异步循环打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(i);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><h2 id="监听图片高度"><a href="#监听图片高度" class="headerlink" title="监听图片高度"></a>监听图片高度</h2><p>图片，用一个其他属性存储真正的图片地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="built_in">window</span>.innerHeight; <span class="comment">//可见区域高度</span></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; img.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">        <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><blockquote><p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">    <span class="keyword">let</span> lazyImageObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> lazyImage = entry.target;</span><br><span class="line">            <span class="comment">// 如果元素可见            </span></span><br><span class="line">            <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyImage.getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                    lazyImage.src = lazyImage.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; img.length; i++) &#123;</span><br><span class="line">        lazyImageObserver.observe(img[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟Object-create"><a href="#模拟Object-create" class="headerlink" title="模拟Object.create"></a>模拟Object.create</h1><blockquote><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个JSON-stringify"><a href="#实现一个JSON-stringify" class="headerlink" title="实现一个JSON.stringify"></a>实现一个JSON.stringify</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 不是字符串 undefined 和 function 类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">            obj = <span class="string">&#x27;&quot;&#x27;</span> + obj + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// JSON为空数组</span></span><br><span class="line">        <span class="keyword">let</span> json = []</span><br><span class="line">        <span class="comment">// 是否为数组</span></span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">let</span> v = obj[k];</span><br><span class="line">            <span class="keyword">let</span> type = <span class="keyword">typeof</span> v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">                v = <span class="string">&#x27;&quot;&#x27;</span> + v + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                v = jsonStringify(v);</span><br><span class="line">            &#125;</span><br><span class="line">            json.push((arr ? <span class="string">&quot;&quot;</span> : <span class="string">&#x27;&quot;&#x27;</span> + k + <span class="string">&#x27;&quot;:&#x27;</span>) + <span class="built_in">String</span>(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jsonStringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;) <span class="comment">// &quot;&#123;&quot;x&quot;:5&#125;&quot;</span></span><br><span class="line">jsonStringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]) <span class="comment">// &quot;[1,&quot;false&quot;,false]&quot;</span></span><br><span class="line">jsonStringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;) <span class="comment">// &quot;&#123;&quot;b&quot;:&quot;undefined&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="实现一个JSON-parse"><a href="#实现一个JSON-parse" class="headerlink" title="实现一个JSON.parse"></a>实现一个JSON.parse</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text[, reviver])</span><br></pre></td></tr></table></figure><blockquote><p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p></blockquote><h2 id="方法1：直接调用-eval"><a href="#方法1：直接调用-eval" class="headerlink" title="方法1：直接调用 eval"></a>方法1：直接调用 eval</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function jsonParse(opt) &#123;</span><br><span class="line">    return eval(&#39;(&#39; + opt + &#39;)&#39;);</span><br><span class="line">&#125;</span><br><span class="line">jsonParse(jsonStringify(&#123;x : 5&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; x: 5&#125;</span><br><span class="line">jsonParse(jsonStringify([1, &quot;false&quot;, false]))</span><br><span class="line">&#x2F;&#x2F; [1, &quot;false&quot;, falsr]</span><br><span class="line">jsonParse(jsonStringify(&#123;b: undefined&#125;))</span><br><span class="line">&#x2F;&#x2F; Object &#123; b: &quot;undefined&quot;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p></blockquote><p>如果你只想记这个方法，就得对参数json做校验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json</span><br><span class="line">            .replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：Function"><a href="#方法2：Function" class="headerlink" title="方法2：Function"></a>方法2：Function</h2><blockquote><p>核心：Function与eval有相同的字符串参数特性</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var func = new Function(arg1, arg2, ..., functionBody);</span><br></pre></td></tr></table></figure><p>在转换JSON的实际应用中，只需要这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> json = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))();</span><br></pre></td></tr></table></figure><blockquote><p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p></blockquote><h1 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line">parseParam(url)</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">        <span class="comment">// 分割 key 和 value</span></span><br><span class="line">        <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 递归调用解码</span></span><br><span class="line">        val = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="comment">// 判断是否转为数字</span></span><br><span class="line">        val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">            paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">        paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板引擎实现"><a href="#模板引擎实现" class="headerlink" title="模板引擎实现"></a>模板引擎实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let template &#x3D; &#39;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#39;;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">    name: &#39;姓名&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">render(template, data); &#x2F;&#x2F; 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">     <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        template = template.replace(reg, data[name]);</span><br><span class="line">        <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="转化为驼峰命名"><a href="#转化为驼峰命名" class="headerlink" title="转化为驼峰命名"></a>转化为驼峰命名</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span></span><br><span class="line"><span class="comment">// 转化为 getElementById</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 首字母大写</span></span><br><span class="line">        <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找字符串中出现最多的字符和个数"><a href="#查找字符串中出现最多的字符和个数" class="headerlink" title="查找字符串中出现最多的字符和个数"></a>查找字符串中出现最多的字符和个数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 自己用哈希表</span></span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.replace(re, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">num &lt; $<span class="number">0.</span>length</span>)</span>&#123;</span><br><span class="line">        num = $<span class="number">0.</span>length;</span><br><span class="line">        char = $<span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><blockquote><p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p></blockquote><p>暴力解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var strStr &#x3D; function(haystack, needle) &#123;</span><br><span class="line">    let m &#x3D;  haystack.length;</span><br><span class="line">    let n &#x3D; needle.length;</span><br><span class="line">    for (let i &#x3D; 0; i &lt;&#x3D; m - n; i++) &#123;</span><br><span class="line">        let j;</span><br><span class="line">        for (j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (needle[j] !&#x3D;&#x3D; haystack[i + j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; needle子串全都匹配了</span><br><span class="line">        if (j &#x3D;&#x3D;&#x3D; n) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; haystack中不存在needle</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = -<span class="number">1</span>, n = haystack.length, p = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="built_in">Array</span>(p).fill(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算next数组</span></span><br><span class="line">    calNext(needle, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; -<span class="number">1</span> &amp;&amp; needle[k + <span class="number">1</span>] != haystack[i]) &#123;</span><br><span class="line">            <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] == haystack[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == p - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数- 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calNext</span>(<span class="params">needle, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>, p = -<span class="number">1</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; -<span class="number">1</span> &amp;&amp; needle[p + <span class="number">1</span>] != needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p + <span class="number">1</span>] == needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 位置j处更新最长前缀</span></span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>马拉车水平不够</p><h1 id="实现千位分隔符"><a href="#实现千位分隔符" class="headerlink" title="实现千位分隔符"></a>实现千位分隔符</h1><p>正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    return (n + &#39;&#39;).replace(&#x2F;(?!^)(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g, &#39;.&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    let ans &#x3D; &quot;&quot;;</span><br><span class="line">    do &#123;</span><br><span class="line">        let cur &#x3D; n % 10;</span><br><span class="line">        n &#x3D; Math.floor(n &#x2F; 10);</span><br><span class="line">        ans +&#x3D; cur;</span><br><span class="line">        count++;</span><br><span class="line">        if (count % 3 &#x3D;&#x3D; 0 &amp;&amp; n) &#123;</span><br><span class="line">            ans +&#x3D; &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (n);</span><br><span class="line">    return ans.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断是否是电话号码"><a href="#判断是否是电话号码" class="headerlink" title="判断是否是电话号码"></a>判断是否是电话号码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isPhone(tel) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;</span><br><span class="line">    return regx.test(tel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证是否是邮箱"><a href="#验证是否是邮箱" class="headerlink" title="验证是否是邮箱"></a>验证是否是邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isEmail(email) &#123;</span><br><span class="line">    var regx &#x3D; &#x2F;^([a-zA-Z0-9_\-]+@([a-zA-Z0-9_\-]+)+$&#x2F;;</span><br><span class="line">    return regx.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用ES5实现数组的map方法"><a href="#用ES5实现数组的map方法" class="headerlink" title="用ES5实现数组的map方法"></a>用ES5实现数组的map方法</h1><ul><li>回调函数的参数有哪些，返回值如何处理</li><li>不修改原来的数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.MyMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 由于是ES5所以就不用...展开符了</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">let</span> mappedArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        mappedArr.push(fn.call(context, arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用ES5实现数组的reduce方法"><a href="#用ES5实现数组的reduce方法" class="headerlink" title="用ES5实现数组的reduce方法"></a>用ES5实现数组的reduce方法</h1><ul><li>初始值不传怎么处理</li><li>回调函数的参数有哪些，返回值如何处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myReduce &#x3D; function(fn, initialValue) &#123;</span><br><span class="line">    let arr &#x3D; Array.prototpye.slice.call(this);</span><br><span class="line">    let res, startIndex;</span><br><span class="line">    res &#x3D; initialValue ? initialValue : arr[0];</span><br><span class="line">    startIndex &#x3D; initialValue ? 0 : 1;</span><br><span class="line">    for (let i &#x3D; startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res &#x3D; fn.call(null, res, arr[i], i, this);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于普通函数，绑定this指向</li><li>对于构造函数，要保证原函数的原型对象上的属性不能丢失</li></ul><h1 id="请实现一个-add-函数，满足以下功能"><a href="#请实现一个-add-函数，满足以下功能" class="headerlink" title="请实现一个 add 函数，满足以下功能"></a>请实现一个 add 函数，满足以下功能</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；<span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> fn_args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">returm args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒"><a href="#实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒" class="headerlink" title="实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒"></a>实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const sleep &#x3D; (time) &#x3D;&gt; &#123;</span><br><span class="line">return new Promise(resolve &#x3D;&gt; setTimeout(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(1000).then(() &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 这里写你的函数</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="实现-5-add-3-minus-2-功能"><a href="#实现-5-add-3-minus-2-功能" class="headerlink" title="实现 (5).add(3).minus(2) 功能"></a>实现 (5).add(3).minus(2) 功能</h1><blockquote><p>例： 5 + 3 - 2，结果为 6</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现一个双向绑定"><a href="#实现一个双向绑定" class="headerlink" title="实现一个双向绑定"></a>实现一个双向绑定</h1><p><strong>defineProperty 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">Object.defineProperty(data, &#39;text&#39;, &#123;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">set(newVal) &#123;</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">data.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>proxy 版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据</span><br><span class="line">const data &#x3D; &#123;</span><br><span class="line">text: &#39;default&#39;</span><br><span class="line">&#125;;</span><br><span class="line">const input  &#x3D; document.getElementById(&#39;input&#39;);</span><br><span class="line">const span  &#x3D; document.getElementById(&#39;span&#39;);</span><br><span class="line">&#x2F;&#x2F; 数据劫持</span><br><span class="line">const handler &#x3D; &#123;</span><br><span class="line">set(target, key, value) &#123;</span><br><span class="line">target[key] &#x3D; value;</span><br><span class="line">&#x2F;&#x2F; 数据变化 --&gt; 修改视图</span><br><span class="line">input.value &#x3D; newVal;</span><br><span class="line">span.innerHTML &#x3D; newVal;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy &#x3D; new Proxy(data, handler);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图更改 --&gt; 数据变化</span><br><span class="line">input.addEventLisener(&#39;keyup&#39;, function(e) &#123;</span><br><span class="line">proxy.text &#x3D; e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Array-isArray-实现"><a href="#Array-isArray-实现" class="headerlink" title="Array.isArray 实现"></a>Array.isArray 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.myIsArray &#x3D; function(o) &#123;</span><br><span class="line">return Object.prototype.toString.call(Object(o)) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Array.myIsArray([])); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h1 id="实现一个函数判断数据类型"><a href="#实现一个函数判断数据类型" class="headerlink" title="实现一个函数判断数据类型"></a>实现一个函数判断数据类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    <span class="comment">// 对象类型 &quot;[object XXX]&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="string">&#x27;[object &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase() : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">getType(<span class="literal">null</span>); <span class="comment">// -&gt; null</span></span><br><span class="line">getType(<span class="literal">undefined</span>); <span class="comment">// -&gt; undefined</span></span><br><span class="line">getType(&#123;&#125;); <span class="comment">// -&gt; object</span></span><br><span class="line">getType([]); <span class="comment">// -&gt; array</span></span><br><span class="line">getType(<span class="number">123</span>); <span class="comment">// -&gt; number</span></span><br><span class="line">getType(<span class="literal">true</span>); <span class="comment">// -&gt; boolean</span></span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// -&gt; string</span></span><br><span class="line">getType(<span class="regexp">/123/</span>); <span class="comment">// -&gt; regexp</span></span><br><span class="line">getType(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// -&gt; date</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;手写常见js函数，面试必备，多练几遍，争取手撕&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="ES6" scheme="https://hxy1997.xyz/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="https://hxy1997.xyz/2020/02/23/javascript/"/>
    <id>https://hxy1997.xyz/2020/02/23/javascript/</id>
    <published>2020-02-22T16:09:54.000Z</published>
    <updated>2021-02-25T08:24:52.941Z</updated>
    
    <content type="html"><![CDATA[<p>javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读</p><a id="more"></a><h1 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h1><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个构造函数都有一个 prototype 属性 ，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 虽然写在注释里，但是你要注意：</span><br><span class="line">&#x2F;&#x2F; prototype是对象的属性</span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F; Kevin</span><br><span class="line">console.log(person2.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></a></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在Firefox或者Chrome中控制台输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图"></a></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为同一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person &#x3D;&#x3D;&#x3D; Person.prototype.constructor); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图"></a></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图"></a></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 就是 Object.prototype 没有原型，表达了同一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><a href="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"><img data-src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></a></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.name &#x3D; &#39;kevin&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 关键 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child1.getName()) &#x2F;&#x2F; kevin</span><br></pre></td></tr></table></figure><p>缺点：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向Parent传参</p><h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Parent () &#123;</span><br><span class="line">    this.names &#x3D; [&#39;kevin&#39;, &#39;daisy&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child () &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(&#39;yayu&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child();</span><br><span class="line"></span><br><span class="line">console.log(child2.names); &#x2F;&#x2F; [&quot;kevin&quot;, &quot;daisy&quot;]</span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义每个子类实例不能共享父函数，浪费内存，开销较大。不能继承父类原型。</p><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">&#x2F;&#x2F; 关键 在子类构造函数中调用父类构造函数</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类的原型指向父类</span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line">Child.prototype.constructor &#x3D; Child;</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">child1.colors.push(&#39;black&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1.name); &#x2F;&#x2F; kevin</span><br><span class="line">console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var child2 &#x3D; new Child(&#39;daisy&#39;, &#39;20&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child2.name); &#x2F;&#x2F; daisy</span><br><span class="line">console.log(child2.age); &#x2F;&#x2F; 20</span><br><span class="line">console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>缺点：Parent的构造函数会多执行了一次</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function createObj(o) &#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：</p><p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;kevin&#39;,</span><br><span class="line">    friends: [&#39;daisy&#39;, &#39;kelly&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; createObj(person);</span><br><span class="line">var person2 &#x3D; createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name &#x3D; &#39;person1&#39;;</span><br><span class="line">console.log(person2.name); &#x2F;&#x2F; kevin</span><br><span class="line"></span><br><span class="line">person1.firends.push(&#39;taylor&#39;);</span><br><span class="line">console.log(person2.friends); &#x2F;&#x2F; [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createObj (o) &#123;</span><br><span class="line">    var clone &#x3D; Object.create(o);</span><br><span class="line">    clone.sayName &#x3D; function () &#123;</span><br><span class="line">        console.log(&#39;hi&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new Parent();</span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype &#x3D; new Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(this, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child (name, age) &#123;</span><br><span class="line">    Parent.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键的三步</span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype &#x3D; Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype &#x3D; new F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var child1 &#x3D; new Child(&#39;kevin&#39;, &#39;18&#39;);</span><br><span class="line"></span><br><span class="line">console.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function prototype(child, parent) &#123;</span><br><span class="line">    var prototype &#x3D; object(parent.prototype);</span><br><span class="line">    prototype.constructor &#x3D; child;</span><br><span class="line">    child.prototype &#x3D; prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当我们使用的时候：</span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p><h1 id="7-Promise-原理"><a href="#7-Promise-原理" class="headerlink" title="7.Promise 原理"></a>7.Promise 原理</h1><p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p><p>基本过程：</p><ol><li>初始化 Promise 状态（pending）</li><li>立即执行 Promise 中传入的 fn 函数，将Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li><li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li><li>Promise里的关键是要保证，then方法传入的参数 onFulfilled 和 onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol><p><strong>真正的链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise.</strong></p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#123; test: 1 &#125;)</span><br><span class="line">            resolve(&#123; test: 2 &#125;)</span><br><span class="line">            reject(&#123; test: 2 &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#125;,(data1)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;result2&#39;,data1)</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result3&#39;, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">    &#x2F;&#x2F;result3 undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>显然这里输出了不同的 data。由此可以看出几点：</p><ol><li>可进行链式调用，且每次 then 返回了新的 Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。</li><li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending -&gt; fulfilled或 pending-&gt; rejected,是不可逆的。</li><li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的。</li></ol><p>基于以上几点，我们先写个基于 <a href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        let state &#x3D; &#39;pending&#39;;</span><br><span class="line">        let value &#x3D; null;</span><br><span class="line">        const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        this.then &#x3D; function (onFulfilled)&#123;</span><br><span class="line">            return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">                handle(&#123; &#x2F;&#x2F;桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span><br><span class="line">                    onFulfilled, </span><br><span class="line">                    resolve</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function handle(callback)&#123;</span><br><span class="line">            if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                callbacks.push(callback)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">                if(!callback.onFulfilled)&#123;</span><br><span class="line">                    callback.resolve(value)</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                const ret &#x3D; callback.onFulfilled(value) &#x2F;&#x2F;处理回调</span><br><span class="line">                callback.resolve(ret) &#x2F;&#x2F;处理下一个 promise 的resolve</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function resolve(newValue)&#123;</span><br><span class="line">            const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">                state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                value &#x3D; newValue</span><br><span class="line">                handelCb()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            setTimeout(fn,0) &#x2F;&#x2F;基于 PromiseA+ 规范</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        function handelCb()&#123;</span><br><span class="line">            while(callbacks.length) &#123;</span><br><span class="line">                const fulfiledFn &#x3D; callbacks.shift();</span><br><span class="line">                handle(fulfiledFn);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fn(resolve)</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个 Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p><p>但是如果仅仅是例子中的情况，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#123; test: 1 &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result1&#39;, data)</span><br><span class="line">        &#x2F;&#x2F;dosomething</span><br><span class="line">        console.log(&#39;result3&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">    &#x2F;&#x2F;result3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#123; test: 1 &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result1&#39;, data)</span><br><span class="line">  &#x2F;&#x2F;dosomething</span><br><span class="line">  return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">  return new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;基于第一个 Promise 模型，执行后的输出</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 Promise &#123;then: ƒ&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        function resolve(newValue)&#123;</span><br><span class="line">            const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">                if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                    const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                    if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                        &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                        &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                        then.call(newValue,resolve)</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                value &#x3D; newValue</span><br><span class="line">                handelCb()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            setTimeout(fn,0)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>用这个模型，再测试我们的例子，就得到了正确的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#123; test: 1 &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result1&#39;, data)</span><br><span class="line">        &#x2F;&#x2F;dosomething</span><br><span class="line">        return test()</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result2&#39;, data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    function test(id) &#123;</span><br><span class="line">        return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#123; test: 2 &#125;)</span><br><span class="line">            &#125;, 5000)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">    &#x2F;&#x2F;result2 &#123; test: 2 &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p><p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p><p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p><p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：</p><table><thead><tr><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>P1</td><td>[{onFulfilled:c1(第一个then中的fn),resolve:p2resolve}]</td></tr><tr><td>P2 (P1 调用 then 时产生)</td><td>[{onFulfilled:c2(第二个then中的fn),resolve:p3resolve}]</td></tr><tr><td>P3 (P2 调用 then 时产生)</td><td>[]</td></tr><tr><td>P4 (执行c1中产生[调用 test ])</td><td>[{onFulfilled:p2resolve,resolve:p5resolve}]</td></tr><tr><td>P5 (调用p2resolve 时，进入 then.call 逻辑中产生)</td><td>[]</td></tr></tbody></table><p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p><p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p><p>以上就是链式调用的原理了。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p><p>完整代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        let state &#x3D; &#39;pending&#39;;</span><br><span class="line">        let value &#x3D; null;</span><br><span class="line">        const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">            return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">                handle(&#123;</span><br><span class="line">                    onFulfilled, </span><br><span class="line">                    onRejected,</span><br><span class="line">                    resolve, </span><br><span class="line">                    reject</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function handle(callback)&#123;</span><br><span class="line">            if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                callbacks.push(callback)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">            const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">            if(!cb)&#123;</span><br><span class="line">                next(value)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const ret &#x3D; cb(value)</span><br><span class="line">            next(ret)</span><br><span class="line">        &#125;</span><br><span class="line">        function resolve(newValue)&#123;</span><br><span class="line">            const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">                if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                    const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                    if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                        &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                        &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                        then.call(newValue,resolve, reject)</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                value &#x3D; newValue</span><br><span class="line">                handelCb()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            setTimeout(fn,0)</span><br><span class="line">        &#125;</span><br><span class="line">        function reject(error)&#123;</span><br><span class="line"></span><br><span class="line">            const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">                if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">                if(error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                    const &#123;then&#125; &#x3D; error</span><br><span class="line">                    if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                        then.call(error,resolve, reject)</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state &#x3D; &#39;rejected&#39;;</span><br><span class="line">                value &#x3D; error</span><br><span class="line">                handelCb()</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(fn,0)</span><br><span class="line">        &#125;</span><br><span class="line">        function handelCb()&#123;</span><br><span class="line">            while(callbacks.length) &#123;</span><br><span class="line">                const fn &#x3D; callbacks.shift();</span><br><span class="line">                handle(fn);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        fn(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p><p>handle代码改造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">        const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">        if(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            const ret &#x3D; cb(value)</span><br><span class="line">            next(ret)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            callback.reject(e);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#123; test: 1 &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;result1&#39;, data)</span><br><span class="line">        &#x2F;&#x2F;dosomething</span><br><span class="line">        return test()</span><br><span class="line">    &#125;).catch((ex) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;error&#39;, ex)</span><br><span class="line">    &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>实际上，错误也好，异常也罢，最终都是通过reject实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">            return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">                handle(&#123;</span><br><span class="line">                    onFulfilled, </span><br><span class="line">                    onRejected,</span><br><span class="line">                    resolve, </span><br><span class="line">                    reject</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.catch &#x3D; function (onError)&#123;</span><br><span class="line">            this.then(null,onError)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="Finally方法"><a href="#Finally方法" class="headerlink" title="Finally方法"></a>Finally方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管Promise最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        this.catch &#x3D; function (onError)&#123;</span><br><span class="line">            this.then(null,onError)</span><br><span class="line">        &#125;</span><br><span class="line">        this.finally &#x3D; function (onDone)&#123;</span><br><span class="line">            this.then(onDone,onDone)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">Promise.reject(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">new Promise((resolve,reject) &#x3D;&gt; reject(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p><ul><li>无参数 [直接返回一个resolved状态的 Promise 对象]</li><li>普通数据对象 [直接返回一个resolved状态的 Promise 对象]</li><li>一个Promise实例 [直接返回当前实例]</li><li>一个thenable对象(thenable对象指的是具有then方法的对象) [转为 Promise 对象，并立即执行thenable对象的then方法。]</li></ul><p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        this.resolve &#x3D; function (value)&#123;</span><br><span class="line">            if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125; else if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                let then &#x3D; value.then;</span><br><span class="line">                return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">                    then(resolve);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else if (value) &#123;</span><br><span class="line">                return new Promise(resolve &#x3D;&gt; resolve(value));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Promise.reject与Promise.resolve类似，区别在于Promise.reject始终返回一个状态的rejected的Promise实例，而Promise.resolve的参数如果是一个Promise实例的话，返回的是参数对应的Promise实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        this.reject &#x3D; function (value)&#123;</span><br><span class="line">            return new Promise(function(resolve, reject) &#123;</span><br><span class="line">reject(value);</span><br><span class="line">&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    function Promise(fn)&#123; </span><br><span class="line">        ...</span><br><span class="line">        this.all &#x3D; function (arr)&#123;</span><br><span class="line">            var args &#x3D; Array.prototype.slice.call(arr);</span><br><span class="line">            return new Promise(function(resolve, reject) &#123;</span><br><span class="line">                if(args.length &#x3D;&#x3D;&#x3D; 0) return resolve([]);</span><br><span class="line">                var remaining &#x3D; args.length;</span><br><span class="line"></span><br><span class="line">                function res(i, val) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if(val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">                            var then &#x3D; val.then;</span><br><span class="line">                            if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                                then.call(val, function(val) &#123;</span><br><span class="line">                                    res(i, val);</span><br><span class="line">                                &#125;, reject);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        args[i] &#x3D; val;</span><br><span class="line">                        if(--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            resolve(args);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch(ex) &#123;</span><br><span class="line">                        reject(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                for(var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                    res(i, args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123; </span><br><span class="line">    ...</span><br><span class="line">    this.race &#x3D; function(values) &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            for(var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://promisesaplus.com/">PromiseA+规范</a></li><li><a href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li><li><a href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30分钟，让你彻底明白Promise原理</a></li></ul><h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  let state &#x3D; &#39;pending&#39;</span><br><span class="line">  let value &#x3D; null</span><br><span class="line">  const callbacks &#x3D; []</span><br><span class="line"></span><br><span class="line">  this.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.catch &#x3D; function (onError) &#123;</span><br><span class="line">    return this.then(null, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.finally &#x3D; function (onDone) &#123;</span><br><span class="line">    this.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">      return value</span><br><span class="line">    &#125; if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const &#123; then &#125; &#x3D; value</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; if (value) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.reject &#x3D; function (value) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.all &#x3D; function (arr) &#123;</span><br><span class="line">    const args &#x3D; Array.prototype.slice.call(arr)</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      if (args.length &#x3D;&#x3D;&#x3D; 0) return resolve([])</span><br><span class="line">      let remaining &#x3D; args.length</span><br><span class="line"></span><br><span class="line">      function res(i, val) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">            const &#123; then &#125; &#x3D; val</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">              then.call(val, (val) &#x3D;&gt; &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] &#x3D; val</span><br><span class="line">          if (--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.race &#x3D; function (values) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      for (let i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handle(callback) &#123;</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    if (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let ret;</span><br><span class="line">    try &#123;</span><br><span class="line">     ret &#x3D; cb(value)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  function resolve(newValue) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; newValue</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">          &#x2F;&#x2F; 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;fulfilled&#39;</span><br><span class="line">      value &#x3D; newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(error) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; error</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;rejected&#39;</span><br><span class="line">      value &#x3D; error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function handelCb() &#123;</span><br><span class="line">    while (callbacks.length) &#123;</span><br><span class="line">      const fn &#x3D; callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; catch(ex) &#123;</span><br><span class="line">reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript基本知识，建议有一定基础，再阅读过《JavaScript高级程序设计》（俗称红宝书）的基础上之后进行阅读&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://hxy1997.xyz/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://hxy1997.xyz/tags/javascript/"/>
    
    <category term="前端基础" scheme="https://hxy1997.xyz/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
