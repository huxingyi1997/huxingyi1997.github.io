<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Frog_16px_1177822_easyicon.net.ico">
  <link rel="mask-icon" href="/images/Frog_32px_1177822_easyicon.net.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hxy1997.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"appID":"G8T14JH1ZW","apiKey":"5d556d7e24cc4708ad9d4689ffec6990","indexName":"My Blog","hits":{"per_page":10},"labels":{"input_placeholder":"输入关键字","hits_empty":"没有找到与「${query}」相关搜索","hits_stats":"${hits} 条相关记录，共耗时 ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。">
<meta property="og:type" content="article">
<meta property="og:title" content="HTML和浏览器">
<meta property="og:url" content="https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/index.html">
<meta property="og:site_name" content="hxy的博客">
<meta property="og:description" content="HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?imageslim">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/3/31/169d468988a6ba8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/57.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/58.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/59.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/60.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/61.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/62.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/63.png">
<meta property="og:image" content="http://blog.poetries.top/img-repo/2019/11/64.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db6358082ff05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db6358033cdc4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635806ca887?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db6358079780e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db6359673e7d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db63596c9de23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db63597182316?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db6359acd19d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635aa7b772b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635afa6f7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635b40660cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635b4f0233b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635bd572192?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635cbfff69d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635cf070ff5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635d2a88984?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635db6d62fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635e4dd628b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635ecb2cae0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/19/162db635ed5f6d26?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2021-03-09T12:42:39.000Z">
<meta property="article:modified_time" content="2021-03-10T12:29:33.246Z">
<meta property="article:author" content="hxy">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?imageslim">

<link rel="canonical" href="https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>HTML和浏览器 | hxy的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="hxy的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxy的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Mia san Mia!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/huxingyi1997" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hxy1997.xyz/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Robben.gif">
      <meta itemprop="name" content="hxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxy的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HTML和浏览器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 20:42:39" itemprop="dateCreated datePublished" datetime="2021-03-09T20:42:39+08:00">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-10 20:29:33" itemprop="dateModified" datetime="2021-03-10T20:29:33+08:00">2021-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/09/HTML%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>HTML也是学习前端最开始学习的基础知识，虽然使用时强调实用性，但一些常见的面试考点还是要掌握的，浏览器的运行机制也需要进行了解，比如浏览器怎么加载页面的，对前端而言是必须掌握的。</p>
<a id="more"></a>

<h1 id="1-行内元素和块级元素"><a href="#1-行内元素和块级元素" class="headerlink" title="1.行内元素和块级元素"></a>1.行内元素和块级元素</h1><h3 id="初窥门径："><a href="#初窥门径：" class="headerlink" title="初窥门径："></a>初窥门径：</h3><p>什么叫行内元素？</p>
<p>常见的span、a、lable、strong、b等html标签都是行内元素</p>
<p>什么叫块级元素？</p>
<p>常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素</p>
<h3 id="略知一二："><a href="#略知一二：" class="headerlink" title="略知一二："></a>略知一二：</h3><p>行内元素有：<br>a, span, label, strong, em, br, img, input, select, textarea, cite,<br>块级元素：<br>div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset</p>
<h3 id="粗通皮毛："><a href="#粗通皮毛：" class="headerlink" title="粗通皮毛："></a>粗通皮毛：</h3><h4 id="（行内元素）内联元素-inline-element"><a href="#（行内元素）内联元素-inline-element" class="headerlink" title="（行内元素）内联元素(inline element)"></a>（行内元素）内联元素(inline element)</h4><ul>
<li>a - 锚点</li>
<li>abbr - 缩写</li>
<li>acronym - 首字</li>
<li>b - 粗体(不推荐)</li>
<li>bdo - bidi override</li>
<li>big - 大字体</li>
<li>br - 换行</li>
<li>cite - 引用</li>
<li>code - 计算机代码(在引用源码的时候需要)</li>
<li>dfn - 定义字段</li>
<li>em - 强调</li>
<li>font - 字体设定(不推荐)</li>
<li>i - 斜体</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>kbd - 定义键盘文本</li>
<li>label - 表格标签</li>
<li>q - 短引用</li>
<li>s - 中划线(不推荐)</li>
<li>samp - 定义范例计算机代码</li>
<li>select - 项目选择</li>
<li>small - 小字体文本</li>
<li>span - 常用内联容器，定义文本内区块</li>
<li>strike - 中划线</li>
<li>strong - 粗体强调</li>
<li>sub - 下标</li>
<li>sup - 上标</li>
<li>textarea - 多行文本输入框</li>
<li>tt - 电传文本</li>
<li>u - 下划线</li>
<li>var - 定义变量</li>
</ul>
<h4 id="块元素-block-element"><a href="#块元素-block-element" class="headerlink" title="块元素(block element)"></a>块元素(block element)</h4><ul>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>center - 举中对齐块</li>
<li>dir - 目录列表</li>
<li>div - 常用块级容易，也是css layout的主要标签</li>
<li>dl - 定义列表</li>
<li>fieldset - form控制组</li>
<li>form - 交互表单</li>
<li>h1 - 大标题</li>
<li>h2 - 副标题</li>
<li>h3 - 3级标题</li>
<li>h4 - 4级标题</li>
<li>h5 - 5级标题</li>
<li>h6 - 6级标题</li>
<li>hr - 水平分隔线</li>
<li>isindex - input prompt</li>
<li>menu - 菜单列表</li>
<li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容</li>
<li>noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）</li>
<li>ol - 排序表单</li>
<li>p - 段落</li>
<li>pre - 格式化文本</li>
<li>table - 表格</li>
<li>ul - 非排序列表</li>
</ul>
<h4 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h4><p>可变元素为根据上下文语境决定该元素为块元素或者行内元素。</p>
<ul>
<li>applet - java applet</li>
<li>button - 按钮</li>
<li>del - 删除文本</li>
<li>iframe - inline frame</li>
<li>ins - 插入的文本</li>
<li>map - 图片区块(map)</li>
<li>object - object对象</li>
<li>script - 客户端脚本</li>
</ul>
<h3 id="驾轻就熟："><a href="#驾轻就熟：" class="headerlink" title="驾轻就熟："></a>驾轻就熟：</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol>
<li>块级元素会独占一行，其宽度自动填满其父元素宽度<br>行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化</li>
<li>块级元素可以设置 width, height属性，【注意：块级元素即使设置了宽度，仍然是独占一行的】<br>行内元素设置width, height无效;</li>
<li>块级元素可以设置margin 和 padding.<br>行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。（水平方向有效，竖直方向无效）</li>
</ol>
<h3 id="青出於蓝"><a href="#青出於蓝" class="headerlink" title="青出於蓝:"></a>青出於蓝:</h3><ul>
<li>行内元素与块级元素直观上的区别<br>行内元素会在一条直线上排列，都是同一行的，水平方向排列<br>块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</li>
<li>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</li>
<li>行内元素与块级元素属性的不同，主要是盒模型属性上<br>行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display：inline 行内元素&#x2F;内联元素</span><br><span class="line">display: block 块级元素</span><br><span class="line">display:inline-block 设置成行内块级元素。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>行内块级元素:和其他元素同一行（行内元素特点），可以设置元素的宽高等（块级元素特点）；这样的元素有img input；它们为行内元素，但可以改变宽和高；<br>但我在我印象中，貌似没有默认样式是inline-block的元素。</p>
</blockquote>
<h3 id="融会贯通："><a href="#融会贯通：" class="headerlink" title="融会贯通："></a>融会贯通：</h3><ul>
<li>行内元素属性<ol>
<li>行内元素属性标签它和其它标签处在同一行内</li>
<li>行内元素属性标签无法设置宽度，高度 行高 距顶部距离 距底部距离</li>
<li>行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的</li>
<li>行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接）</li>
</ol>
</li>
<li>块级元素属性<ol>
<li>每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）</li>
<li>块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离</li>
<li>块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的100%</li>
<li>块级元素属性标签是可以直接嵌套的</li>
<li>p标签中不能嵌套div标签</li>
</ol>
</li>
</ul>
<h3 id="出类拔萃："><a href="#出类拔萃：" class="headerlink" title="出类拔萃："></a>出类拔萃：</h3><ul>
<li><p>CSS设置行内元素的</p>
<ul>
<li><p>水平居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;text-align:center&#125; &#x2F;*DIV内的行内元素均会水平居中*&#x2F; </span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;height:30px; line-height:30px&#125; &#x2F;*DIV内的行内元素均会垂直居中*&#x2F; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>CSS设置块级元素的<br>- 水平居中<br><code>div p&#123;margin:0 auto; width:500px&#125; /*块级元素p一定要设置宽度， 才能相当于DIV父容器水平居中*/</code><br>- 垂直居中<br><code>div&#123;width:500px&#125; /*DIV父容器设置宽度*/ div p&#123;margin:0 aut0; height:30px; line-height:30px&#125; /*块级元素p也可以加个宽度， 以达到相对于DIV父容器的水平居中效果*/</code></p>
</li>
</ul>
<blockquote>
<p>在以后的实际项目中，块级元素的垂直居中布局方式可能会碰到比这个更复杂, 会尝试用inline-block去解决问题，希望后续多多关注；另外推荐各位一本书肖志华《CSS核心技术详解》</p>
</blockquote>
<h3 id="返璞归真："><a href="#返璞归真：" class="headerlink" title="返璞归真："></a>返璞归真：</h3><p>在标准文档流里面，块级元素具有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 总是在新行上开始，占据一整行；</span><br><span class="line">② 高度，行高以及外边距和内边距都可控制；</span><br><span class="line">③ 宽带始终是与浏览器宽度一样，与内容无关；</span><br><span class="line">④ 它可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure>

<p>行内元素的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 和其他元素都在一行上；</span><br><span class="line">② 高，行高及外边距和内边距部分可改变；</span><br><span class="line">③ 宽度只与内容有关；</span><br><span class="line">④ 行内元素只能容纳文本或者其他行内元素。</span><br><span class="line">不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用</span><br></pre></td></tr></table></figure>

<h1 id="2-跨页面通信"><a href="#2-跨页面通信" class="headerlink" title="2.跨页面通信"></a>2.跨页面通信</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。</p>
<p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/4/1/169d767c01990c37?imageslim" alt="跨页面通信实例"></p>
<p>这就是我们所说的前端跨页面通信。</p>
<p>你知道哪些跨页面通信的方式呢？如果不清楚，下面我就带大家来看看七种跨页面通信的方式。</p>
<hr>
<h2 id="一、同源页面间的跨页面通信"><a href="#一、同源页面间的跨页面通信" class="headerlink" title="一、同源页面间的跨页面通信"></a>一、同源页面间的跨页面通信</h2><blockquote>
<p>以下各种方式的 <a target="_blank" rel="noopener" href="https://alienzhou.github.io/cross-tab-communication/">在线 Demo 可以戳这里 &gt;&gt;</a></p>
</blockquote>
<p>浏览器的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Same-origin_policy">同源策略</a>在下述的一些跨页面通信方法中依然存在限制。因此，我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p>
<h3 id="1-BroadCast-Channel"><a href="#1-BroadCast-Channel" class="headerlink" title="1. BroadCast Channel"></a>1. BroadCast Channel</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadCast Channel</a> 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的API和用法都非常简单。</p>
<p>下面的方式就可以创建一个标识为<code>AlienZHOU</code>的频道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br></pre></td></tr></table></figure>

<p>各个页面可以通过<code>onmessage</code>来监听被广播的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[BroadcastChannel] receive message:&#39;, text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要发送消息时只需要调用实例上的<code>postMessage</code>方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Broadcast Channel 的具体的使用方式可以看这篇<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903811228663815">《【3分钟速览】前端广播式通信：Broadcast Channel》</a>。</p>
</blockquote>
<h3 id="2-Service-Worker"><a href="#2-Service-Worker" class="headerlink" title="2. Service Worker"></a>2. Service Worker</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a> 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p>
<blockquote>
<p>Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903588691443725">【PWA学习与实践】(3) 让你的WebApp离线可用</a>。</p>
</blockquote>
<p>首先，需要在页面注册 Service Worker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.register(&#39;..&#x2F;util.sw.js&#39;).then(function () &#123;</span><br><span class="line">    console.log(&#39;Service Worker 注册成功&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中<code>../util.sw.js</code>是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.sw.js Service Worker 逻辑 *&#x2F;</span><br><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    console.log(&#39;service worker receive message&#39;, e.data);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(function (clients) &#123;</span><br><span class="line">            if (!clients || clients.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            clients.forEach(function (client) &#123;</span><br><span class="line">                client.postMessage(e.data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在 Service Worker 中监听了<code>message</code>事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过<code>self.clients.matchAll()</code>获取当前注册了该 Service Worker 的所有页面，通过调用每个client（即页面）的<code>postMessage</code>方法，向页面发送消息。这样就把从一处（某个Tab页面）收到的消息通知给了其他页面。</p>
<p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Service Worker] receive message:&#39;, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，当需要同步消息时，可以调用 Service Worker 的<code>postMessage</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.controller.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<h3 id="3-LocalStorage"><a href="#3-LocalStorage" class="headerlink" title="3. LocalStorage"></a>3. LocalStorage</h3><p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent"><code>StorageEvent</code></a>这个与它相关的事件有些同学可能会比较陌生。</p>
<p>当 LocalStorage 变化时，会触发<code>storage</code>事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听<code>storage</code>事件即可收到通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, function (e) &#123;</span><br><span class="line">    if (e.key &#x3D;&#x3D;&#x3D; &#39;ctc-msg&#39;) &#123;</span><br><span class="line">        const data &#x3D; JSON.parse(e.newValue);</span><br><span class="line">        const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">        console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的<code>setItem</code>方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata.st &#x3D; +(new Date);</span><br><span class="line">window.localStorage.setItem(&#39;ctc-msg&#39;, JSON.stringify(mydata));</span><br></pre></td></tr></table></figure>

<p>注意，这里有一个细节：我们在mydata上添加了一个取当前毫秒时间戳的<code>.st</code>属性。这是因为，<code>storage</code>事件只有在值真正改变时才会触发。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br></pre></td></tr></table></figure>

<p>由于第二次的值<code>&#39;123&#39;</code>与第一次的值相同，所以以上的代码只会在第一次<code>setItem</code>时触发<code>storage</code>事件。因此我们通过设置<code>st</code>来保证每次调用时一定会触发<code>storage</code>事件。</p>
<h3 id="小憩一下"><a href="#小憩一下" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是些 tricky 的<code>storage</code>事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。</p>
<blockquote>
<p>在上面的例子中，这个“中央站”可以是一个 BroadCast Channel 实例、一个 Service Worker 或是 LocalStorage。</p>
</blockquote>
<p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p>
<hr>
<h3 id="4-Shared-Worker"><a href="#4-Shared-Worker" class="headerlink" title="4. Shared Worker"></a>4. Shared Worker</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared Worker</a> 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>
<p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：</p>
<p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过<code>postMessage</code>传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p>
<p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span><br><span class="line">const sharedWorker &#x3D; new SharedWorker(&#39;..&#x2F;util.shared.js&#39;, &#39;ctc&#39;);</span><br></pre></td></tr></table></figure>

<p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.shared.js: Shared Worker 代码 *&#x2F;</span><br><span class="line">let data &#x3D; null;</span><br><span class="line">self.addEventListener(&#39;connect&#39;, function (e) &#123;</span><br><span class="line">    const port &#x3D; e.ports[0];</span><br><span class="line">    port.addEventListener(&#39;message&#39;, function (event) &#123;</span><br><span class="line">        &#x2F;&#x2F; get 指令则返回存储的消息数据</span><br><span class="line">        if (event.data.get) &#123;</span><br><span class="line">            data &amp;&amp; port.postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非 get 指令则存储该消息数据</span><br><span class="line">        else &#123;</span><br><span class="line">            data &#x3D; event.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时轮询，发送 get 指令的消息</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line">    sharedWorker.port.postMessage(&#123;get: true&#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 get 消息的返回数据</span><br><span class="line">sharedWorker.port.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Shared Worker] receive message:&#39;, text);</span><br><span class="line">&#125;, false);</span><br><span class="line">sharedWorker.port.start();</span><br></pre></td></tr></table></figure>

<p>最后，当要跨页面通信时，只需给 Shared Worker <code>postMessage</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.port.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果使用<code>addEventListener</code>来添加 Shared Worker 的消息监听，需要显式调用<code>MessagePort.start</code>方法，即上文中的<code>sharedWorker.port.start()</code>；如果使用<code>onmessage</code>绑定监听则不需要。</p>
</blockquote>
<h3 id="5-IndexedDB"><a href="#5-IndexedDB" class="headerlink" title="5. IndexedDB"></a>5. IndexedDB</h3><p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> 或 cookie。</p>
<blockquote>
<p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p>
</blockquote>
<p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p>
<ul>
<li><p>打开数据库连接：</p>
<p>function openStore() { const storeName = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { if (!(‘indexedDB’ in window)) { return reject(‘don’t support indexedDB’); } const request = indexedDB.open(‘CTC_DB’, 1); request.onerror = reject; request.onsuccess =  e =&gt; resolve(e.target.result); request.onupgradeneeded = function (e) { const db = e.srcElement.result; if (e.oldVersion === 0 &amp;&amp; !db.objectStoreNames.contains(storeName)) { const store = db.createObjectStore(storeName, {keyPath: ‘tag’}); store.createIndex(storeName + ‘Index’, ‘tag’, {unique: false}); } } }); }</p>
</li>
<li><p>存储数据</p>
<p>function saveData(db, data) { return new Promise(function (resolve, reject) { const STORE_NAME = ‘ctc_aleinzhou’; const tx = db.transaction(STORE_NAME, ‘readwrite’); const store = tx.objectStore(STORE_NAME); const request = store.put({tag: ‘ctc_data’, data}); request.onsuccess = () =&gt; resolve(db); request.onerror = reject; }); }</p>
</li>
<li><p>查询/读取数据</p>
<p>function query(db) { const STORE_NAME = ‘ctc_aleinzhou’; return new Promise(function (resolve, reject) { try { const tx = db.transaction(STORE_NAME, ‘readonly’); const store = tx.objectStore(STORE_NAME); const dbRequest = store.get(‘ctc_data’); dbRequest.onsuccess = e =&gt; resolve(e.target.result); dbRequest.onerror = reject; } catch (err) { reject(err); } }); }</p>
</li>
</ul>
<p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null))</span><br></pre></td></tr></table></figure>

<p>对于消息读取，可以在连接与初始化后轮询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        query(db).then(function (res) &#123;</span><br><span class="line">            if (!res || !res.data) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const data &#x3D; res.data;</span><br><span class="line">            const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">            console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… 省略上面的轮询代码</span><br><span class="line">    &#x2F;&#x2F; 触发 saveData 的方法可以放在用户操作的事件监听内</span><br><span class="line">    saveData(db, mydata);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="小憩一下-1"><a href="#小憩一下-1" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p>
<p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听<code>visibilitychange</code>这样的事件，来做一次信息同步即可。</p>
<p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p>
<hr>
<h3 id="6-window-open-window-opener"><a href="#6-window-open-window-opener" class="headerlink" title="6. window.open + window.opener"></a>6. window.open + window.opener</h3><p>当我们使用<code>window.open</code>打开页面时，方法会返回一个被打开页面<code>window</code>的引用。而在未显示指定<code>noopener</code>时，被打开的页面可以通过<code>window.opener</code>获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p>
<p>首先，我们把<code>window.open</code>打开的页面的<code>window</code>对象收集起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let childWins &#x3D; [];</span><br><span class="line">document.getElementById(&#39;btn&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    const win &#x3D; window.open(&#39;.&#x2F;some&#x2F;sample&#39;);</span><br><span class="line">    childWins.push(win);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">if (childWins.length &gt; 0) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; false;</span><br><span class="line">    childWins.forEach(w &#x3D;&gt; w.postMessage(mydata));</span><br><span class="line">&#125;</span><br><span class="line">if (window.opener &amp;&amp; !window.opener.closed) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; true;</span><br><span class="line">    window.opener.postMessage(mydata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我这里先用<code>.closed</code>属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p>
<p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p>
<blockquote>
<p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Cross-document Messaging] receive message:&#39;, text);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (window.opener &amp;&amp; !window.opener.closed &amp;&amp; data.fromOpenner) &#123;</span><br><span class="line">        window.opener.postMessage(data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">    childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (childWins &amp;&amp; !data.fromOpenner) &#123;</span><br><span class="line">        childWins.forEach(w &#x3D;&gt; w.postMessage(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p>
<h3 id="小憩一下-2"><a href="#小憩一下-2" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的<code>window.open</code>打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p>
<p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。</p>
<p>关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903618043183111">《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》</a></p>
<p>此外，我还针对以上各种方式写了一个 <a target="_blank" rel="noopener" href="https://alienzhou.github.io/cross-tab-communication/">在线演示的 Demo &gt;&gt;</a></p>
<p>![Demo页面](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="567"></svg>)</p>
<h2 id="二、非同源页面之间的通信"><a href="#二、非同源页面之间的通信" class="headerlink" title="二、非同源页面之间的通信"></a>二、非同源页面之间的通信</h2><p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p>
<p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定<code>origin</code>来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<code>http://sample.com/bridge.html</code>），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p>
<p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.frames[0].window.postMessage(mydata, &#39;*&#39;);</span><br></pre></td></tr></table></figure>

<p>其中为了简便此处将<code>postMessage</code>的第二个参数设为了<code>&#39;*&#39;</code>，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br><span class="line">&#x2F;&#x2F; 收到来自页面的消息后，在 iframe 间进行广播</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    bc.postMessage(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 对于收到的（iframe）广播消息，通知给所属的业务页面</span><br><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    window.parent.postMessage(e.data, &#39;*&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2019/3/31/169d468988a6ba8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天和大家分享了一下跨页面通信的各种方式。</p>
<p>对于同源页面，常见的方式包括：</p>
<ul>
<li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li>
<li>共享存储模式：Shared Worker / IndexedDB / cookie</li>
<li>口口相传模式：window.open + window.opener</li>
<li>基于服务端：Websocket / Comet / SSE 等</li>
</ul>
<p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p>
<h1 id="3-前端路由的两种模式：hash模式和-history模式"><a href="#3-前端路由的两种模式：hash模式和-history模式" class="headerlink" title="3.前端路由的两种模式：hash模式和 history模式"></a>3.前端路由的两种模式：hash模式和 history模式</h1><h2 id="为什么要使用路由"><a href="#为什么要使用路由" class="headerlink" title="为什么要使用路由"></a>为什么要使用路由</h2><p>现在的网络应用程序越来越多的使用AJAX异步请求完成页面的无缝刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而提高了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。</p>
<p>单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。</p>
<h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能：</p>
<ol>
<li>当浏览器地址变化时，切换页面；</li>
<li>点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</li>
<li>刷新浏览器，网页加载当前路由对应内容；</li>
</ol>
<p>在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：</p>
<ul>
<li>hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；</li>
<li>history模式：利用history API实现url地址改变，网页内容改变；</li>
</ul>
<p>它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。</p>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：</p>
<ol>
<li>hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如<a target="_blank" rel="noopener" href="http://localhost/index.html#abc%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84#abc%E5%B0%B1%E6%98%AFhash%EF%BC%9B">http://localhost/index.html#abc，这里的#abc就是hash；</a></li>
<li>散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；</li>
<li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；</li>
<li>location.hash值的变化会直接反应到浏览器地址栏；</li>
</ol>
<h2 id="触发hashchange事件的几种情况："><a href="#触发hashchange事件的几种情况：" class="headerlink" title="触发hashchange事件的几种情况："></a>触发hashchange事件的几种情况：</h2><ul>
<li>浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；</li>
<li>当浏览器地址栏中URL包含哈希如 <a target="_blank" rel="noopener" href="http://www.baidu.com/#home%EF%BC%8C%E8%BF%99%E6%97%B6%E6%8C%89%E4%B8%8B%E8%BE%93%E5%85%A5%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81http://www.baidu.com/%E8%AF%B7%E6%B1%82%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%E8%AE%BE%E7%BD%AE%E6%95%A3%E5%88%97%E5%80%BC%E4%B8%BA#home%EF%BC%8C%E8%BF%9B%E8%80%8C%E8%A7%A6%E5%8F%91onhashchange%E4%BA%8B%E4%BB%B6%EF%BC%9B">http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；</a></li>
<li>当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；</li>
<li>html中<a>标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置 url 的 hash，会在当前url后加上&#39;#abc&#39;</span><br><span class="line">window.location.hash&#x3D;&#39;abc&#39;;</span><br><span class="line">let hash &#x3D; window.location.hash &#x2F;&#x2F;&#39;#abc&#39;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;hashchange&#39;,function()&#123;</span><br><span class="line">	&#x2F;&#x2F;监听hash变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>概述<br>window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。<br>History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。<br>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。<br>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。<br>属性<br>History 对象主要有两个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">History.length：当前窗口访问过的网址数量（包括当前网页）</span><br><span class="line">History.state：History 堆栈最上层的状态值（详见下文）</span><br><span class="line">&#x2F;&#x2F; 当前窗口访问过多少个网页</span><br><span class="line">history.length &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; History 对象的当前状态</span><br><span class="line">&#x2F;&#x2F; 通常是 undefined，即未设置</span><br><span class="line">history.state &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>


<p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p>
<p>方法<br>History.back()、History.forward()、History.go()<br>这三个方法用于在历史之中移动。</p>
<p>History.back()：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。<br>History.forward()：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。<br>History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(1);&#x2F;&#x2F;相当于history.forward()</span><br><span class="line">history.go(-1);&#x2F;&#x2F;相当于history.back()</span><br><span class="line">history.go(0); &#x2F;&#x2F; 刷新当前页面</span><br></pre></td></tr></table></figure>


<p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<p>History.pushState()<br>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。</p>
<p>语法：history.pushState(object, title, url)</p>
<p>该方法接受三个参数，依次为：</p>
<p>object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。<br>title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。<br>url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(data, &#39;&#39;, &#39;2.html&#39;);</span><br><span class="line">console.log(history.state) &#x2F;&#x2F; &#123;foo: &quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>如果 pushState() 方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">&#x2F;&#x2F; 当前网址为 http:&#x2F;&#x2F;example.com</span><br><span class="line">history.pushState(null, &#39;&#39;, &#39;https:&#x2F;&#x2F;twitter.com&#x2F;hello&#39;);</span><br></pre></td></tr></table></figure>


<p>上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<p>History.replaceState()<br>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。</p>
<p>假定当前网页是 example.com/example.html。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;page: 1&#125;, &#39;&#39;, &#39;?page&#x3D;1&#39;)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;page: 2&#125;, &#39;&#39;, &#39;?page&#x3D;2&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;2</span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &#39;&#39;, &#39;?page&#x3D;3&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html</span><br><span class="line"></span><br><span class="line">history.go(2)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br></pre></td></tr></table></figure>


<p>popstate 事件<br>每当 history 对象出现变化时，就会触发 popstate 事件。</p>
<p>注意：</p>
<p>仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;<br>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。<br>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。<br>页面第一次加载的时候，浏览器不会触发popstate事件。<br>使用的时候，可以为popstate事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;popstate&#39;, function(e) &#123;</span><br><span class="line">	&#x2F;&#x2F;e.state 相当于 history.state</span><br><span class="line">	console.log(&#39;state: &#39; + JSON.stringify(e.state));</span><br><span class="line">	console.log(history.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>点击查看 通过history.pushState 实现页面 tab 切换的功能。</p>
<p>history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。</p>
<h1 id="4-DOM树：JavaScript是如何影响DOM树构建的"><a href="#4-DOM树：JavaScript是如何影响DOM树构建的" class="headerlink" title="4.DOM树：JavaScript是如何影响DOM树构建的"></a>4.DOM树：JavaScript是如何影响DOM树构建的</h1><p>续沿着网络数据流路径来介绍 DOM 树是怎么生成的。然后再基于 DOM 树的解析流程介绍两块内容：第一个是在解析过程中遇到 JavaScript 脚本，DOM 解析器是如何处理的？第二个是 DOM 解析器是如何处理跨站点资源的？</p>
<h2 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h2><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用</p>
<ul>
<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>
<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li>
<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li>
</ul>
<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p>
<h2 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h2><p>在渲染引擎内部，有一个叫HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p>
<p>在开始介绍 HTML 解析器之前，我要先解释一个大家在留言区问到过好多次的问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？</p>
<p>在这里我统一解答下，HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p>
<p>那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p>
<p>解答完这个问题之后，接下来我们就可以来详细聊聊 DOM 的具体生成流程了。</p>
<p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/57.png" alt="img"></p>
<p>从图中你可以看出，字节流转换为 DOM 需要三个阶段。</p>
<p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong></p>
<p>前面《14 | 编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/58.png" alt="img"></p>
<p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如</p>
<p>就是 StartTag ，就是EndTag，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。</p>
<p><strong>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中</strong>。</p>
<blockquote>
<p>HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>
</blockquote>
<ul>
<li>如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>
<li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>
<li>如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li>
</ul>
<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>
<p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p>
<p>这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/59.png" alt="img"></p>
<p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/60.png" alt="img"></p>
<p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/61.png" alt="img"></p>
<p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/62.png" alt="img"></p>
<p>按照同样的规则，一路解析，最终结果如下图所示：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/63.png" alt="img"></p>
<p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p>
<h2 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h2><p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。script标签之前，所有的解析流程还是和之前介绍的一样，但是解析到script标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p>
<p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p>
<p><img data-src="http://blog.poetries.top/img-repo/2019/11/64.png" alt="img"></p>
<p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p>
<p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p>
<p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
<p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script defer type=&quot;text/javascript&quot; src=&#x27;foo.js&#x27;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p>
<p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style src=&#x27;theme.css&#x27;&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">            let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">            div1.innerText = &#x27;time.geekbang&#x27; // 需要 DOM</span><br><span class="line">            div1.style.color = &#x27;red&#x27;  // 需要 CSSOM</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;div&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>该示例中，JavaScript 代码出现了 div1.style.color = ‘red’ 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>
<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p>
<p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p>
<p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p>
<p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p>
<p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了</p>
<h1 id="5-事件模型"><a href="#5-事件模型" class="headerlink" title="5.事件模型"></a>5.事件模型</h1><p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章介绍 DOM 的事件编程。</p>
<h2 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h2><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h3 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var button &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line">button.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<p>关于参数，有两个地方需要注意。</p>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(&#39;click&#39;, &#123;</span><br><span class="line">  handleEvent: function (event) &#123;</span><br><span class="line">    console.log(&#39;click&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>
<p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p>
<blockquote>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
</blockquote>
<p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function hello() &#123;</span><br><span class="line">  console.log(&#39;Hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">document.addEventListener(&#39;click&#39;, hello, false);</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function print(x) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var el &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">el.addEventListener(&#39;click&#39;, function () &#123; print(&#39;Hello&#39;); &#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>
<p>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">var para &#x3D; document.getElementById(&#39;para&#39;);</span><br><span class="line">para.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(this.nodeName); &#x2F;&#x2F; &quot;P&quot;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h3 id="EventTarget-removeEventListener"><a href="#EventTarget-removeEventListener" class="headerlink" title="EventTarget.removeEventListener()"></a>EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, listener, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, listener, false);</span><br></pre></td></tr></table></figure>

<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br><span class="line">div.removeEventListener(&#39;click&#39;, function (e) &#123;&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;mousedown&#39;, handleMouseDown, true);</span><br><span class="line">element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h3 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="EventTarget.dispatchEvent()"></a>EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>

<p><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(&#39;click&#39;, hello, false);</span><br><span class="line">var event &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var canceled &#x3D; !cb.dispatchEvent(event);</span><br><span class="line">if (canceled) &#123;</span><br><span class="line">  console.log(&#39;事件取消&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;事件未取消&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h2><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h3 id="HTML-的-on-属性"><a href="#HTML-的-on-属性" class="headerlink" title="HTML 的 on- 属性"></a>HTML 的 on- 属性</h3><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line">&lt;div onclick&#x3D;&quot;console.log(&#39;触发事件&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething()&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 错误 --&gt;</span><br><span class="line">&lt;body onload&#x3D;&quot;doSomething&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，不要忘记加上一对圆括号。</p>
<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&quot;console.log(2)&quot;&gt;</span><br><span class="line">  &lt;button onClick&#x3D;&quot;console.log(1)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>
<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(&#39;onclick&#39;, &#39;doSomething()&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; &lt;Element onclick&#x3D;&quot;doSomething()&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h3><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h3 id="EventTarget-addEventListener-1"><a href="#EventTarget-addEventListener-1" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h3><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, doSomething, false);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;btn&quot; onclick&#x3D;&quot;console.log(this.id)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;button id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">var btn &#x3D; document.getElementById(&#39;btn&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">btn.onclick &#x3D; function () &#123;</span><br><span class="line">  console.log(this.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">btn.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e) &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;点击&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var phases &#x3D; &#123;</span><br><span class="line">  1: &#39;capture&#39;,</span><br><span class="line">  2: &#39;target&#39;,</span><br><span class="line">  3: &#39;bubble&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, true);</span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line">p.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  var phase &#x3D; phases[event.eventPhase];</span><br><span class="line">  console.log(&quot;Tag: &#39;&quot; + tag + &quot;&#39;. EventPhase: &#39;&quot; + phase + &quot;&#39;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击以后的结果</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;capture&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;P&#39;. EventPhase: &#39;target&#39;</span><br><span class="line">&#x2F;&#x2F; Tag: &#39;DIV&#39;. EventPhase: &#39;bubble&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p>
<ol>
<li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li>
</ol>
<p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p>
<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<h2 id="事件的代理"><a href="#事件的代理" class="headerlink" title="事件的代理"></a>事件的代理</h2><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul &#x3D; document.querySelector(&#39;ul&#39;);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  if (event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; some code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 事件传播到 p 元素后，就不再向下传播了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件冒泡到 p 元素后，就不再向上冒泡了</span><br><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 会触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件向其他元素传播。因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>
<p>如果想要彻底阻止这个事件的传播，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&#39;click&#39;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; 不会被触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底阻止这个事件传播，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h2 id="Event-对象概述"><a href="#Event-对象概述" class="headerlink" title="Event 对象概述"></a>Event 对象概述</h2><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event &#x3D; new Event(type, options);</span><br></pre></td></tr></table></figure>

<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; new Event(</span><br><span class="line">  &#39;look&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    &#39;bubbles&#39;: true,</span><br><span class="line">    &#39;cancelable&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">document.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;&lt;p&gt;Hello&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">function callback(event) &#123;</span><br><span class="line">  var tag &#x3D; event.currentTarget.tagName;</span><br><span class="line">  console.log(&#39;Tag: &#39; + tag); &#x2F;&#x2F; 没有任何输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, callback, false);</span><br><span class="line"></span><br><span class="line">var click &#x3D; new Event(&#39;click&#39;);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h2 id="Event-对象的实例属性"><a href="#Event-对象的实例属性" class="headerlink" title="Event 对象的实例属性"></a>Event 对象的实例属性</h2><h3 id="Event-bubbles，Event-eventPhase"><a href="#Event-bubbles，Event-eventPhase" class="headerlink" title="Event.bubbles，Event.eventPhase"></a>Event.bubbles，Event.eventPhase</h3><p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>
<p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var phase &#x3D; event.eventPhase;</span><br></pre></td></tr></table></figure>

<p><code>Event.eventPhase</code>的返回值有四种可能。</p>
<ul>
<li>0.事件目前没有发生。</li>
<li>1.事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2.事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3.事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
<h3 id="Event-cancelable，Event-cancelBubble，event-defaultPrevented"><a href="#Event-cancelable，Event-cancelBubble，event-defaultPrevented" class="headerlink" title="Event.cancelable，Event.cancelBubble，event.defaultPrevented"></a>Event.cancelable，Event.cancelBubble，event.defaultPrevented</h3><p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>
<p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.cancelable  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function preventEvent(event) &#123;</span><br><span class="line">  if (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.warn(&#39;This event couldn\&#39;t be canceled.&#39;);</span><br><span class="line">    console.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p>
<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (event.defaultPrevented) &#123;</span><br><span class="line">  console.log(&#39;该事件已经取消了&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Event-currentTarget，Event-target"><a href="#Event-currentTarget，Event-target" class="headerlink" title="Event.currentTarget，Event.target"></a>Event.currentTarget，Event.target</h3><p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p>
<p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML代码为</span><br><span class="line">&#x2F;&#x2F; &lt;p id&#x3D;&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;</span><br><span class="line">function hide(e) &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.currentTarget);  &#x2F;&#x2F; 总是 true</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; e.target);  &#x2F;&#x2F; 有可能不是 true</span><br><span class="line">  e.target.style.visibility &#x3D; &#39;hidden&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">para.addEventListener(&#39;click&#39;, hide, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果在<code>para</code>节点的<code>&lt;em&gt;</code>子节点上面点击，则<code>e.target</code>指向<code>&lt;em&gt;</code>子节点，导致<code>&lt;em&gt;</code>子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个<code>para</code>都将不可见。</p>
<h3 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h3><p><code>Event.type</code>属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.type &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Event-timeStamp"><a href="#Event-timeStamp" class="headerlink" title="Event.timeStamp"></a>Event.timeStamp</h3><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.timeStamp &#x2F;&#x2F; 3683.6999999995896</span><br></pre></td></tr></table></figure>

<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<p>下面是一个计算鼠标移动速度的例子，显示每秒移动的像素数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var previousX;</span><br><span class="line">var previousY;</span><br><span class="line">var previousT;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;mousemove&#39;, function(event) &#123;</span><br><span class="line">  if (</span><br><span class="line">    previousX !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousY !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    previousT !&#x3D;&#x3D; undefined</span><br><span class="line">  ) &#123;</span><br><span class="line">    var deltaX &#x3D; event.screenX - previousX;</span><br><span class="line">    var deltaY &#x3D; event.screenY - previousY;</span><br><span class="line">    var deltaD &#x3D; Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));</span><br><span class="line"></span><br><span class="line">    var deltaT &#x3D; event.timeStamp - previousT;</span><br><span class="line">    console.log(deltaD &#x2F; deltaT * 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX &#x3D; event.screenX;</span><br><span class="line">  previousY &#x3D; event.screenY;</span><br><span class="line">  previousT &#x3D; event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Event-isTrusted"><a href="#Event-isTrusted" class="headerlink" title="Event.isTrusted"></a>Event.isTrusted</h3><p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var evt &#x3D; new Event(&#39;foo&#39;);</span><br><span class="line">evt.isTrusted &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>
<h3 id="Event-detail"><a href="#Event-detail" class="headerlink" title="Event.detail"></a>Event.detail</h3><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dbclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">function giveDetails(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;p&#39;).onclick &#x3D; giveDetails;</span><br></pre></td></tr></table></figure>

<h2 id="Event-对象的实例方法"><a href="#Event-对象的实例方法" class="headerlink" title="Event 对象的实例方法"></a>Event 对象的实例方法</h2><h3 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h3><p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>
<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;my-checkbox&quot; &#x2F;&gt;</span><br><span class="line">var cb &#x3D; document.getElementById(&#39;my-checkbox&#39;);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  &#39;click&#39;,</span><br><span class="line">  function (e)&#123; e.preventDefault(); &#125;,</span><br><span class="line">  false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;my-input&quot; &#x2F;&gt;</span><br><span class="line">var input &#x3D; document.getElementById(&#39;my-input&#39;);</span><br><span class="line">input.addEventListener(&#39;keypress&#39;, checkName, false);</span><br><span class="line"></span><br><span class="line">function checkName(e) &#123;</span><br><span class="line">  if (e.charCode &lt; 97 || e.charCode &gt; 122) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h3 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h3><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function stopEvent(e) &#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, stopEvent, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>
<h3 id="Event-stopImmediatePropagation"><a href="#Event-stopImmediatePropagation" class="headerlink" title="Event.stopImmediatePropagation()"></a>Event.stopImmediatePropagation()</h3><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function l1(e)&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function l2(e)&#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;click&#39;, l1, false);</span><br><span class="line">el.addEventListener(&#39;click&#39;, l2, false);</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h3 id="Event-composedPath"><a href="#Event-composedPath" class="headerlink" title="Event.composedPath()"></a>Event.composedPath()</h3><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;div&gt;</span><br><span class="line">var div &#x3D; document.querySelector(&#39;div&#39;);</span><br><span class="line">var p &#x3D; document.querySelector(&#39;p&#39;);</span><br><span class="line"></span><br><span class="line">div.addEventListener(&#39;click&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.composedPath());</span><br><span class="line">&#125;, false);</span><br><span class="line">&#x2F;&#x2F; [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
<h2 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h2><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var event &#x3D; new CustomEvent(&#39;build&#39;, &#123; &#39;detail&#39;: &#39;hello&#39; &#125;);</span><br><span class="line"></span><br><span class="line">function eventHandler(e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&#39;build&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myEvent &#x3D; new CustomEvent(&#39;myevent&#39;, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: &#39;bar&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: true,</span><br><span class="line">  cancelable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(&#39;myevent&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;Hello &#39; + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Wilson Page, <a target="_blank" rel="noopener" href="http://coding.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/">An Introduction To DOM Events</a></li>
<li>Mozilla Developer Network, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching">Using Firefox 1.5 caching</a></li>
<li>Craig Buckler, <a target="_blank" rel="noopener" href="http://www.sitepoint.com/css3-animation-javascript-event-handlers/">How to Capture CSS3 Animation Events in JavaScript</a></li>
<li>Ray Nicholus, <a target="_blank" rel="noopener" href="http://blog.garstasio.com/you-dont-need-jquery/events/">You Don’t Need jQuery!: Events</a></li>
</ul>
<h1 id="6-彻底理解浏览器的缓存机制"><a href="#6-彻底理解浏览器的缓存机制" class="headerlink" title="6.彻底理解浏览器的缓存机制"></a>6.彻底理解浏览器的缓存机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p>
<p>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358082ff05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358033cdc4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635806ca887?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6358079780e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p>
<p>以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。</p>
<h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359673e7d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63596c9de23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db63597182316?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db6359acd19d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>那么强制缓存的缓存规则是什么？</p>
</blockquote>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<blockquote>
<p>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？</p>
</blockquote>
<p>到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>
</ul>
<p>接下来，我们直接看一个例子，如下：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635aa7b772b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>由上面的例子我们可以知道：</p>
<ul>
<li>HTTP响应报文中expires的时间值，是一个绝对值</li>
<li>HTTP响应报文中Cache-Control为max-age=600，是相对值</li>
</ul>
<p>由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。</p>
<p>注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。</p>
<p>了解强制缓存的过程后，我们拓展性的思考一下：</p>
<blockquote>
<p>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</p>
</blockquote>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635afa6f7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。</p>
<blockquote>
<p>那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p>
</blockquote>
<p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p>
<p>虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析：</p>
<p>访问<a target="_blank" rel="noopener" href="https://heyingye.github.io/">heyingye.github.io/ </a> –&gt;200 –&gt; 关闭博客的标签页 –&gt; 重新打开<a href="https://heyingye.github.io>/">heyingye.github.io&gt;</a> –&gt;200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)</p>
<p>过程如下：</p>
<ul>
<li><p>访问<a target="_blank" rel="noopener" href="https://heyingye.github.io/">heyingye.github.io/</a></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b40660cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
</li>
<li><p>关闭博客的标签页</p>
</li>
<li><p>重新打开<a target="_blank" rel="noopener" href="https://heyingye.github.io/">heyingye.github.io/</a></p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635b4f0233b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
</li>
<li><p>刷新</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635bd572192?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>from disk memory</p>
</li>
</ul>
<blockquote>
<p>看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？</p>
</blockquote>
<p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p>
<ul>
<li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li>
<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li>
<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>
<li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li>
</ul>
<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p>协商缓存生效，返回304，如下</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cbfff69d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>304</p>
<p>协商缓存失效，返回200和请求结果结果，如下</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635cf070ff5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>200</p>
<p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h3><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635d2a88984?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>last-modify</p>
<p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635db6d62fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>If-Modified-Since</p>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h3><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635e4dd628b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Etag</p>
<p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ecb2cae0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Etag-match</p>
<p>注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/4/19/162db635ed5f6d26?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>

    </div>

    
    
    
      
<div>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
</div>
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
              <a href="/tags/HTML/" rel="tag"><i class="fa fa-tag"></i> HTML</a>
              <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag"><i class="fa fa-tag"></i> 浏览器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/09/%E4%B8%80%E8%B5%B7%E6%84%89%E5%BF%AB%E5%88%B7%E9%A2%98/" rel="prev" title="一起愉快刷题">
      <i class="fa fa-chevron-left"></i> 一起愉快刷题
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="nav-number">1.</span> <span class="nav-text">1.行内元素和块级元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A"><span class="nav-number">1.0.1.</span> <span class="nav-text">初窥门径：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%95%A5%E7%9F%A5%E4%B8%80%E4%BA%8C%EF%BC%9A"><span class="nav-number">1.0.2.</span> <span class="nav-text">略知一二：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B2%97%E9%80%9A%E7%9A%AE%E6%AF%9B%EF%BC%9A"><span class="nav-number">1.0.3.</span> <span class="nav-text">粗通皮毛：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%EF%BC%89%E5%86%85%E8%81%94%E5%85%83%E7%B4%A0-inline-element"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">（行内元素）内联元素(inline element)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E5%85%83%E7%B4%A0-block-element"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">块元素(block element)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%85%83%E7%B4%A0"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">可变元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%BE%E8%BD%BB%E5%B0%B1%E7%86%9F%EF%BC%9A"><span class="nav-number">1.0.4.</span> <span class="nav-text">驾轻就熟：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">区别：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%92%E5%87%BA%E6%96%BC%E8%93%9D"><span class="nav-number">1.0.5.</span> <span class="nav-text">青出於蓝:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%EF%BC%9A"><span class="nav-number">1.0.6.</span> <span class="nav-text">融会贯通：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E7%B1%BB%E6%8B%94%E8%90%83%EF%BC%9A"><span class="nav-number">1.0.7.</span> <span class="nav-text">出类拔萃：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E7%92%9E%E5%BD%92%E7%9C%9F%EF%BC%9A"><span class="nav-number">1.0.8.</span> <span class="nav-text">返璞归真：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1"><span class="nav-number">2.</span> <span class="nav-text">2.跨页面通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E9%97%B4%E7%9A%84%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1"><span class="nav-number">2.2.</span> <span class="nav-text">一、同源页面间的跨页面通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-BroadCast-Channel"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. BroadCast Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Service-Worker"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. Service Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-LocalStorage"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. LocalStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%86%A9%E4%B8%80%E4%B8%8B"><span class="nav-number">2.2.4.</span> <span class="nav-text">小憩一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Shared-Worker"><span class="nav-number">2.2.5.</span> <span class="nav-text">4. Shared Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-IndexedDB"><span class="nav-number">2.2.6.</span> <span class="nav-text">5. IndexedDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%86%A9%E4%B8%80%E4%B8%8B-1"><span class="nav-number">2.2.7.</span> <span class="nav-text">小憩一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-window-open-window-opener"><span class="nav-number">2.2.8.</span> <span class="nav-text">6. window.open + window.opener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%86%A9%E4%B8%80%E4%B8%8B-2"><span class="nav-number">2.2.9.</span> <span class="nav-text">小憩一下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%9D%9E%E5%90%8C%E6%BA%90%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">2.3.</span> <span class="nav-text">二、非同源页面之间的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8C-history%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">3.前端路由的两种模式：hash模式和 history模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要使用路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">前端路由实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">hash模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91hashchange%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">触发hashchange事件的几种情况：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#history%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">history模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-DOM%E6%A0%91%EF%BC%9AJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8DDOM%E6%A0%91%E6%9E%84%E5%BB%BA%E7%9A%84"><span class="nav-number">4.</span> <span class="nav-text">4.DOM树：JavaScript是如何影响DOM树构建的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DOM"><span class="nav-number">4.1.</span> <span class="nav-text">什么是 DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-%E6%A0%91%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90"><span class="nav-number">4.2.</span> <span class="nav-text">DOM 树如何生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-DOM-%E7%94%9F%E6%88%90%E7%9A%84"><span class="nav-number">4.3.</span> <span class="nav-text">JavaScript 是如何影响 DOM 生成的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">5.事件模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EventTarget-%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.</span> <span class="nav-text">EventTarget 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EventTarget-addEventListener"><span class="nav-number">5.1.1.</span> <span class="nav-text">EventTarget.addEventListener()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventTarget-removeEventListener"><span class="nav-number">5.1.2.</span> <span class="nav-text">EventTarget.removeEventListener()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventTarget-dispatchEvent"><span class="nav-number">5.1.3.</span> <span class="nav-text">EventTarget.dispatchEvent()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">监听函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-%E7%9A%84-on-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.1.</span> <span class="nav-text">HTML 的 on- 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.2.</span> <span class="nav-text">元素节点的事件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventTarget-addEventListener-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">EventTarget.addEventListener()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="nav-number">5.3.</span> <span class="nav-text">this 的指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="nav-number">5.4.</span> <span class="nav-text">事件的传播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">事件的代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">5.6.</span> <span class="nav-text">Event 对象概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">5.7.</span> <span class="nav-text">Event 对象的实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-bubbles%EF%BC%8CEvent-eventPhase"><span class="nav-number">5.7.1.</span> <span class="nav-text">Event.bubbles，Event.eventPhase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-cancelable%EF%BC%8CEvent-cancelBubble%EF%BC%8Cevent-defaultPrevented"><span class="nav-number">5.7.2.</span> <span class="nav-text">Event.cancelable，Event.cancelBubble，event.defaultPrevented</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-currentTarget%EF%BC%8CEvent-target"><span class="nav-number">5.7.3.</span> <span class="nav-text">Event.currentTarget，Event.target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-type"><span class="nav-number">5.7.4.</span> <span class="nav-text">Event.type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-timeStamp"><span class="nav-number">5.7.5.</span> <span class="nav-text">Event.timeStamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-isTrusted"><span class="nav-number">5.7.6.</span> <span class="nav-text">Event.isTrusted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-detail"><span class="nav-number">5.7.7.</span> <span class="nav-text">Event.detail</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.8.</span> <span class="nav-text">Event 对象的实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-preventDefault"><span class="nav-number">5.8.1.</span> <span class="nav-text">Event.preventDefault()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-stopPropagation"><span class="nav-number">5.8.2.</span> <span class="nav-text">Event.stopPropagation()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-stopImmediatePropagation"><span class="nav-number">5.8.3.</span> <span class="nav-text">Event.stopImmediatePropagation()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-composedPath"><span class="nav-number">5.8.4.</span> <span class="nav-text">Event.composedPath()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CustomEvent-%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.9.</span> <span class="nav-text">CustomEvent 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">5.10.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">6.彻底理解浏览器的缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">6.2.</span> <span class="nav-text">缓存过程分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="nav-number">6.3.</span> <span class="nav-text">强制缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Expires"><span class="nav-number">6.3.1.</span> <span class="nav-text">Expires</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Control"><span class="nav-number">6.3.2.</span> <span class="nav-text">Cache-Control</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">6.4.</span> <span class="nav-text">协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Last-Modified-If-Modified-Since"><span class="nav-number">6.4.1.</span> <span class="nav-text">Last-Modified &#x2F; If-Modified-Since</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Etag-If-None-Match"><span class="nav-number">6.4.2.</span> <span class="nav-text">Etag &#x2F; If-None-Match</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">6.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxy"
      src="/images/Robben.gif">
  <p class="site-author-name" itemprop="name">hxy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huxingyi1997" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huxingyi1997" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huxingyi1997@zju.edu.cn" title="E-Mail → mailto:huxingyi1997@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-frog"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxy</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共128.1k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQsO3ySbU4VtWN2j1FLA74Ha-gzGzoHsz',
      appKey     : 'QYacMDY2VY7Wazprg1X6FiUv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
  <!-- 动态背景特效 -->
  <!-- 樱花特效 -->
    <script async src="/js/src/sakura.js"></script>
    <script async src="/js/src/fairyDustCursor.js"></script>
</body>
</html>
