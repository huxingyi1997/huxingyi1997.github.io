<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Frog_32px_1177822_easyicon.net.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Frog_16px_1177822_easyicon.net.ico">
  <link rel="mask-icon" href="/images/Frog_32px_1177822_easyicon.net.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hxy1997.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"输入关键字","hits_empty":"没有找到与「${query}」相关搜索","hits_stats":"${hits} 条相关记录，共耗时 ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="手写常见js函数，面试必备，多练几遍，争取手撕成功，按照顺序补充，加油啊，除了算法题这种题也很关键，总算重新整理了一遍，以该版本为作为自己最终收藏的版本更新了。 目录1.手写 call✅ 2.手写apply✅ 3.手写bind✅️ 4.手写new✅ 5.手写Object.create✅ 6.手写ES5继承✅ 7.手动实现instanceof✅ 8.手写Array.isArray✅ 9.实现一个函数">
<meta property="og:type" content="article">
<meta property="og:title" content="js函数手写">
<meta property="og:url" content="https://hxy1997.xyz/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/index.html">
<meta property="og:site_name" content="hxy的博客">
<meta property="og:description" content="手写常见js函数，面试必备，多练几遍，争取手撕成功，按照顺序补充，加油啊，除了算法题这种题也很关键，总算重新整理了一遍，以该版本为作为自己最终收藏的版本更新了。 目录1.手写 call✅ 2.手写apply✅ 3.手写bind✅️ 4.手写new✅ 5.手写Object.create✅ 6.手写ES5继承✅ 7.手动实现instanceof✅ 8.手写Array.isArray✅ 9.实现一个函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424092024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424092125.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424085011.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424095633.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424153532.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424185842.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428112307.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428111557.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428120949.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428141501.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428144007.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210422113441.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430220903.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221006.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221448.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221558.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221727.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221743.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221800.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221911.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210502151428.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210502151527.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503155419.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503160337.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503171033.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503194414.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503210054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503213226.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104820.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104909.png">
<meta property="article:published_time" content="2021-02-09T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-17T13:58:29.505Z">
<meta property="article:author" content="hxy">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="函数手写">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424092024.png">

<link rel="canonical" href="https://hxy1997.xyz/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>js函数手写 | hxy的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="hxy的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hxy的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Mia san Mia!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/huxingyi1997" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hxy1997.xyz/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Robben.gif">
      <meta itemprop="name" content="hxy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hxy的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          js函数手写
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-10T00:00:00+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-17 21:58:29" itemprop="dateModified" datetime="2021-07-17T21:58:29+08:00">2021-07-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>手写常见js函数，面试必备，多练几遍，争取手撕成功，按照顺序补充，加油啊，除了算法题这种题也很关键，总算重新整理了一遍，以该版本为作为自己最终收藏的版本更新了。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1.<a href="#1.%E6%89%8B%E5%86%99call">手写 call</a>✅</p>
<p>2.<a href="#2.%E6%89%8B%E5%86%99apply">手写apply</a>✅</p>
<p>3.<a href="#3.%E6%89%8B%E5%86%99bind">手写bind</a>✅️</p>
<p>4.<a href="#4.%E6%89%8B%E5%86%99new">手写new</a>✅</p>
<p>5.<a href="#5.%E6%89%8B%E5%86%99Object.create">手写Object.create</a>✅</p>
<p>6.<a href="#6.%E6%89%8B%E5%86%99ES5%E7%BB%A7%E6%89%BF">手写ES5继承</a>✅</p>
<p>7.<a href="#7.%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof">手动实现instanceof</a>✅</p>
<p>8.<a href="#8.%E6%89%8B%E5%86%99Array.isArray">手写Array.isArray</a>✅</p>
<p>9.<a href="#9.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">实现一个函数判断数据类型</a>✅</p>
<p>10.<a href="#10.%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D">手写深拷贝</a>✅</p>
<p>11.<a href="#11.%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96">数组扁平化</a>✅</p>
<p>12.<a href="#12.%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">数组去重</a>✅</p>
<p>13.<a href="#13.%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84ES5%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">手写数组ES5常见方法</a>✅</p>
<p>14.<a href="#14.%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC">实现数组原地反转</a>✅</p>
<p>15.<a href="#15.reduce%E7%9A%84%E5%BA%94%E7%94%A8%E6%B1%87%E6%80%BB">reduce的应用汇总</a>✅</p>
<p>16.<a href="#16.%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95">洗牌算法</a>✅</p>
<p>17.<a href="#17.%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96">对象扁平化</a>✅</p>
<p>18.<a href="#18.%E6%89%8B%E5%86%99%E5%81%8F%E5%87%BD%E6%95%B0">手写偏函数</a>✅</p>
<p>19.<a href="#19.%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">函数柯里化</a>✅</p>
<p>20.<a href="#20.%E6%89%8B%E5%86%99compose%E5%87%BD%E6%95%B0">手写compose函数</a>✅</p>
<p>21.[实现 (5).add(3).minus(2) 功能](#21.实现 (5).add(3).minus(2) 功能)✅</p>
<p>22.[实现一个 add 函数](#22.实现一个 add 函数)✅</p>
<p>23.<a href="#23.%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">计算两个数组的交集</a>✅</p>
<p>24.<a href="#24.%E6%89%8B%E5%86%99%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83">手写对象深度比较</a>✅</p>
<p>25.<a href="#25.%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84">扁平数组转树状结构</a>✅</p>
<p>26.<a href="#26.%E9%98%B2%E6%8A%96(debounce)">防抖(debounce)</a>✅</p>
<p>27.<a href="#27.%E8%8A%82%E6%B5%81(throttle)">节流(throttle)</a>✅</p>
<p>28.<a href="#28.%E6%89%8B%E5%86%99const">手写const</a>✅</p>
<p>29.<a href="#29.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">手写双向绑定</a>✅</p>
<p>30.<a href="#30.%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">图片懒加载</a>✅</p>
<p>31.<a href="#31.%E5%8C%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8">区间随机数生成器</a>✅</p>
<p>32.<a href="#32.%E6%89%93%E5%8D%B0%E8%8F%B1%E5%BD%A2">打印菱形</a>✅</p>
<p>33.<a href="#33.%E6%89%8B%E5%86%99parseInt">手写parseInt</a>✅</p>
<p>34.<a href="#34.%E6%89%8B%E5%86%99JSON.stringify">手写JSON.stringify</a>✅</p>
<p>35.<a href="#35.%E6%89%8B%E5%86%99JSON.parse">手写JSON.parse</a>✅</p>
<p>36.[解析 URL Params 为对象](#36.解析 URL Params 为对象)✅</p>
<p>37.<a href="#37.%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0">模板引擎实现</a>✅</p>
<p>38.<a href="#38.%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D-%E4%B8%AD%E5%88%92%E7%BA%BF%E8%BD%AC%E6%8D%A2">驼峰命名-中划线转换</a>✅</p>
<p>39.<a href="#39.%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E4%B8%AA%E6%95%B0">查找字符串中出现最多的字符和个数</a>✅</p>
<p>40.<a href="#40.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE">字符串查找</a>✅</p>
<p>41.<a href="#41.%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6">实现千位分隔符</a>✅</p>
<p>42.<a href="#42.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8">正则表达式的基本运用</a>✅</p>
<p>43.<a href="#43.%E6%89%8B%E5%86%99trim">手写trim</a>✅</p>
<p>44.<a href="#44.%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83">版本号比较</a>✅</p>
<p>45.<a href="#45.%E6%89%8B%E5%86%99Object.freeze">手写Object.freeze</a>✅</p>
<p>46.<a href="#46.%E5%AE%9E%E7%8E%B0ES6%E7%9A%84extends">实现ES6的extends</a>✅</p>
<p>47.<a href="#47.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Set">手写实现Set</a>✅</p>
<p>48.<a href="#48.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Map">手写实现Map</a>✅</p>
<p>49.<a href="#49.%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">检测对象循环引用</a>✅</p>
<p>50.<a href="#50.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a>✅</p>
<p>51.<a href="#51.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a>✅</p>
<p>52.<a href="#52.%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" title="EventBus/EventEmitter">发布/订阅模式 (EventBus/EventEmitter)</a>✅</p>
<p>53.<a href="#53.%E6%89%8B%E5%86%99%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86">手写事件代理</a>✅</p>
<p>54.<a href="#54.%E6%89%8B%E5%86%99JSONP%E8%B7%A8%E5%9F%9F">手写JSONP跨域</a>✅</p>
<p>55.<a href="#55.%E6%89%8B%E5%86%99Promise">手写Promise</a>✅</p>
<p>56.<a href="#56.%E6%89%8B%E5%86%99ajax%E5%B0%81%E8%A3%85">手写ajax封装</a>✅</p>
<p>57.<a href="#57.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0sleep">手写实现sleep</a>✅</p>
<p>58.<a href="#58.%E6%89%8B%E5%86%99promisify">手写promisify</a>✅</p>
<p>59.<a href="#59.%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97">实现延时执行队列</a>✅</p>
<p>60.<a href="#60.setTimeout%E5%AE%9E%E7%8E%B0setInterval">setTimeout实现setInterval</a>✅</p>
<p>61.<a href="#61.%E6%89%8B%E5%86%99fetch">手写fetch</a>✅</p>
<p>62.<a href="#62.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Generator">手写实现Generator</a>✅</p>
<p>63.<a href="#63.%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0async/await">手写实现async/await</a>✅</p>
<p>64.<a href="#64.%E6%89%8B%E5%86%99%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C">手写异步串行和异步并行</a>✅</p>
<p>65.<a href="#65.%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%95%B0%E9%99%90%E5%88%B6">异步并发数限制</a>✅</p>
<span id="more"></span>

<h2 id="1-手写call"><a href="#1-手写call" class="headerlink" title="1.手写call"></a>1.手写call</h2><h3 id="ES5实现及过程分析："><a href="#ES5实现及过程分析：" class="headerlink" title="ES5实现及过程分析："></a>ES5实现及过程分析：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnFactory</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unique_fn = <span class="string">&quot;fn&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (context.hasOwnProperty(unique_fn)) &#123;</span><br><span class="line">    	unique_fn = <span class="string">&quot;fn&quot;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unique_fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 若是传入的context是null或者undefined时指向window;</span></span><br><span class="line">    <span class="comment">// 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换</span></span><br><span class="line">    context = (context !== <span class="literal">null</span> &amp;&amp; context !== <span class="literal">undefined</span>) ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 3. 创建一个独一无二的fn函数的命名</span></span><br><span class="line">    <span class="keyword">var</span> fn = fnFactory(context);</span><br><span class="line">    <span class="comment">// 4. 这里的this就是指调用call的那个函数</span></span><br><span class="line">    <span class="comment">// 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 6. 定义一个数组用于放arguments的每一项的字符串: [&#x27;agruments[1]&#x27;, &#x27;arguments[2]&#x27;]</span></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 7. 要从第1项开始, 第0项是context</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">    	args.push(<span class="string">&quot;arguments[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8. 使用eval()来执行fn并将args一个个传递进去</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&quot;context[fn](&quot;</span> + args + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="comment">// 9. 给context额外附件了一个属性fn, 所以用完之后需要删除</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 10. 函数fn可能会有返回值, 需要将其返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ES6实现（手写）"><a href="#ES6实现（手写）" class="headerlink" title="ES6实现（手写）"></a>ES6实现（手写）</h3><p>1.判断当前<code>this</code>是否为函数，防止<code>Function.prototype.myCall()</code> 直接调用</p>
<p>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></p>
<p>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</p>
<p>4.处理参数，传入第一个参数后的其余参数</p>
<p>5.调用函数后即删除该<code>Symbol</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span></span><br><span class="line"><span class="comment"> * args 为一个数组或者类数组对象，是调用函数时的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// 这里this指向调用myCall的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，调用myCall的函数,并接收返回值</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 最后删除这个临时属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-手写apply"><a href="#2-手写apply" class="headerlink" title="2.手写apply"></a>2.手写apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p>
<h3 id="ES5实现及过程分析：-1"><a href="#ES5实现及过程分析：-1" class="headerlink" title="ES5实现及过程分析："></a>ES5实现及过程分析：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnFactory</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unique_fn = <span class="string">&quot;fn&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (context.hasOwnProperty(unique_fn)) &#123;</span><br><span class="line">    	unique_fn = <span class="string">&quot;fn&quot;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unique_fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 若是传入的context是null或者undefined时指向window;</span></span><br><span class="line">    <span class="comment">// 2. 若是传入的是原始数据类型, 原生的call会调用 Object() 转换</span></span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 3. 创建一个独一无二的fn函数的命名</span></span><br><span class="line">    <span class="keyword">var</span> fn = fnFactory(context);</span><br><span class="line">    <span class="comment">// 4. 这里的this就是指调用call的那个函数</span></span><br><span class="line">    <span class="comment">// 5. 将调用的这个函数赋值到context中, 这样之后执行context.fn的时候, fn里的this就是指向context了</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="comment">// 6. 判断有没有第二个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    	result = context[fn]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 7. 有的话则用args放每一项的字符串: [&#x27;arr[0]&#x27;, &#x27;arr[1]&#x27;]</span></span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">&quot;arr[&quot;</span> + i + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8. 使用eval()来执行fn并将args一个个传递进去</span></span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">&quot;context[fn](&quot;</span> + args + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9. 给context额外附件了一个属性fn, 所以用完之后需要删除</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 10. 函数fn可能会有返回值, 需要将其返回</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ES6实现："><a href="#ES6实现：" class="headerlink" title="ES6实现："></a>ES6实现：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span></span><br><span class="line"><span class="comment"> * args 为一个数组或者类数组对象，是调用函数时的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用于防止 Function.prototype.myApply() 直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// context = context || window;</span></span><br><span class="line">    <span class="comment">// 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// 这里this指向调用myApply的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重点代码，利用this指向，相当于context.caller(...args)</span></span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="comment">// 最后删除这个临时属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-手写bind"><a href="#3-手写bind" class="headerlink" title="3.手写bind"></a>3.手写bind</h2><p><strong>提示</strong>:</p>
<ol>
<li>函数内的<code>this</code>表示的就是调用的函数</li>
<li>可以将上下文传递进去, 并修改<code>this</code>的指向</li>
<li>返回一个函数</li>
<li>可以传入参数</li>
<li>柯里化</li>
<li>一个绑定的函数也能使用<code>new</code>操作法创建对象, 且提供的<code>this</code>会被忽略</li>
</ol>
<h3 id="ES5实现及过程分析：-2"><a href="#ES5实现及过程分析：-2" class="headerlink" title="ES5实现及过程分析："></a>ES5实现及过程分析：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 判断调用bind的是不是一个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        	<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 外层的this指向调用者(也就是调用的函数)</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 3. 收集调用bind时的其它参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个返回的函数</span></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 6. 收集调用新的函数时传入的其它参数</span></span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 7. 使用apply改变调用函数时this的指向</span></span><br><span class="line">        <span class="comment">// 作为构造函数调用时this表示的是新产生的对象, 不作为构造函数用的时候传递context</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(</span><br><span class="line">            <span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context,</span><br><span class="line">            args.concat(innerArgs)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 5. 创建一个空的函数, 且将原型指向调用者的原型(为了能用调用者原型中的属性)</span></span><br><span class="line">    <span class="comment">// 下面三步的作用有点类似于 fBoun.prototype = this.prototype 但有区别</span></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="comment">// 8. 返回最后的结果</span></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ES6实现：-1"><a href="#ES6实现：-1" class="headerlink" title="ES6实现："></a>ES6实现：</h3><p>1.处理参数，返回一个闭包</p>
<p>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</p>
<p>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">	<span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用和之前apply、call类似的思想，结合闭包实现bind</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context为函数运行时要使用的this值 默认将context指向window 注意仅在非严格模式下会有这种行为</span></span><br><span class="line"><span class="comment"> * args 为一个数组或者类数组对象，是调用函数时的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 为了防止原来的属性被覆盖，用Symbol去创建一个独一无二的值</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">// 这里this指向调用myApply的函数</span></span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 与当前参数组合</span></span><br><span class="line">        args = args.concat(_args);</span><br><span class="line">        <span class="comment">// 重点代码，执行函数</span></span><br><span class="line">        context[fn](...args);</span><br><span class="line">        <span class="comment">// 最后删除这个临时属性</span></span><br><span class="line">        <span class="keyword">delete</span> context[fn];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>获取函数中的参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    fn(...args);</span><br><span class="line">    fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 获取argument对象 类数组对象 不能调用数组方法 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"><span class="built_in">console</span>.log(test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 获取参数数组  可以调用数组方法 (3) [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 获取argument对象 类数组对象 不能调用数组方法 (2) [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 透传 2 3 透传 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 透传 1 2 3</span></span><br></pre></td></tr></table></figure>



<h2 id="4-手写new"><a href="#4-手写new" class="headerlink" title="4.手写new"></a>4.手写new</h2><p><strong>new操作符做了这些事：</strong></p>
<ul>
<li>创建一个全新的对象，这个对象的<code>__proto__</code>要指向构造函数的原型对象</li>
<li>执行构造函数</li>
<li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(instance, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res: instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要实现一个<code>new</code>，首先要明白它有哪些特性。</p>
<p>看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Eatting&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lindaidai = <span class="keyword">new</span> Person(<span class="string">&#x27;LinDaiDai&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lindaidai);</span><br><span class="line">lindaidai.eat();</span><br></pre></td></tr></table></figure>

<p>使用<code>new</code>创建的实例：</p>
<ul>
<li>能访问到构造函数里的属性(<code>name</code>)</li>
<li>能访问原型中的属性(<code>eat</code>)</li>
</ul>
<p><strong>new操作符做了这些事：</strong></p>
<ul>
<li>创建一个全新的对象，这个对象的<code>__proto__</code>要指向构造函数的原型对象</li>
<li>执行构造函数</li>
<li>返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象</li>
</ul>
<p>根据特性，我们可以这样实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取构造函数，并且删除 arguments 中的第一项</span></span><br><span class="line">    <span class="keyword">var</span> fn = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="comment">// 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> res = fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 4. 优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简化写作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">var</span> res = fn.apply(obj, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? res: obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要提一嘴，第四步中为什么要做这么一个判断呢？</p>
<p>主要是你要考虑构造函数它有没有返回值。</p>
<p>像我们案例中的构造函数<code>Person</code>它是没有返回值的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.有返回值且为对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		sex: sex</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 返回值为基本类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构造函数中有返回值且为对象，那么创建的实例就只能访问到返回对象中的属性，所以要判断一下<code>ret</code>的类型，如果是对象的话，则返回这个对象。</li>
<li>构造函数中没有返回值，那么创建的实例就能访问到这个构造函数中的所有属性了，此时<code>ret</code>就会为<code>undefined</code>，所以返回<code>obj</code>。</li>
<li>构造函数中有返回值但是返回值是<code>undefined</code>以外的其它基本类型(比如字符串)，这种情况当成第二种情况(没有返回值)来处理。</li>
</ol>
<p><strong>验证：</strong></p>
<p>来验证一下可行性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Eatting&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取构造函数，并且删除 arguments 中的第一项</span></span><br><span class="line">    <span class="keyword">var</span> fn = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="comment">// 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> res = fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 4. 优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lindaidai = myNew(Person, <span class="string">&#x27;LinDaiDai&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lindaidai); <span class="comment">// Person&#123; name: &#x27;LinDaiDai&#x27; &#125;</span></span><br><span class="line">lindaidai.eat(); <span class="comment">// &#x27;Eatting&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-手写Object-create"><a href="#5-手写Object-create" class="headerlink" title="5.手写Object.create"></a>5.手写Object.create</h2><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__，<code>Object.create</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 继承对象原型</span></span><br><span class="line">    F.prototype = proto;</span><br><span class="line">	<span class="comment">// 返回一个改构建函数实力</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法，特别注意和ES5手写继承时用法不同，因此其传递得时构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;smyhvae&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(p);  <span class="comment">//此方法创建的对象，是用原型链连接的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.__proto__ === p);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(p.prototype);  <span class="comment">//此方法创建的对象，是用原型链连接的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">/* VM3968:4 Uncaught TypeError: Object prototype may only be an Object or null: undefined</span></span><br><span class="line"><span class="comment">    at Function.create (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:4:19 */</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> B = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(B, obj);</span><br><span class="line">    <span class="keyword">return</span> B;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更直观点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> B = &#123;&#125;;</span><br><span class="line">    B.__proto__ = obj;</span><br><span class="line">    <span class="keyword">return</span> B;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="6-手写ES5继承"><a href="#6-手写ES5继承" class="headerlink" title="6.手写ES5继承"></a>6.手写ES5继承</h2><p>面试题如下，想让student继承person，先写下基本框架</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先写了一下继承后上述prototype和__proto__的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.prototype.__proto__ === person.prototype</span><br></pre></td></tr></table></figure>

<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><blockquote>
<p>子类的原型指向父类。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = <span class="keyword">new</span> person();</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.简单，易于实现</p>
<p>2.父类新增原型方法、原型属性，子类都能访问到</p>
<p>缺点：</p>
<p>1.无法实现多继承，因为原型一次只能被一个实例更改</p>
<p>2.来自原型对象的所有属性被所有实例共享,改变一个其他也会改变。</p>
<p>3.创建子类 Child实例时，无法向父构造函数Parent传参</p>
<p>该打，我现场写没写完全对，写的是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student = <span class="keyword">new</span> person();</span><br></pre></td></tr></table></figure>

<p>脑子怎么想的，这样student怎么继承person的实例和共享</p>
<h3 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h3><blockquote>
<p>在子类构造函数中调用父类构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line">	person.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.避免了原型链继承中子类实例共享父类引用属性的问题。</p>
<p>2.创建子类Child 实例时，可以向父类 Parent 传递参数。</p>
<p>3.可以实现多继承（call多个父类对象）</p>
<p>缺点：</p>
<p>1.实例并不是父类的实例，只是子类的实例</p>
<p>2.只能继承父类实例的属性和方法,不能继承父类原型的属性和方法</p>
<p>3.方法都在构造函数中定义，每次创建实例都会创建一遍父类实例函数的副本，浪费内存，且无法实现函数复用。</p>
<p>这个当时倒是完全写对了。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote>
<p>使用构造继承继承父类参数，使用原型继承继承父类函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	person.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = <span class="keyword">new</span> person();</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>1.融合原型链继承和构造函数的优点，既可以继承实例的属性和方法，也可以继承原型的属性和方法。</p>
<p>2.既是子类的实例，也是父类的实例</p>
<p>3.可以向父类传递参数，函数可以复用</p>
<p>缺点：</p>
<p>1.调用了两次父类构造函数，生成了两份实例，即person的构造函数会多执行了一次（<code>Child.prototype = new Parent()</code>;）</p>
<p>2.constructor指向问题，子类实例constructor指向父类</p>
<p>哭了，又没有完全写对，错误同原型继承</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = <span class="built_in">Object</span>.create(person.prototype);</span><br></pre></td></tr></table></figure>

<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<p>又搞错了</p>
<p>写成了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.prototype = <span class="built_in">Object</span>.create(person());</span><br></pre></td></tr></table></figure>

<p>不知道怎么想的，面试官提示我知不知道Object.create怎么一回事，还口述了手写过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.myCreate(proto) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    f.prototype = proto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>口述的方法倒是对的，就是这样传递的参数是什么，我怎么思考</p>
<p>口述之后我发现传递person()不对劲，又重写了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.prototype = <span class="built_in">Object</span>.create(person);</span><br></pre></td></tr></table></figure>

<p>真是该打</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><blockquote>
<p>将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	person.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = person.prototype;</span><br><span class="line"><span class="comment">// 或者 student.prototype = Object.create(person.prototype);</span></span><br></pre></td></tr></table></figure>

<p>缺点：这种继承方法父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p>
<p>我的错误跟上面的一样，不再赘述</p>
<h3 id="寄生组合优化继承"><a href="#寄生组合优化继承" class="headerlink" title="寄生组合优化继承"></a>寄生组合优化继承</h3><p>最后当然是最完美的寄生组合优化继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.kind = <span class="string">&quot;person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; is eating &quot;</span> + food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	person.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = person.prototype;</span><br><span class="line"><span class="comment">// 或者 student.prototype = Object.create(person.prototype);</span></span><br><span class="line">student.prototype.constructor = student;</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<p>总之错误真多，觉得没脸见人了，手写和口述讲思路难度差距真大，自己把错误的地方好好反思</p>
<p>这篇讲的很好<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904148899463175">前端高频面试题整理</a> </p>
<h2 id="7-手动实现instanceof"><a href="#7-手动实现instanceof" class="headerlink" title="7.手动实现instanceof"></a>7.手动实现instanceof</h2><p>使用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>

<p>原理：判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>按照target原型链的向上查找，直到找到 origin 或 null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target instanceof origin</span></span><br><span class="line"><span class="comment">// 变量origin的prototype 存在于变量target的原型链上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得target对象的原型</span></span><br><span class="line">    <span class="keyword">let</span> proto = target.__proto__;</span><br><span class="line">	<span class="comment">// 判断是否target的原型是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === origin.prototype) &#123;</span><br><span class="line">            <span class="comment">// origin的prototype在target的原型链上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续沿着target原型链查找origin的prototype</span></span><br><span class="line">            <span class="keyword">return</span> myInstanceof(proto, origin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>改用循环而不是递归 ，可以参考一下<a href="https://hxy1997.xyz/2021/04/22/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/#more">js函数式编程</a>里面的蹦床函数思想</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target instanceof origin</span></span><br><span class="line"><span class="comment">// 变量origin的prototype 存在于变量target的原型链上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 验证如果为基本数据类型，就直接返回false可以不写</span></span><br><span class="line">    <span class="keyword">const</span> baseType = [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;number&#x27;</span>,<span class="string">&#x27;boolean&#x27;</span>,<span class="string">&#x27;undefined&#x27;</span>,<span class="string">&#x27;symbol&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span>(baseType.includes(<span class="keyword">typeof</span>(target))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 取 origin 的显式原型origin的prototype</span></span><br><span class="line">    <span class="keyword">let</span> oP  = origin.prototype;</span><br><span class="line">    <span class="comment">// 取 target 的隐式原型</span></span><br><span class="line">    proto = target.__proto__;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;           <span class="comment">// 无线循环的写法（也可以使 for(;;) ）</span></span><br><span class="line">        <span class="keyword">if</span>(proto === <span class="literal">null</span>)&#123;    <span class="comment">// 找到最顶层</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(proto === oP)&#123;       <span class="comment">// 严格相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__;  <span class="comment">//没找到继续向上一层原型链查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-手写Array-isArray"><a href="#8-手写Array-isArray" class="headerlink" title="8.手写Array.isArray"></a>8.手写Array.isArray</h2><p>先总结一下判断一个数据是否是一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(arr);</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">arr.constructor === <span class="built_in">Array</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>测试一下结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用toString实现Array-isArray"><a href="#使用toString实现Array-isArray" class="headerlink" title="使用toString实现Array.isArray"></a>使用toString实现Array.isArray</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(obj)) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用instanceof实现Array-isArray"><a href="#使用instanceof实现Array-isArray" class="headerlink" title="使用instanceof实现Array.isArray"></a>使用instanceof实现Array.isArray</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用constructor实现Array-isArray"><a href="#使用constructor实现Array-isArray" class="headerlink" title="使用constructor实现Array.isArray"></a>使用constructor实现Array.isArray</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj.constructor === <span class="built_in">Array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="9-实现一个函数判断数据类型"><a href="#9-实现一个函数判断数据类型" class="headerlink" title="9.实现一个函数判断数据类型"></a>9.实现一个函数判断数据类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    <span class="comment">// 对象类型 &quot;[object XXX]&quot;-&gt;XXX的小写 简单类型typeof obj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ? <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="string">&#x27;[object &#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase() : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">null</span>)); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(&#123;&#125;)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(getType([])); <span class="comment">// array</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="number">123</span>)); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">true</span>)); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="regexp">/123/</span>)); <span class="comment">// regexp</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// date</span></span><br></pre></td></tr></table></figure>



<h2 id="10-手写深拷贝"><a href="#10-手写深拷贝" class="headerlink" title="10.手写深拷贝"></a>10.手写深拷贝</h2><p><strong>深拷贝和浅拷贝都是针对的引用类型，JS中的变量类型分为值类型（基本类型）和引用类型；对值类型进行复制操作会对值进行一份拷贝，而对引用类型赋值，则会进行地址的拷贝，最终两个变量指向同一份数据。</strong>对于引用类型，会导致a b指向同一份数据，此时如果对其中一个进行修改，就会影响到另外一个，有时候这可能不是我们想要的结果，如果对这种现象不清楚的话，还可能造成不必要的bug。</p>
<p>那么如何切断a和b之间的关系呢，可以拷贝一份a的数据，根据拷贝的层级不同可以分为浅拷贝和深拷贝，浅拷贝就是只进行一层拷贝，深拷贝就是无限层级拷贝<strong>假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</strong></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝极简版"><a href="#深拷贝极简版" class="headerlink" title="深拷贝极简版"></a>深拷贝极简版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>

<p>估计这个api能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：</p>
<blockquote>
<p>无法解决<code>循环引用</code>的问题。举个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(res.target);</span><br><span class="line"><span class="comment">/* VM1156:5 Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="comment">    --&gt; starting at object with constructor &#x27;Object&#x27;</span></span><br><span class="line"><span class="comment">    --- property &#x27;target&#x27; closes the circle</span></span><br><span class="line"><span class="comment">    at JSON.stringify (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:5:27 */</span></span><br></pre></td></tr></table></figure>

<p>拷贝a会出现系统栈溢出，因为出现了<code>无限递归</code>的情况。</p>
<blockquote>
<p>无法拷贝一写<code>特殊的对象</code>，诸如 RegExp, Date, Set, Map等。</p>
</blockquote>
<blockquote>
<p>无法拷贝<code>函数</code>(划重点)。</p>
</blockquote>
<p>总结：</p>
<p><strong>该方法的局限性：</strong></p>
<ul>
<li>无法实现对函数 、RegExp等特殊对象的克隆</li>
<li>会抛弃对象的constructor,所有的构造函数会指向Object</li>
<li>对象有循环引用,会报错</li>
<li>所有以 symbol 为属性键的属性都会被完全忽略掉</li>
<li>无法区分布尔值、数字、字符串及其包装对象</li>
<li>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</li>
<li>其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。</li>
</ul>
<h3 id="面试够用的版本：递归法"><a href="#面试够用的版本：递归法" class="headerlink" title="面试够用的版本：递归法"></a>面试够用的版本：递归法</h3><p>考虑到数组和对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">	<span class="comment">// 判断是否是引用类型，特别注意typeof null === &quot;object&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 复杂数据类型的类型</span></span><br><span class="line">		res = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">			<span class="comment">// 遍历对象中的每个元素是否为对象类型</span></span><br><span class="line">			res[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&quot;object&quot;</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">		res = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>上述版本执行下面这样一个测试用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">	<span class="comment">// 判断是否是引用类型，特别注意typeof null === &quot;object&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 复杂数据类型的类型</span></span><br><span class="line">		res = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">			<span class="comment">// 遍历对象中的每个元素是否为对象类型</span></span><br><span class="line">			res[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&quot;object&quot;</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">		res = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> res = deepCopy(a);</span><br><span class="line"><span class="built_in">console</span>.log(res.target);</span><br><span class="line"><span class="comment">/* VM948:12 Uncaught RangeError: Maximum call stack size exceeded</span></span><br><span class="line"><span class="comment">	....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为递归进入死循环导致栈内存溢出了。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424092024.png" alt="img"></p>
<p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接的引用了自身的情况：</p>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>
<p>这个存储空间，需要可以存储 <code>key-value</code>形式的数据，且 <code>key</code>可以是一个引用类型，我们可以选择 <code>Map</code>这种数据结构：</p>
<ul>
<li>检查<code>map</code>中有无克隆过的对象</li>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li>
<li>继续克隆</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">	<span class="comment">// 判断是否是引用类型，特别注意typeof null === &quot;object&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 复杂数据类型的类型</span></span><br><span class="line">		res = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="comment">// map中有克隆过的对象,直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// map中没有克隆过的对象,进行存储</span></span><br><span class="line">        map.set(obj, res);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">			<span class="comment">// 遍历对象中的每个元素是否为对象类型</span></span><br><span class="line">			res[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&quot;object&quot;</span> ? deepCopy(obj[i], map) : obj[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">		res = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> res = deepCopy(a);</span><br><span class="line"><span class="built_in">console</span>.log(res.target);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424092125.jpeg" alt="img"></p>
<p>可以看到，执行没有报错，且 <code>target</code>属性，变为了一个 <code>Circular</code>类型，即循环应用的意思。</p>
<p>接下来，可以使用 <code>WeakMap</code>替代 <code>Map</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么要这样做呢？，先来看看 <code>WeakMap</code>的作用：</p>
<blockquote>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
</blockquote>
<p>什么是弱引用呢？</p>
<blockquote>
<p>在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。</p>
</blockquote>
<p>我们默认创建一个对象：<code>const obj=&#123;&#125;</code>，就默认创建了一个强引用的对象，我们只有手动将 <code>obj=null</code>，它才会被垃圾回收机制进行回收，如果是弱引用对象，垃圾回收机制会自动帮我们回收。</p>
<p>举例：</p>
<p>如果我们使用 <code>Map</code>的话，那么对象间是存在强引用关系的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">&#x27;ConardLi&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    obj:<span class="string">&#x27;code秘密花园&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>虽然我们手动将 <code>obj</code>，进行释放，然是 <code>target</code>依然对 <code>obj</code>存在强引用关系，所以这部分内存依然无法被释放。</p>
<p>再来看 <code>WeakMap</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span> : <span class="string">&#x27;ConardLi&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">target.set(obj, <span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>如果是 <code>WeakMap</code>的话， <code>target</code>和 <code>obj</code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。</p>
<p>设想一下，如果我们要拷贝的对象非常庞大时，使用 <code>Map</code>会对内存造成非常大的额外消耗，而且我们需要手动清除 <code>Map</code>的属性才能释放这块内存，而 <code>WeakMap</code>会帮我们巧妙化解这个问题。</p>
<p>我也经常在某些代码中看到有人使用 <code>WeakMap</code>来解决循环引用问题，但是解释都是模棱两可的，当你不太了解 <code>WeakMap</code>的真正作用时。我建议你也不要在面试中写这样的代码，结果只能是给自己挖坑，即使是准备面试，你写的每一行代码也都是需要经过深思熟虑并且非常明白的。</p>
<p>能考虑到循环引用的问题，你已经向面试官展示了你考虑问题的全面性，如果还能用 <code>WeakMap</code>解决问题，并很明确的向面试官解释这样做的目的，那么你的代码在面试官眼里应该算是合格了。</p>
<h3 id="性能优化（可以跳过，实在有点偏）"><a href="#性能优化（可以跳过，实在有点偏）" class="headerlink" title="性能优化（可以跳过，实在有点偏）"></a>性能优化（可以跳过，实在有点偏）</h3><p>在上面的代码中，我们遍历数组和对象都使用了 <code>forin</code>这种方式，实际上 <code>for in</code>在遍历时效率是非常低的，常见的三种循环 <code>for、while、forin</code>的执行效率中，<code>while</code>的效率是最好的，所以，我们可以想办法把 <code>forin</code>遍历改变为 <code>while</code>遍历。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424085011.jpeg" alt="img"></p>
<p>我们先使用 <code>while</code>来实现一个通用的 <code>forEach</code>遍历， <code>iteratee</code>是遍历的回调函数，它可以接收每次遍历的 <code>value</code>和 <code>index</code>两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对我们的 <code>deepCopy</code>函数进行改写：当遍历数组时，直接使用 <code>forEach</code>进行遍历，当遍历对象时，使用 <code>Object.keys</code>取出所有的 <code>key</code>进行遍历，然后在遍历时把 <code>forEach</code>会调函数的 <code>value</code>当作 <code>key</code>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">	<span class="comment">// 判断是否是引用类型，特别注意typeof null === &quot;object&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 复杂数据类型的类型</span></span><br><span class="line">		res = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="comment">// map中有克隆过的对象,直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// map中没有克隆过的对象,进行存储</span></span><br><span class="line">        map.set(obj, res);</span><br><span class="line">        <span class="keyword">const</span> keys = obj.constructor === <span class="built_in">Array</span> ?  <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">        forEach(keys || obj, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">                key = value;</span><br><span class="line">            &#125;</span><br><span class="line">            res[key] = deepCopy(obj[key], map);</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">			<span class="comment">// 遍历对象中的每个元素是否为对象类型</span></span><br><span class="line">			res[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&quot;object&quot;</span> ? deepCopy(obj[i], map) : obj[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">		res = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    val: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">a.target = a;</span><br><span class="line"><span class="keyword">let</span> res = deepCopy(a);</span><br><span class="line"><span class="built_in">console</span>.log(res.target);</span><br></pre></td></tr></table></figure>

<h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h3><p>在上面的代码中，我们其实只考虑了普通的 <code>object</code>和 <code>array</code>两种数据类型，实际上所有的引用类型远远不止这两个，还有很多，下面我们先尝试获取对象准确的类型。</p>
<h4 id="合理的判断引用类型"><a href="#合理的判断引用类型" class="headerlink" title="合理的判断引用类型"></a>合理的判断引用类型</h4><p>首先，判断是否为引用类型，我们还需要考虑 <code>function</code>和 <code>null</code>两种特殊的数据类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h4><p>我们可以使用 <code>toString</code>来获取准确的引用类型：</p>
<blockquote>
<p>每一个引用类型都有 <code>toString</code>方法，默认情况下， <code>toString()</code>方法被每个 <code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖， <code>toString()</code>返回 <code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p>
</blockquote>
<p>注意，上面提到了如果此方法在自定义对象中未被覆盖， <code>toString</code>才会达到预想的效果，事实上，大部分引用类型比如 <code>Array、Date、RegExp</code>等都重写了 <code>toString</code>方法。</p>
<p>我们可以直接调用 <code>Object</code>原型上未被覆盖的 <code>toString()</code>方法，使用 <code>call</code>来改变 <code>this</code>指向来达到我们想要的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424095633.jpeg" alt="img"></p>
<p>下面我们抽离出一些常用的数据类型以便后面使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">&#x27;[object Arguments]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的集中类型中，我们简单将他们分为两类：</p>
<ul>
<li>可以继续遍历的类型</li>
<li>不可以继续遍历的类型</li>
</ul>
<p>我们分别为它们做不同的拷贝。更详细的写法请参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a>，完整代码请参考<a target="_blank" rel="noopener" href="https://github.com/ConardLi/ConardLi.github.io/blob/master/demo/deepClone/src/clone_6.js">完整版代码</a></p>
<h4 id="可继续遍历的类型"><a href="#可继续遍历的类型" class="headerlink" title="可继续遍历的类型"></a>可继续遍历的类型</h4><p>上面我们已经考虑的 <code>object</code>、 <code>array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有 <code>Map</code>， <code>Set</code>等都是可以继续遍历的类型，这里我们只考虑这四种，如果你有兴趣可以继续探索其他类型。</p>
<p>有序这几种类型还需要继续进行递归，我们首先需要获取它们的初始化数据，例如上面的 <code>[]</code>和 <code>&#123;&#125;</code>，我们可以通过拿到 <code>constructor</code>的方式来通用的获取。</p>
<p>例如：<code>const target = &#123;&#125;</code>就是 <code>const target = new Object()</code>的语法糖。另外这种方法还有一个好处：因为我们还使用了原对象的构造方法，所以它可以保留对象原型上的数据，如果直接使用普通的 <code>&#123;&#125;</code>，那么原型必然是丢失了的。</p>
<p>下面，我们改写 <code>clone</code>函数，对可继续遍历的数据类型进行处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">&#x27;[object Arguments]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj === <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">let</span> type = getType(obj);</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">        <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">        <span class="keyword">let</span> ctor = obj.constructor;</span><br><span class="line">        res = <span class="keyword">new</span> ctor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map中有克隆过的对象,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map中没有克隆过的对象,进行存储</span></span><br><span class="line">    map.set(obj, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">        <span class="comment">// 处理Map</span></span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">            res.set(deepCopy(key, map), deepCopy(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">        <span class="comment">// 处理Set</span></span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            res.add(deepCopy(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数组和对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">            res[prop] = deepCopy(obj[prop], map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;ConardLi&#x27;</span>, <span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line">set.add(<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    set,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = deepCopy(target);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">console</span>.log(res.map === target.map);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424153532.jpeg" alt="preview"></p>
<p>没有问题，继续处理其他类型：</p>
<h4 id="不可继续遍历的类型"><a href="#不可继续遍历的类型" class="headerlink" title="不可继续遍历的类型"></a>不可继续遍历的类型</h4><p>其他剩余的类型我们把它们统一归类成不可处理的数据类型，我们依次进行处理：</p>
<p><code>Bool</code>、 <code>Number</code>、 <code>String</code>、 <code>String</code>、 <code>Date</code>、 <code>Error</code>这几种类型我们都可以直接用构造函数和原始数据创建一个新对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneNotTraverse</span>(<span class="params">obj, tag</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">const</span> Ctor = obj.constructor;</span><br><span class="line">    <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag: </span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="comment">// 大部分都使用构造函数新建</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(obj);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneRegExp(obj);</span><br><span class="line">        <span class="keyword">case</span> funcTag:</span><br><span class="line">            <span class="keyword">return</span> cloneFunc(obj);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>克隆 <code>Symbol</code>类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>克隆正则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; source, flags &#125; = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(source, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上还有很多数据类型我这里没有写到，有兴趣的话可以继续探索实现一下。</p>
<p>如下所示:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> Ctor = obj.constructor;</span><br><span class="line"><span class="keyword">new</span> Ctor(obj); <span class="comment">// 结果为 Boolean &#123;true&#125; 而不是 false。</span></span><br></pre></td></tr></table></figure>

<p>对于这样一个bug，我们可以对 Boolean 拷贝做最简单的修改， 调用valueOf: new obj.constructor(obj.valueOf())。</p>
<p>但实际上，这种写法是不推荐的。因为在ES6后不推荐使用【new 基本类型()】这 样的语法，所以es6中的新类型 Symbol 是不能直接 new 的，只能通过 new Object(SymbelType)。</p>
<p>因此我们接下来统一一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneNotTraverse</span>(<span class="params">obj, tag</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">const</span> Ctor = obj.constructor;</span><br><span class="line">    <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> errorTag: </span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="comment">// 大部分都使用构造函数新建</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(obj);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneRegExp(obj);</span><br><span class="line">        <span class="keyword">case</span> funcTag:</span><br><span class="line">            <span class="keyword">return</span> cloneFunc(obj);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(source, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能写到这里，面试官已经看到了你考虑问题的严谨性，你对变量和类型的理解，对 <code>JS API</code>的熟练程度，相信面试官已经开始对你刮目相看了。</p>
<h3 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h3><p>最后，我把克隆函数单独拎出来了，实际上克隆函数是没有实际应用场景的，两个对象使用一个在内存中处于同一个地址的函数也是没有任何问题的，我特意看了下 <code>lodash</code>对函数的处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"> <span class="keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;</span><br><span class="line">        <span class="keyword">return</span> object ? value : &#123;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可见这里如果发现是函数的话就会直接返回了，没有做特殊的处理，但是我发现不少面试官还是热衷于问这个问题的，而且据我了解能写出来的少之又少。。。</p>
<p>实际上这个方法并没有什么难度，主要就是考察你对基础的掌握扎实不扎实。</p>
<p>首先，我们可以通过 <code>prototype</code>来区分下箭头函数和普通函数，箭头函数是没有 <code>prototype</code>的。</p>
<p>我们可以直接使用 <code>eval</code>和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。</p>
<p>我们可以使用正则来处理普通函数：</p>
<p>分别使用正则取出函数体和函数参数，然后使用 <code>new Function([arg1[, arg2[, ...argN]], ]functionBody)</code>构造函数重新构造一个新的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">    <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">    <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">    <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">    <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (param) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码展示"><a href="#完整代码展示" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><p>最后，我们再来执行clone6.test.js对下面的测试用例进行测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">&#x27;[object Arguments]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> canTraverse = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Map]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Set]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;[object Arguments]&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 简单数据类型 直接 = 赋值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj === <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">let</span> type = getType(obj);</span><br><span class="line">	<span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span>(!canTraverse[type]) &#123;</span><br><span class="line">        <span class="comment">// 处理不能遍历的对象</span></span><br><span class="line">        <span class="keyword">return</span> cloneNotTraverse(obj, type);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这波操作相当关键，可以保证对象的原型不丢失！</span></span><br><span class="line">        <span class="keyword">let</span> ctor = obj.constructor;</span><br><span class="line">        res = <span class="keyword">new</span> ctor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map中有克隆过的对象,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map中没有克隆过的对象,进行存储</span></span><br><span class="line">    map.set(obj, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(type === mapTag) &#123;</span><br><span class="line">        <span class="comment">// 处理Map</span></span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">            res.set(deepCopy(key, map), deepCopy(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(type === setTag) &#123;</span><br><span class="line">        <span class="comment">// 处理Set</span></span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            res.add(deepCopy(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理数组和对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">            res[prop] = deepCopy(obj[prop], map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneNotTraverse</span>(<span class="params">obj, tag</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">const</span> Ctor = obj.constructor;</span><br><span class="line">    <span class="keyword">switch</span>(tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Boolean</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Number</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">String</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(obj));</span><br><span class="line">        <span class="keyword">case</span> errorTag: </span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="comment">// 大部分都使用构造函数新建</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneRegExp(obj);</span><br><span class="line">        <span class="keyword">case</span> funcTag:</span><br><span class="line">            <span class="keyword">return</span> cloneFunc(obj);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 箭头函数直接返回自身</span></span><br><span class="line">    <span class="keyword">if</span>(!func.prototype) <span class="keyword">return</span> func;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="comment">// 分别匹配 函数参数 和 函数体</span></span><br><span class="line">    <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">    <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">    <span class="keyword">if</span>(!body) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (param) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; source, flags &#125; = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(source, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;ConardLi&#x27;</span>, <span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line">set.add(<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    empty: <span class="literal">null</span>,</span><br><span class="line">    map,</span><br><span class="line">    set,</span><br><span class="line">    bool: <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>),</span><br><span class="line">    num: <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>),</span><br><span class="line">    str: <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">2</span>),</span><br><span class="line">    symbol: <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="number">1</span>)),</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    reg: <span class="regexp">/\d+/</span>,</span><br><span class="line">    error: <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">    func1: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;code秘密花园&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = deepCopy(target);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210424185842.jpeg" alt="img"></p>
<h2 id="11-数组扁平化"><a href="#11-数组扁平化" class="headerlink" title="11.数组扁平化"></a>11.数组扁平化</h2><p>面试被问到这题，只能说做出来一半</p>
<p>多维数组=&gt;一维数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>]; <span class="comment">// -&gt; [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>如何实现呢，思路非常简单：<strong>我们要做的就是在数组中找到是数组类型的元素，然后将他们展开</strong>。这就是实现数组拍平 <code>flat</code> 方法的关键思路。</p>
<p>有了思路，我们就需要解决实现这个思路需要克服的困难：</p>
<ul>
<li><strong>第一个要解决的就是遍历数组的每一个元素；</strong></li>
<li><strong>第二个要解决的就是判断元素是否是数组；</strong></li>
<li><strong>第三个要解决的就是将数组的元素展开一层；</strong></li>
</ul>
<h3 id="调用ES6中的flat方法"><a href="#调用ES6中的flat方法" class="headerlink" title="调用ES6中的flat方法"></a>调用ES6中的flat方法</h3><p>面试时机智如我先说了arr自带的flat方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.flatten(<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈哈，又写错了，正确的应该是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.flat(<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>面试官说就是要实现它，不要用自带的flat函数</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>我说可以用正则表达式，然后手写了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().replace(<span class="regexp">/[|]/g</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;5&quot;, &quot;6&quot;]</span></span><br></pre></td></tr></table></figure>

<p>面试官提醒，正则表达式中<code>[</code>和<code>]</code>有什么作用</p>
<p>赶紧解释[]表示匹配中间对应的字符，用转义符才能实现匹配</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;5&quot;, &quot;6&quot;]</span></span><br></pre></td></tr></table></figure>

<p>面试官又说如果本身里面带字符串，字符串中有<code>,</code>就不正确，数字、字符串无法区分。</p>
<p>其实这种时候可以JSON实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br></pre></td></tr></table></figure>

<p>使用JSON.parse还原为原先的格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;[&#x27;</span> + <span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>) + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, null, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我终于决定使用递归的方案做了一版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">            res.push(...flat(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br></pre></td></tr></table></figure>

<p>其中我还写了一下判断数组的方法，可以参见Array.isArray手写</p>
<p>面试官又说这样数组有什么情况如果有空位这种方法不管用</p>
<p>Cannot read property ‘constructor’ of undefined</p>
<p>查了查有可能的情况，发现是数组空位，ES5 大多数数组方法对空位的处理都会选择跳过空位包括：<code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和 <code>some()</code> 都会跳过空位。</p>
<p><strong>ES5 对空位的处理，非常不一致，大多数情况下会忽略空位。</strong></p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code> 都会跳过空位。</li>
<li><code>map()</code> 会跳过空位，但会保留这个值。</li>
<li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code>，而<code>undefined</code> 和 <code>null</code> 会被处理成空字符串。</li>
</ul>
<p><strong>ES6 明确将空位转为 <code>undefined</code>。</strong></p>
<ul>
<li><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code> 和 <code>findIndex()</code> 会将空位处理成 <code>undefined</code>。</li>
<li><code>for...of</code> 循环会遍历空位。</li>
<li><code>fill()</code> 会将空位视为正常的数组位置。</li>
<li><code>copyWithin()</code> 会连空位一起拷贝。</li>
<li>扩展运算符（<code>...</code>）也会将空位转为 <code>undefined</code>。</li>
<li><code>Array.from</code> 方法会将数组的空位，转为 <code>undefined</code>。</li>
</ul>
<p>使用forEach实现数组遍历可破</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.constructor == <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="comment">// if (instanceof(item) == Array) &#123;</span></span><br><span class="line">            res.push(...flat(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="利用reduce函数迭代-原地展开"><a href="#利用reduce函数迭代-原地展开" class="headerlink" title="利用reduce函数迭代(原地展开)"></a>利用reduce函数迭代(原地展开)</h3><p>使用reduce实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flat(cur) : cur);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(flat(arr));</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要有一个元素有数组，那么循环继续</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, ,<span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">while</span> (arr.some(<span class="built_in">Array</span>.isArray)) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//  [1, 2, 3, 4, empty, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>更多牛逼方法可参考面试官连环追问：<a target="_blank" rel="noopener" href="https://github.com/NieZhuZhu/Blog/issues/2">数组拍平（扁平化） flat 方法实现</a></p>
<h2 id="12-数组去重"><a href="#12-数组去重" class="headerlink" title="12.数组去重"></a>12.数组去重</h2><p>尽可能总结全，不过实战很可能会忘掉大部分，特别要注意NaN和{}</p>
<h3 id="双层-for-循环"><a href="#双层-for-循环" class="headerlink" title="双层 for 循环"></a>双层 for 循环</h3><blockquote>
<p>思想: 双重 <code>for</code> 循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是O($n^2$)，如果数组长度很大，效率会很低</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 防止出现类型转换 如果是==NaN只有一个，null消失3</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">                <span class="comment">// splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一</span></span><br><span class="line">                arr.splice(j, <span class="number">1</span>);</span><br><span class="line">                len--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>NaN、{}没有去重</p>
<h3 id="利用indexOf或者includes去重"><a href="#利用indexOf或者includes去重" class="headerlink" title="利用indexOf或者includes去重"></a>利用indexOf或者includes去重</h3><blockquote>
<p>新建一个空的结果数组，<code>for</code> 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则<code>push</code>进数组Object</p>
</blockquote>
<h4 id="使用indexOf判断"><a href="#使用indexOf判断" class="headerlink" title="使用indexOf判断"></a>使用indexOf判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>NaN、{}没有去重</p>
<h4 id="使用includes判断"><a href="#使用includes判断" class="headerlink" title="使用includes判断"></a>使用includes判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.includes(arr[i])) &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p> {}没有去重</p>
<h3 id="Array-filter-indexOf"><a href="#Array-filter-indexOf" class="headerlink" title="Array.filter() + indexOf"></a>Array.filter() + indexOf</h3><blockquote>
<p>思想: 利用<code>indexOf</code>检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.indexOf(item) === index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p> {}没有去重, NaN消失</p>
<h3 id="Array-reduce-indexOf-includes"><a href="#Array-reduce-indexOf-includes" class="headerlink" title="Array.reduce() + indexOf/includes"></a>Array.reduce() + indexOf/includes</h3><h4 id="使用includes判断-1"><a href="#使用includes判断-1" class="headerlink" title="使用includes判断"></a>使用includes判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev.includes(cur) ? prev : [...prev, cur], []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>{}没有去重</p>
<h4 id="使用indexOf判断-1"><a href="#使用indexOf判断-1" class="headerlink" title="使用indexOf判断"></a>使用indexOf判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev.indexOf(cur) !== -<span class="number">1</span> ? prev : [...prev, cur], []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>NaN和{}没有去重</p>
<h3 id="利用ES6-Set去重"><a href="#利用ES6-Set去重" class="headerlink" title="利用ES6 Set去重"></a>利用ES6 Set去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>{}没有去重</p>
<h4 id="利用展开运算符简写"><a href="#利用展开运算符简写" class="headerlink" title="利用展开运算符简写"></a>利用展开运算符简写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>同样{}没有去重</p>
<h3 id="利用Map数据结构去重"><a href="#利用Map数据结构去重" class="headerlink" title="利用Map数据结构去重"></a>利用Map数据结构去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 数组用于返回结果</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果没有该key值</span></span><br><span class="line">        <span class="keyword">if</span>(!map.has(arr[i])) &#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">			map.set(arr[i], <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>{}没有去重</p>
<h3 id="利用hasOwnProperty"><a href="#利用hasOwnProperty" class="headerlink" title="利用hasOwnProperty"></a>利用hasOwnProperty</h3><blockquote>
<p>利用<code>hasOwnProperty</code> 判断是否存在对象属性这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值。 1 和 ‘1’ 是不同的，但是这种直接作为key会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 <code>typeof item + item</code> 拼成字符串作为 key 值来避免这个问题：</p>
</blockquote>
<p>使用filter实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> obj,hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> iten + item] = <span class="literal">true</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>

<p>同时实现NaN和{}去重，这也是最完美的一种去重了，更详细的可以参考冴羽大大的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903482093387783">JavaScript专题之数组去重</a></p>
<h2 id="13-手写数组ES5常见方法"><a href="#13-手写数组ES5常见方法" class="headerlink" title="13.手写数组ES5常见方法"></a>13.手写数组ES5常见方法</h2><p>这个之前写过了，这里复习一下写法</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li>callback 回调函数</li>
<li>context 执行 callback时使用的 this 值</li>
<li>current 数组中正在处理的元素</li>
<li>index 当前索引</li>
<li>array 源数组</li>
<li>accumulator 累加器</li>
<li>initialValue reduce或者reduceRight 第一次调用 callbackFn 函数时的第一个参数的值默认值</li>
<li>self 自己实现的 this 对象</li>
</ul>
<h3 id="1-forEach-函数"><a href="#1-forEach-函数" class="headerlink" title="1.forEach 函数"></a>1.forEach 函数</h3><p><strong>语法：</strong> <code>arr.forEach(callback(current [, index [, array]])[, context])</code></p>
<p><strong>方法功能：</strong>回调参数为：每一项、索引、原数组, 对数组的每个元素执行一次给定的函数。</p>
<p><strong>返回：</strong> undefined。</p>
<p>自定义函数：myForEach。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; element.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        callback.call(context, self[index], index, self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-filter-函数"><a href="#2-filter-函数" class="headerlink" title="2.filter 函数"></a>2.filter 函数</h3><p><strong>语法：</strong> <code>var newArray = arr.filter(callback(current[, index[, array]])[, context])</code></p>
<p><strong>方法功能：</strong> 创建一个新数组, 过滤掉回调函数返回值不为true的项,其包含通过所提供函数实现的测试的所有元素。</p>
<p><strong>返回：</strong> 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>
<p>自定义函数：myFilter。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>,</span><br><span class="line">        newArray = [];</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.call(context, self[index], index, self)) newArray.push(self[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-find-函数"><a href="#3-find-函数" class="headerlink" title="3.find 函数"></a>3.find 函数</h3><p><strong>语法：</strong><code>arr.find(callback[, context])</code></p>
<p><strong>方法功能：</strong> 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p>
<p><strong>返回：</strong> 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。</p>
<p>自定义函数：myFind。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFind = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.call(context, self[index], index, self)) &#123;</span><br><span class="line">            <span class="keyword">return</span> self[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-findIndex-函数"><a href="#4-findIndex-函数" class="headerlink" title="4.findIndex 函数"></a>4.findIndex 函数</h3><p><strong>语法：</strong> <code>arr.findIndex(callback[, context])</code></p>
<p><strong>方法功能：</strong> 返回数组中满足提供的测试函数的第一个元素的索引。否则返回 -1。</p>
<p><strong>返回：</strong> 数组中通过提供测试函数的第一个元素的索引。否则，返回-1。</p>
<p>自定义函数：myFindIndex。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFindIndex = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.call(context, self[index], index, self)) <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-fill函数"><a href="#5-fill函数" class="headerlink" title="5.fill函数"></a>5.fill函数</h3><p><strong>语法：</strong> <code>arr.fill(value[, start[, end]])</code></p>
<p><strong>方法功能：</strong> 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p>
<p><strong>返回：</strong> 返回替换的值，原数组发生改变。</p>
<p>自定义函数：myFill。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFill = <span class="function"><span class="keyword">function</span>(<span class="params">value, start = <span class="number">0</span>, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>;</span><br><span class="line">    end = end || len;</span><br><span class="line">    <span class="keyword">let</span> loopStart = start &lt; <span class="number">0</span> ? <span class="number">0</span> : start, <span class="comment">// 设置循环开始值</span></span><br><span class="line">        loopEnd = end &gt;= len ? len : end; <span class="comment">// 设置循环结束值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; loopStart &lt; loopEnd; loopStart++) &#123;</span><br><span class="line">        self[loopStart] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-map-函数"><a href="#6-map-函数" class="headerlink" title="6.map 函数"></a>6.map 函数</h3><p><strong>语法：</strong> <code>var newArray = arr.map(function callback(current[, index[, array]]) &#123;// Return self for newArray &#125;[, context])</code></p>
<p><strong>方法功能：</strong> 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
<p><strong>返回：</strong> 测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。 一个由原数组每个元素执行回调函数的结果组成的新数组。</p>
<p>自定义函数：myMap。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>,</span><br><span class="line">        result = [];</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        result[index] = callback.call(context, self[index], index, self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-some-函数"><a href="#7-some-函数" class="headerlink" title="7.some 函数"></a>7.some 函数</h3><p><strong>语法：</strong> <code>arr.some(callback(current[, index[, array]])[, context])</code></p>
<p><strong>方法功能：</strong> 测试数组中是不是至少有1个元素通过了被提供的函数测试,回调函数返回值一个为true 结果就为true, 否则为false。它返回的是一个Boolean类型的值。</p>
<p><strong>返回：</strong> 数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为false。</p>
<p>自定义函数：mySome。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.call(context, self[index], index, self)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-every-函数"><a href="#8-every-函数" class="headerlink" title="8.every 函数"></a>8.every 函数</h3><p><strong>语法：</strong> <code>arr.every(callback(current[, index[, array]])[, context])</code></p>
<p><strong>方法功能</strong>：测试一个数组内的所有元素是否都能通过某个指定函数的测试,所有回调函数返回值都为true时 结果为true,否则为false。它返回一个布尔值。</p>
<p><strong>返回：</strong> 如果回调函数的每一次返回都为 true 值，返回 true，否则返回 false。</p>
<p>自定义函数：myEvery。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myEvery = <span class="function"><span class="keyword">function</span>(<span class="params">callback, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self &amp;&amp; self.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!context) context = self;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callback.call(context, element[index], index, element)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-reduce-函数"><a href="#9-reduce-函数" class="headerlink" title="9.reduce 函数"></a>9.reduce 函数</h3><p><strong>语法：</strong><code>arr.reduce(callback(accumulator, current[, index[, array]])[, initialValue])</code></p>
<p><strong>方法功能：</strong>对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。相比其他方法多了一个参数即上次调用的返回值，<br>最后一个回调函数的返回值为reduce的结果，可以指定累积的初始值，不指定初始值从第二项开始遍历</p>
<p><strong>返回：</strong> 函数累计处理的结果。</p>
<p>自定义函数：myReduce。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> (<span class="string">&#x27;callback参数必须是函数&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>,</span><br><span class="line">        len = self.length || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = initialValue ? initialValue : self[<span class="number">0</span>]; <span class="comment">// 不传默认取数组第一项</span></span><br><span class="line">  	<span class="keyword">let</span> index = initialValue ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index <span class="keyword">in</span> self) result = callback(result, self[index], index, self);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用一些方法实现别的方法，如下面两个例子</p>
<h3 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">        	target.push(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="14-实现数组原地反转"><a href="#14-实现数组原地反转" class="headerlink" title="14.实现数组原地反转"></a>14.实现数组原地反转</h2><p>用了双指针，第三变量交换法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revert</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		<span class="keyword">let</span> temp = arr[start];</span><br><span class="line">		arr[start] = arr[end];</span><br><span class="line">		arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line">revert(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [0, 1, 25, 16, 9, 4]</span></span><br></pre></td></tr></table></figure>

<p>有什么别的方法。</p>
<p>解构赋值，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revert</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		[arr[start], arr[end]] = [arr[end], arr[start]];</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line">revert(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [0, 1, 25, 16, 9, 4]</span></span><br></pre></td></tr></table></figure>

<p>利用和或者位运算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revert</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		arr[start] += arr[end];</span><br><span class="line">        arr[end] = arr[start] - arr[end];</span><br><span class="line">        arr[start] = arr[start] - arr[end];</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line">revert(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// [0, 1, 25, 16, 9, 4]</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revert</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		arr[start] ^= arr[end];</span><br><span class="line">        arr[end] ^= arr[start];</span><br><span class="line">        arr[start] ^= arr[end];</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span><br><span class="line">revert(arr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>



<h2 id="15-reduce的应用汇总"><a href="#15-reduce的应用汇总" class="headerlink" title="15.reduce的应用汇总"></a>15.reduce的应用汇总</h2><p><strong>reduce语法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  total: 必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="comment">  currentValue： 必需。当前元素。</span></span><br><span class="line"><span class="comment">  currentIndex： 可选。当前元素的索引；                     </span></span><br><span class="line"><span class="comment">  arr： 可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="comment">  initialValue: 可选。传递给函数的初始值，相当于total的初始值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reduceRight()</code> ,该方法用法与<code>reduce()</code>其实是相同的，只是遍历的顺序相反，它是从数组的最后一项开始，向前遍历到第一项</p>
</blockquote>
<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><p>基础版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 69</span></span><br></pre></td></tr></table></figure>

<p>设定初始值求和</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">10</span>);  <span class="comment">// 以10为初始值求和</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 79</span></span><br></pre></td></tr></table></figure>

<p>对象数组求和</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [</span><br><span class="line">    &#123; <span class="attr">subject</span>: <span class="string">&#x27;math&#x27;</span>, <span class="attr">score</span>: <span class="number">88</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">subject</span>: <span class="string">&#x27;chinese&#x27;</span>, <span class="attr">score</span>: <span class="number">95</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">subject</span>: <span class="string">&#x27;english&#x27;</span>, <span class="attr">score</span>: <span class="number">80</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> sum1 = result.reduce(<span class="function">(<span class="params">accumulator, cur</span>) =&gt;</span> accumulator + cur.score, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(sum1); <span class="comment">// 263</span></span><br><span class="line"><span class="keyword">const</span> sum2 = result.reduce(<span class="function">(<span class="params">accumulator, cur</span>) =&gt;</span> accumulator + cur.score, -<span class="number">10</span>); <span class="comment">// 总分扣除10分</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2); <span class="comment">// 253</span></span><br></pre></td></tr></table></figure>

<h3 id="数组最大值"><a href="#数组最大值" class="headerlink" title="数组最大值"></a>数组最大值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">23</span>, <span class="number">123</span>, <span class="number">342</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> max = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre &gt; cur ? pre : cur, <span class="built_in">Number</span>.MIN_SAFE_INTEGER);</span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">// 342</span></span><br></pre></td></tr></table></figure>

<h3 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> streams = [&#123;<span class="attr">name</span>: <span class="string">&#x27;技术&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;设计&#x27;</span>, <span class="attr">id</span>: <span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> obj = streams.reduce(<span class="function">(<span class="params">accumulator, cur</span>) =&gt;</span> &#123;accumulator[cur.id] = cur; <span class="keyword">return</span> accumulator;&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>见<a href="#%E5%88%A9%E7%94%A8reduce%E5%87%BD%E6%95%B0%E8%BF%AD%E4%BB%A3(%E5%8E%9F%E5%9C%B0%E5%B1%95%E5%BC%80)">数组扁平化</a></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>实现的基本原理如下：</p>
<p>① 初始化一个空数组<br>② 将需要去重处理的数组中的第1项在初始化数组中查找，如果找不到（空数组中肯定找不到），就将该项添加到初始化数组中<br>③ 将需要去重处理的数组中的第2项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>④ ……<br>⑤ 将需要去重处理的数组中的第n项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>⑥ 将这个初始化数组返回</p>
<p>见<a href="#Array.reduce(">数组去重</a> 加 indexOf/includes)</p>
<h3 id="对象数组去重"><a href="#对象数组去重" class="headerlink" title="对象数组去重"></a>对象数组去重</h3><p>根据每个对象的某一个具体属性来进行去重,利用高阶函数 <code>reduce</code> 进行去重， 这里只需要注意<code>initialValue</code>得放一个空数组[]，不然没法<code>push</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resources = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;18&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;19&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;20&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;19&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;20&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;赵六&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedup</span> (<span class="params">data, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = res.map(<span class="function"><span class="params">item</span> =&gt;</span> item[key]);</span><br><span class="line">        <span class="comment">// 如果临时对象没有就把这个名字加进去，同时把当前的这个对象加入到res中</span></span><br><span class="line">        <span class="keyword">return</span> keys.includes(cur[key]) ? res : [...res, cur];</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dedup(resources, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0: &#123;name: &quot;张三&quot;, age: &quot;18&quot;&#125;</span></span><br><span class="line"><span class="comment">    1: &#123;name: &quot;李四&quot;, age: &quot;19&quot;&#125;</span></span><br><span class="line"><span class="comment">    2: &#123;name: &quot;王五&quot;, age: &quot;20&quot;&#125;</span></span><br><span class="line"><span class="comment">    3: &#123;name: &quot;赵六&quot;, age: &quot;21&quot;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="求字符串中字母出现的次数"><a href="#求字符串中字母出现的次数" class="headerlink" title="求字符串中字母出现的次数"></a>求字符串中字母出现的次数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = str.split(<span class="string">&#x27;&#x27;</span>).reduce(<span class="function">(<span class="params">count, next</span>) =&gt;</span> &#123;</span><br><span class="line">    count[next] ? count[next]++ : count[next] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;,&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -: 1</span></span><br><span class="line"><span class="comment">    a: 8</span></span><br><span class="line"><span class="comment">    c: 1</span></span><br><span class="line"><span class="comment">    d: 4</span></span><br><span class="line"><span class="comment">    e: 1</span></span><br><span class="line"><span class="comment">    f: 4</span></span><br><span class="line"><span class="comment">    g: 1</span></span><br><span class="line"><span class="comment">    h: 2</span></span><br><span class="line"><span class="comment">    i: 2</span></span><br><span class="line"><span class="comment">    j: 4</span></span><br><span class="line"><span class="comment">    k: 1</span></span><br><span class="line"><span class="comment">    l: 3</span></span><br><span class="line"><span class="comment">    m: 2</span></span><br><span class="line"><span class="comment">    n: 1</span></span><br><span class="line"><span class="comment">    q: 5</span></span><br><span class="line"><span class="comment">    r: 1</span></span><br><span class="line"><span class="comment">    s: 6</span></span><br><span class="line"><span class="comment">    u: 1</span></span><br><span class="line"><span class="comment">    w: 2</span></span><br><span class="line"><span class="comment">    x: 1</span></span><br><span class="line"><span class="comment">    z: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a>compose函数</h3><blockquote>
<p><code>redux compose</code> 源码实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> a(b(...arg)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">    <span class="built_in">console</span>.log, </span><br><span class="line">    partial(add, <span class="number">10</span>),</span><br><span class="line">    partialRight(pow, <span class="number">3</span>),</span><br><span class="line">    partial(multiply, <span class="number">5</span>)</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>

<p>或者使用reduceRight</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs.reduceRight(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> b(a(...arg)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">    <span class="built_in">console</span>.log, </span><br><span class="line">    partial(add, <span class="number">10</span>),</span><br><span class="line">    partialRight(pow, <span class="number">3</span>),</span><br><span class="line">    partial(multiply, <span class="number">5</span>)</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>

<p>更多写法请参考<a href="#20.%E6%89%8B%E5%86%99compose%E5%87%BD%E6%95%B0">手写compose函数</a></p>
<h3 id="实现多维数组的回溯"><a href="#实现多维数组的回溯" class="headerlink" title="实现多维数组的回溯"></a>实现多维数组的回溯</h3><p> 实现[[‘a’, ‘b’], [‘n’, ‘m’], [‘0’, ‘1’]] =&gt; [“an0”, “an1”, “am0”, “am1”, “bn0”, “bn1”, “bm0”, “bm1”]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> list = [];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prev.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; cur.length; j++) &#123;</span><br><span class="line">				list.push(prev[i] + cur[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(backtrack([[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;m&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]]));</span><br><span class="line"><span class="comment">// [&quot;an0&quot;, &quot;an1&quot;, &quot;am0&quot;, &quot;am1&quot;, &quot;bn0&quot;, &quot;bn1&quot;, &quot;bm0&quot;, &quot;bm1&quot;]</span></span><br></pre></td></tr></table></figure>

<p>不适用reduce也可以实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="string">&#x27;&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr1 = seq(arr1, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr2.length; j++) &#123;</span><br><span class="line">            list.push(arr1[i] + arr2[j]);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(backtrack([[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;m&#x27;</span>], [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]]));</span><br><span class="line"><span class="comment">// [&quot;an0&quot;, &quot;an1&quot;, &quot;am0&quot;, &quot;am1&quot;, &quot;bn0&quot;, &quot;bn1&quot;, &quot;bm0&quot;, &quot;bm1&quot;]</span></span><br></pre></td></tr></table></figure>



<h2 id="16-洗牌算法"><a href="#16-洗牌算法" class="headerlink" title="16.洗牌算法"></a>16.洗牌算法</h2><p>最简单的一种形式，遍历的时候进行交换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">        [array[i], array[random]] = [array[random], array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">100</span>), <span class="function">(<span class="params">item, index</span>) =&gt;</span> index);</span><br><span class="line">shuffle(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>公认成熟的洗牌算法(Fisher-Yates),简单的思路如下：</p>
<ul>
<li><ol>
<li>定义一个数组，以数组的最后一个元素为基准点。</li>
</ol>
</li>
<li><ol start="2">
<li>在数组开始位置到基准点之间随机取一个位置，将所取位置上的元素和基准点上的元素互换。</li>
</ol>
</li>
<li><ol start="3">
<li>基准点左移一位。</li>
</ol>
</li>
<li><ol start="4">
<li>重复2，3步骤，直到基准点为数组的开始位置。</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)); <span class="comment">// 生成起始位置到基准位置之间的随机位置，并将基准从结束位置不停左移。</span></span><br><span class="line">        <span class="comment">// es3实现</span></span><br><span class="line">        <span class="comment">// var newA = arr[i];</span></span><br><span class="line">        <span class="comment">// arr[i] = arr[random];</span></span><br><span class="line">        <span class="comment">// arr[random] = newA;</span></span><br><span class="line">        <span class="comment">// es6 实现</span></span><br><span class="line">        [arr[i], arr[random]] = [arr[random], arr[i]]; <span class="comment">// 本质为交换元素位置。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">100</span>), <span class="function">(<span class="params">item, index</span>) =&gt;</span> index);</span><br><span class="line">shuffle(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>更多方法请看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903778315943949">打造属于自己的underscore系列（六）- 洗牌算法</a></p>
<h2 id="17-对象扁平化"><a href="#17-对象扁平化" class="headerlink" title="17.对象扁平化"></a>17.对象扁平化</h2><p> 实现一个 objectFlat 函数，实现如下的转换功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">c</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    c: &#123; <span class="attr">e</span>: <span class="number">2</span>, <span class="attr">f</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    g: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 转换为</span></span><br><span class="line"><span class="keyword">let</span> objRes = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b[0]&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b[1]&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;b[2].c&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;c.e&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;c.f&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    g: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从结果入手，可以知道我们需要对象进行遍历，把里面的属性值依次输出，所以我们可以知道核心方法体就是：传入对象的 key 值和 value，对 value 再进行递归遍历。</p>
<p>我们知道 js 的数据类型可以基础数据类型和引用数据类型，对于题目而言，基础数据类型无需再进行深层次遍历，引用数据类型需要再次进行递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFlat</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">value, key = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断是基础数据类型还是引用数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 基础数据类型</span></span><br><span class="line">            <span class="keyword">if</span> (key) &#123;</span><br><span class="line">                res[key] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; <span class="comment">// 判断是数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                flat(value[i], key + <span class="string">`[<span class="subst">$&#123;i&#125;</span>]`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 判断是对象</span></span><br><span class="line">            <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(value);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                flat(value[item], key ? <span class="string">`<span class="subst">$&#123;key&#125;</span>.<span class="subst">$&#123;item&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 空对象</span></span><br><span class="line">            <span class="keyword">if</span> (!keys.length &amp;&amp; key) &#123;</span><br><span class="line">                res[key] = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flat(obj);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                c: <span class="number">1</span>,</span><br><span class="line">            	d: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        e: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    f: &#123;</span><br><span class="line">        g: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objectFlat(source));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a.b[0]: 1</span></span><br><span class="line"><span class="comment">    a.b[1]: 2</span></span><br><span class="line"><span class="comment">    a.b[2].c: 1</span></span><br><span class="line"><span class="comment">    a.b[2].d: 2</span></span><br><span class="line"><span class="comment">    a.e: 3</span></span><br><span class="line"><span class="comment">    f.g: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="18-手写偏函数"><a href="#18-手写偏函数" class="headerlink" title="18.手写偏函数"></a>18.手写偏函数</h2><p>一天在面试中，面试官给了我一道手写代码题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现函数 partialUsingArguments，调用之后满足如下条件：</span></span><br><span class="line"><span class="comment">    1、返回一个函数 result</span></span><br><span class="line"><span class="comment">    2、调用 result 之后，返回的结果与调用函数 fn 的结果一致</span></span><br><span class="line"><span class="comment">    3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p>我当时的第一版思路，将两个参数数组进行拼接，通过闭包返回结果，面试官提示如果参数为空，怎么办，我增加了args = args || [];这一句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialUsingArguments</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(args.concat(_args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试官说如果参数不是数组，是对象怎么办，提示ES6还有什么拼接方法，使用展开运算符</p>
<h3 id="偏函数ES6常规写法"><a href="#偏函数ES6常规写法" class="headerlink" title="偏函数ES6常规写法"></a>偏函数ES6常规写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialUsingArguments</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args, ..._args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我当场问面试官，是不是函数柯里化，其实这和柯里化一样，叫作偏函数，和函数柯里化一样，都属于函数式编程的范畴。</p>
<p>我面试的那个问题本质上就是partial偏函数，和柯里化有点类似，所以没见过的我当场做完之后问了一下是不是函数的柯里化，想想也知道不是，知识两者类似。</p>
<h3 id="偏函数ES6简化写法"><a href="#偏函数ES6简化写法" class="headerlink" title="偏函数ES6简化写法"></a>偏函数ES6简化写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> partialUsingArguments = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br></pre></td></tr></table></figure>



<h2 id="19-函数柯里化"><a href="#19-函数柯里化" class="headerlink" title="19.函数柯里化"></a>19.函数柯里化</h2><p>定义</p>
<p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术</p>
<p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p>
<h3 id="函数柯里化ES6常规写法"><a href="#函数柯里化ES6常规写法" class="headerlink" title="函数柯里化ES6常规写法"></a>函数柯里化ES6常规写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> len = fn.length;</span><br><span class="line">	<span class="keyword">if</span> (args.length &gt;= len) &#123;</span><br><span class="line">    	<span class="comment">// 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span></span><br><span class="line">    	<span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">// 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回curry函数</span></span><br><span class="line">		<span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, ...args, ..._args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">5</span>, <span class="number">6</span>)(<span class="number">7</span>)); <span class="comment">// 210</span></span><br></pre></td></tr></table></figure>

<p>经过一些简化的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">    	<span class="comment">// 判断当前函数传入的参数是否大于或等于fn需要参数的数量，如果是，直接执行fn</span></span><br><span class="line">    	<span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回curry函数</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span> curry(fn, ...args, ..._args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">5</span>, <span class="number">6</span>)(<span class="number">7</span>)); <span class="comment">// 210</span></span><br></pre></td></tr></table></figure>

<h3 id="函数柯里化ES6简化写法"><a href="#函数柯里化ES6简化写法" class="headerlink" title="函数柯里化ES6简化写法"></a>函数柯里化ES6简化写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span> (</span><br><span class="line">	args =&gt; args.length === fn.length ? fn(...args) : curry(fn, args)</span><br><span class="line">)([...arr, ..._args])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(multi(<span class="number">5</span>, <span class="number">6</span>)(<span class="number">7</span>)); <span class="comment">// 210</span></span><br></pre></td></tr></table></figure>



<h2 id="20-手写compose函数"><a href="#20-手写compose函数" class="headerlink" title="20.手写compose函数"></a>20.手写compose函数</h2><p>如果我们想，对一个值执行一系列操作，并打印出来，考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add10(pow3(double(<span class="number">2</span>)))); <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>

<p>备注：<code>partialRight</code>和<code>partial</code>见名知意，相当于是彼此的镜像函数。</p>
<blockquote>
<p>_.partialRight: This method is like _.partial except that partially applied arguments are appended to the arguments it receives.</p>
</blockquote>
<p>原文从lodash导入，我自己仿照partial重写了一版。无需否认，这段示例代码的确毫无意义。但是为了达成这一系列操作，我最终执行了这一长串嵌套了四层的函数调用：<code>console.log(add10(pow3(double(2))))</code>。（说实话，我的确觉得有点难以阅读了…），如果更长了，怎么办？可能有的同学会给出以下答案:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixed</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add10(pow3(double(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mixed(<span class="number">2</span>)); <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>

<p>的确，看似好了点，但是也只是将这个冗长的调用封装了一下而已。会不会有更好的做法？</p>
<h3 id="基于栈的compose函数"><a href="#基于栈的compose函数" class="headerlink" title="基于栈的compose函数"></a>基于栈的compose函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> funcs = [...args];</span><br><span class="line">        <span class="keyword">while</span>(funcs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = funcs.pop()(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line">compose(<span class="built_in">console</span>.log, add10, pow3, double)(<span class="number">2</span>) <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>

<p>欧耶！我们通过实现了一个简单的<code>compose</code>函数，然后发现调用的过程<code>compose(console.log, add10, pow3, double)(2)</code>竟然变得如此优雅！多个函数的调用从代码阅读上，多层嵌套被拍平变成了线性！（当然实际上本质上还是嵌套的函数调用的）。</p>
<h3 id="使用函数reduce的compose函数"><a href="#使用函数reduce的compose函数" class="headerlink" title="使用函数reduce的compose函数"></a>使用函数reduce的compose函数</h3><p>当然，关于<code>compose</code>的更加函数式的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">result</span> =&gt;</span> funcs</span><br><span class="line">        .reverse()</span><br><span class="line">        .reduce(<span class="function">(<span class="params">result, fn</span>) =&gt;</span> fn(result), result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line">compose(<span class="built_in">console</span>.log, add10, pow3, double)(<span class="number">2</span>) <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>

<p>那么有同学可能也发现了，上述<code>compose</code>之后的函数是只可以传递一个参数的。这无疑显得有点蠢？难道不可以优化实现支持多个参数么？</p>
<p>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function compose(...funcs) &#123;</span></span><br><span class="line"><span class="comment">    return funcs</span></span><br><span class="line"><span class="comment">        .reverse()</span></span><br><span class="line"><span class="comment">        .reduce((fn1, fn2) =&gt; (...args) =&gt; fn2(fn1(...args)));</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> funcs</span><br><span class="line">        .reduce(<span class="function">(<span class="params">fn1, fn2</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn1(fn2(...args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line">compose(<span class="built_in">console</span>.log, add10, pow3, double)(<span class="number">2</span>); <span class="comment">// 74</span></span><br></pre></td></tr></table></figure>

<p>细心观察，通过将参数传递进行懒执行，从而巧妙的完成了这个任务！示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> funcs</span><br><span class="line">        .reduce(<span class="function">(<span class="params">fn1, fn2</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn1(fn2(...args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">	<span class="built_in">console</span>.log, add10, pow3, multiply</span><br><span class="line">)(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>

<p>当然上述代码最终也可以这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> funcs</span><br><span class="line">        .reduce(<span class="function">(<span class="params">fn1, fn2</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fn1(fn2(...args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">    <span class="built_in">console</span>.log, </span><br><span class="line">    partial(add, <span class="number">10</span>),</span><br><span class="line">    partialRight(pow, <span class="number">3</span>),</span><br><span class="line">    partial(multiply, <span class="number">5</span>)</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>

<h3 id="使用递归来实现compose"><a href="#使用递归来实现compose" class="headerlink" title="使用递归来实现compose"></a>使用递归来实现compose</h3><p>递归版本的<code>compose</code>本质上更接近概念，但是可能也会让人难以理解。了解一下也不错~</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fn1, fn2, ...rest] = funcs.reverse();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">composed</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> fn2(fn1(...args));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rest.length === <span class="number">0</span>) <span class="keyword">return</span> composed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> compose(</span><br><span class="line">        ...rest.reverse(),</span><br><span class="line">        composed</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123; partial, partialRight &#125; from &#x27;lodash&#x27;;</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(...args, ..._args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">const</span> partialRight = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> <span class="function">(<span class="params">..._args</span>) =&gt;</span></span><br><span class="line">	fn(..._args, ...args);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add10 = partial(add, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> pow3 = partialRight(pow, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(</span><br><span class="line">	<span class="built_in">console</span>.log, add10, pow3, multiply</span><br><span class="line">)(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 1010</span></span><br></pre></td></tr></table></figure>



<h2 id="21-实现-5-add-3-minus-2-功能"><a href="#21-实现-5-add-3-minus-2-功能" class="headerlink" title="21.实现 (5).add(3).minus(2) 功能"></a>21.实现 (5).add(3).minus(2) 功能</h2><blockquote>
<p>例： 5 + 3 - 2，结果为 6</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOf() + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">5</span>).add(<span class="number">3</span>).minus(<span class="number">2</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>



<h2 id="22-实现一个-add-函数"><a href="#22-实现一个-add-函数" class="headerlink" title="22.实现一个 add 函数"></a>22.实现一个 add 函数</h2><p>满足以下功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>需要结合上述的偏函数和toString()方法实现功能,打印函数时会自动调用 <code>toString()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(...args, ..._args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>



<h2 id="23-计算两个数组的交集"><a href="#23-计算两个数组的交集" class="headerlink" title="23.计算两个数组的交集"></a>23.计算两个数组的交集</h2><blockquote>
<p>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。</p>
</blockquote>
<p>排序+双指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y);</span><br><span class="line">    nums2.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y);</span><br><span class="line">    <span class="keyword">const</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">let</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> intersection = [];</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">        <span class="keyword">const</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">        <span class="keyword">if</span> (num1 === num2) &#123;</span><br><span class="line">            intersection.push(num1);</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">            index1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"> <span class="keyword">const</span> b = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"> <span class="built_in">console</span>.log(union(a, b)); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>



<h2 id="24-手写对象深度比较"><a href="#24-手写对象深度比较" class="headerlink" title="24.手写对象深度比较"></a>24.手写对象深度比较</h2><blockquote>
<p>思路：深度比较两个对象，就是要深度比较对象的每一个元素。=&gt; 递归</p>
</blockquote>
<ul>
<li>递归退出条件：<ul>
<li>被比较的是两个值类型变量，直接用“===”判断</li>
<li>被比较的两个变量之一为null，直接判断另一个元素是否也为null</li>
</ul>
</li>
<li>提前结束递推：<ul>
<li>两个变量keys数量不同</li>
<li>传入的两个参数是同一个变量</li>
</ul>
</li>
<li>递推工作： 　- 深度比较每一个key</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">obj1, obj2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 其中一个为值类型或null</span></span><br><span class="line">	<span class="keyword">if</span> (!isObject(obj1) || !isObject(obj2)) <span class="keyword">return</span> obj1 === obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否两个对象是同一个变量</span></span><br><span class="line">    <span class="keyword">if</span>(obj1 === obj2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断keys数是否相等</span></span><br><span class="line">    <span class="keyword">const</span> obj1Keys = <span class="built_in">Object</span>.keys(obj1);</span><br><span class="line">    <span class="keyword">const</span> obj2Keys = <span class="built_in">Object</span>.keys(obj2);</span><br><span class="line">    <span class="keyword">if</span>(obj1Keys.length !== obj2Keys.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度比较每一个key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> obj1Keys)&#123;</span><br><span class="line">    	<span class="comment">// 递归查询</span></span><br><span class="line">    	<span class="keyword">if</span> (!isEqual(obj1[key], obj2[key])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="25-扁平数组转树状结构"><a href="#25-扁平数组转树状结构" class="headerlink" title="25.扁平数组转树状结构"></a>25.扁平数组转树状结构</h2><p>怎么进行格式转换，将data转换成result形式（手写代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">10</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&quot;一级菜单-1&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">20</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&quot;一级菜单-2&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">30</span>, <span class="attr">parentId</span>: <span class="number">20</span>, <span class="attr">text</span>: <span class="string">&quot;二级菜单-3&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">25</span>, <span class="attr">parentId</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;三级菜单-25&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">35</span>, <span class="attr">parentId</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;三级菜单-35&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">10</span>,</span><br><span class="line">    text: <span class="string">&#x27;一级菜单-1&#x27;</span>,</span><br><span class="line">    parentId: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">20</span>,</span><br><span class="line">    text: <span class="string">&#x27;一级菜单-2&#x27;</span>,</span><br><span class="line">    parentId: <span class="number">0</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">10</span>,</span><br><span class="line">        text: <span class="string">&#x27;一级菜单-3&#x27;</span>,</span><br><span class="line">        parentId: <span class="number">20</span>,</span><br><span class="line">        children: [...]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>一开始以为只有一层子节点，打算先把有子节点的放入，再遍历有父节点的，写了一半重新理了理思路，写了以下的代码，先根据id从小到大排序，反着遍历，将子节点塞进父节点的children数组中，这是面试当场写的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conver</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.parentId - b.parentId);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findParent(data[i], data[j])) &#123;</span><br><span class="line">                data.slice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findParent</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.parentId == b.id) &#123;</span><br><span class="line">            b.children = b.children || [];</span><br><span class="line">            b.child.push(&#123;...a&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码有小错，面试官放我过了，毕竟总算搞对了思路，将代码进行纠错和改进，能正常使用了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">10</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&quot;一级菜单-1&quot;</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">20</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&quot;一级菜单-2&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">30</span>, <span class="attr">parentId</span>: <span class="number">20</span>, <span class="attr">text</span>: <span class="string">&quot;二级菜单-3&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">25</span>, <span class="attr">parentId</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;三级菜单-25&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">35</span>, <span class="attr">parentId</span>: <span class="number">30</span>, <span class="attr">text</span>: <span class="string">&quot;三级菜单-35&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.parentId - b.parentId);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = data.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (data[i].parentId === <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (findParent(i, j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findParent</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[a].parentId == data[b].id) &#123;</span><br><span class="line">            data[b].children = data[b].children || [];</span><br><span class="line">            data[b].children.push(data.splice(a, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(convert(data));</span><br></pre></td></tr></table></figure>

<p>想要多转换方法，可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6918634850396307469">JS树形结构处理</a></p>
<h2 id="26-防抖-debounce"><a href="#26-防抖-debounce" class="headerlink" title="26.防抖(debounce)"></a>26.防抖(debounce)</h2><p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p>
<p>在前端开发中会遇到一些频繁的事件触发，比如：</p>
<ol>
<li>window 的 resize、scroll</li>
<li>mousedown、mousemove</li>
<li>keyup、keydown<br>……</li>
</ol>
<p>为此，我们举个示例代码来了解事件如何频繁的触发：</p>
<p>我们写个 <code>index.html</code> 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cmn-Hans&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge, chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>debounce<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        #container&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#444</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;debounce.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>debounce.js</code> 文件的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">container.onmousemove = getUserAction;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428112307.gif" alt="debounce"></p>
<p>从左边滑到右边就触发了 165 次 getUserAction 函数！</p>
<p>因为这个例子很简单，所以浏览器完全反应的过来，可是如果是复杂的回调函数或是 ajax 请求呢？假设 1 秒触发了 60 次，每个回调就必须在 1000 / 60 = 16.67ms 内完成，否则就会有卡顿出现。</p>
<p>为了解决这个问题，一般有两种解决方案：</p>
<ol>
<li>debounce 防抖</li>
<li>throttle 节流</li>
</ol>
<h3 id="防抖是什么"><a href="#防抖是什么" class="headerlink" title="防抖是什么"></a>防抖是什么</h3><p>今天重点讲讲防抖的实现。</p>
<p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!</p>
<p>防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：</p>
<blockquote>
<p>防抖，即<code>短时间内大量触发同一事件，只会执行一次函数</code>，实现原理为<code>设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作</code>，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。</p>
<p>不管事件触发频率多高，一定在事件触发<code>n</code>秒后才执行，如果你在一个事件触发的 <code>n</code> 秒内又触发了这个事件，就以新的事件的时间为准，<code>n</code>秒后才执行，总之，触发完事件 <code>n</code> 秒内不再触发事件，<code>n</code>秒后再执行。</p>
</blockquote>
<p><strong>适用场景：</strong></p>
<blockquote>
<p>按钮提交场景：防止多次提交按钮，只执行最后提交的一次 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</p>
</blockquote>
<h3 id="防抖代码（第一版）"><a href="#防抖代码（第一版）" class="headerlink" title="防抖代码（第一版）"></a>防抖代码（第一版）</h3><p>根据这段表述，我们可以写第一版的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要使用它，以最一开始的例子为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.onmousemove = debounce(getUserAction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>现在随你怎么移动，反正你移动完 1000ms 内不再触发，我才执行事件。看看使用效果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428111557.gif" alt="debounce 第一版"></p>
<p>顿时就从 165 次降低成了 1 次!</p>
<p>棒棒哒，我们接着完善它。</p>
<h3 id="this指向（第二版）"><a href="#this指向（第二版）" class="headerlink" title="this指向（第二版）"></a>this指向（第二版）</h3><p>如果我们在 <code>getUserAction</code> 函数中 <code>console.log(this)</code>，在不使用 <code>debounce</code> 函数的时候，<code>this</code> 的值为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是如果使用我们的 debounce 函数，this 就会指向 Window 对象！</p>
<p>所以我们需要将 this 指向正确的对象。</p>
<p>我们修改下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用箭头函数改变this指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 this 已经可以正确指向了。让我们看下个问题：</p>
<h3 id="event-对象（第三版，已经完成基本功能）"><a href="#event-对象（第三版，已经完成基本功能）" class="headerlink" title="event 对象（第三版，已经完成基本功能）"></a>event 对象（第三版，已经完成基本功能）</h3><p>JavaScript 在事件处理函数中会提供事件对象 event，我们修改下 getUserAction 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们不使用 debouce 函数，这里会打印 MouseEvent 对象，如图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428120949.png" alt="MouseEvent"></p>
<p>但是在我们实现的 debounce 函数中，却只会打印 undefined!</p>
<p>所以我们再修改一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">    <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">    <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们修复了两个小问题：</p>
<ol>
<li>this 指向</li>
<li>event 对象</li>
</ol>
<p>功能更丰富的防抖函数请参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903480239325191">JavaScript专题之跟着underscore学防抖</a></p>
<h2 id="27-节流-throttle"><a href="#27-节流-throttle" class="headerlink" title="27.节流(throttle)"></a>27.节流(throttle)</h2><h3 id="节流是什么"><a href="#节流是什么" class="headerlink" title="节流是什么"></a>节流是什么</h3><p>节流规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效</p>
<p>防抖是<code>延迟执行</code>，而节流是<code>间隔执行</code>，函数节流即<code>每隔一段时间就执行一次</code>，实现原理为<code>设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器</code>，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器。规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。<br>我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<p><strong>适用场景：</strong></p>
<blockquote>
<ul>
<li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</li>
<li>缩放场景：监控浏览器<code>resize</code></li>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
</ul>
</blockquote>
<h3 id="时间戳版代码"><a href="#时间戳版代码" class="headerlink" title="时间戳版代码"></a>时间戳版代码</h3><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<p>看了这个表述，是不是感觉已经可以写出代码了…… 让我们来写第一版的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">        <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用两个时间戳<code>prev旧时间戳</code>和<code>now新时间戳</code>，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p>
<p>例子依然是用讲 debounce 中的例子，如果你要使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.onmousemove = throttle(getUserAction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>效果演示如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428141501.gif" alt="使用时间戳"></p>
<p>我们可以看到：当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。</p>
<h3 id="定时器版代码"><a href="#定时器版代码" class="headerlink" title="定时器版代码"></a>定时器版代码</h3><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者采用箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法：定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(</span><br><span class="line">    throttle(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>),</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>为了让效果更加明显，我们设置 wait 的时间为 3s，效果演示如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210428144007.gif" alt="使用定时器"></p>
<p>我们可以看到：当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。</p>
<p>所以比较两个方法：</p>
<ol>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ol>
<p>功能更丰富的节流函数请参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903481761857543">JavaScript专题之跟着 underscore 学节流</a></p>
<h2 id="28-手写const"><a href="#28-手写const" class="headerlink" title="28.手写const"></a>28.手写const</h2><h3 id="在ES5环境下实现let"><a href="#在ES5环境下实现let" class="headerlink" title="在ES5环境下实现let"></a>在ES5环境下实现let</h3><blockquote>
<p>这个问题实质上是在回答<code>let</code>和<code>var</code>有什么区别，对于这个问题，我们可以直接查看<code>babel</code>转换前后的结果，看一下在循环中通过<code>let</code>定义的变量是如何解决变量提升的问题</p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210422113441.jpeg" alt="img"></p>
<p>babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数（闭包）来模拟块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(i)  <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);      <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>不过这个问题并没有结束，我们回到<code>var</code>和<code>let/const</code>的区别上：</p>
<ul>
<li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li>
<li><code>var</code>声明的变量存在变量提升，而<code>let</code>和<code>const</code>不会</li>
<li><code>let</code>和<code>const</code>声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</li>
<li>同一作用域下<code>let</code>和<code>const</code>不能声明同名变量，而<code>var</code>可以</li>
<li>暂时性死区，<code>let</code>和<code>const</code>声明的变量不能在声明前被使用</li>
</ul>
<p>babel的转化，其实只实现了第2、3、5点</p>
<h3 id="const的特点"><a href="#const的特点" class="headerlink" title="const的特点"></a>const的特点</h3><p>实现const的关键在于<code>Object.defineProperty()</code>这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。<code>Object.defineProperty()</code> 接收三个参数：</p>
<blockquote>
<p>Object.defineProperty(obj, prop, desc)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">obj</td>
<td align="center">要在其上定义属性的对象</td>
</tr>
<tr>
<td align="center">prop</td>
<td align="center">要定义或修改的属性的名称</td>
</tr>
<tr>
<td align="center">descriptor</td>
<td align="center">将被定义或修改的属性描述符</td>
</tr>
</tbody></table>
<p>除了以上参数，<code>Object.defineProperty()</code> 具有以下属性，下标进行了详细的属性参数配置的说明：</p>
<table>
<thead>
<tr>
<th align="center">属性描述符</th>
<th align="left">说明</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="left">该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">get</td>
<td align="left">一个给属性提供 getter 的方法，如果没有 getter 则为 undefined</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">set</td>
<td align="left">一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">writable</td>
<td align="left">当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">enumerable</td>
<td align="left">enumerable定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">configurable</td>
<td align="left">configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="在ES5环境下实现const"><a href="#在ES5环境下实现const" class="headerlink" title="在ES5环境下实现const"></a>在ES5环境下实现const</h3><p>由于ES5环境没有<code>block</code>的概念，所以是无法百分百实现<code>const</code>，只能是挂载到某个对象下，要么是全局的<code>window</code>，要么就是自定义一个<code>object</code>来当容器对于const不可修改的特性，我们通过设置writable属性来实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _const = <span class="function"><span class="keyword">function</span> <span class="title">__const</span> (<span class="params">data, value</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 把要定义的data挂载到window下，并赋值value</span></span><br><span class="line">	<span class="built_in">window</span>.data = value;</span><br><span class="line">	<span class="comment">// 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span></span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, data, &#123;</span><br><span class="line">		<span class="comment">// 不可枚举</span></span><br><span class="line">		enumerable: <span class="literal">false</span>,</span><br><span class="line">		<span class="comment">// 不可删除</span></span><br><span class="line">		configurable: <span class="literal">false</span>,</span><br><span class="line">		get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 返回值</span></span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;,</span><br><span class="line">		set: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (data !== value) &#123;</span><br><span class="line">				<span class="comment">// 当要对当前属性进行重新赋值时，则抛出错误！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Assignment to constant variable.&#x27;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// 定义a</span></span><br><span class="line">_const(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> <span class="built_in">window</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (item === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    	<span class="comment">// 因为不可枚举，所以不执行</span></span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="built_in">window</span>[item]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 定义obj</span></span><br><span class="line">_const(<span class="string">&#x27;obj&#x27;</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// 可以正常给obj的属性赋值</span></span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line">obj = &#123;&#125;; <span class="comment">// 无法赋值新对象 报错</span></span><br></pre></td></tr></table></figure>

<p>参考资料：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903848008482824">如何在 ES5 环境下实现一个const ？</a></p>
<h2 id="29-实现一个双向绑定"><a href="#29-实现一个双向绑定" class="headerlink" title="29.实现一个双向绑定"></a>29.实现一个双向绑定</h2><h3 id="defineProperty-版本"><a href="#defineProperty-版本" class="headerlink" title="defineProperty 版本"></a>defineProperty 版本</h3><p>利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">	text: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="comment">// 数据劫持 对象名称和属性名称</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">	enumerable: <span class="literal">true</span>,</span><br><span class="line">	configurable: <span class="literal">true</span>,</span><br><span class="line">	<span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">		input.value = value,</span><br><span class="line">		span.innerHTML = value;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	data.text = e.target.value;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="proxy-版本"><a href="#proxy-版本" class="headerlink" title="proxy 版本"></a>proxy 版本</h3><p>Object.defineProperty() 的问题主要有三个： </p>
<ul>
<li><p> 不能监听数组的变化 </p>
</li>
<li><p> 必须遍历对象的每个属性 </p>
</li>
<li><p>必须深层遍历嵌套的对象</p>
<p>Proxy 在 ES2015 规范中被正式加入，它有以下几个优势点 </p>
</li>
<li><p> 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题 </p>
</li>
<li><p> 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。 </p>
</li>
<li><p> Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 </p>
</li>
<li><p> Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法，可以享受新版本红利。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">	text: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input  = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> span  = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="comment">// 数据劫持 对象名称和文本名称</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">target, key, vlaue</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// target = 目标对象</span></span><br><span class="line">        <span class="comment">// prop = 设置的属性</span></span><br><span class="line">        <span class="comment">// value = 修改后的值</span></span><br><span class="line">		target[key] = value;</span><br><span class="line">		<span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">		input.value = value;</span><br><span class="line">		span.innerHTML = value;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 实现代理</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventLisener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	proxy.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="30-图片懒加载"><a href="#30-图片懒加载" class="headerlink" title="30.图片懒加载"></a>30.图片懒加载</h2><h3 id="监听scroll事件法"><a href="#监听scroll事件法" class="headerlink" title="监听scroll事件法"></a>监听scroll事件法</h3><p>图片，用一个其他属性存储真正的图片地址：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有img标签</span></span><br><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="comment">// 存储图片已经实现加载的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 页面载入完毕加载可是区域内的图片</span></span><br><span class="line">lazyload();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听页面滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>));</span><br><span class="line"><span class="comment">// 懒加载函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 可见区域高度</span></span><br><span class="line">    <span class="keyword">let</span> visualHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">	<span class="comment">// 滚动条距离顶部高度，注意要兼容IE浏览器</span></span><br><span class="line">    <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">    <span class="comment">// 从上一个没有加载完毕的img便利到最后的img</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; imgs.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 在视窗范围以内</span></span><br><span class="line">        <span class="keyword">if</span> (img[i].offsetTop &lt; visualHeight + scrollTop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&#x27;src&#x27;</span>) === <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将src替换为data-src</span></span><br><span class="line">                img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><blockquote>
<p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p>
</blockquote>
<p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有img标签</span></span><br><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断IntersectionObserver可用</span></span><br><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">    <span class="keyword">let</span> lazyloadObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> lazyImgObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 懒加载图片</span></span><br><span class="line">            <span class="keyword">let</span> lazyImg = entry.target;</span><br><span class="line">            <span class="comment">// 如果元素可见</span></span><br><span class="line">            <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyImg.getAttribute(<span class="string">&quot;src&quot;</span>) === <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">                    lazyImg.src = lazyImg.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 图片加载后即停止监听该元素</span></span><br><span class="line">                lazyImgObserver.unobserve(lazyImg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// observe遍历监听所有img节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">        lazyImgObserver.observe(imgs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="31-区间随机数生成器"><a href="#31-区间随机数生成器" class="headerlink" title="31.区间随机数生成器"></a>31.区间随机数生成器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (n - m)) + m;</span><br><span class="line">	<span class="comment">// return parseInt(Math.random() * (n - m)) + m;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(random(<span class="number">28</span>, <span class="number">45</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="32-打印菱形"><a href="#32-打印菱形" class="headerlink" title="32.打印菱形"></a>32.打印菱形</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printDiamond</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="built_in">document</span>.write(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">document</span>.write(<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="built_in">document</span>.write(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">document</span>.write(<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="33-手写parseInt"><a href="#33-手写parseInt" class="headerlink" title="33.手写parseInt"></a>33.手写parseInt</h2><p>一开始以为很简单，写着写着 发现好难，还是先写只带有数字、字母的，0x什么开头的我怕是头想秃了都不会</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">char</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= char &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="built_in">Number</span>(char);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= char &amp;&amp; char &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> char.charCodeAt() - <span class="string">&#x27;a&#x27;</span>.charCodeAt() + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= char &amp;&amp; char &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> char.charCodeAt() - <span class="string">&#x27;A&#x27;</span>.charCodeAt() + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_parseInt</span>(<span class="params">str, radix</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 字符串类型</span></span><br><span class="line">    <span class="keyword">let</span> strType = <span class="built_in">Object</span>.prototype.toString.call(str);</span><br><span class="line">    <span class="comment">// 如果类型不是 string 或 number 类型返回NaN</span></span><br><span class="line">    <span class="keyword">if</span> (strType !== <span class="string">&#x27;[object String]&#x27;</span> &amp;&amp; strType !== <span class="string">&#x27;[object Number]&#x27;</span>) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 radix 为0 null undefined</span></span><br><span class="line">    <span class="keyword">if</span> (!radix) &#123;</span><br><span class="line">        <span class="comment">// 则转化为 10</span></span><br><span class="line">        radix = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(radix) !== <span class="string">&#x27;[object Number]&#x27;</span> || radix &lt; <span class="number">2</span> || radix &gt; <span class="number">36</span> || <span class="built_in">Math</span>.floor(radix) &lt; radix)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则表达式，表示数</span></span><br><span class="line">    <span class="keyword">const</span> re = <span class="regexp">/^[\-|\+]?[0-9a-zA-Z]*(\.[0-9a-zA-Z]+)?/</span>;</span><br><span class="line">    <span class="comment">// 字符串处理，把小数点以后的去除</span></span><br><span class="line">    str = (str + <span class="string">&#x27;&#x27;</span>).trim().match(re)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!str.length) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    <span class="keyword">let</span> sign = <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="comment">// 处理特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        str = str.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        sign = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        str = str.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] === <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> num = getNum(str[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (num &lt; radix &amp;&amp; sign === <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; radix &amp;&amp; sign === <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> -<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把小数点后面的去除</span></span><br><span class="line">    str = str.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!str.length) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    <span class="keyword">let</span> res = getNum(str[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= radix) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = getNum(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= radix) <span class="keyword">return</span> sign === <span class="string">&#x27;+&#x27;</span> ? res : -res;</span><br><span class="line">        res = res * radix + num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign === <span class="string">&#x27;+&#x27;</span> ? res : -res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;F&quot;</span>, <span class="number">16</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;17&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;015&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="number">15.99</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;15,123&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;FXX123&quot;</span>, <span class="number">16</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;1111&quot;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;15 * 3&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;15e2&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;15px&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;12&quot;</span>, <span class="number">13</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-------------------------------&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;Hello&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;546&quot;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-------------------------------&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;-F&quot;</span>, <span class="number">16</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;-0F&quot;</span>, <span class="number">16</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(-<span class="number">15.1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot; -17&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot; -15&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;-1111&quot;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;-15e1&quot;</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(_parseInt(<span class="string">&quot;-12&quot;</span>, <span class="number">13</span>));</span><br></pre></td></tr></table></figure>

<p>大佬的版本，可以参考下，让我当场写肯定不会</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">str, radix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> code = str.toUpperCase().charCodeAt(<span class="number">0</span>),</span><br><span class="line">        num;</span><br><span class="line">    <span class="keyword">if</span> (radix &gt;= <span class="number">11</span> &amp;&amp; radix &lt;= <span class="number">36</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (code &gt;= <span class="number">65</span> &amp;&amp; code &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">            num = code - <span class="number">55</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = code - <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num = code - <span class="number">48</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHex</span>(<span class="params">first, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first === <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="number">1</span>].toUpperCase() === <span class="string">&#x27;X&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_parseInt</span>(<span class="params">str, radix</span>) </span>&#123;</span><br><span class="line">    str = <span class="built_in">String</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    str = str.trim();</span><br><span class="line">    <span class="keyword">let</span> first = str[<span class="number">0</span>],</span><br><span class="line">        sign;</span><br><span class="line">    <span class="comment">//处理第一个字符为 &#x27;-&#x27; || &#x27;+&#x27; 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (first === <span class="string">&#x27;-&#x27;</span> || first === <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        sign = str[<span class="number">0</span>];</span><br><span class="line">        str = str.slice(<span class="number">1</span>);</span><br><span class="line">        first = str[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当 radix 不存在或者小于 11 时，第一个字符只能为数字</span></span><br><span class="line">    <span class="keyword">if</span> (radix === <span class="literal">undefined</span> || radix &lt; <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(first)) <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/^(0+)/</span>;</span><br><span class="line">    <span class="comment">//截取 str 前面符合要求的一段，直到遇到非数字和非字母的字符</span></span><br><span class="line">    <span class="keyword">let</span> reg2 = <span class="regexp">/^[0-9a-z]+/i</span>;</span><br><span class="line">    str = str.match(reg2)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> len = str.length;</span><br><span class="line">    <span class="comment">//在没有第二个参数时或者不是数字时，给第二个参数赋值</span></span><br><span class="line">    <span class="comment">//isNaN(&#x27;0x12&#x27;) 会执行 Number(&#x27;0x12&#x27;) 可以转换成十进制</span></span><br><span class="line">    <span class="keyword">if</span> (radix === <span class="literal">undefined</span> || <span class="built_in">isNaN</span>(radix) || radix === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="comment">//如果 str 是十六进制形式，就转换成十进制</span></span><br><span class="line">        <span class="keyword">if</span> (isHex(first, str)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sign === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Number</span>(-str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不能直接返回 Number(str) 比如 Number(&#x27;0ff23&#x27;) 会返回 NaN，但是应该返回 0</span></span><br><span class="line">            radix = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果有第二个参数，并且是数字，要处理第二个参数</span></span><br><span class="line">        radix = <span class="built_in">String</span>(radix);</span><br><span class="line">        <span class="comment">//如果有小数点，取小数点前面一段，处理不为整数的情况</span></span><br><span class="line">        radix = radix.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//如果 radix 前面有零将零去除，十六进制除外</span></span><br><span class="line">        <span class="keyword">if</span> (radix.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> twoR = radix[<span class="number">1</span>].toUpperCase();</span><br><span class="line">            <span class="keyword">if</span> (radix[<span class="number">0</span>] === <span class="string">&#x27;0&#x27;</span> &amp;&amp; twoR !== <span class="string">&#x27;X&#x27;</span>) radix = radix.replace(reg, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 radix 是十六进制的字符串类型，也会转变成十进制的数字类型</span></span><br><span class="line">        radix = <span class="built_in">Number</span>(radix);</span><br><span class="line">        <span class="comment">//radix 是否在正确的区间</span></span><br><span class="line">        <span class="keyword">if</span> (radix &gt;= <span class="number">2</span> &amp;&amp; radix &lt;= <span class="number">36</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 radix 为 16，且 str 是十六进制形式的话，直接将十六进制转换成十进制</span></span><br><span class="line">            <span class="keyword">if</span> (radix === <span class="number">16</span> &amp;&amp; isHex(first, str)) <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只要 radix 是一个有效的数字，但不在正确的区间里，就返回 NaN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除 str 前面的零</span></span><br><span class="line">    str = str.replace(reg, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (str.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> strArr = str.split(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">        numArr = [],</span><br><span class="line">        result = <span class="number">0</span>,</span><br><span class="line">        num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</span><br><span class="line">        num = compare(strArr[i], radix);</span><br><span class="line">        <span class="keyword">if</span> (num &lt; radix) &#123;</span><br><span class="line">            numArr.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> lenN = numArr.length;</span><br><span class="line">    <span class="keyword">if</span> (lenN &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        numArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">            result += item * <span class="built_in">Math</span>.pow(radix, lenN - index - <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//str 开头有零的话要返回零</span></span><br><span class="line">        <span class="keyword">return</span> first === <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="literal">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign === <span class="string">&#x27;-&#x27;</span>) result = -result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="34-手写JSON-stringify"><a href="#34-手写JSON-stringify" class="headerlink" title="34.手写JSON.stringify"></a>34.手写JSON.stringify</h2><p>先熟悉JSON.stringify的用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])：</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Boolean | Number| String</code>类型会自动转换成对应的原始值。</li>
<li><code>undefined</code>、任意函数以及<code>symbol</code>，会被忽略（出现在非数组对象的属性值中时），或者被转换成 <code>null</code>（出现在数组中时）。</li>
<li>不可枚举的属性会被忽略如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li>
<li>如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略</li>
</ul>
<p>手写代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 不是字符串 undefined 和 function 类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">            obj = <span class="string">&#x27;&quot;&#x27;</span> + obj + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JSON为空数组</span></span><br><span class="line">    <span class="keyword">let</span> json = [];</span><br><span class="line">    <span class="comment">// 是否为数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">let</span> value = jsonStringify(obj[key]);</span><br><span class="line">        json.push((arr ? <span class="string">&quot;&quot;</span> : <span class="string">&#x27;&quot;&#x27;</span> + key + <span class="string">&#x27;&quot;:&#x27;</span>) + <span class="built_in">String</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonStringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;)); <span class="comment">// &#123;&quot;x&quot;:5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonStringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>])); <span class="comment">// [1,&quot;false&quot;,false]</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonStringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;)); <span class="comment">// &#123;&quot;b&quot;:&quot;undefined&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>手写了一下，是不是对于JSON.stringify的不足之处又有了全新的理解了呢，再次强调如下：</p>
<ul>
<li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。</li>
<li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li>
<li><code>undefined</code>、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如<code>JSON.stringify(function()&#123;&#125;)</code> or <code>JSON.stringify(undefined)</code>.</li>
<li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li>
<li>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们。</li>
<li>Date 日期调用了 toJSON() 将其转换为了 string 字符串（同Date.toISOString()），因此会被当做字符串处理。</li>
<li>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</li>
<li>其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。</li>
</ul>
<h2 id="35-手写JSON-parse"><a href="#35-手写JSON-parse" class="headerlink" title="35.手写JSON.parse"></a>35.手写JSON.parse</h2><p>先熟悉JSON.parse的用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(text[, reviver])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)</p>
</blockquote>
<h3 id="直接调用-eval"><a href="#直接调用-eval" class="headerlink" title="直接调用 eval"></a>直接调用 eval</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonParse</span>(<span class="params">opt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span> + opt + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jsonParse(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;))); <span class="comment">// [object Object]: &#123; x: 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonParse(<span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]))); <span class="comment">// [object Array]: [1, &quot;false&quot;, false]</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonParse(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;))); <span class="comment">// [object Object]: &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>避免在不必要的情况下使用 <code>eval</code>，<code>eval()</code> 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用<code>eval()</code>运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。它会执行JS代码，有XSS漏洞。</p>
</blockquote>
<p>如果你只想记这个方法，就得对参数json做校验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.test(</span><br><span class="line">        json</span><br><span class="line">            .replace(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .replace(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .replace(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用Function"><a href="#调用Function" class="headerlink" title="调用Function"></a>调用Function</h3><blockquote>
<p>核心：Function与eval有相同的字符串参数特性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(arg1, arg2, ..., functionBody);</span><br></pre></td></tr></table></figure>

<p>在转换JSON的实际应用中，只需要这么做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123; &quot;age&quot;: 20, &quot;name&quot;: &quot;jack&quot; &#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> json = (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>eval</code> 与 <code>Function</code>都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用</p>
</blockquote>
<p>测试结果如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonStr = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span> : <span class="number">5</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))()); <span class="comment">// [object Object]: &#123;x: 5&#125;</span></span><br><span class="line">jsonStr = <span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))()); <span class="comment">// [object Array]: [1, &quot;false&quot;, false]</span></span><br><span class="line">jsonStr = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">b</span>: <span class="literal">undefined</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;return &#x27;</span> + jsonStr))()); <span class="comment">// [object Object]: &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>eval</code> 与 <code>Function</code> 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。</p>
<p><strong>第三，第四种方法，涉及到繁琐的递归和状态机相关原理，具体可以看：<a target="_blank" rel="noopener" href="https://github.com/youngwind/blog/issues/115">JSON.parse 三种实现方式</a></strong></p>
<h2 id="36-解析-URL-Params-为对象"><a href="#36-解析-URL-Params-为对象" class="headerlink" title="36.解析 URL Params 为对象"></a>36.解析 URL Params 为对象</h2><p>尽可能的全面正确的解析一个任意 url 的所有参数为 Object，注意边界条件的处理<br>要求如下：<br>• 1. 重复出现的 key 要组装成数组<br>• 2. 能被转成数字的就转成数字类型<br>• 3. 中⽂需解码<br>• 4. 未指定值的 key 约定为 true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line">parseParam(url);</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">&#123; user: &#x27;anonymous&#x27;,</span></span><br><span class="line"><span class="comment">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  city: &#x27;北京&#x27;, // 中文需解码</span></span><br><span class="line"><span class="comment">  enabled: true, // 未指定值得 key 约定为 true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>具体实现代码思路如下，对url进行分割</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paramsArr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 分割 key 和 value</span></span><br><span class="line">        <span class="keyword">let</span> [key, value] = paramsArr[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="comment">// 处理没有值的参数，约定值为true</span></span><br><span class="line">        <span class="keyword">if</span> (!value) value = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 中文解码</span></span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(value);</span><br><span class="line">        <span class="comment">// 转为数字类型，必须放中文解码后面</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^\d+(\.\d+)?$/</span>.test(value)) value = <span class="built_in">Number</span>(value);</span><br><span class="line">        <span class="comment">// 处理重复出现的key，组装成数组</span></span><br><span class="line">        <span class="keyword">if</span> (paramsObj[key]) &#123;</span><br><span class="line">            <span class="comment">// 主要是在这里做了一下处理,判断值是不是一个数组</span></span><br><span class="line">            paramsObj[key] = <span class="built_in">Array</span>.isArray(paramsObj[key]) ? [...paramsObj[key], value] : [paramsObj[key], value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paramsObj[key] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(parseParam(url));</span><br></pre></td></tr></table></figure>

<p>也可以使用正则表达式分割，这是网上找的大佬版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParam</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"> 	<span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">    <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">    <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> paramsObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">    paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">     	<span class="comment">// 处理有 value 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">        	<span class="comment">// 分割 key 和 value</span></span><br><span class="line">        	<span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        	<span class="comment">// 递归调用解码</span></span><br><span class="line">        	val = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        	<span class="comment">// 判断是否转为数字</span></span><br><span class="line">        	val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val; </span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">            <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">            	paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">            	paramsObj[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">        	paramsObj[param] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> paramsObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(parseParam(url));</span><br></pre></td></tr></table></figure>



<h2 id="37-模板引擎实现"><a href="#37-模板引擎实现" class="headerlink" title="37.模板引擎实现"></a>37.模板引擎实现</h2><p>将对象data中的数据渲染至template模板中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    name: <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">render(template, data); <span class="comment">// 我是姓名，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>

<p>自己跟着大佬手写的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 模板字符串正则</span></span><br><span class="line">	<span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">	<span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">	<span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">		<span class="comment">// 查找当前模板里第一个模板字符串的字段，对应正则表达式()中的内容</span></span><br><span class="line">		<span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">		template = template.replace(reg, data[name]);</span><br><span class="line">		<span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    name: <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(render(template, data)); <span class="comment">// 我是姓名，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>

<p>递归改为迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 模板字符串正则</span></span><br><span class="line">	<span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>;</span><br><span class="line">	<span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">	<span class="keyword">while</span> (reg.test(template)) &#123;</span><br><span class="line">		<span class="comment">// 查找当前模板里第一个模板字符串的字段，对应正则表达式()中的内容</span></span><br><span class="line">		<span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">		template = template.replace(reg, data[name]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> template = <span class="string">&#x27;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    name: <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(render(template, data)); <span class="comment">// 我是姓名，年龄18，性别undefined</span></span><br></pre></td></tr></table></figure>

<p>这只是自行车级别的模板引擎，想要火箭级别的请参考underscore 提供的模板引擎功能，冴羽大大提供了一步一步实现改模板引擎的手把手教程<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/63">underscore 系列之实现一个模板引擎(上)</a>和<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/70">underscore 系列之实现一个模板引擎(下)</a></p>
<h2 id="38-驼峰命名-中划线转换"><a href="#38-驼峰命名-中划线转换" class="headerlink" title="38.驼峰命名-中划线转换"></a>38.驼峰命名-中划线转换</h2><h3 id="中划线转驼峰"><a href="#中划线转驼峰" class="headerlink" title="中划线转驼峰"></a>中划线转驼峰</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 首字母大写</span></span><br><span class="line">		<span class="keyword">return</span> v.slice(<span class="number">1</span>).toUpperCase();</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span>; <span class="comment">// 转化为 getElementById</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(s1));</span><br></pre></td></tr></table></figure>

<p>简化代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="params">v</span> =&gt;</span> v[<span class="number">1</span>].toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span>; <span class="comment">// 转化为 getElementById</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(s1));</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把-后面的字母替换为大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/-(\w)/g</span>, <span class="function">(<span class="params">v1, v2</span>) =&gt;</span> v2.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;get-element-by-id&quot;</span>; <span class="comment">// 转化为 getElementById</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(s1));</span><br></pre></td></tr></table></figure>

<h3 id="驼峰转中划线"><a href="#驼峰转中划线" class="headerlink" title="驼峰转中划线"></a>驼峰转中划线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把大写字母替换为-和小写字母</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.replace(<span class="regexp">/[A-Z]/g</span>, <span class="function"><span class="params">v</span> =&gt;</span> <span class="string">&#x27;-&#x27;</span> + v.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;getElementById&quot;</span>; <span class="comment">// 转化为 get-element-by-id</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(s2));</span><br></pre></td></tr></table></figure>

<h3 id="拓展到4种模式"><a href="#拓展到4种模式" class="headerlink" title="拓展到4种模式"></a>拓展到4种模式</h3><p>编程语言中常见的命名风格有如下四种：<br>1.全部首字母大写<br>2.第一个单词首字母小写，其余单词首字母大写<br>3.单词全部小写，由下划线连接<br>4.单词全部小写，由减号连接</p>
<p>请设计并实现一个caseTransform函数，使得一个字符串str可以被方便地转成四种形式，并且将四种形式通过空格拼接成一个字符串返回<br>为方便起见，这里假设输入字符串全部符合以上四种形式的英文字母组合</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PascalCaseTest</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PascalCaseTest  pascalCaseTest  pascal_case_test pascal-case-test</span><br></pre></td></tr></table></figure>

<p>判断是哪种模式，识别之后进行拼接操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caseTransform</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> list = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> (s.indexOf(<span class="string">&#x27;_&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 第3种情况</span></span><br><span class="line">		<span class="comment">// 自身</span></span><br><span class="line">		list[<span class="number">2</span>] = s;</span><br><span class="line">		<span class="comment">// 切割</span></span><br><span class="line">		<span class="keyword">let</span> arr = s.split(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第4种模式</span></span><br><span class="line">		list[<span class="number">3</span>] = arr.join(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第1种模式</span></span><br><span class="line">		list[<span class="number">0</span>] = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item[<span class="number">0</span>].toUpperCase() + item.slice(<span class="number">1</span>)).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第2种模式</span></span><br><span class="line">		list[<span class="number">1</span>] = list[<span class="number">0</span>][<span class="number">0</span>].toLowerCase() + list[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.indexOf(<span class="string">&#x27;-&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 第4种情况</span></span><br><span class="line">		<span class="comment">// 自身</span></span><br><span class="line">		list[<span class="number">3</span>] = s;</span><br><span class="line">		<span class="comment">// 切割</span></span><br><span class="line">		<span class="keyword">let</span> arr = s.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第3种模式</span></span><br><span class="line">		list[<span class="number">2</span>] = arr.join(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第1种模式</span></span><br><span class="line">		list[<span class="number">0</span>] = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item[<span class="number">0</span>].toUpperCase() + item.slice(<span class="number">1</span>)).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">		<span class="comment">// 第2种模式</span></span><br><span class="line">		list[<span class="number">1</span>] = list[<span class="number">0</span>][<span class="number">0</span>].toLowerCase() + list[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// 第1种情况</span></span><br><span class="line">		list[<span class="number">0</span>] = s;</span><br><span class="line">		<span class="comment">// 第2种模式</span></span><br><span class="line">		list[<span class="number">1</span>] = s[<span class="number">0</span>].toLowerCase() + s.slice(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 第3种模式</span></span><br><span class="line">		list[<span class="number">2</span>] = list[<span class="number">1</span>].replace(<span class="regexp">/[A-Z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;_&#x27;</span> + x[<span class="number">0</span>].toLowerCase();</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 第4种模式</span></span><br><span class="line">		list[<span class="number">3</span>] = list[<span class="number">2</span>].replace(<span class="regexp">/_/g</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 第2种模式</span></span><br><span class="line">		list[<span class="number">1</span>] = s;</span><br><span class="line">		<span class="comment">// 第1种模式</span></span><br><span class="line">		list[<span class="number">0</span>] = s[<span class="number">0</span>].toUpperCase() + s.slice(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 第3种模式</span></span><br><span class="line">		list[<span class="number">2</span>] = s.replace(<span class="regexp">/[A-Z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;_&#x27;</span> + x[<span class="number">0</span>].toLowerCase();</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 第4种模式</span></span><br><span class="line">		list[<span class="number">3</span>] = list[<span class="number">2</span>].replace(<span class="regexp">/_/g</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;PascalCaseTest&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(caseTransform(str).join(<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>



<h2 id="39-查找字符串中出现最多的字符和个数"><a href="#39-查找字符串中出现最多的字符和个数" class="headerlink" title="39.查找字符串中出现最多的字符和个数"></a>39.查找字符串中出现最多的字符和个数</h2><h3 id="排序-正则统计单个字符个数"><a href="#排序-正则统计单个字符个数" class="headerlink" title="排序+正则统计单个字符个数"></a>排序+正则统计单个字符个数</h3><p>1.使其按照⼀定的次序对数据进行排列</p>
<p>2.利用正则匹配数据</p>
<p>​    反向引用</p>
<p>​        ()相关匹配会被存储到一个临时缓冲区,所捕获的每个子匹配都会按照正则模式中从左到右</p>
<p>​        出现的顺序存储.缓冲区编号从1开始,最多99个捕获的子表达式,</p>
<p>​        每个缓冲区都可用\n表示,其中 n 为一个标识特定缓冲区的一位或两位十进制数。如:</p>
<p>​            \1 指定第一个子匹配项,指定正则表达式的第二部分是对前面捕获的子匹配项的引用</p>
<p>​            即第二个匹配项正好由括号表达式匹配.</p>
<p>3.利用replace的参数特性,得到最多字符及个数<br>  replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<p>语法:</p>
<p>​    stringObject.replace(regexp/substr,replacement)</p>
<p>参数:</p>
<p>​    regexp/substr: 规定子字符串或要替换的模式的 RegExp 对象</p>
<p>​    replacement: 规定了替换文本或生成替换文本的函数。</p>
<p>​        可以是字符串，也可以是函数</p>
<p>​        字符串: 每个匹配都由字符串替换 </p>
<p>​        函数:</p>
<p>​            参数特性: </p>
<p>​                第一个参数:匹配模式的字符串</p>
<p>​                其他参数:模式中的子表达式匹配的字符串,可以有0或多个</p>
<p>​                下一个参数:整数,声明匹配在stringObject 中出现的位置</p>
<p>​                最后一个参数: stringObject本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;aaabbbbbcccccccc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义正则表达式</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(\w)\1+/g</span>;</span><br><span class="line">str.replace(re, <span class="function">(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; $<span class="number">0.</span>length) &#123;</span><br><span class="line">		<span class="comment">// num始终储存次数最大的那个</span></span><br><span class="line">		num = $<span class="number">0.</span>length;</span><br><span class="line">		char = $<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num === $<span class="number">0.</span>length)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(char)) &#123;</span><br><span class="line">			char.push($<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			char = [char, $<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br><span class="line"><span class="comment">// 字符最多的是c，出现了8次</span></span><br></pre></td></tr></table></figure>

<h3 id="哈希表统计单个字符个数"><a href="#哈希表统计单个字符个数" class="headerlink" title="哈希表统计单个字符个数"></a>哈希表统计单个字符个数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcabcabcbbccccc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> char = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 使其按照一定的次序排列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> char = str[i];</span><br><span class="line">    <span class="keyword">if</span> (obj[char]) &#123;</span><br><span class="line">        <span class="comment">// 次数加1</span></span><br><span class="line">        obj[char]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//若第一次出现，次数记为1</span></span><br><span class="line">        obj[char] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出的是完整的对象，记录着每一个字符及其出现的次数</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a: 3</span></span><br><span class="line"><span class="comment">    b: 5</span></span><br><span class="line"><span class="comment">    c: 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; obj[key]) &#123;</span><br><span class="line">		num = obj[key];</span><br><span class="line">		char = key;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num === obj[key])&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(char)) &#123;</span><br><span class="line">			char.push(key);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			char = [char, key];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    a: 3</span></span><br><span class="line"><span class="comment">    b: 5</span></span><br><span class="line"><span class="comment">    c: 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`字符最多的是<span class="subst">$&#123;char&#125;</span>，出现了<span class="subst">$&#123;num&#125;</span>次`</span>);</span><br></pre></td></tr></table></figure>



<h2 id="40-字符串查找"><a href="#40-字符串查找" class="headerlink" title="40.字符串查找"></a>40.字符串查找</h2><blockquote>
<p>请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。</p>
</blockquote>
<h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><p><strong>思路及算法</strong></p>
<p>我们可以让字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次。</p>
<p>为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 -1。</p>
<p><strong>时间复杂度</strong>：$O(n×m)$，其中 n 是字符串 haystack 的长度，m 是字符串 needle 的长度。最坏情况下我们需要将字符串 needle 与字符串haystack 的所有长度为 m 的子串均匹配一次。</p>
<p><strong>空间复杂度</strong>：$O(1)$。我们只需要常数的空间保存若干变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m =  haystack.length;</span><br><span class="line">    <span class="keyword">let</span> n = needle.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] !== haystack[i + j]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// needle子串全都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (j === n) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// haystack中不存在needle</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。</p>
<p>上述的朴素解法，不考虑剪枝的话复杂度是 $O(m∗n)$ 的，而 KMP 算法的复杂度为 $O(m+n)$。</p>
<p>KMP 之所以能够在$O(m+n)$ 复杂度内完成查找，是因为其能在「非完全匹配」的过程中提取到有效信息进行复用，以减少「重复匹配」的消耗。</p>
<ol>
<li>匹配过程<br>在模拟 KMP 匹配过程之前，我们先建立两个概念：</li>
</ol>
<p>前缀：对于字符串 abcxxxxefg，我们称 abc 属于 abcxxxxefg 的某个前缀。<br>后缀：对于字符串 abcxxxxefg，我们称 efg 属于 abcxxxxefg 的某个后缀。<br>然后我们假设原串为 abeababeabf，匹配串为 abeabf：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430220903.png" alt="img"><br>我们可以先看看如果不使用 KMP，会如何进行匹配（不使用 substring 函数的情况下）。</p>
<p>首先在「原串」和「匹配串」分别各自有一个指针指向当前匹配的位置。</p>
<p>首次匹配的「发起点」是第一个字符 a。显然，后面的 abeab 都是匹配的，两个指针会同时往右移动（黑标）。</p>
<p>在都能匹配上 abeab 的部分，「朴素匹配」和「KMP」并无不同。</p>
<p>直到出现第一个不同的位置（红标）：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221006.png" alt="img"></p>
<p>接下来，正是「朴素匹配」和「KMP」出现不同的地方：</p>
<p>先看下「朴素匹配」逻辑：</p>
<ol>
<li><p>将原串的指针移动至本次「发起点」的下一个位置（b 字符处）；匹配串的指针移动至起始位置。</p>
</li>
<li><p>尝试匹配，发现对不上，原串的指针会一直往后移动，直到能够与匹配串对上位置。</p>
</li>
</ol>
<p>如图：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221056.png" alt="image.png"></p>
<p>也就是说，对于「朴素匹配」而言，一旦匹配失败，将会将原串指针调整至下一个「发起点」，匹配串的指针调整至起始位置，然后重新尝试匹配。</p>
<p>这也就不难理解为什么「朴素匹配」的复杂度是O(m∗n) 了。</p>
<p>然后我们再看看「KMP 匹配」过程：<br>首先匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221448.jpeg" alt="img"></p>
<p>跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221558.png" alt="img"></p>
<p>到这里，你应该清楚 KMP 为什么相比于朴素解法更快：</p>
<p>因为 KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。</p>
<p>因为 KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）。</p>
<p>第一点很直观，也很好理解。</p>
<p>我们可以把重点放在第二点上，原串不回溯至「发起点」意味着什么？</p>
<p>其实是意味着：随着匹配过程的进行，原串指针的不断右移，我们本质上是在不断地在否决一些「不可能」的方案。</p>
<p>当我们的原串指针从 i 位置后移到 j 位置，不仅仅代表着「原串」下标范围为 [i,j)[i,j) 的字符与「匹配串」匹配或者不匹配，更是在否决那些以「原串」下标范围为 [i,j)[i,j) 为「匹配发起点」的子集。</p>
<ol start="2">
<li>分析实现</li>
</ol>
<p>到这里，就结束了吗？要开始动手实现上述匹配过程了吗？</p>
<p>我们可以先分析一下复杂度。如果严格按照上述解法的话，最坏情况下我们需要扫描整个原串，复杂度为 $O(n)$。同时在每一次匹配失败时，去检查已匹配部分的相同「前缀」和「后缀」，跳转到相应的位置，如果不匹配则再检查前面部分是否有相同「前缀」和「后缀」，再跳转到相应的位置 … 这部分的复杂度是 $O(m^2)$ ，因此整体的复杂度是 $O(n * m^2)$，而我们的朴素解法是 $O(m * n)$ 的。</p>
<p>说明还有一些性质我们没有利用到。</p>
<p>显然，扫描完整原串操作这一操作是不可避免的，我们可以优化的只能是「检查已匹配部分的相同前缀和后缀」这一过程。</p>
<p>再进一步，我们检查「前缀」和「后缀」的目的其实是「为了确定匹配串中的下一段开始匹配的位置」。</p>
<p>同时我们发现，对于匹配串的任意一个位置而言，由该位置发起的下一个匹配点位置其实与原串无关。</p>
<p>举个例子，对于匹配串 abcabd 的字符 d 而言，由它发起的下一个匹配点跳转必然是字符 c 的位置。因为字符 d 位置的相同「前缀」和「后缀」字符 ab 的下一位置就是字符 c。</p>
<p>可见从匹配串某个位置跳转下一个匹配位置这一过程是与原串无关的，我们将这一过程称为找 next 点。</p>
<p>显然我们可以预处理出 next 数组，数组中每个位置的值就是该下标应该跳转的目标位置（next 点）。</p>
<p>当我们进行了这一步优化之后，复杂度是多少呢？</p>
<p>预处理 next 数组的复杂度未知，匹配过程最多扫描完整个原串，复杂度为$O(n)$。</p>
<p>因此如果我们希望整个 KMP 过程是 $O(m+n)$ 的话，那么我们需要在 $O(m)$ 的复杂度内预处理出 next数组。</p>
<p>所以我们的重点在于如何在 $O(m)$ 复杂度内处理处 next 数组。</p>
<ol start="3">
<li>next 数组的构建<br>接下来，我们看看 next 数组是如何在 $O(m)$的复杂度内被预处理出来的。</li>
</ol>
<p>假设有匹配串 aaabbab，我们来看看对应的 next 是如何被构建出来的。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221727.png" alt="img"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221743.png" alt="img"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221800.png" alt="img"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210430221911.png" alt="img"></p>
<p>这就是整个 <code>next</code> 数组的构建过程，时空复杂度均为 $O(m)$。</p>
<p>至此整个 KMP 匹配过程复杂度是 $O(m+n)$ 的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function"><span class="keyword">function</span>(<span class="params">haystack, needle</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// next数组当前位指针，原串和匹配串的长度</span></span><br><span class="line">    <span class="keyword">let</span> k = -<span class="number">1</span>, n = haystack.length, p = needle.length;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// -1表示不存在相同的最大前缀和后缀</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="built_in">Array</span>(p).fill(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算next数组</span></span><br><span class="line">    calNext(needle, next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; -<span class="number">1</span> &amp;&amp; needle[k + <span class="number">1</span>] !== haystack[i]) &#123;</span><br><span class="line">            <span class="comment">// 有部分匹配，往前回溯</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[k + <span class="number">1</span>] === haystack[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k === p - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明k移动到needle的最末端，返回相应的位置</span></span><br><span class="line">            <span class="keyword">return</span> i - p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅函数- 计算next数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calNext</span>(<span class="params">needle, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造过程 j = 1，p = -1 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>, p = -<span class="number">1</span>; j &lt; needle.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; -<span class="number">1</span> &amp;&amp; needle[p + <span class="number">1</span>] !== needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needle[p + <span class="number">1</span>] === needle[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果下一位相同，更新相同的最大前缀和最大后缀长</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 位置j处更新最长前缀</span></span><br><span class="line">        next[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>马拉车水平不够，看都没看懂，就不写了。</p>
<h2 id="41-实现千位分隔符"><a href="#41-实现千位分隔符" class="headerlink" title="41.实现千位分隔符"></a>41.实现千位分隔符</h2><h3 id="反转整数部分"><a href="#反转整数部分" class="headerlink" title="反转整数部分"></a>反转整数部分</h3><p>实现思路是将数字转换为字符数组，再循环整个数组， 每三位添加一个分隔逗号，最后再合并成字符串。因为分隔符在顺序上是从后往前添加的：比如 1234567添加后是1,234,567 而不是 123,456,7 ，所以方便起见可以先把数组倒序，添加完之后再倒序回来，就是正常的顺序了。要注意的是如果数字带小数的话，要把小数部分分开处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numFormat</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 按小数点分割</span></span><br><span class="line">    num = <span class="built_in">Number</span>(num).toString().split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 将整数部分转换成字符数组并且倒序排列</span></span><br><span class="line">    <span class="keyword">let</span> arr = num[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">    <span class="comment">// 存放添加&#x27;,&#x27;的整数</span></span><br><span class="line">    <span class="keyword">let</span> res = [arr[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 添加分隔符</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> === <span class="number">0</span>) res.push(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次将整数部分倒序成为正确的顺序，并拼接成字符串</span></span><br><span class="line">    res = res.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果有小数的话添加小数部分</span></span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">1</span>]) &#123;</span><br><span class="line">        res += <span class="string">&#x27;.&#x27;</span> + num[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">673439.4542</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numFormat(a)); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(numFormat(b)); <span class="comment">// &quot;673,439.4542&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="自带函数toLocaleSting"><a href="#自带函数toLocaleSting" class="headerlink" title="自带函数toLocaleSting"></a>自带函数toLocaleSting</h3><p>使用JS自带的函数 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString">toLocaleString</a></p>
<blockquote>
<p>语法：  <code>numObj.toLocaleString([locales [, options]])</code></p>
</blockquote>
<p><code>toLocaleString()</code> 方法返回这个数字在特定语言环境下的表示字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">673439.4542</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString()); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toLocaleString()); <span class="comment">// &quot;673,439.454&quot;  （小数部分四舍五入了）</span></span><br></pre></td></tr></table></figure>

<p>要注意的是这个函数在没有指定区域的基本使用时，返回使用默认的语言环境和默认选项格式化的字符串，所以不同地区数字格式可能会有一定的差异。最好确保使用 locales 参数指定了使用的语言。<br> 注：我测试的环境下小数部分会根据四舍五入只留下三位。</p>
<h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">replace</a>函数，相对前两种我更喜欢这种方法，虽然正则有点难以理解。</p>
<blockquote>
<p>replace 语法：<code>str.replace(regexp|substr, newSubStr|function)</code></p>
</blockquote>
<p>其中第一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp">RegExp</a> 对象或者其字面量所匹配的内容会被第二个参数的返回值替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numFormat</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = num.toString().replace(<span class="regexp">/\d+/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 先提取整数部分</span></span><br><span class="line">        <span class="comment">// console.log(n);</span></span><br><span class="line">        <span class="keyword">return</span> n.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 正向搜索后面有3个倍数的数字</span></span><br><span class="line">            <span class="comment">// console.log($1);</span></span><br><span class="line">            <span class="keyword">return</span> $<span class="number">1</span> + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">673439.4542</span>;</span><br><span class="line"><span class="built_in">console</span>.log(numFormat(a)); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(numFormat(b)); <span class="comment">// &quot;673,439.4542&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="42-正则表达式的基本运用"><a href="#42-正则表达式的基本运用" class="headerlink" title="42.正则表达式的基本运用"></a>42.正则表达式的基本运用</h2><h3 id="判断是否是电话号码"><a href="#判断是否是电话号码" class="headerlink" title="判断是否是电话号码"></a>判断是否是电话号码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPhone</span>(<span class="params">tel</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> regx = <span class="regexp">/^1[345789]\d&#123;9&#125;$/</span>;</span><br><span class="line">	<span class="keyword">return</span> regx.test(tel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证是否是邮箱"><a href="#验证是否是邮箱" class="headerlink" title="验证是否是邮箱"></a>验证是否是邮箱</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> regx = <span class="regexp">/^([a-zA-Z0-9_\-]+@([a-zA-Z0-9_\-]+\.)+([a-zA-Z]+)$/</span>;</span><br><span class="line">    <span class="keyword">return</span> regx.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证是否是身份证"><a href="#验证是否是身份证" class="headerlink" title="验证是否是身份证"></a>验证是否是身份证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isCardNo</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 15位身份证，18位身份，</span></span><br><span class="line">    <span class="keyword">let</span> regx = <span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;</span><br><span class="line">    <span class="keyword">return</span> regx.test(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="43-手写trim"><a href="#43-手写trim" class="headerlink" title="43.手写trim"></a>43.手写trim</h2><p>记住空格的转义符是\s</p>
<h3 id="字符串拆分数组"><a href="#字符串拆分数组" class="headerlink" title="字符串拆分数组"></a>字符串拆分数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">this</span>.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    i = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        arr.pop();</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;   ab cdd  &#x27;</span>.myTrim());</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式-2"><a href="#正则表达式-2" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\s+$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;   ab cdd  &#x27;</span>.myTrim());</span><br></pre></td></tr></table></figure>

<p>可以利用g后缀合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;   ab cdd  &#x27;</span>.myTrim());</span><br></pre></td></tr></table></figure>

<p>上述方法假设至少存在一个空白符，因此效率较低，效率较高的写法如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s\s*/</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\s\s*$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;   ab cdd  &#x27;</span>.myTrim());</span><br></pre></td></tr></table></figure>

<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>普通的原生字符串截取方法是远胜于正则替换，虽然是复杂一点。但只要正则不过于复杂，我们就可以利用浏览器对正则的优化，改善程序执行效率。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 优化正则替换前面的空格</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">this</span>.replace(<span class="regexp">/^\s\s*/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> ws = <span class="regexp">/\s/</span>;</span><br><span class="line">    <span class="comment">// 从后向前查找末尾空格</span></span><br><span class="line">    <span class="keyword">let</span> i = str.length;</span><br><span class="line">    <span class="comment">// while循环字符串charAt查找效率比较高</span></span><br><span class="line">    <span class="keyword">while</span> (ws.test(str.charAt(--i)));</span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;   ab cdd  &#x27;</span>.myTrim());</span><br></pre></td></tr></table></figure>

<p>更多方法及效率分析请参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rubylouvre/archive/2009/09/18/1568794.html">JavaScript trim函数大赏</a></p>
<h2 id="44-版本号比较"><a href="#44-版本号比较" class="headerlink" title="44.版本号比较"></a>44.版本号比较</h2><p>将输入字符串数组，按照版本号排序，</p>
<p>例如：<br>输入：var versions=[‘1.45.0’,’1.5’,’6’,’3.3.3.3.3.3.3’]<br>输出：var sorted=[‘1.5’,’1.45.0’,’3.3.3.3.3.3’,’6’]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个版本的大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareVersion</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 先判断2个版本号是否是字符串</span></span><br><span class="line">	<span class="keyword">if</span> (!version1 || !version2 || <span class="built_in">Object</span>.prototype.toString.call(version1) !== <span class="string">&#x27;[object String]&#x27;</span>|| <span class="built_in">Object</span>.prototype.toString.call(version2) !== <span class="string">&#x27;[object String]&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Version is null!&quot;</span>);</span><br><span class="line">	<span class="comment">// 按.将2个version进行分割</span></span><br><span class="line">	<span class="keyword">let</span> arr1 = version1.trim().split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	<span class="keyword">let</span> arr2 = version2.trim().split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 长度</span></span><br><span class="line">	<span class="keyword">const</span> len = <span class="built_in">Math</span>.min(arr1.length, arr2.length);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Number</span>(arr1[i]) &lt; <span class="built_in">Number</span>(arr2[i])) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>(arr1[i]) &gt; <span class="built_in">Number</span>(arr2[i])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> versions = [<span class="string">&#x27;1.45.0&#x27;</span>, <span class="string">&#x27;1.5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3.3.3.3.3.3.3&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(versions.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> compareVersion(a, b)));</span><br></pre></td></tr></table></figure>



<h2 id="45-手写Object-freeze"><a href="#45-手写Object-freeze" class="headerlink" title="45.手写Object.freeze"></a>45.手写Object.freeze</h2><p><strong>Object.freeze()功能介绍</strong></p>
<blockquote>
<p><code>Object.freeze</code>冻结一个对象，让其不能再添加/删除属性，也不能修改该对象已有属性的可枚举性、可配置可写性，也不能修改已有属性的值和它的原型属性，最后返回一个和传入参数相同的对象</p>
</blockquote>
<p>需要用到**<code>Object.seal()</code>**，该方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeze</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断参数是否为Object类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="comment">// 封闭对象</span></span><br><span class="line">        <span class="built_in">Object</span>.seal(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 设置只读</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">                writable: <span class="literal">false</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 如果属性值依然为对象，要通过递归来进行进一步的冻结</span></span><br><span class="line">            <span class="keyword">if</span> (isObject(obj[key])) freeze(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="46-实现ES6的extends"><a href="#46-实现ES6的extends" class="headerlink" title="46.实现ES6的extends"></a>46.实现ES6的extends</h2><p><strong>Object.setPrototypeOf():</strong></p>
<p>该方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>obj：要设置原型对象的对象。</p>
<p>proto：该对象的新原型对象或null，否则抛出TypeError异常。</p>
<p>返回值</p>
<p>设置了新的原型对象的对象。</p>
<p><strong>Object.getPrototypeOf():</strong></p>
<p>该方法用于获取指定对象的原型对象。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>obj：要获取原型对象的对象。</p>
<p>返回值</p>
<p>返回指定对象的原型对象或null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1.将A的原型指向B</span></span><br><span class="line">	<span class="built_in">Object</span>.setPrototypeOf(A, B);</span><br><span class="line">	<span class="comment">// 2.用A的实例作为this调用B,得到继承B之后的实例，这一步相当于调用super</span></span><br><span class="line">	<span class="built_in">Object</span>.getPrototypeOf(A).call(<span class="built_in">this</span>, name);</span><br><span class="line">	<span class="comment">// 3.将A原有的属性添加到新实例上</span></span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="comment">// 4.返回新实例对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(<span class="string">&#x27;poetry&#x27;</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    age: 22</span></span><br><span class="line"><span class="comment">    name: &quot;poetry&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="47-手写实现Set"><a href="#47-手写实现Set" class="headerlink" title="47.手写实现Set"></a>47.手写实现Set</h2><p>Set是ES6提供给我们的构造函数，能够造出一种新的存储数据的结构，只有属性值，成员值唯一（不重复）。手写全部方法有点难，只有部分常用的add、has、delete一定要写出来,引用类型测试错误，估计也不会挖那么深</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">iterator = []</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 判断构造的初始数据是否是可迭代对象</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> iterator[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`你提供的<span class="subst">$&#123;iterator&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存储数据</span></span><br><span class="line">		<span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">		<span class="comment">// 长度;</span></span><br><span class="line">		<span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 循环可迭代对象，将结果加入到MySet中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">			<span class="built_in">this</span>.add(item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在MySet对象尾部添加一个元素。返回该MySet对象。</span></span><br><span class="line">	<span class="function"><span class="title">add</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.has(data)) &#123;</span><br><span class="line">			<span class="built_in">this</span>.items[data] = data;</span><br><span class="line">			<span class="built_in">this</span>.size++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个布尔值，表示该值在MySet中存在与否</span></span><br><span class="line">	<span class="function"><span class="title">has</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除MySet中与这个值相等的元素</span></span><br><span class="line">	<span class="function"><span class="title">delete</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.has(data)) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">this</span>.items[data];</span><br><span class="line">			<span class="built_in">this</span>.size--;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 移除MySet对象内的所有元素。</span></span><br><span class="line">	<span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">		<span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个新的迭代器对象，该对象包含MySet对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">	<span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> keys = [];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">				keys.push(key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> keys;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个新的迭代器对象，该对象包含MySet对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">	<span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> values = [];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">				values.push(<span class="built_in">this</span>.items[key]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> values;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个新的迭代器对象，该对象包含MySet对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</span></span><br><span class="line">	<span class="function"><span class="title">entries</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> entries = [];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">				entries.push([key, <span class="built_in">this</span>.items[key]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> entries;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历，返回一个新的迭代器对象，该对象包含MySet对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照插入顺序，为MySet对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</span></span><br><span class="line">    <span class="function"><span class="title">forEach</span>(<span class="params">callBackFn, thisArgs = <span class="built_in">this</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            callBackFn.call(thisArgs, item, item, <span class="built_in">this</span>.items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> MySet();</span><br><span class="line"></span><br><span class="line">mySet.add(<span class="number">1</span>); <span class="comment">// Set [ 1 ]</span></span><br><span class="line">mySet.add(<span class="number">5</span>); <span class="comment">// Set [ 1, 5 ]</span></span><br><span class="line">mySet.add(<span class="number">5</span>); <span class="comment">// Set [ 1, 5 ]</span></span><br><span class="line">mySet.add(<span class="string">&quot;some text&quot;</span>); <span class="comment">// Set [ 1, 5, &quot;some text&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet);</span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">mySet.add(o);</span><br><span class="line"><span class="built_in">console</span>.log(mySet);</span><br><span class="line"></span><br><span class="line">mySet.add(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;); <span class="comment">// o 指向的是不同的对象，所以没问题</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="number">5</span>));              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="built_in">Math</span>.sqrt(<span class="number">25</span>)));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="string">&quot;Some Text&quot;</span>.toLowerCase())); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(o)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySet.size); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySet.delete(<span class="number">5</span>));  <span class="comment">// true,  从set中移除5</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="number">5</span>));     <span class="comment">// false, 5已经被移除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySet.size); <span class="comment">// 4, 刚刚移除一个值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySet);</span><br><span class="line"><span class="comment">// logs Set(4) &#123; 1, &quot;some text&quot;, &#123;…&#125;, &#123;…&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>还可以尝试着<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C">实现基本集合操作</a>或者<a target="_blank" rel="noopener" href="https://blog.csdn.net/tian_123456789/article/details/89400461">js模拟实现一个Set集合</a>，实现两个集合的并集、交集、差集和子集。</p>
<p>请教了大佬实现size私有化，避免手动修改size</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SIZE = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>[SIZE] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用Proxy实现</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210502151428.png"></p>
<p>大佬的实用改进版</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210502151527.png" alt="image-20210502151520837"></p>
<h2 id="48-手写实现Map"><a href="#48-手写实现Map" class="headerlink" title="48.手写实现Map"></a>48.手写实现Map</h2><p>map也是ES6提供给我们的构造函数，能够造出一种新的存储数据的结构。本质上是键值对的集合。key对应value，key和value唯一，任何值都可以当属性。自己的手写版问题和Set类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">iterator = []</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断构造的初始数据是否是可迭代对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> iterator[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`你提供的<span class="subst">$&#123;iterator&#125;</span>不是一个可迭代的对象`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 长度;</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环可迭代对象，将结果加入到MySet中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">            <span class="comment">// item也是一个可迭代的对象</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> item[<span class="built_in">Symbol</span>.iterator] !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`你提供的<span class="subst">$&#123;item&#125;</span>不是一个可迭代的对象`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> iterator = item[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">            <span class="keyword">const</span> key = iterator.next().value;</span><br><span class="line">            <span class="keyword">const</span> value = iterator.next().value;</span><br><span class="line">            <span class="built_in">this</span>.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置MyMap对象中键的值。返回该MyMap对象。</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.items[key] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个布尔值，表示MyMap实例是否包含键对应的值</span></span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.hasOwnProperty(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回键对应的值，如果不存在，则返回undefined。</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.items[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果MyMap对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</span></span><br><span class="line">    <span class="function"><span class="title">delete</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.items[key];</span><br><span class="line">            <span class="built_in">this</span>.size--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除MyMap对象内的所有元素。</span></span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个新的迭代器对象，该对象包含MyMap对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">    <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> keys = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">                keys.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个新的迭代器对象，该对象包含MyMap对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">    <span class="function"><span class="title">values</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">                values.push(<span class="built_in">this</span>.items[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</span></span><br><span class="line">    <span class="function"><span class="title">entries</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> entries = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.items.hasOwnProperty(key)) &#123;</span><br><span class="line">                entries.push([key, <span class="built_in">this</span>.items[key]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历，返回一个新的迭代器对象，该对象包含MyMap对象中的按插入顺序排列的所有元素的值。</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> [<span class="built_in">this</span>.items[key], key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照插入顺序，为MyMap对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</span></span><br><span class="line">    <span class="function"><span class="title">forEach</span>(<span class="params">callBackFn, thisArgs = <span class="built_in">this</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            callBackFn.call(thisArgs, <span class="built_in">this</span>.items[key], key, <span class="built_in">this</span>.items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> MyMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> keyFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> keyString = <span class="string">&#x27;a string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键</span></span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line">myMap.set(keyObj, <span class="string">&quot;和键keyObj关联的值&quot;</span>);</span><br><span class="line">myMap.set(keyFunc, <span class="string">&quot;和键keyFunc关联的值&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myMap);</span><br><span class="line"><span class="built_in">console</span>.log(myMap.size); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取值</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(keyString));    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(keyObj));       <span class="comment">// &quot;和键keyObj关联的值&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(keyFunc));      <span class="comment">// &quot;和键keyFunc关联的值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(<span class="string">&#x27;a string&#x27;</span>));   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">                         <span class="comment">// 因为keyString === &#x27;a string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(&#123;&#125;));           <span class="comment">// undefined, 因为keyObj !== &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined, 因为keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了上述问题，还有最重要的一个问题，Map 和 Object 是有区别，虽然两者都是键/值对的对象 ；</p>
<p>ES6中Map相对于Object对象有几个区别：</p>
<p>​    1：Object对象有原型， 也就是说他有默认的key值在对象上面， 除非我们使用Object.create(null)创建一个没有原型的对象；<br>　2：在Object对象中， 只能把String和Symbol作为key值， 但是在Map中，key值可以是任何基本类型(String, Number, Boolean, undefined, NaN….)，或者对象(Map, Set, Object, Function , Symbol , null….);<br>　3：通过Map中的size属性， 可以很方便地获取到Map长度， 要获取Object的长度， 你只能用别的方法了；<br>​    Map实例对象的key值可以为一个数组或者一个对象，或者一个函数，比较随意 ，而且Map对象实例中数据的排序是根据用户push的顺序进行排序的， 而Object实例中key,value的顺序就是有些规律了， (他们会先排数字开头的key值，然后才是字符串开头的key值)；</p>
<h2 id="49-检测对象循环引用"><a href="#49-检测对象循环引用" class="headerlink" title="49.检测对象循环引用"></a>49.检测对象循环引用</h2><p>检测对象自身是否循环引用，其实改进后的深拷贝已经囊括了这一检查方案</p>
<p>为此，WeakSet非常适合处理这种情况使用WeakSet简化，注意需要在第一次运行时创建<code>WeakSet</code>，并将其与每个后续函数调用一起传递（使用内部参数_refs）。 WeakSet只能存放对象，且对象的数量或它们的遍历顺序无关紧要，因此，WeakSet比<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>更适合（和执行）跟踪对象引用，尤其是在涉及大量对象时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对传入的obj对象 检查有无循环引用情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execRecursively</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存储前层级对象</span></span><br><span class="line">    <span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dp</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保证当前的元素是对象，若已经存在循环，也直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || flag) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 存储当前层对象</span></span><br><span class="line">        <span class="keyword">let</span> cws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ws.has(obj)) ws.add(obj);</span><br><span class="line">        <span class="comment">// 一次遍历检查当前层是否有相同元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果同层级的引用相同，把它删除</span></span><br><span class="line">                <span class="keyword">if</span> (cws.has(obj[key])) &#123;</span><br><span class="line">                    <span class="comment">// 找到循环引用</span></span><br><span class="line">                    <span class="keyword">delete</span> obj[key];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cws.add(obj[key]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二次遍历检查当前层是否存在循环引用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ws.has(obj[key])) &#123;</span><br><span class="line">                    <span class="comment">// 找到循环引用</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ws.add(obj[key]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 递归检查有无循环使用</span></span><br><span class="line">                dp(obj[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(obj);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="string">&quot;1&quot;</span> &#125;;</span><br><span class="line">obj1.b = &#123;&#125;;</span><br><span class="line">obj1.b.a = obj1.b;</span><br><span class="line">obj1.b.b = obj1.b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">a</span>: &#123; <span class="attr">c</span>: <span class="string">&quot;1&quot;</span> &#125; &#125;;</span><br><span class="line">obj2.a.b = obj2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">4</span> &#125;, <span class="attr">d</span>: &#123;&#125;, <span class="attr">e</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123; <span class="attr">a</span>: <span class="string">&quot;1&quot;</span> &#125;;</span><br><span class="line">obj4.b = &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj4.aa = obj4.b;</span><br><span class="line">obj4.bb = obj4.b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj5 = &#123; <span class="attr">a</span>: <span class="string">&quot;1&quot;</span> &#125;;</span><br><span class="line">obj5.b = &#123;&#125;;</span><br><span class="line">obj5.b.a = obj5.b;</span><br><span class="line">obj5.b.b = obj5.b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj6 = &#123; <span class="attr">a</span>: &#123;<span class="attr">c</span>: <span class="string">&quot;1&quot;</span>&#125; &#125;;</span><br><span class="line">obj6.b = &#123;&#125;;</span><br><span class="line">obj6.b.d = obj6.a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj3)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj4)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj5)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(execRecursively(obj6)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>第6个case目前正在思考算不算循环引用。</p>
<h2 id="50-单例模式"><a href="#50-单例模式" class="headerlink" title="50.单例模式"></a>50.单例模式</h2><p>在合适的时候才创建对象，并且只创建唯一的一个。在单例模式下创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>
<p>使用闭包实现单例模式，我写的这个又被称为懒汉式单例模式，没有一开始就对这个类进行实例化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 实例对象</span></span><br><span class="line">	<span class="keyword">let</span> instance;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton (name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">&#x27;ConardLi2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h2 id="51-观察者模式"><a href="#51-观察者模式" class="headerlink" title="51.观察者模式"></a>51.观察者模式</h2><p>首先想分析一下观察者模式和发布/订阅模式的异同</p>
<h3 id="观察者模式与发布-订阅模式区别"><a href="#观察者模式与发布-订阅模式区别" class="headerlink" title="观察者模式与发布/订阅模式区别"></a>观察者模式与发布/订阅模式区别</h3><p>在翻阅资料的时候，有人把观察者（Observer）模式等同于发布（Publish）/订阅（Subscribe）模式，也有人认为这两种模式还是存在差异，而我认为确实是存在差异的，本质上的区别是调度的地方不同。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。</p>
<p>比如有个“天气中心”的具体目标A，专门监听天气变化，而有个显示天气的界面的观察者B，B就把自己注册到A里，当A触发天气变化，就调度B的更新方法，并带上自己的上下文。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503155419.png" alt="img"></p>
<h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p>
<p>比如有个界面是实时显示天气，它就订阅天气事件（注册到调度中心，包括处理程序），当天气变化时（定时获取数据），就作为发布者发布天气信息到调度中心，调度中心就调度订阅者的天气处理程序。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503160337.png" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    1.从两张图片可以看到，最大的区别是调度的地方。</p>
<p>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。</p>
<p>​    2.两种模式都可以用于松散耦合，改进代码管理和潜在的复用。</p>
<h3 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h3><p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503171033.webp" alt="img"></p>
<p>观察者模式的优点</p>
<ul>
<li>可以广泛应用于异步编程，它可以代替我们传统的回调函数</li>
<li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li>
<li>角色很明确，没有事件调度中心作为中间者一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。目标对象<code>Subject</code>和观察者<code>Observer</code>都要实现约定的成员方法。</li>
<li>双方联系紧密，目标对象的主动性很强，自己收集和维护观察者，并在状态变化时主动通知观察者更新。虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</li>
</ul>
<p>订阅者的能力非常简单，作为被动的一方，它的行为只有两个——被通知、去执行（本质上是接受发布者的调用，这步我们在发布者中已经做掉了）。</p>
<p>发布者的基本操作首先是增加订阅者，然后是通知订阅者，最后是移除订阅者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>cb 回调函数，收到目标对象通知时执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    		<span class="built_in">this</span>.cb = cb;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Observer构造器必须传入函数类型！&#x27;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被目标对象通知时执行回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.cb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象，发布者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 维护观察者列表</span></span><br><span class="line">		<span class="built_in">this</span>.observers = [];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加一个观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Observer&#125;</span> </span>observer Observer实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除一个观察者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Observer&#125;</span> </span>observer Observer实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.observers.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="keyword">if</span> (item === observer) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.observers.splice(i, <span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通知所有的观察者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    		observer.update();</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observerCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我被通知了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> Observer(observerCallback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line">subject.add(observer);</span><br><span class="line">subject.notify(); <span class="comment">// 我被通知了</span></span><br></pre></td></tr></table></figure>

<h3 id="手写Vue-Reactive"><a href="#手写Vue-Reactive" class="headerlink" title="手写Vue Reactive"></a>手写Vue Reactive</h3><h4 id="Vue数据双向绑定（响应式系统）的实现原理"><a href="#Vue数据双向绑定（响应式系统）的实现原理" class="headerlink" title="Vue数据双向绑定（响应式系统）的实现原理"></a>Vue数据双向绑定（响应式系统）的实现原理</h4><p>Vue 框架是热门的渐进式 JavaScript框架。在 Vue 中，当我们修改状态时，视图会随之更新，这就是Vue的数据双向绑定（又称响应式原理）。数据双向绑定是Vue 最独特的特性之一。如果读者没有接触过 Vue，强烈建议阅读<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue官方对响应式原理的介绍 (opens new window)</a>。此处我们用官方的一张流程图来简要地说明一下Vue响应式系统的整个流程：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503194414.png" alt="img"></p>
<p>在 <code>Vue</code> 中，每个组件实例都有相应的 <code>watcher</code> 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。这道面试题考察了受试者对Vue底层原理的理解、对观察者模式的实现能力以及一系列重要的JS知识点，具有较强的综合性和代表性。</p>
<p><strong>在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：</strong></p>
<ul>
<li><code>observer</code>（监听器）：注意，此 <code>observer</code> 非彼 <code>observer</code>。在我们上面的解析中，<code>observer</code> 作为设计模式中的一个角色，代表“订阅者”。但在<code>Vue</code>数据双向绑定的角色结构里，所谓的 <code>observer</code> 不仅是一个数据监听器，它还需要对监听到的数据进行<strong>转发</strong>——也就是说它<strong>同时还是一个发布者</strong>。</li>
<li><code>watcher</code>（订阅者）：<code>observer</code> 把数据转发给了<strong>真正的订阅者</strong>——<code>watcher</code>对象。<code>watcher</code> 接收到新的数据后，会去更新视图。</li>
<li><code>compile</code>（编译器）：<code>MVVM</code> 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~</li>
</ul>
<p>这三者的配合过程如图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503210054.png" alt="img"></p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><blockquote>
<p>下面实现订阅者 <code>Dep</code>：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义订阅者类Dep</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用栈存储目标对象</span></span><br><span class="line">	<span class="keyword">static</span> stack = [];</span><br><span class="line">	<span class="comment">// 订阅者目标对象</span></span><br><span class="line">	<span class="keyword">static</span> target = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 订阅任务</span></span><br><span class="line">	deps = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化订阅任务集合</span></span><br><span class="line">        <span class="built_in">this</span>.deps = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加观察者</span></span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 存在目标对象，添加到订阅任务集合</span></span><br><span class="line">    	<span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    		<span class="built_in">this</span>.deps.add(Dep.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.deps.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象入栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">pushTarget</span>(<span class="params">t</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.target) &#123;</span><br><span class="line">        	<span class="built_in">this</span>.stack.push(<span class="built_in">this</span>.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">this</span>.target = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象出栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">popTarget</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.target = <span class="built_in">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面实现观察者 <code>Watcher</code>：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义观察者类Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建过程</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    	<span class="comment">// 执行一次回调函数</span></span><br><span class="line">    	<span class="built_in">this</span>.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被目标对象通知时执行回调函数</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 实例入栈</span></span><br><span class="line">    	Dep.pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    	<span class="comment">// 回调函数的值</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="built_in">this</span>.cb();</span><br><span class="line">    	Dep.popTarget();</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现reactive方法</strong></p>
<blockquote>
<p>首先我们需要实现一个方法，这个方法会对需要监听的数据对象进行遍历、给它的属性加上定制的 <code>getter</code> 和 <code>setter</code> 函数。这样但凡这个对象的某个属性发生了改变，就会触发 <code>setter</code> 函数，进而通知到订阅者。这个 <code>setter</code> 函数，就是我们的监听器：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive方法遍历并包装对象属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 若obj是一个对象，则遍历它</span></span><br><span class="line">	<span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// defineReactive方法会给目标属性装上“监听器”</span></span><br><span class="line">			defineReactive(obj, key, obj[key]);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义defineReactive方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个订阅者</span></span><br><span class="line">	<span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">	<span class="comment">// 为当前属性安装监听器，劫持其属性</span></span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(obj, key, &#123; </span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        	<span class="comment">// 订阅者更新</span></span><br><span class="line">        	dep.depend();</span><br><span class="line">        	<span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        	<span class="comment">// 更新值</span></span><br><span class="line">        	value = newValue;</span><br><span class="line">        	<span class="comment">// 通知所有观察者</span></span><br><span class="line">        	dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 递归深度包装obj</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    	reactive(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上诉三段代码整合进行测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义订阅者类Dep</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用栈存储目标对象</span></span><br><span class="line">	<span class="keyword">static</span> stack = [];</span><br><span class="line">	<span class="comment">// 订阅者目标对象</span></span><br><span class="line">	<span class="keyword">static</span> target = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 订阅任务</span></span><br><span class="line">	deps = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化订阅任务集合</span></span><br><span class="line">        <span class="built_in">this</span>.deps = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加观察者</span></span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 存在目标对象，添加到订阅任务集合</span></span><br><span class="line">    	<span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    		<span class="built_in">this</span>.deps.add(Dep.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.deps.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象入栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">pushTarget</span>(<span class="params">t</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.target) &#123;</span><br><span class="line">        	<span class="built_in">this</span>.stack.push(<span class="built_in">this</span>.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">this</span>.target = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象出栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">popTarget</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.target = <span class="built_in">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义观察者类Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建过程</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    	<span class="comment">// 执行一次回调函数</span></span><br><span class="line">    	<span class="built_in">this</span>.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被目标对象通知时执行回调函数</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 实例入栈</span></span><br><span class="line">    	Dep.pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    	<span class="comment">// 回调函数的值</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="built_in">this</span>.cb();</span><br><span class="line">    	Dep.popTarget();</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive方法遍历并包装对象属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 若obj是一个对象，则遍历它</span></span><br><span class="line">	<span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// defineReactive方法会给目标属性装上“监听器”</span></span><br><span class="line">			defineReactive(obj, key, obj[key]);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义defineReactive方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个订阅者</span></span><br><span class="line">	<span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">	<span class="comment">// 为当前属性安装监听器，劫持其属性</span></span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(obj, key, &#123; </span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        	<span class="comment">// 订阅者更新</span></span><br><span class="line">        	dep.depend();</span><br><span class="line">        	<span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">        	<span class="comment">// 更新值</span></span><br><span class="line">        	value = newValue;</span><br><span class="line">        	<span class="comment">// 通知所有观察者</span></span><br><span class="line">        	dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 递归深度包装obj</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    	reactive(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">	msg: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Watcher(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;执行：&#x27;</span>, data.msg);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	data.msg = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>改用proxy，优势是不用遍历每个属性，需要深层遍历了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义订阅者类Dep</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用栈存储目标对象</span></span><br><span class="line">	<span class="keyword">static</span> stack = [];</span><br><span class="line">	<span class="comment">// 订阅者目标对象</span></span><br><span class="line">	<span class="keyword">static</span> target = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 订阅任务</span></span><br><span class="line">	deps = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化订阅任务集合</span></span><br><span class="line">        <span class="built_in">this</span>.deps = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加观察者</span></span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 存在目标对象，添加到订阅任务集合</span></span><br><span class="line">    	<span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    		<span class="built_in">this</span>.deps.add(Dep.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.deps.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象入栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">pushTarget</span>(<span class="params">t</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.target) &#123;</span><br><span class="line">        	<span class="built_in">this</span>.stack.push(<span class="built_in">this</span>.target);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">this</span>.target = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标对象出栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">popTarget</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.target = <span class="built_in">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义观察者类Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建过程</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    	<span class="comment">// 执行一次回调函数</span></span><br><span class="line">    	<span class="built_in">this</span>.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被目标对象通知时执行回调函数</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 实例入栈</span></span><br><span class="line">    	Dep.pushTarget(<span class="built_in">this</span>);</span><br><span class="line">    	<span class="comment">// 回调函数的值</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="built_in">this</span>.cb();</span><br><span class="line">    	Dep.popTarget();</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive方法遍历并包装对象属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 若obj是一个对象，则遍历它</span></span><br><span class="line">	<span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// 新建一个订阅者</span></span><br><span class="line">		<span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">		<span class="comment">// 为当前属性安装监听器，劫持其属性</span></span><br><span class="line">		<span class="keyword">const</span> handler = &#123;</span><br><span class="line">			<span class="function"><span class="title">get</span>(<span class="params">obj, key</span>)</span> &#123;</span><br><span class="line">				<span class="comment">// 订阅者更新</span></span><br><span class="line">				dep.depend();</span><br><span class="line">				<span class="keyword">return</span> obj[key];</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="function"><span class="title">set</span>(<span class="params">obj, key, newValue</span>)</span> &#123;</span><br><span class="line">				<span class="comment">// 更新值</span></span><br><span class="line">				obj[key] = newValue;</span><br><span class="line">				<span class="comment">// 通知所有观察者</span></span><br><span class="line">				dep.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 实现代理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> data = reactive(&#123;</span><br><span class="line">	msg: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Watcher(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;执行：&#x27;</span>, data.msg);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	data.msg = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>更完善的程序请参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903974282379271">vue2.0响应式到vue3.0响应式原理</a></p>
<h3 id="变种Reactive问题"><a href="#变种Reactive问题" class="headerlink" title="变种Reactive问题"></a>变种Reactive问题</h3><p>原题目实现vue里的reactive函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...res</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用例</span></span><br><span class="line"><span class="keyword">const</span> obj1 = reactive(&#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj1.subscribe(<span class="function">(<span class="params">newState, key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(newState, key);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj1.a = <span class="number">3</span>; <span class="comment">// &#123;a:3,b:2&#125; &#x27;a&#x27;</span></span><br><span class="line">obj1.b = <span class="number">4</span>; <span class="comment">// &#123;a:3,b:4&#125; &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>大佬提供的Object.defineProperty版本</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 代理对象</span></span><br><span class="line">	<span class="keyword">const</span> proxyObj = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 订阅事件</span></span><br><span class="line">	<span class="keyword">const</span> subs = [];</span><br><span class="line">	<span class="comment">// 使用Object.defineProperty需要遍历所有的键</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">			<span class="comment">// 使用Object.defineProperty使用getter、setter劫持对象属性</span></span><br><span class="line">			<span class="built_in">Object</span>.defineProperty(proxyObj, key, &#123;</span><br><span class="line">				enumerable: <span class="literal">true</span>,</span><br><span class="line">				configurable: <span class="literal">true</span>,</span><br><span class="line">				<span class="comment">// 取值</span></span><br><span class="line">				<span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> obj[key];</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="comment">// 设置值</span></span><br><span class="line">				<span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">					<span class="comment">// 相同无需操作</span></span><br><span class="line">					<span class="keyword">if</span>(obj[key] === newVal) <span class="keyword">return</span>;</span><br><span class="line">					<span class="comment">// 赋值</span></span><br><span class="line">					obj[key] = newVal;</span><br><span class="line">					<span class="comment">// 遍历回调函数，打印对象和发生变化的key</span></span><br><span class="line">					subs.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(obj, key));</span><br><span class="line">					<span class="keyword">return</span> obj[key];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 存储回调函数</span></span><br><span class="line">	proxyObj.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">		subs.push(fn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例测试</span></span><br><span class="line"><span class="keyword">const</span> obj1 = reactive(&#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 订阅函数</span></span><br><span class="line">obj1.subscribe(<span class="function">(<span class="params">newState, key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(newState, key);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监测值发生变化</span></span><br><span class="line">obj1.a = <span class="number">3</span>; <span class="comment">// &#123;a: 3, b: 2&#125; &#x27;a&#x27;</span></span><br><span class="line">obj1.b = <span class="number">4</span>; <span class="comment">// &#123;a: 3, b: 4&#125; &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>自己改用Proxy做了一版</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 订阅事件</span></span><br><span class="line">	<span class="keyword">const</span> subs = [];</span><br><span class="line">	<span class="comment">// 使用proxy无需遍历所有的键</span></span><br><span class="line">	<span class="keyword">const</span> handler = &#123;</span><br><span class="line">		<span class="function"><span class="title">get</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">			<span class="comment">// 取值</span></span><br><span class="line">			<span class="keyword">return</span> target[key];</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="title">set</span>(<span class="params">target, key, newVal</span>)</span> &#123;</span><br><span class="line">			<span class="comment">// 相同无需操作</span></span><br><span class="line">			<span class="keyword">if</span>(target[key] === newVal) <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">// 赋值</span></span><br><span class="line">			target[key] = newVal;</span><br><span class="line">			<span class="comment">// 遍历回调函数，打印对象和发生变化的key</span></span><br><span class="line">			subs.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(target, key));</span><br><span class="line">			<span class="keyword">return</span> target[key];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 代理对象</span></span><br><span class="line">	<span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">	<span class="comment">// 存储回调函数</span></span><br><span class="line">	proxyObj.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">		subs.push(fn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例测试</span></span><br><span class="line"><span class="keyword">const</span> obj1 = reactive(&#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: <span class="number">2</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 订阅函数</span></span><br><span class="line">obj1.subscribe(<span class="function">(<span class="params">newState, key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(newState, key);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监测值发生变化</span></span><br><span class="line">obj1.a = <span class="number">3</span>; <span class="comment">// &#123;a: 3, b: 2&#125; &#x27;a&#x27;</span></span><br><span class="line">obj1.b = <span class="number">4</span>; <span class="comment">// &#123;a: 3, b: 4&#125; &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="52-发布-订阅模式-EventBus-EventEmitter"><a href="#52-发布-订阅模式-EventBus-EventEmitter" class="headerlink" title="52.发布/订阅模式 (EventBus/EventEmitter)"></a>52.发布/订阅模式 (EventBus/EventEmitter)</h2><p><code>EventEmitter</code>是一个典型的发布/订阅模式，实现了事件调度中心。发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的<code>emit</code>方法发布事件，而订阅者则通过<code>on</code>进行订阅。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210503213226.webp" alt="img"></p>
<p><strong>优点：</strong></p>
<ul>
<li>发布订阅模式中，对于发布者<code>Publisher</code>和订阅者<code>Subscriber</code>没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁。</li>
<li>松散耦合，灵活度高，常用作事件总线</li>
<li>易理解，可类比于<code>DOM</code>事件中的<code>dispatchEvent</code>和<code>addEventListener</code>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当事件类型越来越多时，难以维护，需要考虑事件命名的规范，也要防范数据流混乱。</li>
</ul>
<p><code>Event Bus</code>（Vue、Flutter 等前端框架中有出镜）和 <code>Event Emitter</code>（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——<strong>全局事件总线</strong>。</p>
<p><strong>在Vue中使用Event Bus来实现组件间的通讯</strong></p>
<blockquote>
<p><code>Event Bus/Event Emitter</code> 作为全局事件总线，它起到的是一个<strong>沟通桥梁</strong>的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。</p>
</blockquote>
<p>在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 <code>Vuex</code> 之外，我们还可以通过 <code>Event Bus</code> 来实现我们的需求。整个调用过程中，没有出现具体的发布者和订阅者（比如上面的<code>PrdPublisher</code>和<code>DeveloperObserver</code>），全程只有<code>bus</code>这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 存储事件监听器及回调函数</span></span><br><span class="line">		<span class="built_in">this</span>.listeners = &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册事件监听者 on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>eventName 事件类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>cb 回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, cb</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 先检查一下目标事件名有没有对应的监听函数队列</span></span><br><span class="line">    	<span class="keyword">if</span> (!<span class="built_in">this</span>.listeners[eventName]) &#123;</span><br><span class="line">    		<span class="comment">// 如果没有，那么首先初始化一个监听函数队列</span></span><br><span class="line">    		<span class="built_in">this</span>.listeners[eventName] = [];</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 把回调函数推入目标事件的监听函数队列里去</span></span><br><span class="line">    	<span class="built_in">this</span>.listeners[eventName].push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发布事件 emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>eventName 事件类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param  <span class="type">&#123;...any&#125;</span> </span>args 参数列表，把emit传递的参数赋给回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 检查目标事件是否有监听函数队列</span></span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.listeners[eventName]) &#123;</span><br><span class="line">    		<span class="comment">// 如果有，则逐个调用队列里的回调函数</span></span><br><span class="line">    		<span class="built_in">this</span>.listeners[eventName].forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    			cb(...args);</span><br><span class="line">    		&#125;)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * off方法移除某个事件的一个监听者,移除某个事件回调队列里的指定回调函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>eventName 事件类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>cb 回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">eventName, cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.listeners[eventName]) &#123;</span><br><span class="line">    		<span class="keyword">const</span> callbacks = <span class="built_in">this</span>.listeners[eventName];</span><br><span class="line">            <span class="keyword">const</span> index = callbacks.indexOf(cb);</span><br><span class="line">            <span class="keyword">if</span>(index !== -<span class="number">1</span>) callbacks.splice(index, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.listeners[eventName].length === <span class="number">0</span>) <span class="keyword">delete</span> <span class="built_in">this</span>.listeners[eventName];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * offAll移除某个事件的所有监听者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>eventName事件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">offAll</span>(<span class="params">eventName</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.listeners[eventName]) &#123;</span><br><span class="line">    		<span class="keyword">delete</span> <span class="built_in">this</span>.listeners[eventName];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * once方法为事件注册单次监听器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>eventName 事件类型</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>cb 回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">once</span>(<span class="params">eventName, cb</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 对回调函数进行包装，使其执行完毕自动被移除</span></span><br><span class="line">    	<span class="keyword">const</span> wrapper = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 使用箭头函数使this指向EventEmitter实例</span></span><br><span class="line">    		cb.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    		<span class="comment">// 移除该回调函数</span></span><br><span class="line">    		<span class="built_in">this</span>.off(eventName, cb);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">this</span>.on(eventName, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// 创建事件管理器实例</span></span><br><span class="line"><span class="keyword">const</span> ee = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="comment">// 注册一个chifan事件监听者</span></span><br><span class="line">ee.on(<span class="string">&#x27;chifan&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭了，我们走！&#x27;</span>) &#125;);</span><br><span class="line"><span class="comment">// 发布事件chifan</span></span><br><span class="line">ee.emit(<span class="string">&#x27;chifan&#x27;</span>);</span><br><span class="line"><span class="comment">// 也可以emit传递参数</span></span><br><span class="line">ee.on(<span class="string">&#x27;chifan&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">address, food</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`吃饭了，我们去<span class="subst">$&#123;address&#125;</span>吃<span class="subst">$&#123;food&#125;</span>！`</span>) &#125;);</span><br><span class="line">ee.emit(<span class="string">&#x27;chifan&#x27;</span>, <span class="string">&#x27;三食堂&#x27;</span>, <span class="string">&#x27;铁板饭&#x27;</span>); <span class="comment">// 此时会打印两条信息，因为前面注册了两个chifan事件的监听者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试移除事件监听</span></span><br><span class="line"><span class="keyword">const</span> toBeRemovedListener = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我是一个可以被移除的监听者&#x27;</span>) &#125;;</span><br><span class="line">ee.on(<span class="string">&#x27;testoff&#x27;</span>, toBeRemovedListener);</span><br><span class="line">ee.emit(<span class="string">&#x27;testoff&#x27;</span>);</span><br><span class="line">ee.off(<span class="string">&#x27;testoff&#x27;</span>, toBeRemovedListener);</span><br><span class="line">ee.emit(<span class="string">&#x27;testoff&#x27;</span>); <span class="comment">// 此时事件监听已经被移除，不会再有console.log打印出来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试移除chifan的所有事件监听</span></span><br><span class="line">ee.offAll(<span class="string">&#x27;chifan&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ee); <span class="comment">// 此时可以看到ee.listeners已经变成空对象了，再emit发送chifan事件也不会有反应了</span></span><br></pre></td></tr></table></figure>



<h2 id="53-手写事件代理"><a href="#53-手写事件代理" class="headerlink" title="53.手写事件代理"></a>53.手写事件代理</h2><blockquote>
<p>事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：</p>
</blockquote>
<p>事件代理，可能是代理模式最常见的一种应用方式，也是一道实打实的高频面试题。它的场景是一个父元素下有多个子元素，像这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件代理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接1号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接2号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接3号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接4号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接5号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接6号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们现在的需求是，希望鼠标点击每个 a 标签，都可以弹出“我是xxx”这样的提示。比如点击第一个 a 标签，弹出“我是链接1号”这样的提示。这意味着我们至少要安装 <code>6</code> 个监听函数给 <code>6</code> 个不同的的元素(一般我们会用循环，代码如下所示），如果我们的 <code>a</code> 标签进一步增多，那么性能的开销会更大。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如不用代理模式，我们将循环安装监听函数</span></span><br><span class="line"><span class="comment">// 所有a标签节点</span></span><br><span class="line"><span class="keyword">const</span> aNodes = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;father&#x27;</span>).getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环安装监听函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; aNodes.length; i++) &#123;</span><br><span class="line">	aNodes[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="title">funtion</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 阻止事件默认行为</span></span><br><span class="line">		e.preventDefault();</span><br><span class="line">		alert(<span class="string">`我是<span class="subst">$&#123;aNodes[i].innerText&#125;</span>`</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到事件本身具有“冒泡”的特性，当我们点击 a 元素时，点击事件会“冒泡”到父元素 div 上，从而被监听到。如此一来，点击事件的监听函数只需要在 div 元素上被绑定一次即可，而不需要在子元素上被绑定 N 次——这种做法就是事件代理，它可以很大程度上提高我们代码的性能。</p>
</blockquote>
<p><strong>事件代理的实现</strong></p>
<p>用代理模式实现多个子元素的事件监听，代码会简单很多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">const</span> father = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;father&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给父元素安装一次监听函数</span></span><br><span class="line">father.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 识别是否是目标子元素</span></span><br><span class="line">	<span class="keyword">if</span> (e.target.tagName === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// 以下是监听函数的函数体</span></span><br><span class="line">		<span class="comment">// 阻止事件默认行为</span></span><br><span class="line">		e.preventDefault();</span><br><span class="line">		alert(<span class="string">`我是<span class="subst">$&#123;e.target.innerText&#125;</span>`</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这种做法下，我们的点击操作并不会直接触及目标子元素，而是由父元素对事件进行处理和分发、间接地将其作用于子元素，因此这种操作从模式上划分属于代理模式。</p>
<h2 id="54-手写JSONP跨域"><a href="#54-手写JSONP跨域" class="headerlink" title="54.手写JSONP跨域"></a>54.手写JSONP跨域</h2><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。利用<code>&lt;script&gt;</code>标签不受跨域限制的特点，缺点是只能支持 <code>get</code> 请求。</p>
<ul>
<li>1.创建一个script标签</li>
<li>2.设置好<code>src</code>属性，设置好回调函数<code>callback</code>名称</li>
<li>3.将script标签插入到HTML页面中</li>
<li>4.调用回调函数，获取最终的结果</li>
</ul>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, callback, success</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个script标签</span></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置好 src属性</span></span><br><span class="line">    script.src = url;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// src类型</span></span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        success &amp;&amp; success(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">&#x27;http://xxx&#x27;</span>, <span class="string">&#x27;callback&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="其他跨域方案"><a href="#其他跨域方案" class="headerlink" title="其他跨域方案"></a>其他跨域方案</h3><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul>
<li><code>CORS</code>需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li>
<li>浏览器会自动进行 <code>CORS</code> 通信，实现<code>CORS</code>通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li>
<li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</li>
</ul>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><ul>
<li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li>
<li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</li>
</ul>
<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><blockquote>
<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="55-手写Promise"><a href="#55-手写Promise" class="headerlink" title="55.手写Promise"></a>55.手写Promise</h2><p>为什么用Promise？在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而Promise将回调嵌套改为链式调用，增加可读性和可维护性。</p>
<p>romise本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆P，Promise一旦新建就立刻执行, 此时的状态是Pending(进行中)。</p>
<p><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调，resolve和reject。它们是两个函数.<br> resolve函数的作用是将Promise对象的状态从’未完成’变为’成功’(由Pending变为Resolved), 在异步操作成功时,将操作结果作为参数传递出去;<br> reject函数的作用是将Promise对象的状态从’未完成’变为失败(由Pending变为Rejected),在异步操作失败时调用,并将异步操作的错误作为参数传递出去。</p>
<h3 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constuctor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>在基础版本上增加then方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// expected output: &quot;Success!&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h3><p>catch方法本质上就是第一个参数为空函数的then方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// &quot;oh, no!&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after a catch the chain is restored&#x27;</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Not fired due to the catch&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h3><p>无论当前 Promise 是成功还是失败，调用finally之后都会执行 finally 中传入的函数，并且将值原封不动的往下传。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  	resolve(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// expected output: &quot;Success!&quot;</span></span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Finally!&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success!&quot;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;oh, no!&#x27;</span>;</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Finally!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-resolve和Promise-reject"><a href="#Promise-resolve和Promise-reject" class="headerlink" title="Promise.resolve和Promise.reject"></a>Promise.resolve和Promise.reject</h3><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p>
<p>而<code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = MyPromise.resolve(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// expected output: 123</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.error(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)).then(resolved, rejected);</span><br><span class="line"><span class="comment">// expected output: Error: fail</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all() 它接收一个promise对象组成的数组作为参数，并返回一个新的promise对象。</p>
<p>当数组中所有的对象都resolve时，新对象状态变为fulfilled，所有对象的resolve的value依次添加组成一个新的数组，并以新的数组作为新对象resolve的value。<br>当数组中有一个对象reject时，新对象状态变为rejected，并以当前对象reject的reason作为新对象reject的reason。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = value;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 第一个reject的MyPromise</span></span><br><span class="line">    					reject(reason);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = MyPromise.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: Array [3, 42, &quot;foo&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race() 它同样接收一个promise对象组成的数组作为参数，并返回一个新的promise对象。</p>
<p>与Promise.all()不同，它是在数组中有一个对象（最早改变状态）resolve或reject时，就改变自身的状态，并执行响应的回调。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = value;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 第一个reject的MyPromise</span></span><br><span class="line">    					reject(reason);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的race方法,只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    			<span class="comment">// Promise.resolve(promise)用于处理传入值不为Promise的情况</span></span><br><span class="line">    			MyPromise.resolve(promise).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    				<span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">    				resolve(value);</span><br><span class="line">    			&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    				reject(error);</span><br><span class="line">    			&#125;)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.race([promise1, promise2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>接受的结果与入参时的promise实例一一对应，且结果的每一项都是一个对象，告诉你结果和值，对象内都有一个属性叫“status”，用来明确知道对应的这个promise实例的状态（fulfilled或rejected），fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。</p>
<p>重要的一点是，他不论接受入参的promise本身的状态，会返回所有promise的结果，但这一点<code>Promise.all</code>做不到，如果你需要知道所有入参的异步操作的所有结果，或者需要知道这些异步操作是否全部结束，应该使用<code>promise.allSettled()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = value;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 第一个reject的MyPromise</span></span><br><span class="line">    					reject(reason);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的race方法,只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    			<span class="comment">// Promise.resolve(promise)用于处理传入值不为Promise的情况</span></span><br><span class="line">    			MyPromise.resolve(promise).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    				<span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">    				resolve(value);</span><br><span class="line">    			&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    				reject(error);</span><br><span class="line">    			&#125;)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的allSettled方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 和第一个类似，但要注意状态</span></span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason &#125;;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolved = MyPromise.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> rejected = MyPromise.reject(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([resolved, rejected])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any() 是 ES2021 新增的特性，它接收一个 Promise 可迭代对象（例如数组），</p>
<p>只要其中的一个 promise 成功，就返回那个已经成功的 promise<br> 如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// Promise三种状态</span></span><br><span class="line">		<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		<span class="comment">// 定义状态为resolved(fulfilled)的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    	<span class="comment">// 定义状态为rejected的时候的状态</span></span><br><span class="line">    	<span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 成功队列, 存放成功的回调，resolve时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onResolvedCallbacks = [];</span><br><span class="line">    	<span class="comment">// 失败队列,  存放失败的回调，reject时触发</span></span><br><span class="line">    	<span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 由于resolve/reject是在fn内部被调用, 因此需要使用箭头函数固定this指向,指向Promise实例</span></span><br><span class="line">    	<span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.value = value;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 实现同resolve</span></span><br><span class="line">    	<span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">    		<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    			<span class="built_in">this</span>.reason = reason;</span><br><span class="line">    			<span class="comment">// 变更状态</span></span><br><span class="line">    			<span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    			<span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(reason));</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 执行时可能会发生异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Promise()时立即执行fn,并传入resolve和reject</span></span><br><span class="line">            fn(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        	reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFullfilled, onRejected</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 防止值的穿透</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onFullfilled !== <span class="string">&#x27;function&#x27;</span>) onFullfilled = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) onRejected = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">		<span class="comment">// return一个新的promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 把onFullfilled重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论，使用箭头函数，使this指向实例</span></span><br><span class="line">			<span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 把onRejected重新包装一下，使用箭头函数，使this指向实例</span></span><br><span class="line">           	<span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的失败回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error);</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;</span><br><span class="line">           	<span class="comment">// 根据状态变换</span></span><br><span class="line">           	<span class="keyword">switch</span>(<span class="built_in">this</span>.status) &#123;</span><br><span class="line">           		<span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">           		<span class="keyword">case</span> <span class="string">&#x27;pending&#x27;</span>:</span><br><span class="line">           			<span class="built_in">this</span>.onResolvedCallbacks.push(fulfilledFn);</span><br><span class="line">           			<span class="built_in">this</span>.onRejectedCallbacks.push(rejectedFn);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;fulfilled&#x27;</span>:</span><br><span class="line">           			fulfilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">               	<span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">           			rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">           			<span class="keyword">break</span>;</span><br><span class="line">           	&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// catch方法,接收一个失败的回调</span></span><br><span class="line">	<span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally方法</span></span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    		<span class="comment">// 执行回调,并return value传递给后面的then</span></span><br><span class="line">    		value =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    		<span class="comment">// reject同理</span></span><br><span class="line">    		reason =&gt; MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">      	)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    	<span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的reject方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的all方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = value;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 第一个reject的MyPromise</span></span><br><span class="line">    					reject(reason);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态的race方法,只要有一个promise成功了 就算成功。如果第一个失败了就失败了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span></span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    			<span class="comment">// Promise.resolve(promise)用于处理传入值不为Promise的情况</span></span><br><span class="line">    			MyPromise.resolve(promise).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    				<span class="comment">// 注意这个resolve是上边new MyPromise的</span></span><br><span class="line">    				resolve(value);</span><br><span class="line">    			&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    				reject(error);</span><br><span class="line">    			&#125;)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的allSettled方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">allSettled</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> res = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 和第一个类似，但要注意状态</span></span><br><span class="line">    					index++;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					res[i] = &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason &#125;;</span><br><span class="line">    					<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">    					<span class="keyword">if</span> (index === promises.length) resolve(res);</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态的any方法</span></span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">any</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 计数器，用来累计promise的已执行次数</span></span><br><span class="line">    	<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 存放 promise执行后的结果</span></span><br><span class="line">    	<span class="keyword">let</span> reasons = [];</span><br><span class="line">    	<span class="comment">// 返回一个MyPromise对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">    			MyPromise.resolve(promises[i]).then(</span><br><span class="line">    				<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 第一个resolve的MyPromise</span></span><br><span class="line">    					resolve(value);</span><br><span class="line">    				&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    					<span class="comment">// 结果数组按照原数组的顺序依次输出</span></span><br><span class="line">    					index++;</span><br><span class="line">						reasons.push(reason);</span><br><span class="line">						<span class="comment">// 所有MyPromise都resolve</span></span><br><span class="line">						<span class="keyword">if</span> (index === promises.length) reject(<span class="keyword">new</span> AggregateError(<span class="string">&#x27;All promises were rejected&#x27;</span>, reasons));</span><br><span class="line">    				&#125;</span><br><span class="line">    			)</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promises1 = [</span><br><span class="line">	MyPromise.reject(<span class="string">&#x27;ERROR A&#x27;</span>),</span><br><span class="line">	MyPromise.reject(<span class="string">&#x27;ERROR B&#x27;</span>),</span><br><span class="line">	MyPromise.resolve(<span class="string">&#x27;result&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MyPromise.any(promises1).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;value: &#x27;</span>, value);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// value:  result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   如果所有传入的 promises 都失败：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promises2 = [</span><br><span class="line">	MyPromise.reject(<span class="string">&#x27;ERROR A&#x27;</span>),</span><br><span class="line">	MyPromise.reject(<span class="string">&#x27;ERROR B&#x27;</span>),</span><br><span class="line">	MyPromise.reject(<span class="string">&#x27;ERROR C&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MyPromise.any(promises2).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;value：&#x27;</span>, value);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;err：&#x27;</span>, err);</span><br><span class="line">	<span class="built_in">console</span>.log(err.message);</span><br><span class="line">	<span class="built_in">console</span>.log(err.name);</span><br><span class="line">	<span class="built_in">console</span>.log(err.errors);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// err：AggregateError: All promises were rejected</span></span><br><span class="line"><span class="comment">// All promises were rejected</span></span><br><span class="line"><span class="comment">// AggregateError</span></span><br><span class="line"><span class="comment">// [&quot;ERROR A&quot;, &quot;ERROR B&quot;, &quot;ERROR C&quot;]</span></span><br></pre></td></tr></table></figure>

<p>最后的全部reject的失败了。</p>
<h2 id="56-手写ajax封装"><a href="#56-手写ajax封装" class="headerlink" title="56.手写ajax封装"></a>56.手写ajax封装</h2><h3 id="原生ajax封装"><a href="#原生ajax封装" class="headerlink" title="原生ajax封装"></a>原生ajax封装</h3><p><strong>步骤</strong></p>
<ul>
<li>创建 <code>XMLHttpRequest</code> 实例</li>
<li>发出 HTTP 请求</li>
<li>服务器返回 XML 格式的字符串</li>
<li>JS 解析 XML，并更新局部页面</li>
<li>不过随着历史进程的推进，XML 已经被淘汰，取而代之的是 JSON。</li>
</ul>
<p>了解了属性和方法之后，根据 AJAX 的步骤，手写最简单的 GET 请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">	<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">	<span class="comment">// 三个参数，规定请求的类型、URL 以及是否异步处理请求。</span></span><br><span class="line">	xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 设置请求头，发送信息至服务器时内容编码类型，可以不写</span></span><br><span class="line">	xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">	<span class="comment">// 每当 readyState 属性改变时，就会调用该函数。</span></span><br><span class="line">	xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// XMLHttpRequest 代理当前所处状态。</span></span><br><span class="line">		<span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="comment">// 200-300请求成功</span></span><br><span class="line">			<span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr === <span class="number">304</span>) &#123;</span><br><span class="line">				<span class="comment">// JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</span></span><br><span class="line">				success(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fail &amp;&amp; fail();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送请求，用于实际发出 HTTP 请求。不带参数为GET请求</span></span><br><span class="line">	xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promise封装ajax"><a href="#Promise封装ajax" class="headerlink" title="Promise封装ajax"></a>Promise封装ajax</h3><ul>
<li>返回一个新的Promise实例</li>
<li>创建HMLHttpRequest异步对象</li>
<li>调用open方法，打开url，与服务器建立链接（发送前的一些处理）</li>
<li>监听Ajax状态信息</li>
<li>如果<code>xhr.readyState == 4</code>（表示服务器响应完成，可以获取使用服务器的响应了）<ul>
<li><code>xhr.status == 200</code>，返回resolve状态</li>
<li><code>xhr.status == 404</code>，返回reject状态</li>
</ul>
</li>
<li><code>xhr.readyState !== 4</code>，把请求主体的信息基于send发送给服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XHLHttpRequest();</span><br><span class="line">        <span class="comment">// 三个参数，规定请求的类型、URL 以及是否异步处理请求。</span></span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置请求头，发送信息至服务器时内容编码类型，可以不写</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">        <span class="comment">// 每当 readyState 属性改变时，就会调用该函数。</span></span><br><span class="line">        xhr.onreadystatechange() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// XMLHttpRequest 代理当前所处状态。</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">// 200-300请求成功</span></span><br><span class="line">                <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="string">&#x27;请求出错&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="57-手写实现sleep"><a href="#57-手写实现sleep" class="headerlink" title="57.手写实现sleep"></a>57.手写实现sleep</h2><h3 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise"></a>使用Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用生成器Generator"><a href="#使用生成器Generator" class="headerlink" title="使用生成器Generator"></a>使用生成器Generator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleepGenerator</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">sleepGenerator(<span class="number">1000</span>).next().value.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用async-await"><a href="#使用async-await" class="headerlink" title="使用async/await"></a>使用async/await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> out = <span class="keyword">await</span> sleep(time);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span>(callback) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(callback, time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(output, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变种题1-将setTimeout包装成sleep的函数"><a href="#变种题1-将setTimeout包装成sleep的函数" class="headerlink" title="变种题1 将setTimeout包装成sleep的函数"></a>变种题1 将setTimeout包装成sleep的函数</h3><p>手写f函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>), <span class="number">500</span>);</span><br><span class="line"><span class="keyword">const</span> sleep = f(<span class="built_in">setTimeout</span>);</span><br><span class="line">sleep(<span class="number">500</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>即实现高阶函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        	args.unshift(resolve);</span><br><span class="line">        	fn(...args);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = f(<span class="built_in">setTimeout</span>);</span><br><span class="line">sleep(<span class="number">500</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="变种题2-异步循环打印"><a href="#变种题2-异步循环打印" class="headerlink" title="变种题2 异步循环打印"></a>变种题2 异步循环打印</h3><p>使用<code>promise + async await</code>实现异步循环打印</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			resolve(value);</span><br><span class="line">		&#125;, time);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">let</span> res = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">		<span class="built_in">console</span>.log(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure>

<h3 id="变种题3-实现-setTimeout-的同步"><a href="#变种题3-实现-setTimeout-的同步" class="headerlink" title="变种题3 实现 setTimeout 的同步"></a>变种题3 实现 setTimeout 的同步</h3><p>JS中，如果需要一系列的等待，就需要进行 setTimeout 嵌套，或者 setTimeout 时间进行倍数增长，代码可读性非常低。可以利用async/await，实现setTimeout的同步</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;Done sleeping&#x27;</span>);</span><br><span class="line">			resolve(ms);</span><br><span class="line">		&#125;, ms);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123; <span class="comment">// 函数声明使用async，实现异步代码同步化</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Starting...&#x27;</span>);</span><br><span class="line">	<span class="comment">// 测试是否阻塞Ended!</span></span><br><span class="line">	<span class="keyword">await</span> sleep(<span class="number">500</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;Ended!&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 测试多个setTimeout是否同步执行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;loop &#x27;</span> + i);</span><br><span class="line">		<span class="keyword">await</span> sleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 外部代码依然按照事件循环顺序执行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="58-手写promisify"><a href="#58-手写promisify" class="headerlink" title="58.手写promisify"></a>58.手写promisify</h2><p>promisify函数，实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;1.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newReadFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">newReadFile(<span class="string">&#x27;1.txt&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>把代码进行实现拆解</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数作为输入参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 函数返回一个Promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 参数最后增加一个函数的参数</span></span><br><span class="line">			args.push(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">				<span class="comment">// 根据回调函数顺序执行对应的函数</span></span><br><span class="line">				<span class="keyword">if</span>(err) reject(err);</span><br><span class="line">				<span class="keyword">else</span> resolve(data);</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			fn(...args);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者写成一下方便理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数作为输入参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 函数返回一个Promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 参数最后增加一个函数的参数</span></span><br><span class="line">			fn(...args, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">				<span class="comment">// 根据回调函数顺序执行对应的函数</span></span><br><span class="line">				<span class="keyword">if</span>(err) reject(err);</span><br><span class="line">				<span class="keyword">else</span> resolve(data);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="59-实现延时执行队列"><a href="#59-实现延时执行队列" class="headerlink" title="59.实现延时执行队列"></a>59.实现延时执行队列</h2><p>  实现一个延时执行队列，  要求分别在 1,3,4 秒后打印出 “1”, “2”,   “  3”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Queue()</span><br><span class="line">    .task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>) </span><br><span class="line">    &#125;) </span><br><span class="line">    .task(<span class="number">2000</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>) </span><br><span class="line">    &#125;) </span><br><span class="line">    .task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">    &#125;) </span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure>

<h3 id="累加计时"><a href="#累加计时" class="headerlink" title="累加计时"></a>累加计时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 事件队列</span></span><br><span class="line">		<span class="built_in">this</span>.queue = [];</span><br><span class="line">		<span class="comment">// 定时器数组</span></span><br><span class="line">		<span class="built_in">this</span>.timer = [];</span><br><span class="line">		<span class="comment">// 累积开始时间</span></span><br><span class="line">		<span class="built_in">this</span>.startTime = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加入事件队列</span></span><br><span class="line">	<span class="function"><span class="title">task</span>(<span class="params">time, fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 开始时间累加</span></span><br><span class="line">		<span class="built_in">this</span>.startTime += time;</span><br><span class="line">		<span class="comment">// 存入开始时间和对应事件</span></span><br><span class="line">		<span class="built_in">this</span>.queue.push([fn, <span class="built_in">this</span>.startTime]);</span><br><span class="line">		<span class="comment">// 链式调用</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始任务</span></span><br><span class="line">	<span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 遍历队列，依次打开定时器</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.queue.length; i++) &#123;</span><br><span class="line">			<span class="built_in">this</span>.timer[i] = <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.queue[i][<span class="number">0</span>],<span class="built_in">this</span>.queue[i][<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭所有任务</span></span><br><span class="line">	<span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.timer.length; i++) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">q.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">2000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.start();</span><br><span class="line"></span><br><span class="line">q.stop(); <span class="comment">// 可以随时终止任务</span></span><br></pre></td></tr></table></figure>

<h3 id="使用Promise-1"><a href="#使用Promise-1" class="headerlink" title="使用Promise"></a>使用Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 事件队列</span></span><br><span class="line">        <span class="built_in">this</span>.queue = [];</span><br><span class="line">        <span class="comment">// 定时器</span></span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 进行Promise的链式调用</span></span><br><span class="line">        <span class="built_in">this</span>.pro = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入事件队列</span></span><br><span class="line">    <span class="function"><span class="title">task</span>(<span class="params">time, fn</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 把时间和回调函数存入事件队列</span></span><br><span class="line">        <span class="built_in">this</span>.queue.push([time, fn]);</span><br><span class="line">		<span class="comment">// 链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// 开始任务</span></span><br><span class="line">    start () &#123;</span><br><span class="line">    	<span class="comment">// 保证内部定时器this指向Queue实例</span></span><br><span class="line">        <span class="built_in">this</span>.queue.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        	<span class="comment">// promise链式调用</span></span><br><span class="line">            <span class="built_in">this</span>.pro = <span class="built_in">this</span>.pro.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            	<span class="comment">// 返回下一个promise</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                	<span class="comment">// 打开定时器</span></span><br><span class="line">                    <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    	<span class="comment">// 允许这个任务完成后下一个任务执行</span></span><br><span class="line">                    	resolve(item[<span class="number">1</span>]());</span><br><span class="line">                    &#125;, item[<span class="number">0</span>]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// 关闭所有任务</span></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 禁止链式调用</span></span><br><span class="line">        <span class="built_in">this</span>.pro = <span class="built_in">Promise</span>.reject();</span><br><span class="line">        <span class="comment">// 关闭定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">q.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">2000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.start();</span><br><span class="line"></span><br><span class="line">q.stop(); <span class="comment">// 可以随时终止任务</span></span><br></pre></td></tr></table></figure>

<h3 id="使用async-await-1"><a href="#使用async-await-1" class="headerlink" title="使用async/await"></a>使用async/await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="comment">// 事件队列</span></span><br><span class="line">        <span class="built_in">this</span>.queue = [];</span><br><span class="line">        <span class="comment">// 定时器</span></span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入事件队列</span></span><br><span class="line">    <span class="function"><span class="title">task</span>(<span class="params">time, fn</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.push([time, fn]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 开始任务</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.queue.length; i++)&#123;</span><br><span class="line">        	<span class="comment">// 异步任务阻塞</span></span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            	<span class="comment">// 定时器</span></span><br><span class="line">                <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(resolve, <span class="built_in">this</span>.queue[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            	<span class="comment">// 执行回调函数</span></span><br><span class="line">                <span class="built_in">this</span>.queue[i][<span class="number">1</span>]();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 关闭所有任务</span></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = [];</span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">q.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">2000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.task(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.start();</span><br><span class="line"></span><br><span class="line">q.stop(); <span class="comment">// 可以随时终止任务</span></span><br></pre></td></tr></table></figure>



<h2 id="60-setTimeout实现setInterval"><a href="#60-setTimeout实现setInterval" class="headerlink" title="60.setTimeout实现setInterval"></a>60.setTimeout实现setInterval</h2><h3 id="setTimeout实现setInterval"><a href="#setTimeout实现setInterval" class="headerlink" title="setTimeout实现setInterval"></a>setTimeout实现setInterval</h3><p><code>setInterval</code> 需要不停循环调用，这让我们想到了递归调用自身，通过 setTimeout 执行完成再递归执行，达到仿真 setInterval 的效果，先不考虑<code>clearInterval</code> 的存在</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 执行回调函数</span></span><br><span class="line">		callback();</span><br><span class="line">		<span class="comment">// 延时</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化执行函数</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">mySetInterval(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p><code>clearInterval</code> 的用法是 <code>clearInterval(id)</code>。而这个 <code>id</code> 是 <code>setInterval</code>的返回值，通过这个 <code>id</code> 值就能够清除指定的定时器。具体实现请参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903839934447629">用setTimeout和clearTimeout简单实现setInterval与clearInterval</a></p>
<p>和<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903887749513223">你会用 setInterval, setTimeout 互相实现吗？</a></p>
<h3 id="setInterval实现setTimeout"><a href="#setInterval实现setTimeout" class="headerlink" title="setInterval实现setTimeout"></a>setInterval实现setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetTimeout</span>(<span class="params">callback, time</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 定时器命名</span></span><br><span class="line">	<span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 执行回调函数</span></span><br><span class="line">		callback();</span><br><span class="line">		<span class="comment">// 执行一次关闭定时器</span></span><br><span class="line">		<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">	&#125;, time);</span><br><span class="line">	<span class="comment">// 返回定时器</span></span><br><span class="line">	<span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClearTimeout</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 关闭定时器</span></span><br><span class="line">	<span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> timer = mySetTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">myClearTimeout(timer);</span><br></pre></td></tr></table></figure>



<h2 id="61-手写fetch"><a href="#61-手写fetch" class="headerlink" title="61.手写fetch"></a>61.手写fetch</h2><h3 id="promise实现fetch"><a href="#promise实现fetch" class="headerlink" title="promise实现fetch"></a>promise实现fetch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XHLHttpRequest();</span><br><span class="line">        <span class="comment">// 三个参数，规定请求的类型、URL 以及是否异步处理请求。</span></span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置请求头，发送信息至服务器时内容编码类型，可以不写</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">        <span class="comment">// 每当 readyState 属性改变时，就会调用该函数。</span></span><br><span class="line">        xhr.onreadystatechange() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// XMLHttpRequest 代理当前所处状态。</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">// 200-300请求成功</span></span><br><span class="line">                <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="string">&#x27;请求出错&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个Promise</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 通过ajax发送请求</span></span><br><span class="line">		ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 成功</span></span><br><span class="line">			resolve(res);</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 失败</span></span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给fetch添加一个超时控制"><a href="#给fetch添加一个超时控制" class="headerlink" title="给fetch添加一个超时控制"></a>给fetch添加一个超时控制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, param = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XHLHttpRequest();</span><br><span class="line">        <span class="comment">// 三个参数，规定请求的类型、URL 以及是否异步处理请求。</span></span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置请求头，发送信息至服务器时内容编码类型，可以不写</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">        <span class="comment">// 每当 readyState 属性改变时，就会调用该函数。</span></span><br><span class="line">        xhr.onreadystatechange() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// XMLHttpRequest 代理当前所处状态。</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="comment">// 200-300请求成功</span></span><br><span class="line">                <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="string">&#x27;请求出错&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params">url, timeout</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个Promise</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 通过ajax发送请求</span></span><br><span class="line">		ajax(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 成功</span></span><br><span class="line">			resolve(res);</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// 失败</span></span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 增加一个计时器</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			reject(<span class="string">&#x27;超时&#x27;</span>);</span><br><span class="line">		&#125;, timeout)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="62-手写实现Generator"><a href="#62-手写实现Generator" class="headerlink" title="62.手写实现Generator"></a>62.手写实现Generator</h2><h3 id="ES6对迭代器的实现"><a href="#ES6对迭代器的实现" class="headerlink" title="ES6对迭代器的实现"></a>ES6对迭代器的实现</h3><p>JS原生的集合类型数据结构，只有<code>Array</code>（数组）和<code>Object</code>（对象）；而<code>ES6</code>中，又新增了<code>Map</code>和<code>Set</code>。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以<code>ES6</code>在推出新数据结构的同时也推出了一套<strong>统一的接口机制</strong>——迭代器（<code>Iterator</code>）。</p>
<blockquote>
<p><code>ES6</code>约定，任何数据结构只要具备<code>Symbol.iterator</code>属性（这个属性就是<code>Iterator</code>的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被<code>for...of...</code>循环和迭代器的next方法遍历。 事实上，<code>for...of...</code>的背后正是对<code>next</code>方法的反复调用。</p>
</blockquote>
<p>在ES6中，针对<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>、<code>TypedArray</code>、函数的 <code>arguments</code> 对象、<code>NodeList</code> 对象这些原生的数据结构都可以通过<code>for...of...</code>进行遍历。原理都是一样的，此处我们拿最简单的数组进行举例，当我们用<code>for...of...</code>遍历数组时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前元素是<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以能够按顺序一次一次地拿到数组里的每一个成员，是因为我们借助数组的<code>Symbol.iterator</code>生成了它对应的迭代器对象，通过反复调用迭代器对象的<code>next</code>方法访问了数组成员，像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 通过调用iterator，拿到迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对迭代器对象执行next，就能逐个访问集合的成员</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>丢进控制台，我们可以看到<code>next</code>每次会按顺序帮我们访问一个集合成员：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104820.png" alt="img"></p>
<blockquote>
<p>而<code>for...of...</code>做的事情，基本等价于下面这通操作：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 通过调用iterator，拿到迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个迭代结果</span></span><br><span class="line"><span class="keyword">let</span> now = &#123;</span><br><span class="line">    done: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环往外迭代成员</span></span><br><span class="line"><span class="keyword">while</span>(!now.done) &#123;</span><br><span class="line">    now = iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(!now.done) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`现在遍历到了<span class="subst">$&#123;now.value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，<code>for...of...</code>其实就是<code>iterator</code>循环调用换了种写法。在ES6中我们之所以能够开心地用<code>for...of...</code>遍历各种各种的集合，全靠迭代器模式在背后给力。</p>
</blockquote>
<p>ps：此处推荐阅读<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议 (opens new window)</a>，相信大家读过后会对迭代器在ES6中的实现有更深的理解。</p>
<h3 id="手写实现迭代器生成函数"><a href="#手写实现迭代器生成函数" class="headerlink" title="手写实现迭代器生成函数"></a>手写实现迭代器生成函数</h3><p>我们说<strong>迭代器对象</strong>全凭<strong>迭代器生成函数</strong>帮我们生成。在<code>ES6</code>中，实现一个迭代器生成函数并不是什么难事儿，因为ES6早帮我们考虑好了全套的解决方案，内置了贴心的<strong>生成器</strong>（<code>Generator</code>）供我们使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个迭代器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">iteratorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1号选手&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2号选手&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;3号选手&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> iterator = iteratorGenerator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></table></figure>

<p>丢进控制台，不负众望：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104849.png" alt="img"></p>
<p>写一个生成器函数并没有什么难度，但在面试的过程中，面试官往往对生成器这种语法糖背后的实现逻辑更感兴趣。下面我们要做的，不仅仅是写一个迭代器对象，而是用<code>ES5</code>去写一个能够生成迭代器对象的迭代器生成函数（解析在注释里）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义生成器函数，入参是任意集合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorGenerator</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// index记录当前访问的索引</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// len记录传入集合的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = list.length;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义next方法</span></span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果索引还没有超出集合长度，done为false</span></span><br><span class="line">            <span class="keyword">let</span> done = index &gt;= len;</span><br><span class="line">            <span class="comment">// 如果done为false，则可以继续取值</span></span><br><span class="line">            <span class="keyword">let</span> value = done ? <span class="literal">undefined</span> : list[index++];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将当前值与遍历是否完毕（done）返回</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> iterator = iteratorGenerator([<span class="string">&#x27;1号选手&#x27;</span>, <span class="string">&#x27;2号选手&#x27;</span>, <span class="string">&#x27;3号选手&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不断调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></table></figure>

<p>此处为了记录每次遍历的位置，我们实现了一个闭包，借助自由变量来做我们的迭代过程中的“游标”。</p>
<p>运行一下我们自定义的迭代器，结果符合预期：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210508104909.png" alt="img"></p>
<h2 id="63-手写实现async-await"><a href="#63-手写实现async-await" class="headerlink" title="63.手写实现async/await"></a>63.手写实现async/await</h2><blockquote>
<p>核心：传递给我一个<code>Generator</code>函数，把函数中的内容基于<code>Iterator</code>迭代器的特点一步步的实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收一个Generator函数作为输入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// return一个function，和async保持一致</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 先调用generator函数 生成迭代器</span></span><br><span class="line">    	<span class="keyword">const</span> gen = generatorFunc.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">/* 内部定义一个_next函数 用来一步一步的跨过yield的阻碍</span></span><br><span class="line"><span class="comment">            	arg参数则是用来把promise resolve出来的值交给下一个yield</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">            	<span class="keyword">let</span> generatorResult;</span><br><span class="line">            	</span><br><span class="line">            	<span class="comment">// 这个方法需要包裹在try catch中</span></span><br><span class="line">        		<span class="comment">// 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误</span></span><br><span class="line">        		<span class="keyword">try</span> &#123;</span><br><span class="line">        			generatorResult = gen.next(arg);</span><br><span class="line">        		&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        			<span class="keyword">return</span> reject(error);</span><br><span class="line">        		&#125;</span><br><span class="line">        		</span><br><span class="line">        		<span class="comment">// gen.next() 得到的结果是一个 &#123; value, done &#125; 的结构</span></span><br><span class="line">        		<span class="keyword">const</span> &#123; value, done &#125; = generatorResult;</span><br><span class="line">        		</span><br><span class="line">        		<span class="comment">// 如果已经完成了 这个done是在最后一次调用next后才会为true</span></span><br><span class="line">        		<span class="keyword">if</span> (done) &#123;</span><br><span class="line">        			<span class="comment">// 就直接resolve这个promise</span></span><br><span class="line">        			<span class="keyword">return</span> resolve(value);</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 除了最后结束的时候外，每次调用gen.next()</span></span><br><span class="line">                    <span class="comment">// 其实是返回 &#123; value: Promise, done: false &#125; 的结构，</span></span><br><span class="line">                    <span class="comment">// 这里要注意的是Promise.resolve可以接受一个promise为参数</span></span><br><span class="line">                    <span class="comment">// 并且这个promise参数被resolve的时候，这个then才会被调用</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">                    	<span class="comment">// 这个value对应的是yield后面的promise</span></span><br><span class="line">                    	value</span><br><span class="line">                    ).then(</span><br><span class="line">                        <span class="comment">// value这个promise被resove的时候，就会执行_next</span></span><br><span class="line">                		<span class="comment">// 并且只要done不是true的时候 就会递归的往下解开promise</span></span><br><span class="line">                		<span class="function"><span class="keyword">function</span> <span class="title">onResolve</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">                			_next(val);</span><br><span class="line">                		&#125;,</span><br><span class="line">                		<span class="comment">// 如果promise被reject了 就再次进入_next函数</span></span><br><span class="line">                        <span class="comment">// 不同的是，这次的try catch中调用的是gen.throw(err)</span></span><br><span class="line">                        <span class="comment">// 那么自然就被catch到 然后把promise给reject掉啦</span></span><br><span class="line">                        <span class="function"><span class="keyword">function</span> <span class="title">onReject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                        	<span class="keyword">throw</span>(err);</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">        		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _next();</span><br><span class="line">    	&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)) ;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">2</span>);   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result是一个Promise</span></span><br><span class="line"><span class="keyword">const</span> result = asyncToGenerator(myGenerator)();</span><br><span class="line"><span class="comment">// 输出 1 2 error</span></span><br></pre></td></tr></table></figure>

<p><code>async</code>函数就是将 <code>Generator</code> 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已</p>
<p><strong>async函数对 Generator 函数的改进，体现在以下四点</strong></p>
<ol>
<li>内置执行器</li>
</ol>
<blockquote>
<p><code>Generator</code>函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 <code>Generator</code> 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果</p>
</blockquote>
<p>2.更好的语义</p>
<blockquote>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</p>
</blockquote>
<p>3.更广的适用性</p>
<blockquote>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
</blockquote>
<p>4.返回值是 <code>Promise</code></p>
<blockquote>
<p><code>async</code>函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便多了。你可以用<code>then</code>方法指定下一步的操作</p>
</blockquote>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖</p>
<h2 id="64-手写异步串行和异步并行"><a href="#64-手写异步串行和异步并行" class="headerlink" title="64.手写异步串行和异步并行"></a>64.手写异步串行和异步并行</h2><h3 id="实现异步加法"><a href="#实现异步加法" class="headerlink" title="实现异步加法"></a>实现异步加法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决方案</span></span><br><span class="line"><span class="comment">// 1. promisify 实现promise版本的加法</span></span><br><span class="line"><span class="keyword">const</span> promiseAdd = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 实现一个异步加法</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">let</span> res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	res = a + b;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        	reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(res);</span><br><span class="line">	&#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 串行处理</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">serialSum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 通过数组reduce办法实现加法，初始值不是简单的0，需要设置为Promise.resolve(0);</span></span><br><span class="line">	<span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">task, now</span>) =&gt;</span> task.then(<span class="function"><span class="params">res</span> =&gt;</span> promiseAdd(res, now)), <span class="built_in">Promise</span>.resolve(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 并行处理 需要两两分组求和递归处理</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">parallelSum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 递归重点，只有一个数</span></span><br><span class="line">	<span class="keyword">if</span> (args.length === <span class="number">1</span>) <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 存放本轮的异步任务</span></span><br><span class="line">	<span class="keyword">const</span> tasks = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i+= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// 两两相加，注意最后可能需要补零</span></span><br><span class="line">		tasks.push(promiseAdd(args[i], args[i + <span class="number">1</span>] || <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用Promise.all并行处理</span></span><br><span class="line">	<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">	<span class="keyword">return</span> parallelSum(...results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Running...&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> serialSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> parallelSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="实现异步串行的方法"><a href="#实现异步串行的方法" class="headerlink" title="实现异步串行的方法"></a>实现异步串行的方法</h3><p>初始代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`wait <span class="subst">$&#123;time&#125;</span>s`</span>)</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;execute&#x27;</span>);</span><br><span class="line">			resolve();</span><br><span class="line">		&#125;, time * <span class="number">100</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>一个封装的延迟函数，然后一个装有 3,4,5 的数组，需求就是在开始执行时依次等待 3, 4, 5 秒，并在之后打印对应输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> 3s // 等待3s</span><br><span class="line"></span><br><span class="line">execute</span><br><span class="line"><span class="built_in">wait</span> 4s // 等待4s</span><br><span class="line"></span><br><span class="line">execute</span><br><span class="line"><span class="built_in">wait</span> 5s // 等待5s</span><br><span class="line"></span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`wait <span class="subst">$&#123;time / <span class="number">10</span>&#125;</span>s`</span>)</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;execute&#x27;</span>);</span><br><span class="line">			resolve();</span><br><span class="line">		&#125;, time * <span class="number">100</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">await</span> sleep(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`wait <span class="subst">$&#123;time / <span class="number">10</span>&#125;</span>s`</span>)</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;execute&#x27;</span>);</span><br><span class="line">			resolve();</span><br><span class="line">		&#125;, time * <span class="number">100</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化为Promise.resolve()</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">promise, time</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> promise.then(<span class="function">() =&gt;</span> sleep(time));</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve());</span><br></pre></td></tr></table></figure>

<p>更多方法参考<a target="_blank" rel="noopener" href="https://www.manman.io/2019/03/21/promise_series/">来说一下如何串行执行多个 Promise</a></p>
<h3 id="实现异步串行的方法-1"><a href="#实现异步串行的方法-1" class="headerlink" title="实现异步串行的方法"></a>实现异步串行的方法</h3><p>不使用Promise.all，但本质上很接近其实现，准确来说更接近Promise.allSettled的实现，将rejected的结果转换为null，返回输出数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execter([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res); <span class="comment">// [1,null,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实现execter函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execter</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个Prommise</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 结果数组</span></span><br><span class="line">		<span class="keyword">const</span> len = arr.length;</span><br><span class="line">		<span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">		<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 将结果放入结果数组</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params">data, i</span>) </span>&#123;</span><br><span class="line">			result[i] = data;</span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">				resolve(result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="built_in">Promise</span>.resolve(arr[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">				setData(data, i);</span><br><span class="line">			&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">				setData(<span class="literal">null</span>, i);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">execter([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">2</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res); <span class="comment">// [1,null,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="65-异步并发数限制"><a href="#65-异步并发数限制" class="headerlink" title="65.异步并发数限制"></a>65.异步并发数限制</h2><h3 id="使用队列缓存并发任务"><a href="#使用队列缓存并发任务" class="headerlink" title="使用队列缓存并发任务"></a>使用队列缓存并发任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关键点</span></span><br><span class="line"><span class="comment"> * 1. new promise 一经创建，立即执行</span></span><br><span class="line"><span class="comment"> * 2. 使用 Promise.resolve().then 可以把任务加到微任务队列，防止立即执行迭代方法</span></span><br><span class="line"><span class="comment"> * 3. 微任务处理过程中，产生的新的微任务，会在同一事件循环内，追加到微任务队列里</span></span><br><span class="line"><span class="comment"> * 4. 使用 race 在某个任务完成时，继续添加任务，保持任务按照最大并发数进行执行</span></span><br><span class="line"><span class="comment"> * 5. 任务完成后，需要从 doingTasks 中移出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">limit</span>(<span class="params">count, array, iterateFunc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 所有任务列表结果</span></span><br><span class="line">    <span class="keyword">const</span> tasks = [];</span><br><span class="line">    <span class="keyword">const</span> doingTasks = [];</span><br><span class="line">    <span class="comment">// 完成的任务数量</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 所有任务都完成了，实现任务完成</span></span><br><span class="line">        <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以把任务加到微任务队列，防止立即执行迭代方法</span></span><br><span class="line">        <span class="keyword">const</span> task = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> iterateFunc(array[i++]));</span><br><span class="line">        <span class="comment">// 将任务存入任务数组中</span></span><br><span class="line">        tasks.push(task);</span><br><span class="line">        <span class="comment">// 任务完成后从工作数组中删除</span></span><br><span class="line">        <span class="keyword">const</span> doing = task.then(<span class="function">() =&gt;</span> doingTasks.splice(doingTasks.indexOf(doing), <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// doingTasks任务队列</span></span><br><span class="line">        doingTasks.push(doing);</span><br><span class="line">        <span class="comment">// doingTasks长度超过count完成最快的Promise，保持任务按照最大并发数进行执行</span></span><br><span class="line">        <span class="keyword">const</span> res = doingTasks.length &gt;= count ? <span class="built_in">Promise</span>.race(doingTasks) : <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        <span class="comment">// 链式调用</span></span><br><span class="line">        <span class="keyword">return</span> res.then(enqueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueue().then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.all(tasks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 本质就是sleep函数</span></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">i</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(i), i));</span><br><span class="line">limit(<span class="number">2</span>, [<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>], timeout).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="并发数目限制为2的异步调度器"><a href="#并发数目限制为2的异步调度器" class="headerlink" title="并发数目限制为2的异步调度器"></a>并发数目限制为2的异步调度器</h3><p>我们都知道promise.all方法可以执行多个promise，你给他多少个他就执行多少个，而且是一起执行，也就是并发执行。如果你给他100个，他会同时执行100个，如果这100个promise内都包含网络请求呢？</p>
<p>可能有人说，这种场景不多吧，一个页面内加起来就没几个接口，何况是并发请求了</p>
<p>但是如果让你做个文件分片上传呢？一个几百兆的文件分片后可能有几百个片段了吧。当然这也是一种极端情况，不过这确实是一个很明显的问题，还是需要解决的。</p>
<p>所以需要我们控制同时执行的promise个数，比如控制为2个，后面的所有promise都排队等待前面的执行完成。</p>
<p>进入正题，要求的代码实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善代码中Scheduler类，使得以下程序能正确输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">promiseCreator</span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> Scheduler();</span><br><span class="line"><span class="keyword">const</span> addTask = <span class="function">(<span class="params">time, order</span>) =&gt;</span> &#123;</span><br><span class="line">    scheduler.add(<span class="function">() =&gt;</span> timeout(time))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(order));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(<span class="number">1000</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">addTask(<span class="number">500</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">addTask(<span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">addTask(<span class="number">400</span>, <span class="string">&#x27;4&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>不控制并发的情况下的执行顺序应该是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>控制并发为2后的执行结果是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>详细情况如下：</p>
<p> 一开始，1、2两个任务进入队列<br>500ms时，2完成，输出2，任务3进队<br>800ms时，3完成，输出3，任务4进队<br>1000ms时，1完成，输出1<br>1200ms时，4完成，输出4</p>
<p>这个题本身也并不难，主要还是考察对题目的理解。</p>
<p><strong>题目分析</strong></p>
<ul>
<li>最后执行的是 <code>addTask</code> 方法，那我们首先从这个方法入手。函数执行体中执行了 <code>scheduler.add(fn)</code>，这个方法后面紧接着 <code>then</code> 方法，意味着 <code>scheduler.add</code> 返回的是一个 <code>Promise</code> 对象。</li>
<li>按照题意，当前最多只能有两个任务在运行，那么我们在 <code>Scheduler</code> 类中定义一个任务队列 <code>tasks</code> 属性，定义一个当前正在运行的任务数量 <code>runningTaskCount</code> 属性，当 <code>runningTaskCount</code> 小于2 时，马上执行 <code>add(promiseCreator)</code> 中的 <code>promiseCreator</code> 函数，否则当某一个任务执行完后再执行一个新的任务。</li>
</ul>
<p><strong>思路</strong></p>
<p>注意add方法里面传入的是函数并返回Promise，这是难点，很多人都是改题，我见过拿getter、setter写的，我觉得跟题目要考的主旨不同。</p>
<p>先把要执行的promise function 存到数组内</p>
<p>既然是最多为2个，那我们必然是要启动的时候就要让两个promise函数执行</p>
<p>设置一个临时变量，表示当前执行ing几个promise，判断执行队列中是否满员，未满直接进队</p>
<p>然后一个promise执行完成将临时变量-1</p>
<p>然后借助递归重复执行</p>
<p>第三个及以后则需要判断前两者是否resolve，注意这里前两者和前两个的概念不同（由于是一层抽象，这里举例说明：目前处于第三个，那么前两者的前者指第一个到第一个，后者指第二个；目前处于第四个，那么前两者的前者指第一个到第二个，后者指第三个；以此类推），resolve后从等待队列按顺序加入到执行队列。</p>
<p>说下原因，有两种情况。前者先完成，也就是集合中的任务全部执行完成，那么后者一定会进入执行（未完成），那么执行队列中一定会剩下一个位置；后者先完成，这个没什么可说的，后者完成后一定会剩下一个位置。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善代码中Scheduler类，使得以下程序能正确输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 待运行的任务</span></span><br><span class="line">		<span class="built_in">this</span>.tasks = [];</span><br><span class="line">		<span class="comment">// 正在运行的任务数量</span></span><br><span class="line">		<span class="built_in">this</span>.active = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 限制同时运行的最多任务个数</span></span><br><span class="line">    	<span class="built_in">this</span>.limit = <span class="number">2</span>;</span><br><span class="line">    	<span class="comment">// 完成后Promise的resolve函数</span></span><br><span class="line">    	<span class="built_in">this</span>.resolves = [];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// promiseCreator 是一个异步函数，返回Promise</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">promiseCreator</span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 将异步函数加入任务</span></span><br><span class="line">    	<span class="built_in">this</span>.tasks.push(promiseCreator);</span><br><span class="line">        <span class="comment">// 返回Promise</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    		<span class="comment">// resolve队列</span></span><br><span class="line">    		<span class="built_in">this</span>.resolves.push(resolve);</span><br><span class="line">    		<span class="comment">// 执行任务</span></span><br><span class="line">    		<span class="built_in">this</span>.run();</span><br><span class="line">    	&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">// 确保异步任务不超过限制且仍存在待执行任务</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.active &lt; <span class="built_in">this</span>.limit &amp;&amp; <span class="built_in">this</span>.tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 活动任务增加</span></span><br><span class="line">			<span class="built_in">this</span>.active++;</span><br><span class="line">			<span class="comment">// 按照任务顺序找对应的异步任务和其对应resolve函数</span></span><br><span class="line">			<span class="keyword">const</span> resolveFn = <span class="built_in">this</span>.resolves.shift();</span><br><span class="line">			<span class="keyword">const</span> task = <span class="built_in">this</span>.tasks.shift();</span><br><span class="line">			task().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 活动任务减少</span></span><br><span class="line">				<span class="built_in">this</span>.active--;</span><br><span class="line">				<span class="comment">// 执行任务</span></span><br><span class="line">				resolveFn();</span><br><span class="line">				<span class="comment">// 递归执行</span></span><br><span class="line">				<span class="built_in">this</span>.run();</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> Scheduler();</span><br><span class="line"><span class="keyword">const</span> addTask = <span class="function">(<span class="params">time, order</span>) =&gt;</span> &#123;</span><br><span class="line">    scheduler.add(<span class="function">() =&gt;</span> timeout(time))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(order));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTask(<span class="number">1000</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">addTask(<span class="number">500</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">addTask(<span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">addTask(<span class="number">400</span>, <span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="comment">// 2 3 1 4</span></span><br></pre></td></tr></table></figure>

<h3 id="实现带有执行器和拦截器的并发控制"><a href="#实现带有执行器和拦截器的并发控制" class="headerlink" title="实现带有执行器和拦截器的并发控制"></a>实现带有执行器和拦截器的并发控制</h3><p><strong>前言</strong><br>实际场景中，我们常常会对请求并发做一些限制，比如微信小程序中wx.request的最大并发限制就是 10 个，那如何实现一个并发的限制呢？</p>
<p><strong>实现</strong><br>首先考虑下实现最大并发的流程：</p>
<p>请求需要先被拦截器拦截，判断是否等于限制数量<br>如果大于限制是数量，就把请求生成一个 Promise 先放进队列中<br>每个请求结束的时候都要判断队列是否为空<br>假设请求的 API 返回一个 Promise（当然不是的话也可以转换）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过promise 实现一个并发限制类</span></span><br><span class="line"><span class="comment"> * 两个要点：一个执行器，一个拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plimit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 并发限制，默认为2</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit || <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 缓存队列</span></span><br><span class="line">		<span class="built_in">this</span>.queue = [];</span><br><span class="line">		<span class="comment">// 当前活跃的任务总数</span></span><br><span class="line">		<span class="built_in">this</span>.active = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把任务放入队列中</span></span><br><span class="line">	<span class="function"><span class="title">enqueue</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 返回一个Promise</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 关键代码: fn, resolve, reject 统一管理</span></span><br><span class="line">			<span class="built_in">this</span>.queue.push(&#123;fn, resolve, reject&#125;);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从队列起始位置开始执行任务</span></span><br><span class="line">	<span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.active &lt; <span class="built_in">this</span>.limit &amp;&amp; <span class="built_in">this</span>.queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 等到 Promise 计数器小于阈值时，则出队执行</span></span><br><span class="line">			<span class="keyword">const</span> &#123;fn, resolve, reject&#125; = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">			<span class="comment">// 执行任务</span></span><br><span class="line">			<span class="built_in">this</span>.run(fn).then(resolve, reject);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// async/await 执行器 简化错误处理</span></span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 当前活动任务数量增加</span></span><br><span class="line">		<span class="built_in">this</span>.active++;</span><br><span class="line">		<span class="keyword">const</span> value = <span class="keyword">await</span> fn();</span><br><span class="line">		<span class="comment">// 当前活动任务数量增加</span></span><br><span class="line">		<span class="built_in">this</span>.active++;</span><br><span class="line">		<span class="comment">// 执行完，看看队列有东西没</span></span><br><span class="line">		<span class="built_in">this</span>.deque();</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 拦截器</span></span><br><span class="line">    <span class="function"><span class="title">interceptor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.active &gt; <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">        	<span class="comment">// 如果没有到达阈值，直接执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.enqueue(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果超出阈值，则先扔到队列中，等待有空闲时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.run(fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Promise并发限制"><a href="#使用Promise并发限制" class="headerlink" title="使用Promise并发限制"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuGuy/p/13112876.html">使用Promise并发限制</a></h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>我们在需要保证代码在多个异步处理之后执行,我们通常会使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(promises: []).then(fun: <span class="function"><span class="keyword">function</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调</p>
<p>那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出.</p>
<p>这个时候需要我们对HTTP的连接数做限制。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise并发限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plimit</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">limit, fn</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 最大并发数</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">		<span class="comment">// 自定义的请求函数</span></span><br><span class="line">		<span class="built_in">this</span>.fn = fn;</span><br><span class="line">		<span class="comment">// 并发队列</span></span><br><span class="line">		<span class="built_in">this</span>.queue = [];</span><br><span class="line">		<span class="comment">// 剩余的请求地址</span></span><br><span class="line">		<span class="built_in">this</span>.urls = [];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化链接</span></span><br><span class="line">	<span class="function"><span class="title">start</span>(<span class="params">urls</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.urls = urls;</span><br><span class="line">		<span class="comment">// 先循环把并发池塞满</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">this</span>.queue.length &lt; <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">			<span class="keyword">let</span> url = <span class="built_in">this</span>.urls.shift();</span><br><span class="line">			<span class="built_in">this</span>.setTask(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用Promise.race方法来获得并发池中某任务完成的信号</span></span><br><span class="line">		<span class="keyword">let</span> race = <span class="built_in">Promise</span>.race(<span class="built_in">this</span>.queue);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.run(race);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	<span class="function"><span class="title">run</span>(<span class="params">race</span>)</span> &#123;</span><br><span class="line">		race.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="line">			<span class="keyword">let</span> url = <span class="built_in">this</span>.urls.shift();</span><br><span class="line">			<span class="built_in">this</span>.setTask(url);</span><br><span class="line">			<span class="comment">// 递归调用</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.run(<span class="built_in">Promise</span>.race(<span class="built_in">this</span>.queue));</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 网址请求</span></span><br><span class="line">	<span class="function"><span class="title">setTask</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!url) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 执行函数</span></span><br><span class="line">		<span class="keyword">let</span> task = <span class="built_in">this</span>.fn(url);</span><br><span class="line">		<span class="comment">// 将该任务推入queue并发队列中</span></span><br><span class="line">		<span class="built_in">this</span>.queue.push(task);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`\x1B[43m <span class="subst">$&#123;url&#125;</span> 开始，当前并发数：<span class="subst">$&#123;<span class="built_in">this</span>.queue.length&#125;</span>`</span>)</span><br><span class="line">        task.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 请求结束后将该Promise任务从队列中移除</span></span><br><span class="line">            <span class="built_in">this</span>.queue.splice(<span class="built_in">this</span>.queue.indexOf(task), <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`\x1B[43m <span class="subst">$&#123;url&#125;</span> 结束，当前并发数：<span class="subst">$&#123;<span class="built_in">this</span>.queue.length&#125;</span>`</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> URLS = [</span><br><span class="line">    <span class="string">&#x27;bytedance.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tencent.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;alibaba.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;microsoft.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;apple.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;hulu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;amazon.com&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//自定义请求函数</span></span><br><span class="line"><span class="keyword">var</span> requestFn = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">`任务<span class="subst">$&#123;url&#125;</span>完成`</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;外部逻辑&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> plimit = <span class="keyword">new</span> Plimit(<span class="number">5</span>, requestFn); <span class="comment">//并发数为5</span></span><br><span class="line">plimit.start(URLS);</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，思路如下：定义一个 PromisePool 对象，初始化一个 pool 作为并发池，然后先循环把并发池塞满，不断地调用 setTask 然后通过自己自定义的任务函数(任务函数可以是网络请求封装的 promise 对象，或者是其他的)，而且每个任务是一个Promise对象包装的，执行完就 pop 出连接池， 任务push 进并发池 pool 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Promise.race方法来获得并发池中某任务完成的信号</span></span><br><span class="line"><span class="keyword">let</span> race = <span class="built_in">Promise</span>.race(<span class="built_in">this</span>.queue);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.run(race);</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="function"><span class="title">run</span>(<span class="params">race</span>)</span> &#123;</span><br><span class="line">    race.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="built_in">this</span>.urls.shift();</span><br><span class="line">        <span class="built_in">this</span>.setTask(url);</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.run(<span class="built_in">Promise</span>.race(<span class="built_in">this</span>.queue));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个地方就是不断通过递归的方式，每当并发池跑完一个任务，就再塞入一个任务</p>

    </div>

    
    
    
      
<div>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
</div>
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a>
              <a href="/tags/%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/" rel="tag"><i class="fa fa-tag"></i> 函数手写</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/30/Promise%20async%20Generator%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" rel="prev" title="Promise async Generator实现原理解析">
      <i class="fa fa-chevron-left"></i> Promise async Generator实现原理解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/23/javascript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" rel="next" title="javascript面试问题">
      javascript面试问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%89%8B%E5%86%99call"><span class="nav-text">1.手写call</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-text">ES5实现及过程分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%89%8B%E5%86%99%EF%BC%89"><span class="nav-text">ES6实现（手写）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%8B%E5%86%99apply"><span class="nav-text">2.手写apply</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="nav-text">ES5实现及过程分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-text">ES6实现：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%8B%E5%86%99bind"><span class="nav-text">3.手写bind</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A-2"><span class="nav-text">ES5实现及过程分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%AE%9E%E7%8E%B0%EF%BC%9A-1"><span class="nav-text">ES6实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%89%8B%E5%86%99new"><span class="nav-text">4.手写new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%89%8B%E5%86%99Object-create"><span class="nav-text">5.手写Object.create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%89%8B%E5%86%99ES5%E7%BB%A7%E6%89%BF"><span class="nav-text">6.手写ES5继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-text">原型继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF"><span class="nav-text">构造继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="nav-text">原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-text">寄生组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E7%BB%A7%E6%89%BF"><span class="nav-text">寄生组合优化继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof"><span class="nav-text">7.手动实现instanceof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-text">递归实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-text">迭代实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%89%8B%E5%86%99Array-isArray"><span class="nav-text">8.手写Array.isArray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8toString%E5%AE%9E%E7%8E%B0Array-isArray"><span class="nav-text">使用toString实现Array.isArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8instanceof%E5%AE%9E%E7%8E%B0Array-isArray"><span class="nav-text">使用instanceof实现Array.isArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8constructor%E5%AE%9E%E7%8E%B0Array-isArray"><span class="nav-text">使用constructor实现Array.isArray</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">9.实现一个函数判断数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">10.手写深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%9E%81%E7%AE%80%E7%89%88"><span class="nav-text">深拷贝极简版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%A4%9F%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%9A%E9%80%92%E5%BD%92%E6%B3%95"><span class="nav-text">面试够用的版本：递归法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-text">循环引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%8F%AF%E4%BB%A5%E8%B7%B3%E8%BF%87%EF%BC%8C%E5%AE%9E%E5%9C%A8%E6%9C%89%E7%82%B9%E5%81%8F%EF%BC%89"><span class="nav-text">性能优化（可以跳过，实在有点偏）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">其他数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E7%90%86%E7%9A%84%E5%88%A4%E6%96%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">合理的判断引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">获取数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%BB%A7%E7%BB%AD%E9%81%8D%E5%8E%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">可继续遍历的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E7%BB%A7%E7%BB%AD%E9%81%8D%E5%8E%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">不可继续遍历的类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E5%87%BD%E6%95%B0"><span class="nav-text">克隆函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="nav-text">完整代码展示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="nav-text">11.数组扁平化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8ES6%E4%B8%AD%E7%9A%84flat%E6%96%B9%E6%B3%95"><span class="nav-text">调用ES6中的flat方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8reduce%E5%87%BD%E6%95%B0%E8%BF%AD%E4%BB%A3-%E5%8E%9F%E5%9C%B0%E5%B1%95%E5%BC%80"><span class="nav-text">利用reduce函数迭代(原地展开)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">扩展运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-text">12.数组去重</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%B1%82-for-%E5%BE%AA%E7%8E%AF"><span class="nav-text">双层 for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8indexOf%E6%88%96%E8%80%85includes%E5%8E%BB%E9%87%8D"><span class="nav-text">利用indexOf或者includes去重</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8indexOf%E5%88%A4%E6%96%AD"><span class="nav-text">使用indexOf判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8includes%E5%88%A4%E6%96%AD"><span class="nav-text">使用includes判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-filter-indexOf"><span class="nav-text">Array.filter() + indexOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-reduce-indexOf-includes"><span class="nav-text">Array.reduce() + indexOf&#x2F;includes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8includes%E5%88%A4%E6%96%AD-1"><span class="nav-text">使用includes判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8indexOf%E5%88%A4%E6%96%AD-1"><span class="nav-text">使用indexOf判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8ES6-Set%E5%8E%BB%E9%87%8D"><span class="nav-text">利用ES6 Set去重</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AE%80%E5%86%99"><span class="nav-text">利用展开运算符简写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%BB%E9%87%8D"><span class="nav-text">利用Map数据结构去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8hasOwnProperty"><span class="nav-text">利用hasOwnProperty</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84ES5%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-text">13.手写数组ES5常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-forEach-%E5%87%BD%E6%95%B0"><span class="nav-text">1.forEach 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-filter-%E5%87%BD%E6%95%B0"><span class="nav-text">2.filter 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-find-%E5%87%BD%E6%95%B0"><span class="nav-text">3.find 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-findIndex-%E5%87%BD%E6%95%B0"><span class="nav-text">4.findIndex 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-fill%E5%87%BD%E6%95%B0"><span class="nav-text">5.fill函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-map-%E5%87%BD%E6%95%B0"><span class="nav-text">6.map 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-some-%E5%87%BD%E6%95%B0"><span class="nav-text">7.some 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-every-%E5%87%BD%E6%95%B0"><span class="nav-text">8.every 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-reduce-%E5%87%BD%E6%95%B0"><span class="nav-text">9.reduce 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8reduce%E5%AE%9E%E7%8E%B0map"><span class="nav-text">使用reduce实现map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8reduce%E5%AE%9E%E7%8E%B0filter"><span class="nav-text">使用reduce实现filter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-text">14.实现数组原地反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-reduce%E7%9A%84%E5%BA%94%E7%94%A8%E6%B1%87%E6%80%BB"><span class="nav-text">15.reduce的应用汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C"><span class="nav-text">数组求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">数组最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AF%B9%E8%B1%A1"><span class="nav-text">数组转对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="nav-text">数组扁平化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-text">数组去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-text">对象数组去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">求字符串中字母出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compose%E5%87%BD%E6%95%B0"><span class="nav-text">compose函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9E%E6%BA%AF"><span class="nav-text">实现多维数组的回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="nav-text">16.洗牌算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%AF%B9%E8%B1%A1%E6%89%81%E5%B9%B3%E5%8C%96"><span class="nav-text">17.对象扁平化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E6%89%8B%E5%86%99%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-text">18.手写偏函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0ES6%E5%B8%B8%E8%A7%84%E5%86%99%E6%B3%95"><span class="nav-text">偏函数ES6常规写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0ES6%E7%AE%80%E5%8C%96%E5%86%99%E6%B3%95"><span class="nav-text">偏函数ES6简化写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-text">19.函数柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96ES6%E5%B8%B8%E8%A7%84%E5%86%99%E6%B3%95"><span class="nav-text">函数柯里化ES6常规写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96ES6%E7%AE%80%E5%8C%96%E5%86%99%E6%B3%95"><span class="nav-text">函数柯里化ES6简化写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%89%8B%E5%86%99compose%E5%87%BD%E6%95%B0"><span class="nav-text">20.手写compose函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84compose%E5%87%BD%E6%95%B0"><span class="nav-text">基于栈的compose函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0reduce%E7%9A%84compose%E5%87%BD%E6%95%B0"><span class="nav-text">使用函数reduce的compose函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0compose"><span class="nav-text">使用递归来实现compose</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%AE%9E%E7%8E%B0-5-add-3-minus-2-%E5%8A%9F%E8%83%BD"><span class="nav-text">21.实现 (5).add(3).minus(2) 功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-add-%E5%87%BD%E6%95%B0"><span class="nav-text">22.实现一个 add 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-text">23.计算两个数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E6%89%8B%E5%86%99%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="nav-text">24.手写对象深度比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84"><span class="nav-text">25.扁平数组转树状结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E9%98%B2%E6%8A%96-debounce"><span class="nav-text">26.防抖(debounce)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">防抖是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%89"><span class="nav-text">防抖代码（第一版）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E5%90%91%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89"><span class="nav-text">this指向（第二版）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event-%E5%AF%B9%E8%B1%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%8C%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="nav-text">event 对象（第三版，已经完成基本功能）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E8%8A%82%E6%B5%81-throttle"><span class="nav-text">27.节流(throttle)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">节流是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E7%89%88%E4%BB%A3%E7%A0%81"><span class="nav-text">时间戳版代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%88%E4%BB%A3%E7%A0%81"><span class="nav-text">定时器版代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E6%89%8B%E5%86%99const"><span class="nav-text">28.手写const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8ES5%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%9E%E7%8E%B0let"><span class="nav-text">在ES5环境下实现let</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">const的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8ES5%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%9E%E7%8E%B0const"><span class="nav-text">在ES5环境下实现const</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="nav-text">29.实现一个双向绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defineProperty-%E7%89%88%E6%9C%AC"><span class="nav-text">defineProperty 版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proxy-%E7%89%88%E6%9C%AC"><span class="nav-text">proxy 版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-text">30.图片懒加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E5%90%ACscroll%E4%BA%8B%E4%BB%B6%E6%B3%95"><span class="nav-text">监听scroll事件法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntersectionObserver"><span class="nav-text">IntersectionObserver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E5%8C%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">31.区间随机数生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E6%89%93%E5%8D%B0%E8%8F%B1%E5%BD%A2"><span class="nav-text">32.打印菱形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E6%89%8B%E5%86%99parseInt"><span class="nav-text">33.手写parseInt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E6%89%8B%E5%86%99JSON-stringify"><span class="nav-text">34.手写JSON.stringify</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-%E6%89%8B%E5%86%99JSON-parse"><span class="nav-text">35.手写JSON.parse</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-eval"><span class="nav-text">直接调用 eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8Function"><span class="nav-text">调用Function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E8%A7%A3%E6%9E%90-URL-Params-%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">36.解析 URL Params 为对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0"><span class="nav-text">37.模板引擎实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D-%E4%B8%AD%E5%88%92%E7%BA%BF%E8%BD%AC%E6%8D%A2"><span class="nav-text">38.驼峰命名-中划线转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%88%92%E7%BA%BF%E8%BD%AC%E9%A9%BC%E5%B3%B0"><span class="nav-text">中划线转驼峰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%BC%E5%B3%B0%E8%BD%AC%E4%B8%AD%E5%88%92%E7%BA%BF"><span class="nav-text">驼峰转中划线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E5%88%B04%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-text">拓展到4种模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E4%B8%AA%E6%95%B0"><span class="nav-text">39.查找字符串中出现最多的字符和个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-%E6%AD%A3%E5%88%99%E7%BB%9F%E8%AE%A1%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0"><span class="nav-text">排序+正则统计单个字符个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%9F%E8%AE%A1%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0"><span class="nav-text">哈希表统计单个字符个数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><span class="nav-text">40.字符串查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3"><span class="nav-text">暴力解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-text">41.实现千位分隔符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%E9%83%A8%E5%88%86"><span class="nav-text">反转整数部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B8%A6%E5%87%BD%E6%95%B0toLocaleSting"><span class="nav-text">自带函数toLocaleSting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-text">正则表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8"><span class="nav-text">42.正则表达式的基本运用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="nav-text">判断是否是电话号码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E9%82%AE%E7%AE%B1"><span class="nav-text">验证是否是邮箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%98%AF%E8%BA%AB%E4%BB%BD%E8%AF%81"><span class="nav-text">验证是否是身份证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E6%89%8B%E5%86%99trim"><span class="nav-text">43.手写trim</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-text">字符串拆分数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2"><span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="nav-text">字符串截取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83"><span class="nav-text">44.版本号比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E6%89%8B%E5%86%99Object-freeze"><span class="nav-text">45.手写Object.freeze</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E5%AE%9E%E7%8E%B0ES6%E7%9A%84extends"><span class="nav-text">46.实现ES6的extends</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Set"><span class="nav-text">47.手写实现Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Map"><span class="nav-text">48.手写实现Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-text">49.检测对象循环引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">50.单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">51.观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="nav-text">观察者模式与发布&#x2F;订阅模式区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">发布&#x2F;订阅模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">观察者模式的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99Vue-Reactive"><span class="nav-text">手写Vue Reactive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">Vue数据双向绑定（响应式系统）的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="nav-text">核心代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E7%A7%8DReactive%E9%97%AE%E9%A2%98"><span class="nav-text">变种Reactive问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-EventBus-EventEmitter"><span class="nav-text">52.发布&#x2F;订阅模式 (EventBus&#x2F;EventEmitter)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-%E6%89%8B%E5%86%99%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="nav-text">53.手写事件代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-%E6%89%8B%E5%86%99JSONP%E8%B7%A8%E5%9F%9F"><span class="nav-text">54.手写JSONP跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88"><span class="nav-text">其他跨域方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS"><span class="nav-text">CORS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-domain"><span class="nav-text">document.domain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postMessage"><span class="nav-text">postMessage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-%E6%89%8B%E5%86%99Promise"><span class="nav-text">55.手写Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC"><span class="nav-text">基础版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#then%E6%96%B9%E6%B3%95"><span class="nav-text">then方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch%E6%96%B9%E6%B3%95"><span class="nav-text">catch方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally%E6%96%B9%E6%B3%95"><span class="nav-text">finally方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-resolve%E5%92%8CPromise-reject"><span class="nav-text">Promise.resolve和Promise.reject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-all"><span class="nav-text">Promise.all</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race"><span class="nav-text">Promise.race</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-allSettled"><span class="nav-text">Promise.allSettled</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-any"><span class="nav-text">Promise.any</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-%E6%89%8B%E5%86%99ajax%E5%B0%81%E8%A3%85"><span class="nav-text">56.手写ajax封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9Fajax%E5%B0%81%E8%A3%85"><span class="nav-text">原生ajax封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise%E5%B0%81%E8%A3%85ajax"><span class="nav-text">Promise封装ajax</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0sleep"><span class="nav-text">57.手写实现sleep</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Promise"><span class="nav-text">使用Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8Generator"><span class="nav-text">使用生成器Generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8async-await"><span class="nav-text">使用async&#x2F;await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5"><span class="nav-text">ES5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E7%A7%8D%E9%A2%981-%E5%B0%86setTimeout%E5%8C%85%E8%A3%85%E6%88%90sleep%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">变种题1 将setTimeout包装成sleep的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E7%A7%8D%E9%A2%982-%E5%BC%82%E6%AD%A5%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0"><span class="nav-text">变种题2 异步循环打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E7%A7%8D%E9%A2%983-%E5%AE%9E%E7%8E%B0-setTimeout-%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-text">变种题3 实现 setTimeout 的同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-%E6%89%8B%E5%86%99promisify"><span class="nav-text">58.手写promisify</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97"><span class="nav-text">59.实现延时执行队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%AF%E5%8A%A0%E8%AE%A1%E6%97%B6"><span class="nav-text">累加计时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Promise-1"><span class="nav-text">使用Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8async-await-1"><span class="nav-text">使用async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-setTimeout%E5%AE%9E%E7%8E%B0setInterval"><span class="nav-text">60.setTimeout实现setInterval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout%E5%AE%9E%E7%8E%B0setInterval"><span class="nav-text">setTimeout实现setInterval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setInterval%E5%AE%9E%E7%8E%B0setTimeout"><span class="nav-text">setInterval实现setTimeout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E6%89%8B%E5%86%99fetch"><span class="nav-text">61.手写fetch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#promise%E5%AE%9E%E7%8E%B0fetch"><span class="nav-text">promise实现fetch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99fetch%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="nav-text">给fetch添加一个超时控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Generator"><span class="nav-text">62.手写实现Generator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">ES6对迭代器的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-text">手写实现迭代器生成函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0async-await"><span class="nav-text">63.手写实现async&#x2F;await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E6%89%8B%E5%86%99%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C"><span class="nav-text">64.手写异步串行和异步并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%8A%A0%E6%B3%95"><span class="nav-text">实现异步加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">实现异步串行的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#async-await"><span class="nav-text">async&#x2F;await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-text">reduce</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95-1"><span class="nav-text">实现异步串行的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%95%B0%E9%99%90%E5%88%B6"><span class="nav-text">65.异步并发数限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1"><span class="nav-text">使用队列缓存并发任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%95%B0%E7%9B%AE%E9%99%90%E5%88%B6%E4%B8%BA2%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-text">并发数目限制为2的异步调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%B8%A6%E6%9C%89%E6%89%A7%E8%A1%8C%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-text">实现带有执行器和拦截器的并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Promise%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6"><span class="nav-text">使用Promise并发限制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-text">内容</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hxy"
      src="/images/Robben.gif">
  <p class="site-author-name" itemprop="name">hxy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huxingyi1997" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huxingyi1997" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huxingyi1997@zju.edu.cn" title="E-Mail → mailto:huxingyi1997@zju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-frog"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hxy</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共843.6k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQsO3ySbU4VtWN2j1FLA74Ha-gzGzoHsz',
      appKey     : 'QYacMDY2VY7Wazprg1X6FiUv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
  <!-- 动态背景特效 -->
  <!-- 樱花特效 -->
    <script async src="/js/src/sakura.js"></script>
    <script async src="/js/src/fairyDustCursor.js"></script>
</body>
</html>
